<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אז מדוע קשה להוכיח ש-P שונה מ-NP? (בלכסון) - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2010/08/16/p_vs_np_hard_to_diagonalize/">
    <meta property="og:title" content="אז מדוע קשה להוכיח ש-P שונה מ-NP? (בלכסון)">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2010/08/16/p_vs_np_hard_to_diagonalize/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="אז מדוע קשה להוכיח ש-P שונה מ-NP? (בלכסון)">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2010/08/15/p_vs_np_overview/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">אז מה זה עניין P=NP, בעצם?</span>
            </a>
            

            
            <a href="/2010/08/31/oracles_and_p_vs_np/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">כיצד אורקלים מנבאים שקשה להוכיח ש-P שונה מ-NP</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>אז מדוע קשה להוכיח ש-P שונה מ-NP? (בלכסון)</h1>
            <div class="post-meta">
                <span class="date">2010-08-16</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/חישוביות.html">חישוביות</a>
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/בעיית P=NP.html">בעיית P=NP</a>
                    
                    <a href="/tags/בעיית העצירה.html">בעיית העצירה</a>
                    
                    <a href="/tags/לכסון.html">לכסון</a>
                    
                    <a href="/tags/משפטי היררכייה בסיבוכיות.html">משפטי היררכייה בסיבוכיות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אם תבקשו ממני לתארך את הולדת מדעי המחשב התיאורטיים, אגיד שזה היה ב<a href="http://www.google.com/url?sa=t&amp;source=web&amp;cd=1&amp;ved=0CBcQFjAA&amp;url=http%3A%2F%2Fwww.thocp.net%2Fbiographies%2Fpapers%2Fturing_oncomputablenumbers_1936.pdf&amp;ei=NYppTJ2mDc-fONmQwbgF&amp;usg=AFQjCNHLCPE7ZMMOfz6ZUP2gDQYZGCoxIA&amp;sig2=VkKRrxKmGZBD-j04nHYVFw">מאמר של טיורינג</a> מ-1936 שבו הוא הציג את המודל החישובי שלו והוכיח שבעיית העצירה אינה ניתנת לפתרון על ידו. אמנם, מודלים חישוביים הוצעו קודם ותוצאות אי אפשרות הוכחו קודם, אך המאמר של טיורינג (לדעתי הלא מלומדת) הוא הראשון שתפס בצורה פשוטה ואינטואיטיבית אך מתמטית את הרעיון של חישוב; ויש משהו אירוני אך הולם בכך שלידתם של מדעי המחשב הייתה בדיוק בעיסוק בגבולותיהם - בדברים שלא ניתנים כלל לחישוב. זה כמובן אינו מקרי - הצורך להגדיר באופן מדוייק את מושג החישוב נבע בדיוק מהרצון להראות שמשהו בלתי ניתן לחישוב - שכן כדי להראות זאת צריך לומר תוצאה <strong>כללית</strong> על כל החישובים האפשריים, ולשם כך חייבים להגדיר במדוייק מה נקרא בכלל "חישוב".</p>
<p>ההוכחה של טיורינג (שאת הגרסה המקובלת שלה כיום <a href="http://www.gadial.net/2007/09/27/halting_problem_proof/">הצגתי כבר בעבר</a>. אמנם עסקה במודל קונקרטי, אך למעשה היא כמעט ולא השתמשה בפרטים קונקרטיים הקשורים למודל זה. התכונה המרכזית שבה נעשה שימוש הייתה העובדה שמכונת טיורינג ניתנת לתיאור באמצעות מחרוזת (רצף תווים) סופית, ושבהינתן מחרוזת תווים שכזו, מכונת טיורינג אחרת מסוגלת <strong>לבצע סימולציה</strong> של המכונה המקודדת. כל מי שמקיים תכונות אלו (ומאפשר לנו בנוסף לכך לבצע חישובים מאוד בסיסיים) חשוף להוכחה של טיורינג.</p>
<p>אזכיר אותה בקצרה (כפי שכל מי שיביט במאמר של טיורינג יראה, זה "לא בדיוק" מה שטיורינג אמר, אבל ביד חופשית שכזו נהוג להשתמש כל הזמן כל עוד לא מתיימרים לעסוק בהיסטוריה של המתמטיקה): נניח שיש לנו מכונה <span class="math">\(Q\)</span> שבהינתן מכונה אחרת <span class="math">\(M\)</span> וקלט עבורה <span class="math">\(x\)</span> אומרת האם <span class="math">\(M\)</span> עוצרת בריצתה על <span class="math">\(x\)</span> או שלא. כעת נבנה מכונה <span class="math">\(U\)</span> שעל קלט <span class="math">\(x\)</span> מזינה ל-<span class="math">\(Q\)</span> את הזוג <span class="math">\(\left(x,x\right)\)</span> (כלומר, שואלת את <span class="math">\(Q\)</span> "מה עושה המכונה המקודדת בתור <span class="math">\(x\)</span> כשמריצים אותה על עצמה?") ופועלת <strong>הפוך</strong> ממה ש-<span class="math">\(Q\)</span> אמרה - אם <span class="math">\(Q\)</span> אמרה ש-<span class="math">\(x\)</span> עוצרת על <span class="math">\(x\)</span>, אז <span class="math">\(U\)</span> נכנסת ללולאה אינסופית; ואחרת, <span class="math">\(U\)</span> עוצרת. בבירור ההתנהגות של <span class="math">\(U\)</span> כשיריצו אותה על הקלט <span class="math">\(U\)</span> תהיה פרדוקסלית, וזה סוף הסיפור.</p>
<p>ההוכחה הקצרצרה הזו מתארת אי שוויון בין מחלקות של בעיות חישוביות - במקרה הזה, בין המחלקה <span class="math">\(\text{R}\)</span> של בעיות שניתנות לפתרון, ו<a href="http://www.gadial.net/2007/09/18/r_and_re/">המחלקה</a> <span class="math">\(\text{RE}\)</span> של בעיות שניתנות לפתרון "חד צדדי"- בעיות שעבורן קיימת מכונה שעוצרת ועונה "כן" אם התשובה היא אכן כן, אך אחרת ייתכן שהיא לא תעצור כלל (או שתעצור ותגיד "לא"). אף שזה לא ברור מייד, שאלת <span class="math">\(\text{P} \ne \text{NP}\)</span> היא האנלוג הקשור ל"זמן ריצה יעיל" של תוצאת ה-<span class="math">\(\text{R}\ne\text{RE}\)</span> הזו. (אם לוקחים את הגדרת <span class="math">\(\text{P}\)</span> ומחלישים את הדרישה של "זמן ריצה פולינומי" על ידי החלפתה ב"זמן ריצה כלשהו, העיקר שהמכונה תעצור", מקבלים את <span class="math">\(\text{R}\)</span>; ואם עושים את אותו הדבר ל-<span class="math">\(\text{NP}\)</span> מקבלים את <span class="math">\(\text{RE}\)</span> - זה תרגיל נחמד שאולי גם אדבר עליו פעם בבלוג).</p>
<p>ההוכחה הזו מחוכמת למדי - במקום לנסות ולתפוס את כל הדרכים האפשריות שבהן אפשר, אולי, להכריע את בעיית העצירה ולהראות שבכל אחת מהן יש כשל כלשהו, ההוכחה הזו הולכת בדלת האחורית - היא מניחה שאפשר להכריע את בעיית העצירה, ומראה אילו דברים אבסורדיים נובעים מכך. אם כן, מדוע לא ניתן להשתמש בהוכחה הזו גם כדי להראות ש-<span class="math">\(\text{P}\)</span> שונה מ-<span class="math">\(\text{NP}\)</span>?</p>
<p>הבעיה היא שלא ברור באיזו בעיה כדאי להשתמש בתור הבעיה-חסומת-הזמן שאנלוגית לבעיית העצירה. אפשר להגדיר כל מני שפות דומות אבל אני מעדיף להציג גישה שונה מעט להוכחה שהצגתי לעיל - גישה שבפועל היא שימושית מאוד, ואולי מבהירה מעט יותר טוב מדוע להוכחה הזו קוראים <strong>לכסון</strong>.</p>
<p>הרעיון בהוכחה הוא זה: אם יש לנו שתי מחלקות <span class="math">\(A,B\)</span> של שפות ("שפה"היא פשוט אוסף של קלטים - נניח, אוסף הקלטים שעליהם המכונה עוצרת ואומרת "כן") ואנו רוצים להראות כי <span class="math">\(A\ne B\)</span>, וכמו כן <span class="math">\(A\)</span> בבירור מוכל ב-<span class="math">\(B\)</span>, אז דרך אחת להראות זאת היא על ידי הצגת מכונה ששפתה נמצאת ב-<span class="math">\(B\)</span>, אבל היא מתנהגת באופן שונה מאשר <strong>כל</strong> מכונה ששפתה ב-<span class="math">\(A\)</span>. מה ה"לכסון"כאן? ובכן, זכרו שבהוכחת <a href="http://www.gadial.net/2007/08/29/cantor_diagonal/">האלכסון של קנטור</a> התעלול היה לבנות מספר ממשי ש"מתנהג באופן שונה" מאשר כל מספר ממשי שהיה קיים במספור של הממשיים - כלומר, הוא נבדל מכל אחד מהמספרים הללו באחד מהמקומות בפיתוח העשרוני שלהם. כאן זה אותו רעיון: אם <span class="math">\(U\)</span> היא המכונה שאנו בונים ו-<span class="math">\(M\)</span> היא מכונה כלשהי ששפתה ב-<span class="math">\(A\)</span>, אז יהיה קיים קלט <span class="math">\(x\)</span> שעליו <span class="math">\(U\)</span> ו-<span class="math">\(M\)</span> יתנהגו שונה (ובפרט לכל <span class="math">\(M\)</span> יהיה מדובר על <span class="math">\(x\)</span> אחר).</p>
<p>כאשר <span class="math">\(A=\text{R}\)</span> ו-<span class="math">\(B=\text{RE}\)</span>, אז המכונות ששפתן ב-<span class="math">\(A\)</span> הן "מכונות שעוצרות תמיד" ואילו מכונות ששפתן ב-<span class="math">\(B\)</span> הן "מכונות שעוצרות תמיד אם התשובה היא "כן", ואחרת יכולות לא לעצור". במילים אחרות, המכונה <span class="math">\(U\)</span> שנבנה יכולה לא לעצור על קלטים מסויימים, ואז מובטח שהם לא יהיו בשפה שלה.</p>
<p>כעת הבניה של <span class="math">\(U\)</span> היא פשוטה ביותר: בהינתן קלט <span class="math">\(x\)</span>, <span class="math">\(U\)</span> <strong>מפרשת</strong> אותו כמכונה <span class="math">\(M_{x}\)</span>, מריצה את <span class="math">\(M_{x}\)</span> על הקלט <span class="math">\(x\)</span> עצמו, ואם <span class="math">\(M_{x}\)</span> עצרה וענתה - היא עונה הפוך ממנה. מכיוון שכל <span class="math">\(M\)</span> ששפתה ב-<span class="math">\(\text{R}\)</span> מחוייבת לעצור, מובטח לנו ש-<span class="math">\(U\)</span> תענה הפוך מכל <span class="math">\(M\)</span> כזו על הקלט <span class="math">\(\left\langle M\right\rangle \)</span> עצמו (הסוגריים המשולשים באים לציין שמדובר על <strong>הקידוד</strong> של <span class="math">\(M\)</span> כמחרוזת). כמובן ש-<span class="math">\(U\)</span> עלולה לא לעצור כלל אם המכונה <span class="math">\(M_{x}\)</span> שהיא מסמלצת היא מהסוג שלא עונה אף פעם - אבל זה בסדר, כי הרשינו ל-<span class="math">\(B\)</span> להתנהג כך.</p>
<p>מכיוון שלא ממש ברור איך נראית השפה ש-<span class="math">\(U\)</span> מקבלת, תוצאה זו לא נותנת לנו שפה קונקרטית שלא ניתן להכריע (ועל כן ההוכחה הראשונה שהצגתי עדיפה על פניה באספקט זה) אך היא מראה כי המחלקות <span class="math">\(\text{R}\)</span> ו-<span class="math">\(\text{RE}\)</span> הן שונות; וחשוב מכך, ניתן להכליל אותה לסיטואציות רבות אחרות. אדגים כעת את אחת מהפשוטות שבהן: נניח שאנו רוצים להוכיח כי <span class="math">\(\text{P} \ne \text{R}\)</span>, דהיינו שיש בעיות שניתן להכריע אך אינן פתירות בזמן פולינומי - ההוכחה תעבוד כמעט באותו האופן, למעט תוספת טכנית חשובה אחת. אני מזהיר מראש - ההוכחה אינה פשוטה לגמרי וחלקכם כנראה יאבד אותי - אפשר לעבור לסוף ההוכחה בלי לפגוע מהותית בקריאת הפוסט.</p>
<p>שימו לב שכעת <span class="math">\(U\)</span> שלנו צריכה לעצור תמיד, אחרת ייתכן ששפתה לא תשתייך ל-<span class="math">\(\text{R}\)</span>. במילים אחרות, תמו ימי הנעורים הפרועים שבהם <span class="math">\(U\)</span> יכלה פשוט להריץ כל מכונת טיורינג עם כל קידוד שהוא, כי ייתכן שחלק מהמכונות שהיא מריצה לא יעצרו לעולם. כאן נכנס לתמונה התעלול הטכני - <span class="math">\(U\)</span> תפרש את הקלט <span class="math">\(x\)</span> כמכונה כמו קודם, אבל תריץ את <span class="math">\(M_{x}\)</span> על <span class="math">\(x\)</span> רק במשך <span class="math">\(2^{\left|x\right|}\)</span> צעדים - שתיים בחזקת האורך של <span class="math">\(x\)</span> צעדים (זכרו - <span class="math">\(x\)</span> היא מחרוזת). אם בפרק הזמן הזה <span class="math">\(M_{x}\)</span> עצרה על <span class="math">\(x\)</span>, הרי ש-<span class="math">\(U\)</span> תענה הפוך ממנה; ואחרת, פשוט תדחה. מה שאנו מתבססים עליו כאן הוא שלכל מכונה יש אינסוף קידודים מאורכים שונים ומשונים, כי תמיד אפשר להכריז שאם תו מסויים מופיע בקידוד פשוט מתעלמים ממנו (למי שזה מפריע לו - יש עוד דרכים, טיפה פחות אלגנטיות, לעקוף את הבעיה הזו).</p>
<p>כעת מגיע החלק המסובך - נניח שיש מכונה <span class="math">\(M\)</span> שפועלת בזמן ריצה פולינומי, נניח עם פולינום <span class="math">\(p\left(n\right)\)</span>. אז קיים <span class="math">\(m\)</span> טבעי כלשהו כך ש-<span class="math">\(p\left(m\right)<2^{m}\)</span> - זה מכיוון שפונקציה מעריכית כמו <span class="math">\(2^{x}\)</span> גדלה מהר יותר מכל פולינום (טענה שדורשת הוכחה אך אינה מסובכת). בואו ניקח בתור <span class="math">\(x\)</span> עותק של <span class="math">\(M\)</span> שאורכו לפחות <span class="math">\(m\)</span> - כעת מובטח לנו שכאשר <span class="math">\(U\)</span> תרוץ על <span class="math">\(x\)</span> היא תסמלץ את ריצת <span class="math">\(M\)</span> על <span class="math">\(x\)</span> למשך מספר צעדים כה גדול עד כי מובטח ש-<span class="math">\(M\)</span> תעצור על <span class="math">\(x\)</span>, ולכן <span class="math">\(U\)</span> תענה הפוך מ-<span class="math">\(M\)</span>. מכאן שאף מכונה פולינומית אינה מקבלת את אותה שפה בדיוק כמו <span class="math">\(U\)</span>, וזהו סוף הסיפור.</p>
<p>את ההוכחה הזו ניתן להמשיך ולשכלל, ולקבל את מה שמכונה "משפטי ההיררכייה" של תורת הסיבוכיות. הם מראים, למשל, שיש בעיות שניתן לפתור בסיבוכיות זמן <span class="math">\(O\left(n^{2}\right)\)</span> אך לא בסיבוכיות זמן <span class="math">\(O\left(n\right)\)</span>, וכדומה. אפשר להחיל את אותו רעיון גם על מחלקות סיבוכיות אי דטרמיניסטיות (הדבר דורש עוד תעלולים לא פשוטים), וישנן עוד הוכחות לכסון מחוכמות אף יותר - המפורסם ביותר מבין התוצאות המחוכמות הוא ככל הנראה <a href="http://en.wikipedia.org/wiki/NP-Intermediate">משפט לדנר</a>, שמראה שאם <span class="math">\(\text{P} \ne \text{NP}\)</span> אז קיימות "שפות ביניים" שאינן ב-<span class="math">\(\text{P}\)</span> וגם אינן <span class="math">\(\text{NP}\)</span>-שלמות, אך נעזוב את זה.</p>
<p>הפאנץ' המרכזי בכל הוכחות הלכסון הללו הוא המיעוט בהנחות קונקרטיות שהן דורשות מאיתנו; הרעיון שחוזר שוב ושוב בכולן הוא שאפשר לקודד מכונת טיורינג קידוד סופי, כך שמכונה אחרת יכולה לקרוא את הקידוד הזה ולסמלץ אותה בלי תוספת משאבים משמעותית. זה הכל. הוכחות שמתבססות רק על תכונות אלו מכונות "הוכחות רלטביסטיות". באופן ציורי אפשר לומר שאלו הן הוכחות שמתייחסות למכונת הטיורינג כאל "קופסה שחורה"- אפשר להריץ אותה על קלט מספר כלשהו של צעדים, וזהו. זה כל מה שעושים איתה. אין שום התייחסות לתכונות אחרות של המכונה או לסיטואציות שעשויות לצוץ בזמן הריצה. זו הוכחה מופשטת שכמעט ואינה תלויה בפרטי המודל - והבעיה היא ככל הנראה שהיא מופשטת <strong>מדי</strong>.</p>
<p>האם גם את <span class="math">\(\text{P} \ne \text{NP}\)</span> ניתן להוכיח בדרך זאת? נסיון נאיבי לעשות זאת ייכשל - היתרון היחיד שיש למכונות ששפתן ב-<span class="math">\(\text{NP}\)</span> על פני מכונות ב-<span class="math">\(\text{P}\)</span> הוא שהן יכולות להיות אי-דטרמיניסטיות; לא אכנס להגדרה המדוייקת של המושג (שכבר עסקתי בה בעבר) כי זה לא קריטי כרגע - הנקודה היא שעל פניו זה לא מאפשר למכונה לבצע סימולציה "עד הסוף" של כל המכונות הפולינומיות הדטרמיניסטיות; במשפטי הלכסון הקלאסיים הבעיה הזו נפתרת על ידי כך ש-<span class="math">\(U\)</span> רצה <strong>הרבה</strong> זמן ביחס למכונות שהיא מנסה לענות שונה מהן - כאן ל-<span class="math">\(U\)</span> אין שום יתרון כזה.</p>
<p>כמובן שבעיה אינטואיטיבית שכזו לא אמורה לעצור אף אחד. מה שעצר אנשים היה מאמר משנת 1975 של Baker-Gill-Solovay שהראה שפשוט לא ניתן להשתמש בשיטות רלטביסטיות כדי להוכיח ש-<span class="math">\(\text{P} \ne \text{NP}\)</span>. איך מוכיחים דבר כזה? להוכחה המדוייקת אקדיש פוסט נפרד וכעת אסתפק בתיאור הרעיון. המושג החדש שהם מכניסים לתמונה הוא זה של <a href="http://he.wikipedia.org/wiki/%D7%90%D7%95%D7%A8%D7%A7%D7%9C_%28%D7%9E%D7%93%D7%A2%D7%99_%D7%94%D7%9E%D7%97%D7%A9%D7%91%29">אורקל</a>. אורקל, בפשטות, הוא כוח שמיימי שמסוגל לענות על שאלות מסויימות באופן מושלם ומבלי שהדבר ייקח זמן. באופן קצת יותר פורמלי מדברים תמיד על אורקל לשפות מסויימות. אורקל לשפה יכול, בהינתן מילה כלשהי, לומר מייד אם היא שייכת לשפה או לא. למשל - אורקל לבעיית העצירה יכול, בהינתן זוג <span class="math">\(M,x\)</span>, להגיד מייד אם <span class="math">\(M\)</span> עוצרת על <span class="math">\(x\)</span> או שאינה עוצרת. זהו כמובן מושג תיאורטי לחלוטין; במציאות אפילו חישובים פשוטים דורשים זמן. עם זאת, התועלת שצומחת משימוש תיאורטי ביצור הזה היא עצומה, והדבר דומה לשימושיות הרבה של מושג המכונה האי-דטרמיניסטית, למרות שמכונה כזו אינה קיימת במציאות.</p>
<p>כעת, בהינתן מודל כלשהו של מכונות טיורינג (למשל - מכונות דטרמיניסטיות פולינומיות) אפשר "לחזק" את המודל על ידי כך שמרשים למכונות בו גישה לאורקל מסויים (כלומר, אורקל עבור שפה ספציפית נתונה). למשל, את המודל של "מכונות דטרמיניסטיות פולינומיות"אפשר לחזק ולהפוך למודל של "מכונות דטרמיניסטיות פולינומיות עם אורקל לבעיית העצירה".</p>
<p>אלא מה? הוכחות רלטיביסטיות הן "עיוורות" לחיזוק שכזה. אם אנחנו מצליחים להוכיח באופן רלטיביסטי ששתי מחלקות <span class="math">\(A,B\)</span> שונות זו מזו, ואנו מחזקים את המכונות <strong>בשתי</strong> המחלקות באמצעות אותו אורקל, ההוכחה ממשיכה לעבוד באותו האופן; בכל פעם שסימולציה של מכונה <span class="math">\(M\)</span> מתוך <span class="math">\(A\)</span> תדרוש קריאה לאורקל, <span class="math">\(U\)</span> תוכל לבצע את הקריאה הזו כי גם ל-<span class="math">\(B\)</span> הוספנו גישה לאותו אורקל. באופן פורמלי זה אומר שאם הוכחנו רלטיביסטית ש-<span class="math">\(A\ne B\)</span> אז גם <span class="math">\(A^{L}\ne B^{L}\)</span>, כאשר <span class="math">\(A^{L}\)</span> אומר, כצפוי, "המחלקה <span class="math">\(A\)</span> כשמוסיפים למכונות בה גישה לאורקל לשפה <span class="math">\(L\)</span>".</p>
<p>ומה שהראו באותו מאמר משנת 1975 היה שקיימות שתי שפות, <span class="math">\(L_{1},L_{2}\)</span>, כך ש-<span class="math">\(\text{P}^{L_{1}}\ne\text{NP}^{L_{1}}\)</span>, אבל <span class="math">\(\text{P}^{L_{2}}=\text{NP}^{L_{2}}\)</span>. זה מראה מייד שלא ניתן להוכיח לא ש-<span class="math">\(\text{P}\ne\text{NP}\)</span> בשיטות רלטביסטיות, וגם לא ש-<span class="math">\(\text{P}=\text{NP}\)</span>.</p>
<p>מהן השפות <span class="math">\(L_{1},L_{2}\)</span> המסתוריות הללו ואיך הולכת ההוכחה? מכיוון שהיא טכנית יחסית, אדחה אותה לפוסט נפרד.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>