<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>כיצד אורקלים מנבאים שקשה להוכיח ש-P שונה מ-NP - לא מדויק</title>
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <header>
            <h1>כיצד אורקלים מנבאים שקשה להוכיח ש-P שונה מ-NP</h1>
            <div class="post-meta">
                <span class="date">2010-08-31</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אורקלים.html">אורקלים</a>
                    
                    <a href="/tags/בעיית P=NP.html">בעיית P=NP</a>
                    
                    <a href="/tags/הוכחות יפות.html">הוכחות יפות</a>
                    
                    <a href="/tags/טכני.html">טכני</a>
                    
                    <a href="/tags/לכסון.html">לכסון</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p><a href="http://www.gadial.net/2010/08/16/p_vs_np_hard_to_diagonalize/">בפוסט הקודם</a> נפנפתי קצת ידיים על אחת מהסיבות הנפוצות לקושי שבהוכחה ש-<span class="math">\(\mbox{P}\ne\mbox{NP}\)</span>; העובדה שאחד מרעיונות ההוכחה החזקים והיפים שבמתמטיקה ומדעי המחשב, הלכסון שגורם להפניה עצמית, מה שמככב במשפט אי השלמות של גדל ובהוכחת אי כריעותה של בעית העצירה - רעיון זה פשוט לא יכול לעבוד כאשר עוסקים ב-<span class="math">\(\mbox{P}\)</span> וב-<span class="math">\(\mbox{NP}\)</span>. בפוסט הזה אני רוצה להיות יותר טכני ולפרט גם את האופן שבו עושים זאת, אף שאני משער שחלק מהקוראים לא יצליחו לעקוב אחרי ההוכחה עד סופה. אני מניח כאן ידע מוקדם כלשהו בתורת הסיבוכיות - ספציפית, למה אנחנו מתכוונים ב"<a href="http://www.gadial.net/2007/09/23/turing_machine/">מכונת טיורינג</a>", ב"<a href="http://www.gadial.net/2007/12/23/nondeterminism/">מכונת טיורינג אי דטרמיניסטית</a>" וב"שפה" (אוסף של מחרוזת סופיות) - מי שאינו מכיר מושגים אלו כנראה יתקשה לעקוב אחרי ההמשך.</p>
<p>ראשית, תזכורת לגבי שיטת הפעולה שלנו: אנחנו משתמשים במודל החישובי של מכונת טיורינג עם אורקל, שאולי יותר פשוט לחשוב עליה במונחים מעשיים כ"תוכנית מחשב עם פונקצית ספריה חזקה במיוחד". אותה פונקצית ספריה מקבלת כקלט מחרוזת ואומרת עליה "כן"או "לא" בהתאם לשאלה מסויימת וקבועה מראש. למשל, "האם למשוואה הזו יש פתרון בשלמים" על קלט שהוא בעצמו משוואה פולינומית עם מקדמים שלמים. זו נשמעת כמו פונקצית ספריה נחמדה ופשוטה יחסית במבט ראשון; אך למעשה, אפשר להוכיח ש<strong>לא קיימת</strong> פונקציה שכזו בעולם האמיתי. עם זאת, אין מניעה מלשחק ב"נדמה לי" - נניח שפונקציה שכזו עומדת לרשותנו; אילו תוכניות מחשב נוכל לכתוב באמצעותה?</p>
<p>מכיוון שאנחנו עוסקים בענייני יעילות, עוד הנחה שלנו לגבי האורקל היא שהוא פועל באופן מיידי. כך אפשר לקצר את פרק הזמן שדורשים חישובים, על ידי כך ששואלים את האורקל שאלות שחישוב התשובה להן באופן ידני הוא תובעני, והאורקל עונה עליהן תכף ומייד. למשל, אם נתון לנו גרף ואנו מתבקשים למצוא כיסוי בצמתים שלו מגודל מסויים (כיסוי בצמתים הוא אוסף צמתים שכל קשת בגרף נוגעת באחד מהם לפחות) ויש לנו פונקצית ספריה שאומרת תכף ומייד, בהינתן גרף ומספר, האם קיים בגרף כיסוי קודקודים בגודל הדרוש, אז קל מאוד למצוא את הכיסוי: בוחרים צומת, מסלקים אותה ואת כל הקשתות המחוברות אליה מהגרף, ושואלים את הפונקציה האם קיים כעת כיסוי מהגודל שאנו רוצים פחות 1. אם כן, אז משאירים את הצומת שבחרנו בכיסוי, ואחרת "מתקנים" את הגרף ובודקים את הצומת הבא. הסיבה לכך שהאלגוריתם הוא כעת יעיל היא שהחלק ה"כבד" בו הוא הבדיקה האם בגרפים שמתקבלים במהלך ההרצה יש כיסוי קודקודים.</p>
<p>לא הבנתם כלום? מצויין, ההמשך עוד יותר מבלבל.</p>
<p>הטענה <span class="math">\(\mbox{P}\ne\mbox{NP}\)</span> היא בעצם הטענה "מכונות אי-דטרמיניסטיות פולינומיות יכולות לעשות משהו שמכונות דטרמיניסטיות פולינומיות לא יכולות לעשות". מה שאנו רוצים להראות הוא שאם מחזקים את שני המודלים הללו עם אורקל, אז עבור אורקל אחד המכונות כן ישתוו בכוחן, אבל עבור אורקל אחר אפשר יהיה להראות שהן לא שוות בכוחן (כלומר, להוכיח טענה דמויית <span class="math">\(\mbox{P}\ne\mbox{NP}\)</span> אבל על מחלקה אחרת של מכונות). החלק הקל יותר הוא להרחיב את שני המודלים כך שהם כן יהיו שווים בכוחם - פשוט צריך לתת להם אורקל למשהו שהוא <strong>כל כך חזק</strong> עד שההבדלים בכוח של שתי המכונות (אם קיימים כאלו) מתפוגגים ונעלמים. דוגמה לאורקל כזה היא אורקל שבהינתן שלשה <span class="math">\(\left(M,x,1^{n}\right)\)</span> של מכונה <span class="math">\(M\)</span>, קלט <span class="math">\(x\)</span> ומספר <span class="math">\(n\)</span> שנתון בבסיס אונרי (למה? מסיבת טכניות - יעילות של אלגוריתמים נמדדת ביחס ל<strong>גודל הייצוג</strong> של קלט, ואם מייצגים מספר שלא בבסיס אונרי אז גודל הייצוג שלו הוא לוגריתמי בגודל של המספר עצמו), אומר האם <span class="math">\(M\)</span> עונה "כן"על <span class="math">\(x\)</span> תוך <span class="math">\(2^{n}\)</span> צעדים.</p>
<p>אורקל לשפה הזו מאפשר למכונה דטרמיניסטית לקבל כל שפה שמכונה אי דטרמיניסטית פולינומית יכולה לקבל: אם <span class="math">\(M\)</span> היא מכונה אי דטרמיניסטית פולינומית ואנו רוצים לדעת אם היא מקבלת את <span class="math">\(x\)</span>, אז נבקש מהאורקל תשובה עבור <span class="math">\(\left(M^{\prime},x,1^{n}\right)\)</span> כאשר <span class="math">\(M^{\prime}\)</span> היא מכונה דטרמיניסטית שמבצעת חיפוש ממצה על כל אפשרויות הריצה של <span class="math">\(M\)</span> על <span class="math">\(x\)</span>; חיפוש ממצה שכזה לוקח זמן שהוא אקספוננציאלי באורך של <span class="math">\(x\)</span>, ולכן בהתאם בוחרים את <span class="math">\(n\)</span> להיות בערך הגודל של <span class="math">\(x\)</span> (מסיבות טכניות אולי יהיה צורך בקצת יותר).</p>
<p>אלא מה? כל מה שזה מראה הוא ש-<span class="math">\(\mbox{NP}\subseteq\mbox{P}^{L}\)</span> (כש-<span class="math">\(L\)</span> היא השפה של האורקל שלנו). אנחנו רוצים להראות ש-<span class="math">\(\mbox{NP}^{L}\subseteq\mbox{P}^{L}\)</span> - כלומר, שגם אחרי שמחזקים את המכונות האי-דטרמיניסטיות עם האורקל של <span class="math">\(L\)</span>, עדיין מכונות דטרמיניסטיות מצליחות לעשות את אותם הדברים. אלא שזו לא בעיה אמיתית, כי אותה מכונה <span class="math">\(M^{\prime}\)</span> שמסמלצת את המכונה האי דטרמיניסטית <span class="math">\(M\)</span> יכולה לסמלץ גם קריאות לאורקל - כלומר, לבצע בעצמה את החישוב שהאורקל מבצע, על איזה קלט שלא יהיה ש-<span class="math">\(M\)</span> תזרוק עליו, ולענות במקום האורקל. זה לא יגדיל את זמן הריצה של <span class="math">\(M^{\prime}\)</span> בצורה משמעותית (כאן צריך לבוא נימוק טכני מפורט יותר, אך אמנע ממנו - זה תרגיל טוב לחשוב מה בדיוק צריך לומר ואיזה עוד סיבוכים עשויים לצוץ; למשל, האם <span class="math">\(M\)</span> יכולה לקרוא לאורקל עם קלטים שבהם <span class="math">\(1^{n}\)</span> הוא "גדול מדי"?).</p>
<p>יפה. אם כן, עבור האורקל החזק הזה, מכונת דטרמיניסטיות ואי דטרמיניסטיות משתוות. החלק הקשה יותר הוא לחשוב על אורקל שעבורו לא רק שהן לא משתוות, אלא שאפילו ניתן להוכיח זאת. במילים אחרות, אנחנו רוצים להוכיח משפט ש<strong>דומה</strong> למשפט <span class="math">\(\mbox{P}\ne\mbox{NP}\)</span>, וצריכים לחפש את ההקלה המתאימה שתאפשר לנו להוכיח משפט שכזה.</p>
<p>בואו ניקח שפה <span class="math">\(L\)</span> כלשהי. לשפה הזו ניתן להתאים שפה אחרת, <span class="math">\(U_{L}\)</span>, של אורכי המילים ב-<span class="math">\(L\)</span> (שוב, בייצוג אונרי). במילים אחרות, בהינתן מספר <span class="math">\(1^{n}\)</span> השאלה היא האם קיימת מילה מאורך <span class="math">\(n\)</span> בשפה <span class="math">\(L\)</span>. זו שאלה שקל מאוד להכריע אם אנחנו מכונה אי דטרמיניסטית עם אורקל לשפה <span class="math">\(L\)</span>: בהינתן <span class="math">\(n\)</span> פשוט מנחשים מילה מאורך <span class="math">\(n\)</span>, שואלים את האורקל האם היא שייכת ל-<span class="math">\(L\)</span> ואם כן - מקבלים. אם כן, לכל שפה <span class="math">\(L\)</span> מתקיים ש-<span class="math">\(U_{L}\in\mbox{NP}^{L}\)</span>. מצד שני, מכונה דטרמיניסטית פולינומית לא יכולה לנקוט בגישה הזו - אם נותנים לה <span class="math">\(n\)</span>, לבדוק את כל המילים מאורך <span class="math">\(n\)</span> ייקח לה יותר מדי זמן כי יש <span class="math">\(2^{n}\)</span> כאלו. זה נותן פתח לתקווה לכך שיתקיים <span class="math">\(U_{L}\notin\mbox{P}^{L}\)</span> עבור שפה <span class="math">\(L\)</span> שתהונדס בצורה מתאימה. כמו שכל מי שמכיר קצת את תורת הסיבוכיות יודע, להוכיח שמשהו הוא קשה זה עניין קשה, והבניה של <span class="math">\(L\)</span> היא יצירתית למדי ומסתמכת - איך לא - על לכסון.</p>
<p>הבה ונמספר את כל מכונות הטיורינג הדטרמיניסטיות עם אורקל הקיימות - <span class="math">\(M_{1},M_{2},M_{3},\dots\)</span>. מה שנעשה יהיה לבנות את <span class="math">\(L\)</span> בשלבים, כשבשלב ה-<span class="math">\(i\)</span> ננסה לגרום למכונה <span class="math">\(M_{i}\)</span> לטעות בתשובה שהיא אמורה לתת על מילה כלשהי מ-<span class="math">\(L\)</span>.</p>
<p>נתחיל מכך ש-<span class="math">\(L\)</span> ריקה. כפי שניתן יהיה לראות מהבניה, בכל שלב תישמר התכונה שב-<span class="math">\(L\)</span> רק מספר סופי של מילים. בסיבוב ה-<span class="math">\(i\)</span> בבניה, ניקח מספר <span class="math">\(n\)</span> שגדול ממספר הסיבוב הנוכחי <span class="math">\(i\)</span> ומאורך כל המילים שעד כה הוכנסו ל-<span class="math">\(n\)</span>. המטרה שלנו - לגרום ל-<span class="math">\(M_{i}\)</span> "לטעות"בתשובה שהיא מחזירה על <span class="math">\(1^{n}\)</span>. בדרך כלל מה שהיינו עושים הוא לומר "נריץ את <span class="math">\(M_{i}\)</span> על <span class="math">\(1^{n}\)</span>; אם <span class="math">\(M_{i}\)</span> דחתה, נוסיף את <span class="math">\(1^{n}\)</span> ל-<span class="math">\(L\)</span>; ואם היא קיבלה לא נוסיף אותו". זה גם הרעיון כאן אבל יש לנו סיבוך - <span class="math">\(M_{i}\)</span> היא מכונה עם גישה לאורקל. ולא סתם אורקל - אורקל לשפה <span class="math">\(L\)</span> שאותה אנו בונים. כלומר, <span class="math">\(M_{i}\)</span>, במהלך ריצתה על <span class="math">\(1^{n}\)</span>, עשויה לשאול את האורקל על מילים שבכלל עוד לא החלטנו אם הן כן או לא ב-<span class="math">\(L\)</span>. עם זאת, זו לא בעיה של ממש - מה שנעשה הוא להריץ את <span class="math">\(M_{i}\)</span> על <span class="math">\(1^{n}\)</span>, בכל פעם שבה <span class="math">\(M_{i}\)</span> תשאל את האורקל על מילה שכבר החלטנו אם היא שייכת ל-<span class="math">\(L\)</span> או לא נענה בהתאם לבחירה שביצענו; ואם <span class="math">\(M_{i}\)</span> שואלת על מילה שאיננה מהמילים שכבר החלטנו עליהן, נענה (בתור האורקל) שהמילה איננה ב-<span class="math">\(L\)</span> ונסמן לנו את זה בצד, למקרה שגם בעתיד ישאלו על המילה הזו.</p>
<p>ה"סכנה" שבדרך הפעולה שלנו היא ש-<span class="math">\(M_{i}\)</span> עלולה לשאול את האורקל שאלה על <strong>כל</strong> המילים מאורך <span class="math">\(n\)</span>. זה אולי נשמע מוזר קצת בהתחלה - לא אמרנו שנדרש זמן אקספוננציאלי כדי לעשות זאת? אבל זו הנקודה העדינה המרכזית בהוכחות מהסוג הזה - אנחנו תוקפים את <span class="math">\(M_{i}\)</span> עבור <span class="math">\(n\)</span> <strong>ספציפי</strong>, בעוד שדיבורים על זמן ריצה אקספוננציאלי הם רלוונטיים רק כשמדברים על ההתנהגות <strong>האסימפטוטית</strong> של <span class="math">\(M_{i}\)</span>, כלומר על האופן שבו <span class="math">\(M_{i}\)</span> מתנהגת על אינסוף קלטים. ייתכן שעל כל הקלטים עד גודל זיליארד <span class="math">\(M_{i}\)</span> דורשת פרק זמן גדול עד להדהים, ורק לאחר מכן היא "נרגעת" ורצה זמן פולינומי - גם אז היא עדיין תיחשב פולינומית. מכאן שהסכנה ש-<span class="math">\(M_{i}\)</span> תבדוק את כל המילים מאורך <span class="math">\(n\)</span> היא מוחשית מאוד, ונדרשים פיתולים טכניים כדי להתגבר עליה. במקרה שלנו, פשוט נגביל את זמן הריצה של <span class="math">\(M_{i}\)</span> - אם היא רצה יותר מ-<span class="math">\(\frac{2^{n}}{10}\)</span> צעדים, פשוט נשכח ממנה ונעבור למכונה הבאה. עוד מעט אסביר איך אפשר להבטיח שזה לא יגרום נזק להוכחה שלנו.</p>
<p>אם <span class="math">\(M_{i}\)</span> עצרה על <span class="math">\(1^{n}\)</span> תוך לכל היותר <span class="math">\(\frac{2^{n}}{10}\)</span> צעדים, אז <strong>בהכרח</strong> היא לא הספיקה לשאול את האורקל על כל הקלטים מאורך <span class="math">\(n\)</span>. אם <span class="math">\(M_{i}\)</span> קיבלה, הרי שהיא טוענת שב-<span class="math">\(L\)</span> יש מילה מאורך <span class="math">\(n\)</span>, אולם כרגע בבניה שלנו אין מילה כזו. זכרו - <span class="math">\(n\)</span> היה מספר שגדול מאורך כל המילים שהחלטנו אם הן ב-<span class="math">\(L\)</span> או לא בתחילת הסיבוב <span class="math">\(i\)</span>, ובמהלך הסיבוב עצמו לא הוספנו אף מילה ל-<span class="math">\(L\)</span> - בכל פעם ש-<span class="math">\(M_{i}\)</span> שאלה את האורקל על מילה חדשה, אמרנו לה שאותה מילה אינה ב-<span class="math">\(L\)</span>. מכאן ש-<span class="math">\(M\)</span> טועה. אם לעומת זאת <span class="math">\(M\)</span> דחתה את <span class="math">\(1^{n}\)</span>, כלומר טענה שאין ב-<span class="math">\(L\)</span> מילה מאורך <span class="math">\(n\)</span>, פשוט נוסיף ל-<span class="math">\(L\)</span> מילה כלשהי ש-<span class="math">\(M_{i}\)</span> לא הספיקה לשאול את האורקל עליה (כאמור, יש כזו). ושוב, <span class="math">\(M\)</span> טועה, והגדלנו את <span class="math">\(L\)</span> במילה אחת בסך הכל, כך ש-<span class="math">\(L\)</span> עדיין סופית.</p>
<p><span class="math">\(L\)</span> "האמיתית" היא התוצר הסופי של כל שלבי הבניה הללו. פורמלית, אם <span class="math">\(L_{i}\)</span> מסמנת את השפה שהתקבלה אחרי השלב ה-<span class="math">\(i\)</span>, אז <span class="math">\(L=\bigcup L_{i}\)</span>. מבחינה מתמטית זו בניה חוקית לחלוטין והשפה מוגדרת היטב, אבל היא עשויה להיות מבלבלת למדי למי שלא רגיל לדברים כאלו. עכשיו צריך להשתכנע ש-<span class="math">\(U_{L}\)</span> אכן אינה מתקבלת על ידי אף מכונה דטרמיניסטית פולינומית.</p>
<p>ובכן, נניח ש-<span class="math">\(M\)</span> היא מכונה דטרמיניסטית פולינומית שכזו, ושזמן הריצה שלה חסום על ידי הפולינום <span class="math">\(p\left(n\right)\)</span>. אז קיים <span class="math">\(n\)</span> גדול מספיק כך ש-<span class="math">\(\frac{2^{n}}{10}&gt;p\left(n\right)\)</span>. במילים אחרות, אם ננסה "לתקוף" את <span class="math">\(M\)</span> עבור המילה <span class="math">\(1^{n}\)</span> או מילים ארוכות יותר, ננצח. איך אפשר להבטיח שאכן נתקוף את <span class="math">\(M\)</span> מתישהו עם מילה ארוכה שכזו? תעלול פשוט - במקום לתקוף את <span class="math">\(M\)</span> פעם אחת, נתקוף אותה <strong>אינסוף</strong> פעמים. כלומר, המניה <span class="math">\(M_{1},M_{2},M_{3},\dots\)</span> לא תכיל כל מכונה רק פעם אחת, אלא מספר אינסופי של פעמים. קל להנדס מניה שכזו - למשל, הביטו בסדרה <span class="math">\(1,1,2,1,2,3,1,2,3,4,\dots\)</span> שבה מובטח שכל מספר טבעי יופיע מספר אינסופי של פעמים. מכאן שאנו נתקלים ב-<span class="math">\(M\)</span> בתור <span class="math">\(M_{i}\)</span> עבור אינסוף ערכים שונים של <span class="math">\(i\)</span>, ומכיוון שדרשנו שה-<span class="math">\(n\)</span> שאותו בוחרים בסיבוב ה-<span class="math">\(i\)</span> יהיה בפרט גדול מ-<span class="math">\(i\)</span>, מובטח לנו שהחל מסיבוב מסויים ה-<span class="math">\(n\)</span> שאיתו נתקוף את <span class="math">\(M\)</span> אכן יביס אותה.</p>
<p>אחרי שמבינים את כל הפרטים הללו, ההוכחה הזו אינה כה מסובכת - ואכן, רוב הרעיונות בה הם סטנדרטיים לגמרי בתורת הסיבוכיות. עיקר היופי בה הוא בבניה ההדרגתית, הכמו-אלגוריתמית של <span class="math">\(L\)</span> ובאופן המחוכם שבו היא מצליחה להתגבר על סכנת ההפניה העצמית שנוצרת משאלות האורקל של <span class="math">\(M_{i}\)</span>. אבל הדבר היפה באמת בהוכחה הזו הוא בכך שההוכחה לכך שלכסון <strong>לא</strong> מסוגל לעשות דבר מה היא עצמה הוכחה בלכסון!</p>
        </article>
        
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2010/09/05/calculus_intro/" class="nav-link nav-next">
                <span class="nav-label">→ פוסט חדש יותר</span>
                <span class="nav-title">אז מה זה חשבון דיפרנציאלי ואינטגרלי?</span>
            </a>
            
            
            
            <a href="/2010/08/16/p_vs_np_hard_to_diagonalize/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר ←</span>
                <span class="nav-title">אז מדוע קשה להוכיח ש-P שונה מ-NP? (בלכסון)</span>
            </a>
            
        </nav>
        
        
        <footer>
            <p>בלוג מתמטיקה בעברית</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>