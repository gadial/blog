<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט לדנר, או - מפרקים לגורמים את NP - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/blog/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/blog/">דף הבית</a>
                <a href="/blog/random.html">פוסט אקראי</a>
                <a href="/blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/blog/2010/11/08/hilberts_hotel/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">המלון של הילברט, או - מדוע יש גדלים שונים של אינסוף</span>
            </a>
            

            
            <a href="/blog/2010/11/20/russel_paradox_and_cantor_theorem/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">הפרדוקס של ראסל ומשפט קנטור</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט לדנר, או - מפרקים לגורמים את NP</h1>
            <div class="post-meta">
                <span class="date">2010-11-10</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/הוכחות יפות.html">הוכחות יפות</a>
                    
                    <a href="/tags/טכני.html">טכני</a>
                    
                    <a href="/tags/משפט לדנר.html">משפט לדנר</a>
                    
                    <a href="/tags/סיבוכיות.html">סיבוכיות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>סדרת הפוסטים האחרונה בבלוג עוררה תגובות נזעמות על כך שהכל קל וטריוויאלי מדי. כדי לנקום במי שטוענים כך, אציג היום פוסט שילכלך את הידיים עד למאוד בפרטים טכניים, אך יציג תוצאה בתורת הסיבוכיות שלטעמי היא יפה מאוד - משפט לדנר (יש יותר ממשפט מפורסם אחד של לדנר, אבל תכף יתברר על מה בדיוק מדובר). גם מי שנרתעים מפרטים טכניים מוזמנים להישאר לפחות לתחילת הפוסט, שבו אסביר מי נגד מי כאן.</p>
<p>ובכן, לא אחזור על כל תורת הסיבוכיות מההתחלה - אניח שהקוראים מכירים את המושגים P ו-NP, ואפילו את המושג הקשה יותר של NP-שלמות. <a href="http://www.gadial.net/2010/08/15/p_vs_np_overview/">כתבתי</a> לא מזמן על המחלקות הללו כך שלא אעשה זאת שוב. השאלה שבה אעסוק הפעם היא זו:</p>
<p>אנחנו מכירים בעיות רבות ששייכות ל-P, כלומר בעיות ששיכות ל-NP והן "הכי קלות" שם. על קצה המזלג: חישוב אריתמטי, חיפוש ברשימה, מיון, חיפוש בגרף, מציאת עץ פורש של גרף, התמרת פורייה בדידה, מציאת קמור של קבוצת נקודות, פתרון בעיית תכנון לינארי, ועוד ועוד ועוד ועוד - וגולת הכותרת של תחילת העשור: בדיקת ראשוניות. לא כל אלו הן בעיות כן/לא אבל העיקרון ברור). בדומה, אנחנו מכירים בעיות רבות שהן NP-שלמות - כלומר, בעיות ב-NP שהן "הכי קשות". ושוב, רשימת המכולת כוללת את SAT, את 3-צביעה של גרפים, מציאת מעגל המילטוני, פתרון בעיית תכנון לינארי בשלמים, ועוד ועוד ועוד. אבל מה אנחנו לא מכירים כרגע בכלל? בעיות ב-NP שהן לא ב-P וגם אינן NP-שלמות.</p>
<p>צריך להבהיר כאן משהו: אין לנו כרגע מושג האם P שונה מ-NP. אם שתי המחלקות הללו שוות, אז <strong>כל</strong> בעיה ב-NP היא גם NP-שלמה, וגם ב-P (למעשה, שתי השפות ה"טריוויאליות" - שפת כל המילים והשפה הריקה - אינן NP-שלמות בגלל בעיה טכנית לא חשובה, אבל נעזוב את זה). אם כן, לשאלה האם יש שפה שאינה ב-P וגם אינה NP-שלמה. כלומר, האם העולם שלנו כולל רק בעיות "הכי קלות" ובעיות "הכי קשות", או שיש גם בעיות "הכי בינוניות"?</p>
<p>יש לנו כרגע מועמדת טבעית לתפקיד בעיה שכזו - בעיית הפירוק לגורמים. לא ידוע אלגוריתם פולינומי לבעיה זו, ובניגוד לבדיקת ראשוניות - גם לא ממש מצפים שאלגוריתם כזה יימצא. עם זאת, ולמרות שזו תהיה סנסציה של ממש, אני לא חושב שהאפשרות לכך שזה יקרה נפסלת על הסף (למעשה, <strong>קיים</strong> אלגוריתם פולינומי לפירוק לגורמים, אבל למחשבים קוונטיים). מפתיע עוד יותר יהיה לגלות שפירוק לגורמים היא בעיה NP-שלמה. אבל כאמור, <strong>להוכיח</strong> שפירוק לגורמים זו בעיית ביניים שכזו בפרט יפתור לנו אחת ולתמיד את סוגיית <span class="math">\(\text{P=NP}\)</span>, ולא ממש סביר שכך זה יקרה...</p>
<p>אז מה כן אפשר לעשות? הוכחה שמתבססת על ההנחה ש-<span class="math">\(\text{P}\ne\text{NP}\)</span>, כמובן, וזה מה שאציג כעת. לרוע המזל, ההוכחה אינה פשוטה; למרבה המזל, היא גם לא כל כך קשה כמו הוכחה אחרת שקראתי בשעתו. ההוכחה הזו קלה מספיק כדי שאציג אותה בבלוג, ולו כדי לנקום במי שרוצים דברים קשים יותר.</p>
<p>כעת אני עובר למוד "מתמטי". אתם מוזמנים להפסיק כאן - מי שימשיך, שלא יתלונן - הזהרתי אתכם. מכאן ואילך אני מניח ידע כלשהו בסיבוכיות.</p>
<p>שפת הביניים שנבנה תתבסס על <span class="math">\(\text{SAT}\)</span>; כזכור (מי שלא זוכר, אולי עדיף שלא ימשיך...), SAT היא פשוט אוסף של פסוקי <span class="math">\(\text{CNF}\)</span> ספיקים, והיא האמא של השפות ה-NP-שלמות, ולכן בוחרים אותה, אבל אפשר היה לקחת כל שפה NP-שלמה אחרת במקומה. הרעיון הוא לקחת מילים ב-SAT ו"לנפח" את האורך שלהן על ידי הוספת ג'יבריש לא מזיק - נניח, תווי <span class="math">\(x\)</span>, שמן הסתם לא מהווים חלק מקידוד של פסוק חוקי. בשביל מה זה טוב? כי אם נוסיף המון תווי <span class="math">\(x\)</span> לפסוק, זה "ישפר"את זמן הריצה של אלגוריתמים עליו; זמן הריצה נמדד ביחס לאורך המילה כולה, כולל הדולרים, אבל זמן הריצה של האלגוריתם ינבע רק מאורך הפסוק עצמו, כי מהדולרים הוא מתעלם... זה נראה כמו רמאות מוחלטת וכמו משהו מטופש מאין כמותו, אני יודע; זו אחת הסיבות שבגללן ההוכחה הזו כה מגניבה.</p>
<p>פורמלית, נניח ש-<span class="math">\(H\left(n\right)\)</span> היא פונקציה מהטבעיים לטבעיים, אז נסמן <span class="math">\(\text{SAT}_{H}\triangleq\left\{ \varphi \\)</span>^{n^{H\left(n\right)}}|\varphi\in\text{SAT},\left|\varphi\right|=n\right} <span class="math">\(. כלומר, אנחנו "מרפדים" כל \)</span>\varphi\in\text{SAT}<span class="math">\( על ידי הוספת \)</span>n^{H\left(n\right)}<span class="math">\( תווי זבל, כאשר \)</span>n<span class="math">\( הוא האורך של \)</span>\varphi<span class="math">\(. ה-\)</span>H\left(n\right)<span class="math">\( שבה נשתמש, שאגדיר אותה בהמשך, תקיים את התכונות הבאות: ראשית, אפשר יהיה לחשב אותה בזמן "סביר". שנית, היא תהיה מונוטונית עולה; ושלישית, והכי חשוב, היא תהיה חסומה אם ורק אם \)</span>\text{SAT}<em H="H">{H}\in\text{P}<span class="math">\(.

כאן נמצא לב ההוכחה. אם \)</span>H<span class="math">\( הייתה גדלה <strong>מהר</strong>, אז היא הייתה גורמת לניפוח אדיר של מילים מ-\)</span>\text{SAT}<span class="math">\( ואז לא היה שום דבר מפתיע בכך ש-\)</span>\text{SAT}</em>}\in\text{P}<span class="math">\(. כי, למשל, אם אני מקבל קלט \)</span>\varphi \<span class="math">\(^{2^{n}}\)</span>, אז גם אם אבדוק את כל ההשמות האפשריות ל-<span class="math">\(\varphi\)</span> זה ייקח לי זמן של <span class="math">\(O\left(2^{n}\right)\)</span> בלבד, וזהו האורך של המילה <span class="math">\(\varphi \\)</span>^{2^{n}}<span class="math">\( - כלומר, יש לי אלגוריתם "לינארי" שפותר את \)</span>\text{SAT<em H="H">{H}<span class="math">\(, אבל כמובן שלא עשיתי פה שום דבר חכם. אם כן, העובדה שדווקא כאשר \)</span>H<span class="math">\( חסומה, ולכן הניפוח שלנו את \)</span>\text{SAT}<span class="math">\( הוא לא יותר מפולינומי בגודלו, דווקא אז \)</span>\text{SAT}</em>}\in\text{P}<span class="math">\( - זו עובדה משונה מאוד שלא כל כך מפתיע שגוררת את התוצאה שאנו מחפשים.

בואו נראה למה.

ראשית, אם \)</span>\text{SAT<em H="H">{H}\in\text{P}<span class="math">\( אז כאמור \)</span>H<span class="math">\( חסומה, כלומר \)</span>H\left(n\right)&lt;c<span class="math">\( עבור קבוע \)</span>c<span class="math">\( כלשהו ולכן \)</span>\text{SAT}</em><span class="math">\(: בהינתן \)</span>\varphi<span class="math">\(, צריך לייצר ממנו את \)</span>\varphi\<span class="math">\(^{n^{H\left(n\right)}}\)</span> אבל את זה קל לעשות - אמרתי שקל לחשב את <span class="math">\(H\left(n\right)\)</span>, ומכיוון שצריך לכתוב רק מספר פולינומי של תווים אחרי <span class="math">\(\varphi\)</span>, הרדוקציה תהיה פולינומית (אם למשל היה צריך לכתוב <span class="math">\(2^{n}\)</span> תווים, הרדוקציה לא הייתה פולינומית והכל היה קורס). אם כן, מאחר והנחנו ש-<span class="math">\(\text{SAT}_{H}\in\text{P}\)</span> והראינו רדוקציה פולינומית של <span class="math">\(\text{SAT}\)</span> אל <span class="math">\(\text{SAT}_{H}\)</span>, אז גם <span class="math">\(\text{SAT}\in\text{P}\)</span> מה שגורר <span class="math">\(\text{P=NP}\)</span>, בסתירה להנחה שלנו ש-<span class="math">\(\text{P}\ne\text{NP}\)</span>.}<span class="math">\( כוללת פסוקים שהניפוח שלהם הוא בסך הכל פולינומי. זה מאפשר לנו לבצע רדוקציה פשוטה של \)</span>\text{SAT}<span class="math">\( אל \)</span>\text{SAT}_{H</p>
<p>מצד שני, אם <span class="math">\(\text{SAT}_{H}\)</span> היא <span class="math">\(\text{NP}\)</span>-שלמה, זה אומר (מהגדרת המושג של <span class="math">\(\text{NP}\)</span>-שלמות) שיש רדוקציה פולינומית מ-<span class="math">\(\text{SAT}\)</span> אליה. טוב, הפעם זה לא מוביל מייד לסתירה כי הרי לא ניתן להסיק מכך ש-<span class="math">\(\text{SAT}\in\text{P}\)</span>, אז מה כן? ובכן, הרדוקציה היא פולינומית? נניח שיש לה חסם זמן ריצה של <span class="math">\(c\cdot n^{d}\)</span>.</p>
<p>עכשיו נעשה תעלול חביב ביותר - <strong>רדוקציה עצמית</strong> של <span class="math">\(\text{SAT}\)</span>. נראה אלגוריתם שבהינתן פסוק <span class="math">\(\varphi\)</span> שאנו רוצים לבדוק את שייכותו ל-<span class="math">\(\text{SAT}\)</span>, מצליח לחלץ ממנו פסוק <span class="math">\(\psi\)</span> ששייך ל-<span class="math">\(\text{SAT}\)</span> אם ורק אם <span class="math">\(\varphi\)</span> שייך ל-<span class="math">\(\text{SAT}\)</span>, וכמו כן <span class="math">\(\left|\psi\right|<\left|\varphi\right|\)</span>. ההקטנה הזו היא קריטית - זה אומר שנוכל לחזור על התהליך שוב ושוב ובכל סיבוב להקטין בביט אחד את מה שיש לבדוק, ועל כן תוך מספר לינארי של סיבובים הפסוק שאנו בודקים יהיה קטן מספיק כדי שניתן יהיה לבדוק אותו באופן ישיר בלי לחשוש מהשלכות קטסטרופליות על זמן הריצה. הרעיון של רדוקציות עצמיות מקצרות אורך שכאלו הוא רעיון יפה וחשוב בפני עצמו ואני שמח שהוא צץ כך באמצע ההוכחה הזו.</p>
<p>טוב, אז איפה היינו? אה, כן, <span class="math">\(\text{SAT}_{H}\notin\text{P}\)</span> (כי היא <span class="math">\(\text{NP}\)</span>-שלמה והנחנו ש-<span class="math">\(\text{P}\ne\text{NP}\)</span>). ולכן מהתכונה החשובה של <span class="math">\(H\left(n\right)\)</span> שדיברתי עליה עולה ש-<span class="math">\(H\left(n\right)\)</span> לא חסומה. מכיוון שהיא גם מונוטונית עולה, נקבל שקיים <span class="math">\(n_{0}\)</span> כך שלכל <span class="math">\(n>n_{0}\)</span> מתקיים <span class="math">\(n^{H\left(n\right)}&gt;c\cdot n^{2d}\)</span>. במילים אחרות - הניפוח הוא יחסית גדול.</p>
<p>אלא מה? הרדוקציה של <span class="math">\(\text{SAT}\)</span> ל-<span class="math">\(\text{SAT}_{H}\)</span> לוקחת פסוק <span class="math">\(\varphi\)</span> כך ש-<span class="math">\(\left|\varphi\right|=n>n_{0}\)</span> ומייצרת אחד משני דברים: או משהו שנראה כמו <span class="math">\(\psi \\)</span>^{\left|\psi\right|^{H\left(\left|\psi\right|\right)}}<span class="math">\(, כאשר \)</span>\psi<span class="math">\( הוא פסוק חוקי (כי כך נראית מילה ב-\)</span>\text{SAT}<em H="H">{H}<span class="math">\(), או משהו שבכלל לא מהצורה הזו (אין בו את הכמות הנכונה של דולרים, או שהוא בכלל נראה שונה לגמרי). במקרה שהמשהו לא מהצורה הנכונה, ברור לנו שהוא לא שייך ל-\)</span>\text{SAT}</em><span class="math">\( וסיימנו. אז נניח מעתה ואילך שהרדוקציה תמיד מייצרת משהו מהצורה הנכונה. השאלה שלנו היא - כמה גדול \)</span>\psi<span class="math">\( יכול להיות? התשובה היא שלא ממש גדול, בגלל שלא היה לרדוקציה הרבה זמן כדי לכתוב את \)</span>\psi\<span class="math">\(^{\left|\psi\right|^{H\left(\left|\psi\right|\right)}}\)</span>, והיו לה המון דולרים לכתוב...}<span class="math">\( ולכן \)</span>\varphi<span class="math">\( לא שייך ל-\)</span>\text{SAT</p>
<p>פורמלית, בואו נסמן <span class="math">\(\left|\psi\right|=k\)</span>. הרדוקציה פעלה על <span class="math">\(\varphi\)</span> בזמן <span class="math">\(c\cdot n^{d}\)</span> לכל היותר, ולכן זה המספר המקסימלי של תווים שהיא יכלה לכתוב - כלומר, <span class="math">\(\left|\psi \\)</span>^{k^{H\left(k\right)}}\right|\le c\cdot n^{d}<span class="math">\(. מצד שני, \)</span>\left|\psi \<span class="math">\(^{k^{H\left(k\right)}}\right|=k+k^{H\left(k\right)}>c\cdot k^{2d}\)</span>. כלומר, קיבלנו <span class="math">\(c\cdot k^{2d}&lt;c\cdot n^{d}\)</span>. מכאן חיש קל עולה ש-<span class="math">\(k=\sqrt{n}\)</span>. כלומר, קיצרנו <strong>מאוד</strong> את <span class="math">\(\varphi\)</span>, ולכן ניתן להשתמש בתעלול הרדוקציה העצמית.</p>
<p>הפסקה. מישהו עדיין עוקב? כי עכשיו הגענו לחלק המסובך בהוכחה - הבניה של <span class="math">\(H\)</span>. למי שבאמת שרד עד לכאן - קחו נשימה עמוקה. ועכשיו בואו ונתחיל.</p>
<p>ראשית, נמספר את כל מכונות הטיורינג: <span class="math">\(M_{k}\)</span> תהיה המכונה ה-<span class="math">\(k\)</span>-ית בסדר הלקסיקוגרפי על כל קידודי המכונות. כעת נגדיר את <span class="math">\(H\left(n\right)=k\)</span> להיות ה-<span class="math">\(k\)</span> הקטן ביותר שמקיים <span class="math">\(k<\log\log n\)</span> וגם ש-<span class="math">\(M_{k}\)</span> מכריעה את <span class="math">\(\text{SAT}_{H}\)</span> עבור <span class="math">\(x\)</span>-ים המקיימים <span class="math">\(\left|x\right|\le\log n\)</span>, בזמן ריצה <span class="math">\(k\left|x\right|^{k}\)</span> לכל היותר. אם אין מכונה כזו, אז <span class="math">\(k=\log\log n\)</span>.</p>
<p>ההגדרה נראית מעגלית, אך מכיוון שכדי להגדיר את <span class="math">\(H\left(n\right)\)</span> עלינו להכיר רק ערכים של <span class="math">\(H\)</span> הקטנים או שווים ל-<span class="math">\(\log n\)</span> אין כאן מעגליות (זוהי הגדרה <strong>רקורסיבית</strong>, לא מעגלית).</p>
<p>אם אתם תוהים כרגע מה לעזאזל - כן, גם אני הרגשתי ככה בהתחלה. אבל ההגדרה לא באמת כזו נוראית, וכל הלוגים המפחידים קיימים שם מסיבה טובה - אנחנו רוצים שאפשר יהיה לחשב את <span class="math">\(H\left(n\right)\)</span> ביעילות. החישוב הזה הוא עניין ישיר למדי - פשוט עוברים בהרצה מבוקרת על כל המכונות <span class="math">\(M_{1},\dots,M_{\log\log n}\)</span> ולכל מכונה, מריצים אותה על כל הקלטים <span class="math">\(x\)</span> המקיימים <span class="math">\(\left|x\right|\le\log n\)</span>. בנוסף צריך לבדוק באופן ישיר האם <span class="math">\(x\in\text{SAT}_{h}\)</span> - זאת עושים באמצעות פתרון בכוח גס של <span class="math">\(\text{SAT}\)</span> וחישוב רקורסיבי של <span class="math">\(H\left(n\right)\)</span> לגדלים קטנים יותר. זו פשוט הפעלת כוח גס באופן הברוטלי ביותר האפשרי, וזה יוצא יעיל בזכות הלוגים.</p>
<p>עכשיו, אם <span class="math">\(H\)</span> אינה מונוטונית עולה אז יש <span class="math">\(n\)</span> כך ש-<span class="math">\(H\left(n\right)=k\)</span> אבל <span class="math">\(H\left(n+1\right)<k\)</span>. מכאן בפרט ש-<span class="math">\(H\left(n+1\right)\ne\log\log\left(n+1\right)\)</span> (כי <span class="math">\(k\le\log\log n\)</span>), כלומר <span class="math">\(H\left(n+1\right)\)</span> הוא מספרה של מכונה שעונה "כמו שצריך" על כל הקלטים עד גודל <span class="math">\(\log\left(n+1\right)\)</span>. אבל מכונה כזו עונה נכון על כל הקלטים עד גודל <span class="math">\(\log n\)</span> ולכן <span class="math">\(H\left(n\right)\)</span> היה צריך להיות קטן או שווה למספרה הסידורי - סתירה.</p>
<p>הראנו כי <span class="math">\(H\left(n\right)\)</span> ניתנת לחישוב יעיל ושהיא מונוטונית עולה. נותר להבין מדוע <span class="math">\(H\left(n\right)\)</span> אכן מקיימת את תכונת החסימות. ראשית נניח כי <span class="math">\(\text{SAT}_{H}\in\text{P}\)</span> ונוכיח כי <span class="math">\(H\)</span> חסומה. אם <span class="math">\(\text{SAT}_{H}\in\text{P}\)</span> אז יש אינסוף מכונות פולינומיות המכריעות את <span class="math">\(\text{SAT}_{H}\)</span> בזמן <span class="math">\(cn^{c}\)</span> עבור <span class="math">\(c>0\)</span> קבוע גדול דיו; תהא <span class="math">\(M_{k}\)</span> מכונה שכזו כך ש-<span class="math">\(k>c\)</span>. אז בפרט <span class="math">\(M_{k}\)</span> מכריעה את <span class="math">\(\text{SAT}_{H}\)</span> עבור קלטים המקיימים <span class="math">\(\left|x\right|\le\log n\)</span> בזמן ריצה <span class="math">\(k\left|x\right|^{k}\)</span> <strong>לכל</strong> <span class="math">\(n\)</span>; מכאן ש-<span class="math">\(H\left(n\right)\le k\)</span> לכל <span class="math">\(n\)</span> שעבורו <span class="math">\(k\le\log\log n\)</span>, כלומר לכל <span class="math">\(n>2^{2^{k}}\)</span>, כלומר <span class="math">\(H\)</span> חסומה.</p>
<p>בכיוון השני, אם <span class="math">\(H\)</span> חסומה נוכיח ש-<span class="math">\(\text{SAT}_{H}\in\text{P}\)</span> באופן הבא: מכיוון ש-<span class="math">\(H\left(n\right)\)</span> חסומה, מעקרון שובך היונים יש ערך <span class="math">\(k\)</span> שאותו היא מקבלת אינסוף פעמים, והדבר גורר ש-<span class="math">\(M_{k}\)</span> מכריעה את <span class="math">\(\text{SAT}_{H}\)</span> בזמן <span class="math">\(k\cdot n^{k}\)</span>. כדי לראות זאת, נניח שעל קלט <span class="math">\(x\)</span> כלשהו, <span class="math">\(M_{k}\)</span> לא עוצרת עם התשובה הנכונה בזמן <span class="math">\(k\cdot\left|x\right|^{k}\)</span>, אז על פי הגדרת <span class="math">\(H\)</span> בהכרח <span class="math">\(H\left(n\right)\ne k\)</span> לכל <span class="math">\(n>2^{\left|x\right|}\)</span> - סתירה.</p>
<p>זו סוף ההוכחה.</p>
<p>בקריאה מחודשת, ההוכחה הזו היא למעשה <strong>פשוטה</strong> למדי. אין בה יותר מדי פרטים, ההגדרה היא יחסית ישירה, ואין צורך בטיעונים מחוכמים כל כך בשביל להתקדם. הוכחות כאלו הן נפוצות למדי בתורת הסיבוכיות, ואחרי שמתרגלים אליהן, הן באמת לא נוראיות כל כך. כך זה באופן כללי במתמטיקה - הוכחות שלצופה מבחוץ נראות מזוויעות לחלוטין, נראות פשוטות למדי למישהו "מבפנים". עבורי, ככותב בלוג מתמטי, הוכחות כאלו מהוות בעיה מהותית. מצד אחד לטעמי הן יפהפיות וקלות להבנה ומן הראוי שאציג אותן לכל דורש; מצד שני, ברור לי לחלוטין שרובם המוחץ של הקוראים לא ישרדו יותר מכמה שורות של ההוכחה - ולמה שישרדו? הרי הם לא קוראים ספר לימוד בסיבוכיות וקשה להם להתעמק בפרטים, שאותם אני כנראה לא מציג באופן טוב כפי שספר לימוד מסוגל. אני לא מסוגל לפשט מהותית את ההוכחה או לתת הרבה הסברים אינטואיטיביים לה - כאן ההבנה מגיעה משליטה בטכניקה עצמה.</p>
<p>אז טוב שלפעמים מפצירים בי לכתוב משהו מתקדם ונותנים לי תירוץ לכתוב פוסט כזה כעונש. כמובן, אנסה גם לכתוב פוסטים יותר "סקירתיים"ופחות טכניים על נושאים מתקדמים, אבל יותר קל להבטיח מלקיים; בפרט, בהתחשב בכך שהידע המתמטי שלי הוא לא רחב עד כדי כך (גם אם הבלוג אולי נותן אשלייה שגויה שאין זה כך).</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>