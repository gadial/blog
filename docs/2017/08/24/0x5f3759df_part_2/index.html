<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>המעשה המופלא בקבוע המסתורי 0x5f3759df (חלק ב&#39; - הקשה) - לא מדויק</title>
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2017/08/22/0x5f3759df_part_1/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">המעשה המופלא בקבוע המסתורי 0x5f3759df (חלק א&#39; - הקל)</span>
            </a>
            

            
            <a href="/2017/08/29/plimpton_322/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">המעשה המופלא בלוח המסתורי פלימפטון 322</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>המעשה המופלא בקבוע המסתורי 0x5f3759df (חלק ב&#39; - הקשה)</h1>
            <div class="post-meta">
                <span class="date">2017-08-24</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אנליזה מתמטית.html">אנליזה מתמטית</a>
                    
                    <a href="/categories/תכנות.html">תכנות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/1597463007.html">1597463007</a>
                    
                    <a href="/tags/לוגריתמים.html">לוגריתמים</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בואו נמשיך את <a href="http://www.gadial.net/2017/08/22/0x5f3759df_part_1/">סיפור המעשה מהפוסט הקודם</a> על קוד מסתורי שמחשב את <span class="math">\(f\left(x\right)=\frac{1}{\sqrt{x}}\)</span> בצורה יעילה עד להפתיע. אנחנו כבר כמעט מסוגלים להבין מה הקוד עושה באופן מלא, רק צריך קודם להבין את העניין הפעוט הזה של איך מספרים מיוצגים במחשב.</p>
<h2>פרק רביעי, ובו ביטים עושים דברים</h2>
<p>בגדול, אפשר לומר שחלק נכבד מהיקום כולל דברים שמורכבים מדברים. יצירות לגו מפוארות מורכבות מאבני לגו בסיסיות. מולקולות חומר פשוטות ומסובכות בנויות מאטומים (והם בתורם בנויים מ... עזבו, לא פוסט בפיזיקה). המידע הגנטי שלנו שמקודד ב-DNA בנוי מארבע "אותיות בסיסיות" G,C,T,A. התמונה שאתם רואים במסך המחשב מורכבת מ<strong>פיקסלים</strong> - נקודות על המסך שכל אחת מהן היא בעלת צבע אחיד (שבתורו מורכב משלושה צבעים - אדום, ירוק, כחול - בעוצמות משתנות). כאשר מדברים על משהו שמורכב מאבני יסוד בסיסיות לא מספיק לומר מה אבני היסוד - גם צריך להסביר איך הן מתחברות זו לזו כדי ליצור דברים. אצטון ופרופיונאלדהיד הן שתי מולקולות שונות שמורכבות בדיוק מאותם אטומים אבל מחוברים בצורה שונה. כרגע עומד מולי רובוט לגו שבעזרת אותן אבני בניין בדיוק שלו יכלתי להרכיב גם מסוק או טנדר.</p>
<p><a href="/img/2017/08/lego.jpg" rel="attachment wp-att-3483"><img class="aligncenter size-full wp-image-3483" src="/img/2017/08/lego.jpg" alt="lego" width="640" height="520" /></a></p>
<p>כאשר מדובר על לגו, יש אינספור אבנים בסיסיות, אבל אצלנו במדעי המחשב יש בדיוק שני אבני בניין: הספרות 0 ו-1, שבהקשר הזה נקראות <strong>ביטים</strong>. אנחנו בונים מהן הכל. כל פריט מידע במחשב הוא, בסופו של דבר, ביטים. המספרים השלמים; והמספרים הממשיים; וקומנדר קין והרפתקאותיו והמסמך שאני כותב כרגע וכל המידע שאי פעם נכתב בפייסבוק וכל סרט קולנוע שאי פעם אוכסן במחשב - כולם בסופו של דבר בנויים רק מ-0 ו-1. למה? למה לא לאפשר אבני בניין מורכבות יותר? כי קל, ברמת החומרה של המחשבים, לעבוד רק עם שתי אבני הבניין הללו (בלשון ציורית ולא מדויקת, קל להבדיל ביניהן במערכת אלקטרונית בעזרת "יש זרם חשמלי" ו"אין זרם חשמלי"). גם האופן שבו אנחנו מחברים את 0 ו-1 זה לזה הוא פשוט ביותר - אנחנו פשוט כותבים אותם בשורה. למשל:</p>
<p>011010101</p>
<p>רצף הביטים הזה הוא דוגמא לפריט מידע שמאוחסן במחשב. אבל <strong>איזה</strong> מידע? ובכן, כאן ההקבלה ללגו או למולקולות קצת משתנה. המחשב יכול לקחת את אותה סדרה של אפסים ואחדות ולחשוב עליה כאילו היא מייצגת דברים שונים ומשונים. היא יכולה לייצג מספר, והיא יכולה באותה מידע בדיוק גם לייצג אות. בשל כך המחשב על פי רוב מבצע איזה שהוא סוג של <strong>פירוש</strong> כדי להבין איך לחשוב על הסדרה הזו כרגע. זה דומה לאופן שבו מילים נהגות בתור סדרה של הברות בסיסיות, אבל אותו צליל, בשפות שונות, יכול להיות בעל משמעויות שונות. "היא" בעברית ו-he באנגלית נשמעים אותו דבר אבל הם <strong>מתפרשים</strong> שונה, בהתאם לשומע והשפה שהוא מצפה לשמוע באותו הרגע.</p>
<p>שפות תכנות משתמשות ב<strong>משתנים</strong>. משתנה הוא מקום בזיכרון של המחשב שניתן לו שם קליט בתוך הקוד של התוכניות ובאמצעות השם הזה אפשר לומר לתוכנית לעשות עם המקום הזה דברים - לכתוב שם הרבה פעמים 0, לכתוב שם הרבה פעמים 1, לכתוב 01010101 וכדומה. כדי שלתוכנית יהיה קל להבין מה בדיוק אמור לקרות עם המקום הזה בזכרון, למשתנים בדרך כלל יש <strong>טיפוס</strong> - משהו שכולל מידע על "מה המשתנה אמור לייצג". מה זה בדיוק אומר - זה משתנה משפת תכנות לשפת תכנות, ואפילו מסוג אחד של טיפוס לסוג אחר, מבחינת רמת הפירוט שאליה ההגדרה נכנסת. למשל, זה יכול לכלול מידע על כמות הביטים שהמשתנה משתמש בהם (לפעמים בכמה ביטים <strong>בדיוק</strong> הוא משתמש, ולפעמים בכמה ביטים <strong>לכל הפחות</strong> הוא אמור להשתמש). פרט לכמות הביטים הטיפוס גם כולל לפעמים מידע על איך אמורים להתייחס אליהם. אותנו מעניינים בהקשר של הקוד שלנו שני טיפוסים שבהם משתמשים בשפת C: הראשון הוא long, שמיועד לתאר ערכים מספריים שלמים, והשני הוא float שנועד לתאר מספרים שיכולים להיות גם שבריים ומיוצגים בייצוג שנקרא <strong>נקודה צפה</strong> ואסביר בקרוב.</p>
<p>נתחיל בלדבר על long. זו דוגמה לטיפוס שמגדיר את ה"בערך" אבל ההגדרה שלו לא נכנסת לפרטים מדוייקים. אין הגדרה חד משמעית לכמות הביטים שמשתנה מסוג long משתמש בהם, אבל התקן קובע שהוא ישתמש <strong>לפחות</strong> ב-32 ביטים. בהקשר של הקוד שהופיע ב-Quake אנחנו יודעים שהכוונה הייתה ל<strong>בדיוק</strong> 32 ביטים כי אחרת לא ברור מה הולך שם. לצורך מה שקורה בקוד חשוב שמספר הביטים של ה-long יהיה שווה למספר הביטים ש-float משתמש בו (והמספר הזה הוא <strong>חד משמעית</strong> 32, כי כך קובע התקן). אין גם הגדרה חד משמעית לאופן שבו הביטים של משתנה מטיפוס long אמורים להתנהג, אבל בפועל מה ש-long תמיד עושה הוא לחשוב על הביטים שלו כמייצגים מספר שלם בבסיס בינארי. יש לי <a href="http://www.gadial.net/2017/06/11/number_bases/">פה</a> הסבר על בסיסי ספירה אבל הנה הרעיון הבסיסי: בבסיס בינארי כל מספר מיוצג על ידי סדרת ביטים שמתארת אותו כסכום של חזקות של 2. למשל, סדרת הביטים 1101 אומרת "זה המספר שמיוצג על ידי הסכום <span class="math">\(2^{0}+2^{2}+2^{3}=1+4+8=13\)</span>". הביט הכי <strong>שמאלי</strong> מייצג את החזקה <strong>הכי גבוהה </strong>של 2 שמחברים. כל זה קורה גם בבסיס 10, כמובן: אנחנו רגילים כבר לתרגם אוטומטית משהו כמו 1,089 ל"אלף ועוד שמונים ועוד תשע" בלי אולי לשים לב לכך שאנחנו מחברים חזקות של 10 שנכפלות במקדם כלשהו בבסיס בינארי המקדם הוא רק 0 או 1, אבל הרעיון הוא אותו רעיון.</p>
<p>יש לייצוג מספרים על ידי long רמת סיבוך נוספת שאני חוסך מכם בפוסט הזה כי היא לא רלוונטית - האופן שבו מיוצגים מספרים שליליים. לא ניכנס לזה כרגע. ובמקום זה נעבור לדבר על הייצוג של מספרים על ידי נקודה צפה.</p>
<h2>פרק חמישי, ובו נתוודע לפרנקנשטיין של שפות התכנות - הנקודה הצפה</h2>
<p>בואו נתחיל מכך שאודה ששיקרתי לכם. קודם הצגתי את העניינים כאילו הרעיון ב-long הוא ייצוג של מספר שלם והרעיון ב-float הוא ייצוג של מספר "ממשי", בפרט כזה שיכול להיות שבר. ובכן, ראשית כל, float לא יכול לייצג מספר ממשי כללי, למשל את <span class="math">\(\pi\)</span>. כל מה שהוא יודע לייצג הוא מספרים רציונליים - שברים שאפשר להציג בתור <span class="math">\(\frac{a}{b}\)</span> כאשר <span class="math">\(a,b\)</span> שניהם שלמים. שנית, אם כל מה שהייתי רוצה הוא לייצג רציונליים הייתי יכול פשוט להשתמש בזוג long, לא לגמרי ברור שצריך טיפוס נתונים חדש בשביל זה. אם כן, "לייצג מספר ממשי" או "לייצג שבר" <strong>איננה</strong> הסיבה שבגללה אנחנו מתעניינים ב-float. אז מה כן הסיבה?</p>
<p>הסיבה היא שלפעמים לא אכפת לנו אם המספר שלנו לא מיוצג בצורה <strong>מדוייקת</strong>. לפעמים אפשר לחפף ולעגל קצת, אם זה משתלם לנו. הרעיון ב-float הוא לוותר קצת על הדיוק המושלם ש-long מציע ותחת זאת להרחיב בצורה <strong>משמעותית</strong> את טווח המספרים שאפשר לייצג באמצעות 32 ביט. אם באמצעות long אפשר לייצג במדויק <strong>כל מספר</strong> בתחום שבין 0 ל-<span class="math">\(2^{32}-1\)</span> (מי שרוצה לנטפק - תזכרו, אמרתי שלא אכנס לשלמים שליליים פה) הרי שבאמצעות float אפשר לייצג מספרים עד בערך <span class="math">\(2^{127}\)</span>, ושברים עד בערך <span class="math">\(2^{-126}\)</span> ואפילו קטן יותר מכך. המחיר הוא שאי אפשר לייצג <strong>את כל המספרים</strong> בטווחים הללו; יש לנו מגבלת דיוק. על פי רוב, בשימושים של float שמעניינים אותנו המגבלה הזו לא מפריעה לנו.</p>
<p>ב-float גם כן יכולים להיות מספרים שליליים, והפעם גם אתייחס לאופן שבו מייצגים אותם כי הוא קצת יותר פשוט מאשר ב-long, ולשם שינוי גם מוגדר היטב. בכלל, לנקודה צפה יש יתרון שהיא מוגדרת יחסית טוב <a href="https://en.wikipedia.org/wiki/IEEE_754">בסטנדרט</a> של ה-IEEE ורוב מי שמממש נקודה צפה (בתוכנה/חומרה) יתאים את עצמו לסטנדרט. הקוד של 0x5f3759df מתבסס על זה, כמובן.</p>
<p>מספר בייצוג float מורכב מ-32 ביט, שמחולקים לשלוש קבוצות: הביט הראשון, השמאלי ביותר, הוא <strong>הסימן</strong> של המספר. אם הוא 0, המספר חיובי; אם הוא 1, המספר שלילי. 8 הביטים הבאים נקראים <strong>האקספוננט</strong> של המספר, ו-23 הביטים הנותרים נקראים <strong>המנטיסה</strong> שלו.</p>
<p><a href="/img/2017/08/618px-IEEE_754_Single_Floating_Point_Format.svg_.png" rel="attachment wp-att-3485"><img class="aligncenter size-full wp-image-3485" src="/img/2017/08/618px-IEEE_754_Single_Floating_Point_Format.svg_.png" alt="618px-IEEE_754_Single_Floating_Point_Format.svg" width="618" height="125" /></a></p>
<p>כדי להבין את המשמעות של אלו, בואו נראה לרגע על דרכים שונות שבהן אפשר לייצג את המספר <span class="math">\(314.15\)</span>. אני יכול לכתוב סתם <span class="math">\(314.15\)</span>, אבל אני גם יכול לכפול בחזקות של 10: למשל, לכתוב <span class="math">\(31.415\cdot10^{1}\)</span>, או <span class="math">\(3.1415\cdot10^{2}\)</span>, או <span class="math">\(3141.5\cdot10^{-1}\)</span> וכדומה. הבנתם את הרעיון: אני לוקח את המספר הבסיסי, <span class="math">\(314.15\)</span>, ו"מזיז" את הנקודה העשרונית ("מציף" אותה) כשהמחיר הוא כפל בחזקה מתאימה של 10. הזזתי את הנקודה שמאלה? אני כופל בחזקה חיובית של 10. הזזתי אותה ימינה? אני כופל בחזקה שלילית. באופן הזה אפשר להחליט שכל מספר ייוצג בצורה "נורמלית" שבה יש בדיוק ספרה אחת משמאל לנקודה העשרונית; הייצוג ה"נורמלי" של <span class="math">\(314.15\)</span> יהיה, אם כן, <span class="math">\(3.1415\cdot10^{2}\)</span>. ה<strong>אקספוננט</strong> של המספר הזה הוא החזקה של 10 בייצוג הנורמלי, וה<strong>מנטיסה</strong> שלו היא המספר שבו מכפילים מצד שמאל.</p>
<p>בואו נראה עוד דוגמה. את המספר <span class="math">\(1,000\)</span> קל לייצג עם נקודה צפה: <span class="math">\(1.0\cdot10^{3}\)</span>. מה על מספר ששונה ממנו טיפ-טיפה, נאמר 1,002? אותו אפשר לייצג על ידי <span class="math">\(1.002\cdot10^{3}\)</span>. שימו לב מה קרה - נזקקנו ליותר ספרות במנטיסה כדי לייצג את המספר הזה מאשר את <span class="math">\(1,000\)</span> שמיוצג בצורה ישירה באמצעות האקספוננט. באופן דומה, אם אני ארצה לייצג את מיליון זה יהיה קל, אבל אם ארצה לייצג את "מיליון ועוד 2" אצטרך עוד הרבה ספרות במנטיסה. וגם את <span class="math">\(10^{100}\)</span> קל לייצג, אבל לייצג את <span class="math">\(10^{100}+2\)</span> כבר יהיה יותר מדי עבורי - אין לי מספיק מקום במנטיסה בשביל זה כי אצטרך לכתוב <span class="math">\(1.000\dots2\)</span> כאשר יש בערך מאה אפסים. הנה כי כן, זו בדיוק מגבלת ה"חוסר דיוק" שדיברתי עליה. את <span class="math">\(10^{100}+2\)</span> אני לא יכול לייצג, אבל אני יכול להסתפק ב-<span class="math">\(10^{100}\)</span> שאותו אני כן יכול לייצג והוא קירוב מצויין ל-<span class="math">\(10^{100}+2\)</span>. כל עוד אני לא <strong>חייב</strong> ייצוג מדויק של כל המספרים הללו.</p>
<p>בסדר עד כאן? אז בואו נסבך קצת. הצגתי את מספרי הנקודה הצפה שלי כאילו הם כתובים בבסיס עשרוני, אבל בפועל float מיוצג על ידי ייצוג בינארי (יש גם נקודה צפה של מספרים עשרוניים אבל זה לא רלוונטי לכאן). זה אומר שהאקספוננט והמנטיסה שניהם נכתבים בבסיס בינארי ואנחנו כופלים את המנטיסה בחזקה של 2 ולא 10, אבל זה גם אומר עוד משהו - אין צורך לזכור את הספרה הבודדת שמשמאל לנקודה העשרונית במפורש; אנחנו יודעים שהיא לא 0, כי ככה מוגדרת הצורה הנורמלית של מספר - יש משמאל לנקודה בדיוק ספרה אחת שאינה 0. לכן, עבור מספר נקודה צפה בבסיס בינארי, המנטיסה מתארת רק את מה שקורה <strong>מימין</strong> לנקודה העשרונית - החלק השברי של המספר.</p>
<p>סיבוך נוסף שטרם דיברתי עליו הוא האופן שבו מאפשרים למספרים שליליים להופיע בתוך האקספוננט. מה שעושים הוא להשתמש במשהו שנקרא bias. יש 8 ביטים של אקספוננט, מה שאומר שאפשר לייצג איתם כל מספר מ-0 עד 255. מכיוון שרוצים חצי חיוביים וחצי שליליים, מגדירים bias של <span class="math">\(B=127\)</span> ומגדירים שהוא תמיד מחוסר מהאקספוננט. כלומר, אם <span class="math">\(E\)</span> מייצג את <span class="math">\(200\)</span> אז האקספוננט של המספר יהיה <span class="math">\(2^{E-B}=2^{73}\)</span>. בצורה הזו האקספוננט הגבוה ביותר הוא <strong>לכאורה</strong> <span class="math">\(2^{128}\)</span> והנמוך ביותר הוא <span class="math">\(2^{-127}\)</span> אבל בפועל הסטנדרט לא מרשה לנו להשתמש באקספוננטים 11111111 ו-0000000 באופן חופשי: את 11111111 שומרים כדי לייצג את אינסוף ואת NaN (ערך שאומר "לא קיבלתי מספר") ואילו 00000000 שמור כדי לאפשר ייצוג של 0 ושל מספרים נמוכים במיוחד (משהו שנקרא denormalized numbers שאני פשוט לא הולך לדבר עליהם כאן כי לא צריך את זה). לכן טווח האקספוננטים החוקי הוא מ-<span class="math">\(2^{127}\)</span> ועד <span class="math">\(2^{-126}\)</span>.</p>
<p>בואו נחזור על מה שיש לנו במספר float: יש 32 ביטים בסך הכל. ביט אחד, שנקרא לו <span class="math">\(s\)</span>, הוא ביט הסימן. 8 הביטים הבאים, שנקרא להם <span class="math">\(E\)</span>, הם הביטים של האקספוננט: אפשר לכתוב <span class="math">\(E=E_{7}E_{6}E_{5}E_{4}E_{3}E_{2}E_{1}E_{0}\)</span> כאשר כל <span class="math">\(E_{i}\)</span> באגף ימין הוא ביט בודד. לסיום, המנטיסה תסומן ב-<span class="math">\(M\)</span> (ברשותכם, לא אכתוב את כל הביטים שלה). עכשיו, בהינתן <span class="math">\(s,E,M\)</span> אפשר לחשב את הערך המפורש של המספר שהם מייצגים ככה:</p>
<p><span class="math">\(\left(-1\right)^{s}\cdot1.M\cdot2^{E-B}\)</span></p>
<p>לפעמים במקום <span class="math">\(1.M\)</span> יותר נוח וקריא לכתוב <span class="math">\(1+\frac{M}{2^{23}}\)</span> או אפילו לסמן <span class="math">\(m=\frac{M}{2^{23}}\)</span> ואז לכתוב</p>
<p><span class="math">\(\left(-1\right)^{s}\cdot\left(1+m\right)\cdot2^{E-B}\)</span></p>
<p>סיימנו עם זה! עכשיו אנחנו מבינים מספרי נקודה צפה ברמה שתספיק להמשך הפוסט. נעבור סוף סוף לשאלת השאלות: מה קורה כשאני לוקח float וחושב על הביטים שלו כמגדירים long?</p>
<h2>פרק שישי, ובו שלמים ושברים ולוגריתמים יפים אלו דברים שאותי משמחים</h2>
<p>בואו נסתכל על שורת ה"המרה" הידועה לשמצה מהקוד:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="c1">// evil floating point bit level hacking</span>
</code></pre></div>


</div>

<p>כפי שאמרתי קודם, מה שקורה בשורה הזו איננו המרה - אנחנו לא אומרים לתוכנית לקחת את ה-float שלנו ולעגל אותו עד שיתקבל מספר שלם או משהו. אנחנו עושים משהו ברוטלי ומסוכן באופן כללי: לוקחים את 32 הביטים בזיכרון שמיוצגים על ידי y ואומרים לתוכנית לחשוב עליהם בכוח בתור long. למי שסקרן, זה האופן הטכני שבו זה נעשה: ראשית אנחנו מבקשים "נא לתת לנו את הכתובת בזכרון שבה המידע של y שוכן". זה מה שעושה האופרטור &amp; כשהוא מוצמד ל-y. אחר כך אנחנו לוקחים את הכתובת הזו, שכרגע התוכנית חושבת עליה בתור "כתובת של float'', ואנחנו מבצעים עליה פעולה שבשפת c נקראת casting ומתבצעת על ידי ה-long * שבסוגריים (הסוגריים עצמם אומרים לתוכנית שיש כאן פעולת casting). הפעולה הזו אומרת לתוכנית - "נכון שיש לך כתובת שאת חושבת עליה בתור כתובת של float? מעכשיו תחשבי עליה בתור כתובת של long". הכוכבית האחרונה בתחילת השורה היא דרך לומר "אוקיי, עכשיו נא לתת לי את הערך המספרי שכתוב בתוך כתובת הזיכרון שלך". התוכנית עושה את הדבר הבא: בשלב הזה, יש לה כתובת זכרון ולידה סימון "הכתובת הזו מכילה long''. אז התוכנית לוקחת את 32 הביטים מהכתובת, מתייחסת אליהם בתור מספר long ומציבה בתוך i. כל זה ברור למי שמכיר את השפה, ואני מנחש שמי שלא מכיר אותה כבר הלך לאיבוד. לא נורא, לא צריך להבין מה השורה עושה ברמה הטכנית הזו, רק מה האפקט שזה משיג.</p>
<p>ומה זה עושה בפועל, למספר? מיש-מש, זה מה שזה עושה. ביטים שלפני רגע הייתה להם משמעות אחת מקבלים משמעות לא לגמרי קשורה, אבל גם לא לגמרי שונה. אנחנו עדיין יכולים לחשוב על הביטים בתור שלוש קבוצות - <span class="math">\(s,E,M\)</span> - רק שעכשיו כל קבוצה תורמת משהו למספר השלם שמיוצג על ידי ה-long.</p>
<p>המשך הניתוח שאציג מתבסס בעיקר על <a href="http://h14s.p5r.org/2012/09/0x5f3759df.html">המאמר הזה</a> שמספק ניתוח יפה מאוד של הסיפור הזה. יש עוד ניתוחים שונים ומשונים שאפשר לעשות וקשה לי לומר מי מהם הוא ה"נכון", אבל זה שאציג כרגע הוא ללא ספק הפשוט ביותר (והנחמד ביותר, לטעמי) מביניהם.</p>
<p>בגדול, מאוד בגדול, מה שקורה כשמעבירים ככה מספר מ-float אל long הוא שממירים אותו ל<strong>לוגריתם</strong> של עצמו כפול איזה שהוא קבוע. בואו נזכר מה זה לוגריתם בכלל. אם <span class="math">\(x=2^{y}\)</span> אז <span class="math">\(\log x=y\)</span>. כלומר, הלוגריתם של <span class="math">\(x\)</span> הוא המספר שאם מעלים את 2 בחזקה שלו, מקבלים את <span class="math">\(x\)</span> (אני מציג פה את מה שנקרא "לוגריתם על בסיס 2" כי זה מה שרלוונטי לנו בפוסט הזה). למשל, <span class="math">\(\log8=3\)</span> כי <span class="math">\(2^{3}=8\)</span>. לעומת זאת <span class="math">\(\log7\)</span> לא הולך לצאת מספר יפה אלא משהו אי-רציונלי שנמצא אי שם בין 2 ל-3.</p>
<p>אנחנו אוהבים לוגריתמים כי הם מבצעים מעין "הורדה בדרגת הקושי" לפעולות חשבוניות מסובכות. כפל וחילוק הופכים להיות חיבור וחיסור, ואילו העלאה בחזקה והוצאת שורש הופכות להיות כפל וחילוק. הנה הכללים המתאימים:</p>
<p><span class="math">\(\log\left(a\cdot b\right)=\log a+\log b\)</span></p>
<p><span class="math">\(\log\left(\frac{a}{b}\right)=\log a-\log b\)</span></p>
<p><span class="math">\(\log a^{n}=n\log a\)</span></p>
<p><span class="math">\(\log\sqrt[n]{a}=\frac{1}{n}\log a\)</span> (זה בעצם נובע מכך ש-<span class="math">\(\sqrt[n]{a}\)</span> הוא <span class="math">\(a^{\frac{1}{n}}\)</span>).</p>
<p>בימים עברו, לפני המצאת המחשבון, השתמשו ב<strong>טבלאות לוגריתמים</strong> כדי לבצע חישובים מסובכים: טבלת לוגריתמים כללה ערכים של מספרים ולידם את הערך של הלוגריתם שלהם. אם הייתי רוצה לבצע פעולה מסובכת כמו כפל 128 ב-512 מה שהייתי עושה הוא להסתכל בטבלת הלוגריתמים, לראות שהלוגריתמים של שני המספרים הללו הם 7 ו-9 בהתאמה, <strong>לחבר</strong> את 7 ו-9 לקבלת 16, ואז להסתכל בטבלת הלוגריתמים ולראות שהמספר שהלוגריתם שלו הוא 16 הוא המספר 65536. היו גם כלים מיוחדים בשם <strong>סרגלי חישוב</strong> שסייעו לעשות את החישוב הזה. בצורה הזו אמנם נדרשה עבודה ראשונית ביצירה של טבלת הלוגריתמים/סרגל החישוב, אבל בעבודה היומיומית הם חסכו הרבה כאב ראש בביצוע פעולות חשבון. מה שאני רוצה לומר כאן הוא שלוגריתמים זה דבר נפלא שכשלומדים אותו בתיכון לפעמים בכלל לא מבינים בשביל מה הוא טוב.</p>
<p>המקרה הנוכחי מושלם עבור לוגריתמים. <span class="math">\(\frac{1}{\sqrt{x}}\)</span> זו דרך אחרת לכתוב <span class="math">\(x^{-\frac{1}{2}}\)</span>. נפעיל על זה לוגריתם ונקבל <span class="math">\(\log\left(x^{-\frac{1}{2}}\right)=-\frac{1}{2}\log x\)</span>. אז ברמת הלוגריתמים כל פעולת החישוב המסובכת שאנחנו רוצים לבצע היא בסך הכל כפל במינוס חצי. ומה תגידו? כפל כזה מתבצע בפועל!</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x5f3759df</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// what the fuck?</span>
</code></pre></div>


</div>

<p>תתעלמו לרגע מהקבוע המסתורי שלנו. מה שיש באגף ימין הוא <span class="math">\(-\frac{i}{2}\)</span>. בשביל לראות את זה אני צריך להסביר סוף סוף מה אומר ה-1&lt;&lt; הזה. ובכן,&lt;&lt; זה אופרטור שמופעל על מספר שלם ומבצע <strong>הזזה ימינה</strong> של הביטים שלו. ה-1 שמצד ימין של האופרטור אומר כמה להזיז ימינה - 1 פירושו להזיז בדיוק פעם אחת. כלומר, המספר <span class="math">\(0110\)</span> יהפוך להיות המספר <span class="math">\(0011\)</span> וכן הלאה. בפועל הפעולה הזו מבצעת חלוקה ב-2 של המספר השלם (עם עיגול למטה במקרה שמקבלים שבר). אם כן, מה שהשורה המסתורית הזו הוא הוא לכפול את <span class="math">\(i\)</span> במינוס חצי ולהוסיף לו את הקבוע המסתורי בתור... לא לגמרי ברור בתור מה עדיין. אז בואו נמשיך עם הפרטים.</p>
<h2>פרק שביעי, שבו התעלומה באה על פתרונה והקוראים מתלוננים על אנטי-קליימקס</h2>
<p>כעת, אמרנו שמספר float מיוצג על ידי ביט אחד של <span class="math">\(s\)</span>, אחריו ביטים של <span class="math">\(E\)</span> ואחר כך ביטים של <span class="math">\(M\)</span>. הביטים של <span class="math">\(M\)</span> הם הראשונים, ולכן הם אכן מייצגים בדיוק את המספר <span class="math">\(M\)</span>. הביטים של <span class="math">\(E\)</span>, לעומת זאת, מתחילים החל מהמקום ה-24. אם הביט במקום ה-1 מייצג את הספרה שמתאימה ל-<span class="math">\(2^{0}\)</span>, הרי שהביט במקום ה-24 מיצג את הספרה שמתאימה ל-<span class="math">\(2^{23}\)</span>, ולכן <span class="math">\(E\)</span> מייצג את המספר</p>
<p><span class="math">\(2^{23}E_{0}+2^{24}E_{1}+\dots+2^{30}E_{7}=2^{23}\left(E_{0}+2^{1}E_{1}+\dots2^{7}E_{7}\right)=2^{23}\cdot E\)</span></p>
<p>ולבסוף, הביט <span class="math">\(s\)</span> של הסימן מייצג את <span class="math">\(2^{31}\)</span>. כלומר, המספר כולו מתפרש בתור ה-long הבא: <span class="math">\(2^{31}s+2^{23}E+M\)</span>. בפועל, אפשר להתעלם מהביט <span class="math">\(s\)</span> של הסימן: הוצאת שורש היא פעולה שאנחנו מבצעים רק עבור מספרים חיוביים, ולכן הסימן של ה-float הוא חיובי, מה שאומר ש-<span class="math">\(s=0\)</span> בכל מה שנעשה. על כן המספר מתפרש בתור <span class="math">\(L\cdot E+M\)</span> כאשר <span class="math">\(L=2^{23}\)</span> הוא קבוע שיאפשר לנו לקרוא יותר בקלות מכאן ואילך. זכרו שהמספר המקורי בתור float היה <span class="math">\(x=\left(1+\frac{M}{L}\right)2^{E-B}\)</span>. נשאלת כעת השאלה - עד כמה <span class="math">\(L\cdot E+M\)</span> הזה אכן יהיה דומה ל-<span class="math">\(\log x\)</span>? לצורך כך כדאי לקבל הערכה כלשהי לערך של <span class="math">\(\log x\)</span>, ולצורך כך אני אשתמש ב<strong>קירוב</strong> מוכר במתמטיקה: זה ידוע שכאשר <span class="math">\(t\)</span> הוא קטן יחסית, אז <span class="math">\(\log\left(1+t\right)\approx t\)</span> (למעוניינים, זה נובע מפיתוח טיילור של <span class="math">\(\log\left(1+t\right)\)</span>). במקרה שלנו, <span class="math">\(\frac{M}{L}\)</span> הוא קטן יחסית (כי הגדול של <span class="math">\(M\)</span> חסום על ידי <span class="math">\(L\)</span>) ולכן אפשר להשתמש בקירוב <span class="math">\(\log\left(1+\frac{M}{L}\right)\approx\frac{M}{L}\)</span>. מצד שני, אין סיבה שנשתמש בקירוב הזה באופן עיוור ופשוט נתעלם מכך שאולי כדאי להוסיף "תיקון" כלשהו שיפצה על החלקים שהעפנו מהקירוב. אז נגדיר פרמטר <span class="math">\(\sigma\)</span> שאת הערך שלו נוכל לבחור באופן שרירותי ונשתמש בקירוב הבא: <span class="math">\(\log\left(1+\frac{M}{L}\right)\approx\frac{M}{L}+\sigma\)</span>. לא לגמרי ברור בשלב הזה אילו ערכים של <span class="math">\(\sigma\)</span> הם טובים לנו ואיזה לא (אולי <span class="math">\(\sigma=0\)</span> הוא טוב?) ולכן אנחנו לא מתחייבים על ערך ספציפי עבורו.</p>
<p>כעת, נקבל מהזהויות שקשורות בלוגריתם שראינו למעלה את הדבר הבא:</p>
<p><span class="math">\(\log\left(x\right)=\log\left(\left(1+\frac{M}{L}\right)2^{E-B}\right)=\log\left(1+\frac{M}{L}\right)+\log2^{E-b}\)</span></p>
<p><span class="math">\(\approx\frac{M}{L}+\sigma+E-B\)</span></p>
<p>עכשיו, אם נסמן <span class="math">\(y=\frac{1}{\sqrt{x}}\)</span>, הרי ש-<span class="math">\(y\)</span> הוא המספר שאנחנו מחפשים. בייצוג על ידי נקודה צפה גם הוא ישתמש בפרמטרים <span class="math">\(M,E\)</span>, אבל כאלו שיהיו שונים מאלו של <span class="math">\(x\)</span>. לכן נשתמש בסימונים כדי להבדיל ביניהם: את <span class="math">\(M,E\)</span> שהשתמשתי בהם עד כה אסמן מעכשיו ב-<span class="math">\(M_{x},E_{x}\)</span>, ואילו את האקספוננט והמנטיסה של <span class="math">\(y\)</span>, שאותם אני מחפש, אסמן ב-<span class="math">\(E_{y},M_{y}\)</span>. אותו חישוב כמו קודם עובד גם עבור <span class="math">\(y\)</span>, ולכן יש לנו עכשיו שלוש משוואות:</p>
<p><span class="math">\(\log\left(x\right)\approx\frac{M_{x}}{L}+\sigma+E_{x}-B\)</span></p>
<p><span class="math">\(\log\left(y\right)\approx\frac{M_{y}}{L}+\sigma+E_{y}-B\)</span></p>
<p><span class="math">\(\log y=-\frac{1}{2}\log x\)</span></p>
<p>נשלב את המשוואות הללו יחד:</p>
<p><span class="math">\(\frac{M_{y}}{L}+\sigma+E_{y}-B\approx-\frac{1}{2}\left(\frac{M_{x}}{L}+\sigma+E_{x}-B\right)\)</span></p>
<p>נעביר את הקבועים <span class="math">\(\sigma,B\)</span> אגף ונקבל</p>
<p><span class="math">\(\frac{M_{y}}{L}+E_{y}\approx\left(B+\frac{1}{2}B\right)-\left(\sigma+\frac{1}{2}\sigma\right)-\frac{1}{2}\left(\frac{M_{x}}{L}+E_{x}\right)\)</span></p>
<p>כלומר</p>
<p><span class="math">\(\frac{M_{y}}{L}+E_{y}\approx\frac{3}{2}\left(B-\sigma\right)-\frac{1}{2}\left(\frac{M_{x}}{L}+E_{x}\right)\)</span></p>
<p>לסיום, נכפול את שני האגפים ב-<span class="math">\(L\)</span> ונקבל</p>
<p><span class="math">\(M_{y}+LE_{y}\approx\frac{3}{2}L\left(B-\sigma\right)-\frac{1}{2}\left(M_{x}+LE_{x}\right)\)</span></p>
<p>ותראו מה קיבלנו! ה-<span class="math">\(M_{x}+LE_{x}\)</span> באגף ימין הוא <strong>בדיוק</strong> הערך של המספר שממנו התחלנו, כשמפרשים את הביטים שלו בתור long; והערך באגף שמאל הוא מספר שאם נפרש את הביטים שלו בתור float אז המנטיסה שלו תהיה <span class="math">\(M_{y}\)</span> והאקספוננט שלו יהיה <span class="math">\(E_{y}\)</span>. זה גם בדיוק מה שעושים בשורה הבאה:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
</code></pre></div>


</div>

<p>ועל כן, המשוואה שלעיל היא בדיוק מה שמנחה את שורת ה-what the fuck? הידועה לשמצה:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x5f3759df</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// what the fuck?</span>
</code></pre></div>


</div>

<p>זה מסביר למה היא נראית ככה וגם מיהו הקבוע המסתורי: הוא פשוט <span class="math">\(\frac{3}{2}L\left(B-\sigma\right)\)</span>. זכרו ש-<span class="math">\(L\)</span> הוא פשוט המספר <span class="math">\(2^{23}\)</span> ו-<span class="math">\(B\)</span> הוא המספר <span class="math">\(127\)</span> - אלו פרמטרים שנטועים עמוק בהגדרה של ה-IEEE למהו float, אבל גם אם הערכים שלהם היו שונים היינו עדיין מקבלים משוואה דומה, רק עם "קבוע מסתורי" שונה.</p>
<p>כמובן שעכשיו נשאלת השאלה איזה ערך של פרמטר <span class="math">\(\sigma\)</span> הולך לתת את הקבוע 0x5f3759df מתוך הביטוי <span class="math">\(\frac{3}{2}L\left(B-\sigma\right)\)</span>. התשובה היא שזה <span class="math">\(\sigma=0.0450465\)</span>, אבל זה בעצם לא אומר לנו שום דבר. כאן בעצם מגיע החלק המאכזב ביותר בכל הסיפור - מי שיצפה לראות איזה הגיון קוסמי שבזכותו נוצר דווקא המספר 0x5f3759df ולא אחרים לא ימצא אותו - זה ככל הנראה מספר שכותב הקוד הגיע אליו אחרי קצת ניסוי וטעיה - ראה שהוא עובד מספיק טוב, ולא ניסה לשפר יותר. עדיין, אם מישהו רוצה ניתוח קצת יותר מפורט של ערכים אפשריים אחרים, אפשר להסתכל <a href="https://cs.uwaterloo.ca/~m32rober/rsqrt.pdf">בתזה הזו</a>, שבכלל נמנעת משימוש בלוגריתמים ומסתכלת בצורה מפורשת מאוד על ההבדל בתוך ה-float שגורמות הפעולות שמבצעים עליו. מסבירים שם, למשל, למה קבוע שנותן ערך <strong>טוב יותר</strong> בתור הקירוב אחרי השורה הזו הוא <strong>פחות טוב</strong> באופן כללי, כי ניוטון-רפסון מחזיר עליו תוצאה פחות נחמדה, וגם נותנים ערך טוב יותר מ-0x5f3759df בתור קבוע קסם מסתורי עבור הפונקציה. מבחינתי זה מחסל את 0x5f3759df המסכן לגמרי - הוא לא כל כך מעניין אם הבחירה בו הייתה כל כך שרירותית. אולי יום אחד אתבדה ואגלה שהוא נבחר מסיבות מצויינות שאיני מכיר.</p>
<h2>פרק שמיני, שבו אנחנו תוהים בשביל מה כל זה היה טוב</h2>
<p>הסיפור שלנו מתקרב לסופו, אבל אני רוצה להזכיר למה בכלל נכנסנו אליו מלכתחילה. כזכור, שם המשחק הוא גרפיקה. הגרפיקה הזו:</p>
<p><a href="/img/2017/08/Quake-3-Torrent-3.jpg" rel="attachment wp-att-3479"><img class="aligncenter size-full wp-image-3479" src="/img/2017/08/Quake-3-Torrent-3.jpg" alt="Quake-3-Torrent-3" width="810" height="407" /></a></p>
<p>בשביל לייצר גרפיקה יפה שכזו צריך לדעת לחשב כל מני חישובים. למשל, איך אור משתקף מכל מני משטחים. כשהיינו בימי Wolf3D העליזים כל המשטחים היו פשוטים מאוד - קירות שעמדו בזווית של 90 מעלות ביחס לרצפה וזהו. אבל בעולם תלת-ממדי שנראה טוב, זה לא המצב. יש משטחים באלכסונים, ויש משטחים מעוגלים ועוד ועוד. כשרוצים לחשב איך תתנהג קרן אור שפוגעת במשטח בנקודה כלשהי, אנחנו צריכים לדעת משהו על "הכיוון המקומי" של המשטח באותה נקודה. הכיוון הזה מיוצג באמצעות <strong>וקטור יחידה</strong> במרחב התלת ממדי. "וקטור יחידה" פירושו שהאורך של הוקטור הוא 1. למה דווקא 1? כי פעולות שמערבות את הוקטור הזה דורשות שהוא יוכפל סקלרית בדברים, ואם האורך שלו הוא לא 1 אז הוא "ינפח" את הדברים הללו באופן מלאכותי. בפועל מה שקורה הוא שקודם כל מוצאים את הכיוון של הוקטור - כלומר, מוצאים וקטור <strong>כלשהו</strong> שמצביע בכיוון הנכון, ואז <strong>מנרמלים</strong> את הוקטור - מחלקים אותו באורך של עצמו. אם <span class="math">\(v\)</span> הוא וקטור, אז האורך שלו הוא <span class="math">\(\|v\|\triangleq\sqrt{v\cdot v}\)</span>. על כן, הוקטור המנורמל <span class="math">\(\frac{v}{\|v\|}\)</span> שווה ל-<span class="math">\(v\cdot\frac{1}{\sqrt{v\cdot v}}\)</span>. הופס! אנחנו צריכים למצוא את ההופכי של שורש של משהו!</p>
<p>אם מסתכלים בקוד ומחפשים שימושים של Q_rsqrt זה בדיוק מה שמוצאים. למשל:</p>
<p><a href="/img/2017/08/code2.png" rel="attachment wp-att-3484"><img class="aligncenter size-full wp-image-3484" src="/img/2017/08/code2.png" alt="code2" width="561" height="326" /></a></p>
<p>שמופיע בקובץ q_math.c (ואפשר לראות כרגע <a href="https://github.com/id-Software/Quake-III-Arena/blob/master/code/game/q_math.c">כאן</a>).</p>
<p>"רגע, זה הכל?" אולי אתם שואלים. ובכן, צריך לזכור שאנחנו מחשבים את הוקטורים הללו עבור אינספור נקודות על כל המשטחים שסביבנו. ככל שיש יותר וקטורים, כך התיאור שלנו של המשטחים נראה יותר ריאליסטי. לכן הפונקציה הזו הולכת להיקרא המון פעמים. ככה בדיוק זה אופטימיזציות: בסופו של דבר צוואר הבקבוק הוא בדיוק בפונקציות הכי קטנות ופשוטות ושם שוברים את הראש על מציאת דרכים טובות יותר לבצע את החישוב.</p>
<p>אז בעצם, מה גרם לחישוב להיות כל כך טוב? שילוב של שני דברים: ראשית, ניוטון-רפסון, שהיא שיטה מגניבה באופן כללי; ושנית, קירוב (קונספטואלי, לכל הפחות) שבוצע ללא שום המרה מפורשת אלא פשוט התייחסות קצת שונה לביטים של הערכים שפעלנו עליהם. אלו הרעיונות המגניבים כאן. ומה עם המספר המסתורי 0x5f3759df? למה בדיוק הוא נבחר? האם יש לו איזו תכונה קסומה שבעטיה הוא נבחר? כנראה שלא, אבל זו תישאר אחת מהתעלומות הקטנות של מדעי המחשב גם לדורות הבאים.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>