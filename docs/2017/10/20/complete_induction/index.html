<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אינדוקציה שלמה ואינדוקציה רגילה - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.5em 10px;
            quotes: "\201C""\201D""\2018""\2019";
        }
        
        blockquote:before {
            color: #ccc;
            content: open-quote;
            font-size: 4em;
            line-height: 0.1em;
            margin-left: 0.25em;
            vertical-align: -0.4em;
        }
        
        blockquote p {
            display: inline;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2017/09/04/chess_queens_fiasco/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">על הבעיה הקשה של מלכות השחמט והבעיה הקשה עוד יותר של מלקות התקשורת</span>
            </a>
            

            
            <a href="/2017/10/31/what_are_rings/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">אז מה זה בעצם חוג?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>אינדוקציה שלמה ואינדוקציה רגילה</h1>
            <div class="post-meta">
                <span class="date">2017-10-20</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/כללי.html">כללי</a>
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אינדוקציה מתמטית.html">אינדוקציה מתמטית</a>
                    
                    <a href="/tags/אינדוקציה שלמה.html">אינדוקציה שלמה</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>פנו אלי בשאלה פשוטה: איך מוכיחים את עקרון האינדוקציה השלמה מעקרון האינדוקציה הרגיל? ובכן, בואו נסביר על מה מדובר בכלל, ואיך מוכיחים.</p>
<p>אינדוקציה "רגילה" היא דרך מקובלת במתמטיקה להסיק טענה כללית: מתחילים ממקרים פרטיים ספציפיים שבהם קל להראות את הטענה באופן מפורש, ואז מציגים "תבנית הוכחה" שהיא מהצורה "אם המקרה הפשוט הזה נכון, אז גם המקרה היותר מסובך הזה נכון". הרעיון הוא שלכל מקרה שנרצה להוכיח, נוכל איכשהו להתחיל ממקרה פרטי שעבורו כבר הוכחנו את הטענה, ואז להסיק ממנו, באמצעות תבנית ההוכחה שלנו, מקרים יותר ויותר מסובכים עד שנגיע אל המקרה הספציפי שאנחנו רוצים להוכיח.</p>
<p>את התיאור המאוד כללי ומנופנף ידיים הזה לרוב דוחסים לתוך המסגרת המאוד פשוטה של המספרים הטבעיים - המספרים <span class="math">\(1,2,3,4,\dots\)</span> (נעזוב את 0 להפעם). הרעיון הוא שיש לנו סדרה של טענות, כשכל טענה מתאימה למספר טבעי אחר. למשל, השווין <span class="math">\(1+2+3+\dots+n=\frac{n\left(n+1\right)}{2}\)</span> הוא בעצם דרך כללית לתאר את הסדרה הבאה של טענות:</p>
<p>טענה מס' 1: <span class="math">\(1=\frac{1\left(1+1\right)}{2}\)</span></p>
<p>טענה מס' 2: <span class="math">\(1+2=\frac{2\left(2+1\right)}{2}\)</span></p>
<p>טענה מס' 3: <span class="math">\(1+2+3=\frac{3\left(3+1\right)}{2}\)</span></p>
<p>וכך זה נמשך ונמשך.</p>
<p>אינדוקציה "רגילה" אומרת את הדבר הבא: נניח שאנחנו יודעים להוכיח את הטענה במפורש עבור <span class="math">\(n=1\)</span> (<strong>הבסיס</strong>) ונניח גם ש<strong>אם</strong> נתון לנו שהטענה נכונה עבור <span class="math">\(n\)</span> כלשהו אז אנחנו יודעים להוכיח שהטענה נכונה עבור <span class="math">\(n+1\)</span> (<strong>הצעד</strong>) אז הטענה נכונה לכל <span class="math">\(n\)</span>. האינטואיציה היא שכדי להוכיח את טענה 3, למשל, אנחנו מבצעים שרשרת של טענות מהצורה "אוקיי, קודם כל טענה 1 נכונה כי הנה הוכחה מפורשת. עכשיו, אני יודע להוכיח ש<strong>אם</strong> טענה 1 נכונה אז גם טענה 2 נכונה, וכבר ראיתי שטענה 1 נכונה אז המסקנה היא שטענה 2 נכונה. עכשיו, אני יודע להוכיח ש<strong>אם </strong>טענה 2 נכונה אז גם טענה 3 נכונה, וכבר ראינו ש-2 נכונה ולכן גם 3 נכונה". עבור טענה 1,000,000 אותו עיקרון בדיוק יעבוד, אם כי השרשרת שתיווצר תהיה מפלצתית באורכה (אבל האורך הזה יהיה סופי, שזו הנקודה החשובה פה כי הוכחות אמורות להיות תמיד סופיות).</p>
<p>אינדוקציה "שלמה" אומרת את הדבר הבא: נניח ש<strong>אם </strong>נתון לנו שהטענה נכונה <strong>לכל</strong> מספר טבעי מ-1 ועד <span class="math">\(n\)</span>, אז אנחנו יודעים להוכיח את הטענה עבור <span class="math">\(n+1\)</span>, אז מכאן נובע שהטענה נכונה לכל <span class="math">\(n\)</span>. כאן אין הבדלה בין הבסיס ובין הצעד, כי הבסיס הוא הסיטואציה שבה <span class="math">\(n=0\)</span>, ואז ה"צעד" אומר את הדבר הבא: אנחנו יודעים להוכיח שהטענה נכונה עבור 1 <strong>אם</strong> נתון לנו שהיא נכונה לכל מספר טבעי שגדול או שווה ל-1 אבל קטן או שווה ל-0, כלומר במקרה הזה לא נתון לנו כלום, וזו בדיוק הסיטואציה של להוכיח את המקרה <span class="math">\(n=1\)</span> בלי כלום.</p>
<p>מה ההבדל בין אינדוקציה רגילה ושלמה? באינדוקציה שלמה <strong>יש יותר על מה להתבסס</strong> כשבאים להוכיח שהטענה נכונה עבור <span class="math">\(n+1\)</span>. באינדוקציה רגילה כל מה שיש לנו הוא את נכונות הטענה עבור <span class="math">\(n\)</span>, וזהו; אבל אולי המקרה עבור <span class="math">\(n\)</span> לא רלוונטי עבור <span class="math">\(n+1\)</span> ודווקא קל להוכיח את המקרה <span class="math">\(n+1\)</span> אם נתונה לנו הטענה עבור <span class="math">\(n-1\)</span>? לכן אינדוקציה שלמה באה להגיד לנו - קחו איזה מקרה שתרצו מבין אלו ש"כבר עברתם". אם נחשוב על זה לרגע, כשאני מוכיח את המקרה <span class="math">\(n=5\)</span> באינדוקציה <strong>רגילה</strong>, מה שאני עושה הוא קודם כל לייצר הוכחות עבור המקרים <span class="math">\(1,2,3,4\)</span> ואז להשתמש רק במקרה 4 כדי להוכיח את 5. אין סיבה עקרוני למה לא להשתמש גם ב"תוצרי הלוואי" שהוכחתי בדרך - 1,2,3.</p>
<p>אם לסכם - אינדוקציה שלמה נראית <strong>חזקה יותר</strong> כי היא נותנת לנו בצעד האינדוקציה יותר מידע שאפשר להתבסס עליו, אבל בפועל זה לא מידע שצץ משום מקום - גם באינדוקציה רגילה הוא נוצר, והאינדוקציה הרגילה פשוט "שוכחת ממנו". תחשבו על האופן שבו אנחנו לפעמים קוראים ערכים בויקיפדיה: אנחנו נכנסים לערך כלשהו, באמצע הקריאה לוחצים על לינק ומתחילים לקרוא על ערך אחר, ואז על ערך אחר וכן הלאה; כשאנחנו עוברים ערך אנחנו יכולים או סתם ללחוץ על הלינק והדפדפן יעבור לערך החדש, או שאנחנו יכולים לפתוח את הלינק בטאב חדש, תוך שאנחנו שומרים את הטאבים שכוללים את כל הערכים שבהם היינו עד כה. זו המחשה להבדל בין שתי הגישות.</p>
<p>אז למה אנחנו כאן? בשביל הפורמליזם. השאלה המעניינת היא זו: נניח שאנחנו יודעים שהמספרים הטבעיים מקיימים את תכונת האינדוקציה הרגילה; איך אפשר להסיק מכך שהם מקיימים את תכונת האינדוקציה השלמה? איך עושים את זה פורמלית? ולמה בעצם זו בעיה?</p>
<p>כדי לפשט טיפה את הדיון מבלי לפגוע במהות שלו, בואו נציג ניסוח קצת יותר נקי של מהי אינדוקציה. במקום לדבר על "תכונות" נדבר על קבוצות. אינדוקציה רגילה אומרת את הדבר הבא: תהא <span class="math">\(S\)</span> קבוצה כלשהי של מספרים טבעיים. אם <span class="math">\(1\in S\)</span> וגם ידוע שלכל <span class="math">\(n\)</span> טבעי, אם <span class="math">\(n\in S\)</span> אז <span class="math">\(n+1\in S\)</span>, אז המסקנה היא ש-<span class="math">\(S=\mathbb{N}\)</span>, דהיינו <span class="math">\(S\)</span> כוללת את כל הטבעיים. בואו ננסח את זה בצורה יותר פורמלית, כדי למנוע ככל הניתן כפלי משמעות שהשפה מכניסה:</p>
<p><span class="math">\(\forall S\left[\left(1\in S\wedge\left(\forall n\left(n\in S\to n+1\in S\right)\right)\right)\to S=\mathbb{N}\right]\)</span></p>
<p>הניסוח הזה הוא עדיין כתיבה בנפנוף ידיים כלשהו - זה לא פסוק שמתאים בדיוק לכל כללי הלוגיקה הפורמלית, אבל זה מספיק טוב לצריכנו, שהם לתאר פורמלית את מה שקורה פה. עכשיו אנסח אינדוקציה שלמה בצורה דומה:</p>
<p><span class="math">\(\forall S\left[\left(\forall n\left(\forall k\left(k&amp;lt;n\to k\in S\right)\to n\in S\right)\right)\to S=\mathbb{N}\right]\)</span></p>
<p>בואו ננסה להבין איך צריכה להיראות הוכחה פורמלית יחסית לדברים הללו. ראשית, ה-<span class="math">\(\forall S\)</span> הזה אומר שאני צריך לקחת <span class="math">\(S\)</span> <strong>כלשהי</strong> ולהוכיח את הטענה בסוגריים עבור אותה <span class="math">\(S\)</span>. כלומר, מה שנשאר להוכיח הוא כעת</p>
<p><span class="math">\(\left(\forall n\left(\forall k\left(k&amp;lt;n\to k\in S\right)\to n\in S\right)\right)\to S=\mathbb{N}\)</span></p>
<p>זו טענה מהמבנה הכללי <span class="math">\(A\to B\)</span>. טענות כאלו הן נכונות תמיד, למעט במקרה שבו <span class="math">\(A\)</span> הוא "אמת" ואילו <strong><span class="math">\(B\)</span> </strong>הוא "שקר". כלומר, היעד שלנו הוא להראות שהמקרה הזה לא מתאפשר. מכיוון שבמקרה הזה <span class="math">\(A\)</span> הוא "אמת" אני יכול להוסיף את <span class="math">\(A\)</span> להנחות שלי, ומכיוון שאני רוצה להראות שגם <span class="math">\(B\)</span> הוא אמת, אני רוצה להוכיח את <span class="math">\(B\)</span>. במילים אחרות, אם אני מתחזק לעצמי שתי רשימות - רשימה של "ההנחות שלי" ורשימה של "הדברים שעלי להוכיח", ורשימת "הדברים שעלי להוכיח" כללה את <span class="math">\(A\to B\)</span>, אז אני מוציא את <span class="math">\(A\to B\)</span> מהרשימה הזו, מוסיף לה את <span class="math">\(B\)</span> ומוסיף את <span class="math">\(A\)</span> לרשימת ההנחות שלי.</p>
<p>על כן, ה"צריך להוכיח" שלי כולל דבר יחיד: <span class="math">\(S=\mathbb{N}\)</span>. ההנחות שלי כוללות את הרישא של נוסחת האינדוקציה השלמה, ואת <strong>כל</strong> נוסחת האינדוקציה הרגילה. כלומר, יש לי שתי הנחות:</p>
<ol>
    <li><span class="math">\(\forall n\left(\forall k\left(k&amp;lt;n\to k\in S\right)\to n\in S\right)\)</span></li>
    <li><span class="math">\(\left(1\in S\wedge\left(\forall n\left(n\in S\to n+1\in S\right)\right)\right)\to S=\mathbb{N}\)</span></li>
</ol>
<p>את הנחה מס' 2 אפשר לנצל בצורה הבאה: הסיפא שלה היא בדיוק מה שאני צריך להוכיח, ולכן אם אוכיח את הרישא שלה, סיימתי. זה אומר שאני יכול <strong>להחליף</strong> את הצריך להוכיח המקורי שלי בנוסחה הבאה:</p>
<p><span class="math">\(1\in S\wedge\left(\forall n\left(n\in S\to n+1\in S\right)\right)\)</span></p>
<p>אלו בעצם שני "צריך להוכיח" שונים שכתובים יחד. רשימת ה"צריך להוכיח" שלי, אם כן, היא כעת:</p>
<ol>
    <li><span class="math">\(1\in S\)</span></li>
    <li><span class="math">\(\forall n\left(n\in S\to n+1\in S\right)\)</span></li>
</ol>
<p>וההנחה שבאמצעותה אני אמור להוכיח את שני אלו היא זו: <span class="math">\(\forall n\left(\forall k\left(k&amp;lt;n\to k\in S\right)\to n\in S\right)\)</span>. בואו נראה איך זה מוכיח את 1: ההנחה מתקיימת לכל <span class="math">\(n\)</span>, ולכן בפרט עבור הבחירה <span class="math">\(n=1\)</span>. כשמציבים את הבחירה הזו בהנחה, מקבלים</p>
<p><span class="math">\(\left(\forall k\left(k&amp;lt;1\to k\in S\right)\to1\in S\right)\)</span>. כמו קודם, אנחנו יכולים להחליף את ה"צריך להוכיח" הנוכחי שלנו, <span class="math">\(1\in S\)</span>, ברישא של הפסוק הזה, <span class="math">\(\forall k\left(k&amp;lt;1\to k\in S\right)\)</span>. אצלנו הטבעיים לא כוללים את 0, ולכן <span class="math">\(k&amp;lt;1\)</span> הוא משהו שלא מתקיים לאף טבעי. לכן הנוסחה <span class="math">\(\forall k\left(k&amp;lt;1\to k\in S\right)\)</span> היא נכונה תמיד (אם הרישא היא "שקר" לא אכפת לנו אם הסיפא היא אמת או שקר). זה מסיים את זה.</p>
<p>עד עכשיו הכל עבד כל כך חלק, אז איפה הבעיה בעצם? בדיוק בשלב הבא: נשאר לי להוכיח ש-</p>
<p><span class="math">\(\forall n\left(n\in S\to n+1\in S\right)\)</span></p>
<p>כלומר, עבור <span class="math">\(a\)</span> שרירותי כלשהו, אנחנו רוצים להוכיח ש-<span class="math">\(a\in S\to a+1\in S\)</span> (בכוונה החלפתי את האות). במילים אחרות, אנחנו רוצים להוכיח את <span class="math">\(a+1\in S\)</span> עם ההנחה <span class="math">\(a\in S\)</span> והנחה נוספת: ההנחה החזקה-לכאורה של אינדוקציה שלמה, שאומרת ש- <span class="math">\(\forall n\left(\forall k\left(k&amp;lt;n\to k\in S\right)\to n\in S\right)\)</span>. אם אני אציב <span class="math">\(n=a+1\)</span>, הסיפא של ההנחה שלי תהיה בדיוק מה שאני חותר אליו, ויישאר לי רק להראות את <span class="math">\(\forall k\left(k&amp;lt;a+1\to k\in S\right)\)</span>. וכאן אני נתקע.</p>
<p>למה אני נתקע? כי לא נתון לי ש-<span class="math">\(k\in S\)</span> <strong>לכל</strong> <span class="math">\(k&amp;lt;a+1\)</span>; זה נתון רק עבור <span class="math">\(k\)</span> ספציפי - <span class="math">\(k=a\)</span>. ההנחה הרחבה של האינדוקציה השלמה היא <strong>חסרון</strong> במקרה הנוכחי, כי בניגוד לסיטואציות הרגילות שבהן אני <strong>משתמש</strong> באינדוקציה שלמה, ואז זה מקל על החיים, כאן אני מנסה להוכיח <strong>את עקרון האינדוקציה השלמה עצמו</strong>, ולצורך כך אני צריך לקושש <strong>יותר</strong> נתונים מאשר בדרך כלל. לכאורה נתקעתי.</p>
<p>הפתרון הוא פתרון סטנדרטי כאשר משתמשים באינדוקציה ונתקעים - <strong>לחזק את הנחת האינדוקציה</strong>. כשמוכיחים את צעד האינדוקציה מוכיחים <span class="math">\(n\in S\to n+1\in S\)</span>. כאן אנחנו נעזרים ב<strong>הנחה</strong> <span class="math">\(n\in S\)</span> כדי להוכיח את ה<strong>צעד</strong> <span class="math">\(n+1\in S\)</span>. אם ההנחה <span class="math">\(n\in S\)</span> לא מספיק טובה לנו, אנחנו מחליפים את <span class="math">\(S\)</span> כולה ב-<span class="math">\(S^{\prime}\)</span> שהיא <strong>חיזוק</strong> של <span class="math">\(S\)</span> - כלומר, היא תכונה שכל מי שמקיים אותה מקיים גם את <span class="math">\(S\)</span>, אבל כוללת יותר אינפורמציה שאפשר לנצל. בצורה הזו אנחנו מקבלים את ההנחה החזקה יותר <span class="math">\(n\in S^{\prime}\)</span> ואם בחרנו את <span class="math">\(S^{\prime}\)</span> בחוכמה, נוכל להוכיח את הצעד החזק יותר (ולכן הקשה יותר להוכחה) <span class="math">\(n+1\in S^{\prime}\)</span> יותר בקלות.</p>
<p>במקרה שלנו החיזוק הוא די ברור: <span class="math">\(S^{\prime}=\left\{ n\in S\ |\ \forall k&amp;lt;n\left(k\in S\right)\right\} \)</span>. כלומר, התכונה שלנו עכשיו היא "אני מקיים את <span class="math">\(S\)</span> וכך גם כל מי שקטן ממני". בבירור <span class="math">\(S^{\prime}\subseteq S\)</span> ולכן אם אוכיח <span class="math">\(S^{\prime}=\mathbb{N}\)</span> ינבע מכך <span class="math">\(S=\mathbb{N}\)</span>. בשביל להוכיח ש-ּ<span class="math">\(S^{\prime}=\mathbb{N}\)</span> צריך להוכיח את שתי הטענות שהצגתי קודם:</p>
<ol>
    <li><span class="math">\(1\in S^{\prime}\)</span></li>
    <li><span class="math">\(\forall n\left(n\in S^{\prime}\to n+1\in S^{\prime}\right)\)</span></li>
</ol>
<p>מבין שתיהן, הטענה הראשונה כבר טופלה - כבר ראינו ש-<span class="math">\(1\in S\)</span> ומכיוון שלא קיים <span class="math">\(k&amp;lt;1\)</span> אז השייכות <span class="math">\(1\in S^{\prime}\)</span> נובעת מיידית. נשאר רק להוכיח את צעד האינדוקציה ה"מחוזק", כלומר ש-<span class="math">\(a\in S^{\prime}\to a+1\in S^{\prime}\)</span>. כעת, אם <span class="math">\(a\in S^{\prime}\)</span> אז מהגדרת <span class="math">\(S^{\prime}\)</span> נקבל ש-<span class="math">\(k\in S\)</span> לכל <span class="math">\(k&amp;lt;a+1\)</span>. זה אומר שכדי להראות ש-<span class="math">\(a+1\in S^{\prime}\)</span> צריך אך ורק להראות ש-<span class="math">\(a+1\in S\)</span>. עכשיו מצבנו השתפר! אנחנו צריכים להוכיח את הטענה</p>
<p><span class="math">\(a+1\in S\)</span></p>
<p>שגם קודם הסתבכנו איתה, אבל עכשיו יש לנו הנחה חזקה יותר:</p>
<p><span class="math">\(a\in S^{\prime}\)</span></p>
<p>וההנחה הזו נותנת לנו את מה שהיה חסר לנו קודם: <span class="math">\(k\in S\)</span> לכל <span class="math">\(k&amp;lt;a+1\)</span>. עם ההנחה הזו אפשר להשתמש בהנחה הנוספת שקיבלנו מעקרון האינדוקציה השלמה ולקבל <span class="math">\(a+1\in S\)</span> כפי שרצינו, מה שמסיים את ההוכחה.</p>
<p>לסיכום, אין בעקרון האינדוקציה השלמה שום דבר מתוחכם במיוחד - הוא דוגמא בסיסית לאופן שבו אפשר <strong>לחזק</strong> את עקרון האינדוקציה הרגיל על ידי שינוי התכונה שאותה מוכיחים באינדוקציה. אבל זה אחד מהמקרים הללו שבהם קשה להבין מה בעצם הבעיה עד שלא חופרים בו טכנית לעומק.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>