<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>על P=NP מעל חבורות אבליות - מבוא שלם - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                text-align: center;
                margin-bottom: 10px;
            }
            
            .top-nav .nav-links {
                flex-direction: column;
                width: 100%;
            }
            
            .top-nav .nav-links a {
                text-align: center;
                padding: 8px;
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/new_blog/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/new_blog/">דף הבית</a>
                <a href="/new_blog/random.html">פוסט אקראי</a>
                <a href="/new_blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_blog/2013/06/08/student_and_computer_2-3-4/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">פרוייקט &#34;התלמיד והמחשב&#34;, בעיות 2-3-4</span>
            </a>
            

            
            <a href="/new_blog/2013/06/21/ultrafilters_and_ultraproducts/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">על על-מסננים ועל-מכפלות</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>על P=NP מעל חבורות אבליות - מבוא שלם</h1>
            <div class="post-meta">
                <span class="date">2013-06-15</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אלגברה מופשטת.html">אלגברה מופשטת</a>
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/חבורות אבליות.html">חבורות אבליות</a>
                    
                    <a href="/tags/מודלים חישוביים.html">מודלים חישוביים</a>
                    
                    <a href="/tags/שאלת P=NP.html">שאלת P=NP</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בואו נוכיח ש-<span class="math">\(\text{P}\ne\text{NP}\)</span>.</p>
<p>אה... מה?</p>
<p><a href="http://www.gadial.net/2010/08/15/p_vs_np_overview/">תיארתי בעבר בבלוג</a> את בעיית <span class="math">\(\text{P=NP}\)</span> בתור הבעיה הפתוחה המרכזית במדעי המחשב ולא הרבה השתנה מאז - עדיין אין לנו הוכחה ש-<span class="math">\(\text{P}\ne\text{NP}\)</span> למרות שרוב מדעני המחשב חושבים שזה המצב. אז מן הסתם לא על הבעיה הזו אני רוצה לדבר. אני רוצה לדבר על <span class="math">\(\text{P}\ne\text{NP}\)</span> מעל מודל חישוב <strong>אחר</strong>, אבל כזה שלדעתי לא שונה יותר מדי באופיו ממודל החישוב הרגיל (אם כי אחרים - למשל, אני - עשויים לחלוק עלי ולטעון שיש הבדלים מהותיים ביותר ושנראה אותם עוד בפוסט הזה). פורמלית מה שארצה להראות הוא שלכל <strong>חבורה אבלית אינסופית</strong> <span class="math">\(G\)</span> מתקיים <span class="math">\(\text{P}_{G}\ne\text{NP}_{G}\)</span> כאשר <span class="math">\(\text{P}_{G},\text{NP}_{G}\)</span> הן מחלקות הסיבוכיות הרלוונטיות מעל החבורה <span class="math">\(G\)</span>. כמובן שתכף אגדיר את הכל במפורש, אבל רק כדי שנהיה סגורים על האופן שבו התוצאה הזו מתקשרת לתורת הסיבוכיות הרגילה: במקרה שבו <span class="math">\(G=\mathbb{Z}_{2}\)</span> אנו מקבלים את המחלקות <span class="math">\(\text{P},\text{NP}\)</span> ה"רגילות".</p>
<p>ההוכחה שאציג תתבסס על המאמר של Prunescu שאפשר לראות <a href="http://home.mathematik.uni-freiburg.de/prunescu/grupshor.pdf">כאן</a>. זו הוכחה קצרצרה של ארבעה עמודים, אבל כזו שמסתמכת על לא מעט ידע מוקדם שאציג בפוסטים בצורה מקיפה יותר. זו אחת הסיבות לכך שזו תוצאה כל כך יפה: היא מערבת מושגים ורעיונות מתורת הסיבוכיות, תורת החבורות ותורת המודלים, ותיתן לנו הזדמנות להכיר כמה מושגים ותוצאות שטרם הוזכרו בבלוג ולראות איך משתמשים בהן בפועל.</p>
<p>נתחיל עם להסביר מה זה בכלל המודל החישובי הזה, "חישוב מעל חבורה <span class="math">\(G\)</span>". אני אנסה דווקא לא להיכנס להגדרות מדויקות פה אלא להסביר את הרעיון כפי שאני מבין אותו. אני מזהיר מראש שהבקיאות שלי בנושאים הללו היא לא משהו ולפעמים יכולה להיות תלות לא טריוויאלית של מחלקות הסיבוכיות בהגדרה המדויקת של המודל, כך שאני עלול לטעות; אתם מוזמנים לאתגר אותי בתגובות.</p>
<p>הרעיון הוא זה: קחו את שפת התכנות החביבה עליכם. אפשר להשתמש בה כמות שהיא - יש לנו משתנים שהם מספרים, מחרוזות, ערכים בוליאניים... הכל כרגיל. יש לכם גם את כל פונקציות הספריה שאתם מכירים ואוהבים והכל טוב ויפה. אלא שבנוסף לכך יש מחלקה בשם <span class="math">\(G\)</span> שאין לכם גישה להגדרות הפנימיות שלה. כל מה שיש לכם הוא קבוע <span class="math">\(e\in G\)</span>, ולמשתנים ששייכים למחלקה <span class="math">\(G\)</span> יש שלוש מתודות - האחת, <span class="math">\(=\)</span>, מקבלת משתנה נוסף השייך למחלקה <span class="math">\(G\)</span> ומחזירה <span class="math">\(\text{True}\)</span> אם הם שווים ואחרת <span class="math">\(\text{False}\)</span>; השניה, <span class="math">\(+\)</span>, מקבלת משתנה נוסף השייך למחלקה <span class="math">\(G\)</span> ומחזירה את החיבור של שתיהן, על פי כלל החיבור בחבורה <span class="math">\(G\)</span>, ומובטח לנו ש-<span class="math">\(a+e=e+a=a\)</span> לכל <span class="math">\(a\in G\)</span>, והשלישית, <span class="math">\(-\)</span>, מקבלת משתנה אחד <span class="math">\(a\)</span> השייך למחלקה <span class="math">\(G\)</span> ומחזירה משתנה אחר <span class="math">\(-a\)</span>, כך שמובטח שמתקיים <span class="math">\(a+\left(-a\right)=e\)</span>. אין לכם יכולת לחבר איברים של <span class="math">\(G\)</span> עם משתנים מסוג אחר (למשל, עם מספרים שלמים) או להשוות אותם למספרים מסוג שונה; אברי <span class="math">\(G\)</span> הם סוג של "קופסה שחורה".</p>
<p>כל בעיה חישובית מהסוג שעליו נרצה לדבר כאן תהיה מהסוג הבא: אנחנו מקבלים כקלט מערך של משתנים מתוך <span class="math">\(G\)</span>, שאורכו ידוע רק בזמן ריצה (כלומר, אנחנו צריכים להתמודד עם מערך מאורך כלשהו) וצריכים להחזיר כפלט <span class="math">\(\text{True}\)</span> או <span class="math">\(\text{False}\)</span>, בהתאם לתכונה שהמערך הזה מקיים או לא מקיים. בואו נציג מייד דוגמה לבעיה כזו כדי שיהיה ברור - זו תהיה הבעיה המרכזית שנעסוק בה בפוסט. במאמר קוראים לה Nullsack (וריאציה על Knapsack, למי שמכיר).</p>
<p><span class="math">\(\Sigma_{G}=\left\{ \left(x_{1},\dots,x_{n}\right)\in G^{n}\ |\ n\in\mathbb{N}\wedge\exists J\ne\emptyset:\sum_{i\in J}x_{i}=e\right\} \)</span></p>
<p>מילולית, ב-<span class="math">\(\Sigma_{G}\)</span> כלולים כל הוקטורים מאורך <span class="math">\(n\)</span> טבעי <strong>כלשהו</strong> (כלומר, יכולים להיות שם וקטורים מאורך 1, מאורך 10, מאורך <span class="math">\(10^{100}\)</span> וכן הלאה) שאפשר לסכום <strong>חלק</strong> מהאיברים בהם ולקבל את <span class="math">\(e\)</span>. במקרה שבו <span class="math">\(G=\mathbb{Z}\)</span>, זו השאלה הבאה: נותנים לכם אוסף של מספרים שלמים (לא קבוצה במובן המתמטי, כי אותו מספר יכול להופיע כמה פעמים) - האם אפשר לבחור מתוכו תת-אוסף של מספרים שהסכום שלהם הוא 0?</p>
<p>הבעיה הזו היא בעיה מוכרת מאוד בתורת הסיבוכיות: היא נקראת Subset-Sum והיא דוגמה פשוטה ושימושית לבעייה חישובית שהיא NP-שלמה. אלא שיש הבדל קריטי שחייבים לתת עליו את הדעת מייד: במודל הרגיל של תורת הסיבוכיות (מכונת טיורינג "רגילה"), הקלט ל-Subset-Sum נתון בתור <strong>סדרה של ביטים</strong> שמקודדת את וקטור המספרים, וזמן הריצה של האלגוריתם נמדד <strong>ביחס לאורך סדרת הביטים</strong> הזו. לעומת זאת, במודל החדש שהצגתי, זמן החישוב נמדד תמיד ביחס למספר <span class="math">\(n\)</span> ותו לא, והקלט נתון לנו בתור "קופסה שחורה". ההבדל הזה הוא קריטי. אנסה לתת דוגמה: נניח שהחבורה שלנו <span class="math">\(G\)</span> היא אכן <span class="math">\(\mathbb{Z}\)</span>. אז אם האיבר <span class="math">\(a\in G\)</span> היה מיוצג בתור סדרת ביטים, היינו יכולים לחלק אותו ב-2 בקלות, על ידי הסרת הביט הימני ביותר ממנו. במודל החדש אין לי מושג איך אפשר לחלק את המספר ב-2. ונניח (רק לצורך ההמחשה) שאיכשהו יש לי משתנה מהמחלקה <span class="math">\(G\)</span> שידוע לי שמכיל את הערך <span class="math">\(1\)</span>, ויש לי משתנה אחר <span class="math">\(a\)</span> שידוע לי שהוא חזקה כלשהי של <span class="math">\(2\)</span> ואני רוצה "לגלות" מה הערך המספרי שלו. אז אפשר לחבר את 1 ל-1 ולקבל 2, ואת 2 ל-2 ולקבל 4, ואת 4 ל-4 ולקבל 8 וכך הלאה לקבל חזקות של <span class="math">\(2\)</span> ובכל פעם להשוות ל-<span class="math">\(a\)</span>. מספר הפעולות שיידרש לנו לעשות את זה הוא מאותו סדר גודל של מספר הביטים שנדרשים כדי לייצג את <span class="math">\(a\)</span>, דהיינו זה זמן ריצה <strong>לינארי</strong> בגודל הייצוג של <span class="math">\(a\)</span>, כלומר במודל הקלאסי, אבל זה זמן ריצה <strong>לא חסום</strong> ב<strong>מספר</strong> הקלטים שלנו, כלומר במודל ה"חדש". בכל מקרה, אני מקווה שכבר קיבלתם את התחושה שחישובים במודל החדש הם <strong>יותר קשים</strong> מאשר במודל הרגיל, בגלל שהקלט פחות נגיש לנו.</p>
<p>למי שעדיין לא הבין את ההבדלה הזו, לא נורא - בהמשך נראה בדיוק איך היא רלוונטית לנו.</p>
<p>עכשיו אפשר להגדיר את <span class="math">\(\text{P}_{G}\)</span>: אלו כל בעיות ההכרעה שניתן לפתור במודל החישובי מעל <span class="math">\(G\)</span> בזמן שהוא פולינומי באורך הקלט (כלומר, באורך של וקטור הקלטים שהתקבל). אבל עדיין צריך להגדיר את <span class="math">\(\text{NP}_{G}\)</span>. וכאן יש לנו דילמה כלשהי. בואו ניזכר שניה בהגדרה של <span class="math">\(\text{NP}\)</span> הרגילה: אנחנו אומרים ש-<span class="math">\(L\in\text{NP}\)</span> אם קיים אלגוריתם פולינומי <span class="math">\(M\)</span> שמקבל שני סוגי קלטים: הקלט ה"רגיל", שמסומן ב-<span class="math">\(x\)</span>, וקלט שהוא "עד", או "הוכחה" לשייכות של <span class="math">\(x\)</span> ל-<span class="math">\(M\)</span>, שמסומן <span class="math">\(y\)</span>. הפולינומיות של <span class="math">\(M\)</span> היא ביחס לגודל הייצוג של <span class="math">\(x\)</span>, וגם <span class="math">\(x\)</span> וגם <span class="math">\(y\)</span> הם סדרות של ביטים (מכאן יוצא שאפשר להניח שהגודל של <span class="math">\(y\)</span> יהיה גם הוא פולינומי בגודל הייצוג של <span class="math">\(x\)</span> כי אחרת <span class="math">\(M\)</span> ממילא לא הייתה מצליחה לקרוא את הכל ולעמוד במגבלות הזמן שלה). אנו דורשים שאם <span class="math">\(x\in L\)</span> אז יהיה <span class="math">\(y\)</span> כלשהו כך ש-<span class="math">\(M\left(x,y\right)=\text{True}\)</span>, אבל שאם <span class="math">\(x\notin L\)</span> אז לכל <span class="math">\(y\)</span> שהוא, <span class="math">\(M\left(x,y\right)=\text{False}\)</span>. למשל, ב-Subset-Sum ה-<span class="math">\(x\)</span> הוא וקטור של מספרים שלמים, ואילו <span class="math">\(y\)</span> הוא קבוצת האינדקסים <span class="math">\(J\)</span> שיש לסכום, במקרה שבו אכן קיימת קבוצה כזו.</p>
<p>הדילמה שעומדת בפנינו היא זו: בהינתן <span class="math">\(x\)</span> שהוא וקטור של אברי <span class="math">\(G\)</span>, מה יהיה <span class="math">\(y\)</span>? הוא יכול להיות וקטור של אברי <span class="math">\(G\)</span> בעצמו, והוא גם יכול להיות סתם וקטור של ביטים. די בבירור המקרה הראשון חזק יותר מהשני (כי וקטור ביטים ודאי שאפשר "לקודד" בעזרת וקטור של אברי <span class="math">\(G\)</span>: 0 יהיה <span class="math">\(e\)</span> ו-1 יהיה כל איבר שאינו <span class="math">\(e\)</span>) ולא ברור אוטומטית מה ההגדרה ה"נכונה". מכיוון שהתוצאה שאנחנו רוצים להראות היא ש-<span class="math">\(\text{P}_{G}\ne\text{NP}_{G}\)</span>, כלומר ש-<span class="math">\(\text{NP}_{G}\)</span> היא מחלקה <strong>גדולה יותר</strong>, הרי שאם נראה את זה עבור ההגדרה של "עד" שמקודד על ידי ביטים, בוודאי שהתוצאה תנבע גם עבור "עד" שמקודד על ידי אברי <span class="math">\(G\)</span>. לכן נשתמש בהגדרה-מבוססת-הביטים בפוסטים על הנושא.</p>
<p>שימו לב שבבירור Subset-Sum שייך ל-<span class="math">\(\text{NP}_{G}\)</span>: בהינתן וקטור <span class="math">\(x=\left(x_{1},\dots,x_{n}\right)\)</span>, ה-<span class="math">\(y\)</span> שלנו יהיה סדרה של <span class="math">\(n\)</span> ביטים <span class="math">\(\left(b_{1},\dots,b_{n}\right)\)</span> כך ש-<span class="math">\(\sum b_{i}x_{i}=e\)</span>. את החישוב קל מאוד לבצע, כמובן. לכן כל מה שנשאר לעשות הוא להשתכנע ש-Subset-Sum <strong>אינה</strong> שייכת ל-<span class="math">\(\text{P}_{G}\)</span>, כלומר ש<strong>אף</strong> אלגוריתם לא יוכל לפתור את הבעיה בזמן פולינומי. וכאן מן הסתם יהיה עיקר הסיבוך - איך אפשר לטעון טענה כל כך כללית, על <strong>כל</strong> אלגוריתם, מחוכם ומסובך ככל שיהיה?</p>
<p>הדרך לעשות דבר כזה היא לתקוף את האלגוריתם בדרך עקיפה - את האופן שבו האלגוריתם <strong>משיג מידע על הקלט</strong>. כאן אנחנו גם נפרדים לשלום מבעיית <span class="math">\(\text{P}=\text{NP}\)</span> הרגילה, שבה <strong>אי אפשר </strong>לעשות תעלולים כאלו בגלל שהאלגוריתמים הרלוונטיים יודעים (במובן מסויים) את "הכל" על הקלט (אבל גם בסיבוכיות "רגילה", בהקשרים של מחלקות סיבוכיות אחרות, דרך התקיפה הזו עובדת, כי מחלקות הסיבוכיות מגבילות איכשהו את היכולת לבדוק את כל הקלט, או לבצע עליו חישובים מסויימים, או לזכור אותו בשלמותו). מה שנרצה לעשות הוא להראות שיש שני קלטים <strong>שונים</strong> לאלגוריתם, אחד ששייך ל-Subset-Sum והשני שלא שייך ל-Subset-Sum, כך שבכל דרך אפשרית שבה האלגוריתם "דוגם" אותם הוא מקבל את אותו מידע בדיוק, ולכן מבחינתו שני הקלטים הללו נראים זהים, ולכן הוא יענה עליהן את אותן התשובה בדיוק, ובהכרח יטעה עבור אחד מהם.</p>
<p>נראה איך אפשר לעשות דבר כזה במקרה הפרטי שבו <span class="math">\(G=\mathbb{Z}\)</span>. אחר כך נראה איך עושים את זה עבור עוד מחלקה מעניינת של חבורות, ואז ננטוש את הסיבוכיות ונעבור לדבר על תורת המודלים ונשתמש בתעלול מתוכה כדי להראות שההוכחות שלנו יעבדו עבור כל חבורה. אבל לעת עתה, בואו נתמקד במקרה של <span class="math">\(G=\mathbb{Z}\)</span>. מה קורה כאן?</p>
<p>ובכן, האלגוריתם מקבל קלטים, <span class="math">\(\left(x_{1},\dots,x_{n}\right)\)</span>. הוא יכול לבצע עליהם פעולות חיבור וחיסור ולקבל איברים חדשים שהם <strong>צירופים לינאריים</strong> של <span class="math">\(\left(x_{1},\dots x_{n}\right)\)</span> עם מקדמים מתוך <span class="math">\(\mathbb{Z}\)</span>. כלומר, איבר כללי ב-<span class="math">\(G\)</span> שהמשתמש יכול לבנות הוא מהצורה <span class="math">\(\sum_{i=1}^{n}a_{i}x_{i}\)</span> כך ש-<span class="math">\(a_{i}\in\mathbb{Z}\)</span> (האלגוריתם גם יכול לחבר או לחסר את <span class="math">\(e\)</span> לכל זה, אבל זה לא ישפיע על ערך הסכום ולכן לא צריך להתייחס לזה).</p>
<p>חישובים זה טוב ויפה, אבל מה שמשפיע על ריצת האלגוריתם בסופו של דבר הם ערכים בוליאנים - זה מה שמשפיע על התפצלויות בתוכנית ועל לולאות. הדרך היחידה להפיק ערכים בוליאנים מתוך איברי <span class="math">\(G\)</span> היא באמצעות פונקציית ה-<span class="math">\(=\)</span>. על שני איברים כלליים, החישוב יבדוק אם <span class="math">\(\sum_{i=1}^{n}a_{i}x_{i}=\sum_{i=1}^{n}b_{i}x_{i}\)</span>, כאשר <span class="math">\(a_{i},b_{i}\in\mathbb{Z}\)</span>. אפשר לפשט את זה - הבדיקה הזו שקולה לבדיקה האם <span class="math">\(\sum_{i=1}^{n}\left(a_{i}-b_{i}\right)x_{i}=0\)</span>, או בסימון אחר - האם <span class="math">\(\sum_{i=1}^{n}c_{i}x_{i}=0\)</span> כאשר <span class="math">\(c_{i}\in\mathbb{Z}\)</span>. בסימון עוד יותר קומפקטי: האם <span class="math">\(c\cdot x=0\)</span>, כאשר <span class="math">\(c\)</span> ו-<span class="math">\(x\)</span> שניהם וקטורים והמכפלה היא מכפלה סקלרית "רגילה".</p>
<p>בואו ניקח עכשיו אלגוריתם פולינומי קונקרטי ונחסל אותו. נשחק איתו את המשחק הבא: נתחיל להריץ אותו וניתן לו לעשות איזה חישובים שבא לו, אבל בכל פעם שהוא בודק שוויון בין שני איברים של <span class="math">\(G\)</span> נענה לו "לא", אלא אם זה שוויון טריוויאלי לחלוטין - כזה שבו במשוואה <span class="math">\(\sum_{i=1}^{n}c_{i}x_{i}=0\)</span> המתאימה כל ה-<span class="math">\(c_{i}\)</span>-ים הם 0 (למשל, אם הוא שואל האם <span class="math">\(x_{1}=x_{1}\)</span>). האלגוריתם ירוץ ירוץ ירוץ ירוץ וישאל שאלות, אבל בסופו של דבר הוא חייב לעצור ולענות "כן" או "לא", הרי הוא בעל זמן ריצה פולינומי ובפרט חסום.</p>
<p>עכשיו נוכל לפרוש את כל השאלות הלא טריוויאליות שהאלגוריתם שאל במהלך הריצה:</p>
<p><span class="math">\(c^{1}\cdot x\ne0\)</span></p>
<p><span class="math">\(c^{2}\cdot x\ne0\)</span></p>
<p><span class="math">\(\vdots\)</span></p>
<p><span class="math">\(c^{m}\cdot x\ne0\)</span></p>
<p>סה"כ <span class="math">\(m\)</span> שאלות, כאשר <span class="math">\(m\)</span> פולינומי ב-<span class="math">\(n\)</span> (<span class="math">\(n\)</span> הוא מספר האיברים ב-<span class="math">\(x\)</span>, כזכור). כעת אנחנו חושבים על <span class="math">\(x\)</span> בתור וקטור של <strong>משתנים</strong> שהם מספרים שלמים, ועל השאלות של האלגוריתם בתור <strong>אי שוויונים</strong>, ואנחנו שואלים את עצמנו אם קיימת הצבת ערכים אפשרית ל-<span class="math">\(x\)</span> שתספק את כל האי-שוויונים בו זמנית. יותר מכך - אנחנו רוצים <strong>שני</strong> פתרונות, <span class="math">\(x,y\)</span> לאותה מערכת משוואות, אבל כך ש-<span class="math">\(x\)</span> שייך ל-Subset-Sum ואילו <span class="math">\(y\)</span> לא שייך. אם נוכיח שקיימים שני וקטורים כאלו, הרי שהוכחנו שהאלגוריתם טועה על אחד מהם, ובכך חיסלנו אותו. להוכיח פורמלית שקיימים שני פתרונות כאלו זה קצת טכני ולא אכנס לזה (היי, גם המאמר לא!) אבל אפשר להבין את הרעיון לא רע אם חושבים על הסיטואציה בדו-מימד, כלומר כאשר <span class="math">\(n=2\)</span>: נוח לעבור לדבר על גיאומטריה ולכן אפשר לדבר על המרחב הוקטורי <span class="math">\(\mathbb{Q}^{2}\)</span> (כל הנקודות הרציונליות במישור), ואז כל משוואה מהצורה <span class="math">\(c\cdot x=0\)</span> מגדיר <strong>ישר</strong> במרחב הזה. הפואנטה כעת היא שאיחוד סופי של ישרים לא יכול לכסות את כל המישור; השאלה אם נקודה במישור תכוסה על ידי אחד מהישרים זהה לשאלה אם היחס בין הקואורדינטות שלה שווה לשיפוע של אחד הישרים בקבוצה, אבל קבוצת השיפועים הזו סופית ויש אינסוף שיפועים אפשריים. זה מבטיח שאפשר למצוא פתרון למערכת האי-שוויונים ב-<span class="math">\(\mathbb{Q}^{2}\)</span>, ואפשר לעבור ממנו ל-<span class="math">\(\mathbb{Z}^{2}\)</span> על ידי לקיחת הפתרון וכפל במכנה המשותף של הגורמים בו. שימו לב שבלי האינסופיות של <span class="math">\(\mathbb{Z}\)</span> זה לא היה עובד.</p>
<p>האתגר הוא לוודא שאחד הפתרונות שייך ל-Subset-Sum. באופן כללי לא בטוח שנוכל למצוא פתרון כזה! למשל, נניח שלכל וקטור ב-<span class="math">\(\left\{ 0,1\right\} ^{n}\)</span> שאינו וקטור האפס, יש שאלה <span class="math">\(c^{i}\)</span> כלשהי שהאלגוריתם שאל ששווה לוקטור הזה (כלומר, האלגוריתם ביצע "חיפוש ממצה") - ברור שלא נוכל למצוא פתרון <span class="math">\(x\)</span> שמצד אחד עונה "לא שווה לאפס" על כל <span class="math">\(c^{i}\cdot x\)</span> ומצד שני כן עונה <span class="math">\(a\cdot x=0\)</span> על <span class="math">\(a\in\left\{ 0,1\right\} ^{n}\)</span> כלשהו.</p>
<p>כאן אנחנו חייבים להשתמש בכך שהאלגוריתם הוא <strong>פולינומי</strong> (שהרי כל מטרתו היא להוכיח ש-Subset-Sum שייכת ל-<span class="math">\(\text{P}_{\mathbb{Z}}\)</span>. זה אומר שקיים <span class="math">\(n\)</span> גדול דיו כך שזמן הריצה הכולל של האלגוריתם יהיה לכל היותר <span class="math">\(2^{n}-2\)</span> צעדים, כלומר בפרט <span class="math">\(m&lt;2^{n}-1\)</span>. זה מבטיח (שוב, נדרשת פה קצת עבודה טכנית) שיהיה <span class="math">\(a\in\left\{ 0,1\right\} ^{n}\)</span> שלא "מכוסה" על ידי אף אחת מהשאלות של האלגוריתם, ולכן אפשר למצוא <span class="math">\(x\)</span> כך ש-<span class="math">\(c^{i}\cdot x\ne0\)</span> לכל <span class="math">\(i\)</span> אבל <span class="math">\(a\cdot x=0\)</span>.</p>
<p>זה מסיים את ההוכחה במקרה שבו אנחנו מעל החבורה הקונקרטית <span class="math">\(\mathbb{Z}\)</span>. למי שמתעניין בתורת הסיבוכיות נטו, הסיפור נגמר כאן: טכניקת ההוכחה שראינו היא כל מה שהולך להיות כאן בכל הנוגע לתורת הסיבוכיות; ההמשך, שבו אנחנו מנסים להכליל את התוצאה לכל חבורה <span class="math">\(G\)</span> יתבסס בעיקר על אבחנות מתוך תורת החבורות ותורת המודלים שיאפשרו לנו להשתמש "בחינם" בטכניקה שכבר ראינו. יהיה אקשן.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>