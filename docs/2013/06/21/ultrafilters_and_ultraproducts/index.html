<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>על על-מסננים ועל-מכפלות - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                text-align: center;
                margin-bottom: 10px;
            }
            
            .top-nav .nav-links {
                flex-direction: column;
                width: 100%;
            }
            
            .top-nav .nav-links a {
                text-align: center;
                padding: 8px;
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2013/06/15/p_vs_np_on_abelian_groups_intro/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">על P=NP מעל חבורות אבליות - מבוא שלם</span>
            </a>
            

            
            <a href="/2013/06/30/p_vs_np_on_abelian_groups_ending/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">על P=NP מעל חבורות אבליות - סוף דבר</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>על על-מסננים ועל-מכפלות</h1>
            <div class="post-meta">
                <span class="date">2013-06-21</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                    <a href="/categories/תורת הקבוצות.html">תורת הקבוצות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/מסננים.html">מסננים</a>
                    
                    <a href="/tags/משפט הקומפקטיות.html">משפט הקומפקטיות</a>
                    
                    <a href="/tags/על-מכפלות.html">על-מכפלות</a>
                    
                    <a href="/tags/תורת המודלים.html">תורת המודלים</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אני רוצה להציג הפעם שני מושגים יחסית מופשטים, עם שימושים נרחבים בתורת הקבוצות, בטופולוגיה ובלוגיקה (ובעוד מקומות) - על-מסננים (אולטרה פילטרים באנגלית) ועל-מכפלות. אבל אציג את המושגים הללו באופן קצת יותר כללי, בתור מקרים פרטיים של מסננים ומכפלות מצומצמות. תצטרכו להמתין טיפה בסבלנות לפני שיהיה ברור למה הנושאים הללו מגניבים; ההקשר הנוכחי הוא ההוכחה שהתחלתי <a href="http://www.gadial.net/2013/06/15/p_vs_np_on_abelian_groups_intro/">בפוסט הקודם</a> לפיה <span class="math">\(\text{P}\ne\text{NP}\)</span> מעל חבורות אבליות אינסופיות, אבל את השימוש הזה נראה רק בפוסט המשך; עם זאת, גם בפוסט הזה אני מתכנן להראות כמה דברים נחמדים.</p>
<p>בשביל להבין את המושגים הבסיסיים מספיק להכיר את תורת הקבוצות האלמנטרית, אבל בשביל הלהטוטים שאעשה לקראת הסוף כבר צריך להכיר לוגיקה מסדר ראשון, שלמרבה המזל כבר <a href="http://www.gadial.net/2012/06/17/first_order_logic/">הצגתי בבלוג בעבר</a>. בואו ניגש לאקשן.</p>
<p>הרעיון שמאחורי <strong>מסנן</strong> הוא זה: נתונה לנו קבוצה <span class="math">\(X\)</span> כלשהי - ה"עולם" שלנו, למשל המספרים הטבעיים. ל-<span class="math">\(X\)</span> יש המוני תת-קבוצות (כבר עבור הטבעיים יש מספר לא בן מניה של תת-קבוצות) ועל הקבוצות הללו יש מעין "היררכייה" - <span class="math">\(A\)</span> נמצאת "מעל" <span class="math">\(B\)</span> בהיררכייה אם <span class="math">\(B\subseteq A\)</span>. זה נותן לנו תחושה ש-<span class="math">\(A\)</span> "גדולה יותר" מ-<span class="math">\(B\)</span> במובן מסויים. מה שמסנן עושה הוא לאפיין אוסף כלשהו של תת-קבוצות של <span class="math">\(X\)</span> שהן "גדולות" או "גבוהות בהיררכייה". כמובן שעל אותה קבוצה אפשר להגדיר הרבה מסננים, ובכך לתת הרבה משמעויות ל"קבוצות גדולות" שכאלו.</p>
<p>אז איך מוגדר מסנן? פורמלית, זו קבוצה לא ריקה <span class="math">\(D\subseteq2^{X}\)</span> (אוסף של תת-קבוצות של <span class="math">\(X\)</span>) שלא כוללת את הקבוצה הריקה וסגורה לחיתוך ולהכלה כלפי מעלה. פורמלית:</p>
<ol>
    <li><span class="math">\(\emptyset\notin D\)</span> ו-<span class="math">\(X\in D\)</span>.</li>
    <li>אם <span class="math">\(B\subseteq A\)</span> ו-<span class="math">\(B\in D\)</span> אז גם <span class="math">\(A\in D\)</span>.</li>
    <li>אם <span class="math">\(A,B\in D\)</span> אז גם <span class="math">\(A\cap B\in D\)</span>.</li>
</ol>
<p>שימו לב לכך ש-<span class="math">\(X\in D\)</span> נובע מההנחה ש-<span class="math">\(D\)</span> לא ריקה ומתכונה 2, ולכן פשוט דרשתי <span class="math">\(X\in D\)</span> במפורש במקום לומר ש-<span class="math">\(D\)</span> לא ריקה.</p>
<p>ההגדרה מייד מעלה תהיה - למה דווקא התכונות הללו? אפשר עוד להבין את זה שהקבוצה הריקה לא בפנים (אם היא "גדולה", מי לא?) ואת זה ש-<span class="math">\(X\)</span> בפנים (אם היא לא "גדולה", מי כן?) וגם הכלה כלפי מעלה נראית סבירה; אבל חיתוך? המממ. האינטואיציה היא שאם קבוצה היא <strong>ממש</strong> גדולה, אז גם לחתוך אותה עם קבוצה גדולה אחרת לא יוכל לקלקל את זה יותר מדי. כדי לקבל את התחושה כדאי לראות תכף ומייד דוגמאות. אז ניקח קבוצה <strong>אינסופית</strong> <span class="math">\(X\)</span> ונתהה האם אנחנו מסוגלים למצוא מסנן מעל <span class="math">\(X\)</span>. די בבירור <span class="math">\(D=\left\{ X\right\} \)</span> הוא מסנן, אבל טריוויאלי לגמרי ולכן לא מעניין. אז הנה מסנן יותר מעניין: <span class="math">\(D\)</span> יהיה קבוצת כל הקבוצות שהן <strong>קו-סופיות</strong>. קבוצה היא קו-סופית אם <strong>המשלימה</strong> שלה היא סופית, כלומר אם יש בה את כל האיברים ב-<span class="math">\(X\)</span> פרט למספר סופי של איברים. פורמלית, <span class="math">\(D=\left\{ A\subseteq X\ |\ \overline{A}&amp;lt;\infty\right\} \)</span> (<span class="math">\(\overline{A}\)</span> הוא סימון פשוט יותר ל-<span class="math">\(X\backslash A\)</span>).</p>
<p>זה בוודאי מתאים לתחושה האינטואיטיבית שלנו של "גודל"; האם זה מקיים את האקסיומות? ובכן, בבירור אקסיומה 1 מתקיימת; גם אקסיומה 2 די פשוטה, שהרי אם <span class="math">\(B\subseteq A\)</span> אז <span class="math">\(\overline{A}\subseteq\overline{B}\)</span>, כלומר ב-<span class="math">\(\overline{A}\)</span> יש עוד פחות איברים מאשר ב-<span class="math">\(\overline{B}\)</span> הסופית, ולכן גם היא סופית בעצמה. ומה באשר לחיתוך? ובכן, כאן נחלצים כללי דה-מורגן לעזרתנו: <span class="math">\(\overline{A\cap B}=\overline{A}\cup\overline{B}\)</span>. האיחוד של שתי קבוצות סופיות גם הוא סופי, כי גודלו חסום על ידי סכום הגדלים של הקבוצות: <span class="math">\(\left|\overline{A\cap B}\right|=\left|\overline{A}\cup\overline{B}\right|\le\left|\overline{A}\right|+\left|\overline{B}\right|\)</span> ולכן <span class="math">\(A\cap B\)</span> גם היא קבוצה קו-סופית. הנה לנו דוגמה לא טריוויאלית למסנן, שנקראת <strong>מסנן פרשה</strong>.</p>
<p>בואו נראה דוגמה אחרת. נניח ש-<span class="math">\(A\subseteq X\)</span> היא תת-קבוצה לא ריקה כלשהי של <span class="math">\(X\)</span>. נניח שהחלטנו לראות את <span class="math">\(A\)</span> בתור קבוצה "גדולה", כלומר אנחנו בונים מסנן כך ש-<span class="math">\(A\in D\)</span>. אוטומטית נובע מכך ש-<span class="math">\(D\)</span> חייב לכלול את כל הקבוצות שמכילות את <span class="math">\(A\)</span>. האם זה לכשעצמו מספיק כדי ליצור מסנן? בהחלט: <span class="math">\(D=\left\{ B\subseteq X\ |\ A\subseteq B\right\} \)</span> הוא בבירור מסנן - קל לבדוק ש-3 האקסיומות מתקיימות. מסנן כזה - שמתקבל מלקיחת כל הקבוצות שמכילות קבוצה נתונה <span class="math">\(A\)</span> - נקרא <strong>מסנן ראשי</strong> (מי שבקיאים בתורת החוגים ודאי יזכרו כעת במושג של <strong>אידאל ראשי</strong> שהוא דומה מאוד - זה אידאל שנוצר על ידי איבר יחיד). האם כל מסנן הוא ראשי? ובכן, דרך פשוטה לבדוק זאת היא זו: לוקחים מסנן <span class="math">\(D\)</span> ומסתכלים על <span class="math">\(\bigcap D\)</span> - החיתוך של <strong>כל</strong> הקבוצות במסנן. אם <span class="math">\(D\)</span> הוא ראשי אנחנו מצפים לקבל את <span class="math">\(A\)</span> - הקבוצה שממנה <span class="math">\(D\)</span> נבנה. אם קיבלנו, למשל, קבוצה ריקה, אז <span class="math">\(D\)</span> אינו ראשי. קל לראות שמסנן פרשה הוא לא ראשי, בדיוק בצורה הזו (כי למשל, לכל <span class="math">\(a\in X\)</span>, הקבוצה <span class="math">\(A=X\backslash\left\{ a\right\} \)</span> שייכת ל-<span class="math">\(D\)</span>, אבל החיתוך של כולן הוא ריק).</p>
<p>לעומת זאת, אם <span class="math">\(X\)</span> סופית ו-<span class="math">\(D\)</span> הוא מסנן מעל <span class="math">\(X\)</span>, אז <span class="math">\(\bigcap D\)</span> הוא חיתוך של מספר סופי של קבוצות ולכן באינדוקציה אפשר להראות ש-<span class="math">\(\bigcap D\in D\)</span>, ומכאן ש-<span class="math">\(D=\left\{ B\subseteq X\ |\ \bigcap D\subseteq B\right\} \)</span>. כלומר, במובן מסויים כל המסננים מעל קבוצות סופיות הם פשוטים, ואנחנו יודעים בדיוק איך הם נראים. לכן אנחנו מדברים על מסננים בהקשר של קבוצות אינסופיות, ומעתה והלאה <span class="math">\(X\)</span> תמיד יהיה קבוצה אינסופית.</p>
<p>משחק החיתוכים הזה עשוי לעורר שאלה אחרת - נניח שיש לנו "מועמד למסנניות" <span class="math">\(S\subseteq2^{X}\)</span> - אוסף כלשהו של תת-קבוצות של <span class="math">\(X\)</span> שאנחנו מקווים שיהיה מסנן. מן הסתם הוא לא תמיד יהיה מסנן כי עשויות להיות חסרות בו קבוצות - למשל, ייתכן ש-<span class="math">\(S\)</span> קבוצה <span class="math">\(A\)</span> שיש קבוצה שמכילה אותה ואינה ב-<span class="math">\(S\)</span>; או שיש שתי קבוצות ב-<span class="math">\(S\)</span> שהחיתוך שלהן לא ב-<span class="math">\(S\)</span>; התחושה היא שאפשר יהיה "לתקן" את זה על ידי הוספת עוד קבוצות - <strong>להרחיב</strong> את <span class="math">\(S\)</span> עד שנקבל מסנן. אבל האם תמיד אפשר לעשות את זה?</p>
<p>זכרו שאסור שהקבוצה הריקה תהיה שייכת למסנן <span class="math">\(D\)</span>. אז אם <span class="math">\(\emptyset\in S\)</span> ברור שלא משנה כמה נרחיב את <span class="math">\(S\)</span> - מסנן כבר לא נקבל. אבל האם אם <span class="math">\(\emptyset\notin S\)</span> אנחנו בסדר? לא בהכרח; הכי נצטרך לוודא ש-<span class="math">\(S\)</span> סגורה לחיתוך. סגירות לחיתוך שתי קבוצות גוררת סגירות לחיתוך מספר <strong>סופי</strong> כלשהו של קבוצות, ולכן אנחנו חייבים לדרוש שלכל סדרה סופית של קבוצות <span class="math">\(A_{1},A_{2},\dots,A_{n}\in S\)</span> יתקיים <span class="math">\(\bigcap A_{i}\ne\emptyset\)</span>. התכונה הזו - חיתוך כל מספר סופי של איברים של <span class="math">\(S\)</span> הוא לא ריק - נקראת <strong>תכונת החיתוכים הסופיים</strong> והיא מככבת גם בטופולוגיה; במקרה שלנו, מסתבר שהיא לא רק הכרחית לכך ש-<span class="math">\(S\)</span> תהיה ניתנת להרחבה למסנן אלא גם מספיקה: אם <span class="math">\(S\)</span> מקיימת את תכונת החיתוכים הסופיים, אז קיים מסנן <span class="math">\(D\)</span> שמכיל את <span class="math">\(S\)</span>.</p>
<p>איך בונים את <span class="math">\(D\)</span>? הבניה גם כן באה בצורה טבעית למדי. ברור שנצטרך להכניס ל-<span class="math">\(D\)</span> את <span class="math">\(S\)</span>, ולכן גם כל חיתוך סופי של איברים מ-<span class="math">\(S\)</span> (כי אקסיומה 3), ולכן גם כל קבוצה שמכילה חיתוך סופי של איברים מ-<span class="math">\(S\)</span> (כי אקסיומה 2), אז בואו ננסה להגדיר את <span class="math">\(D\)</span> כך:</p>
<p><span class="math">\(D=\left\{ A\subseteq X\ |\ \exists A_{1},\dots,A_{n}\in S:\bigcap A_{i}\subseteq A\right\} \)</span></p>
<p>לא קשה להראות ש-<span class="math">\(D\)</span> הוא מסנן; התכונה המאתגרת היא 3, וגם היא פשוטה למדי (אם <span class="math">\(\bigcap A_{i}\subseteq A\)</span> ו-<span class="math">\(\bigcap B_{i}\subseteq B\)</span> אז <span class="math">\(\bigcap A_{i}\cap\bigcap B_{i}\subseteq A\cap B\)</span>). מה שנחמד הוא ש-<span class="math">\(D\)</span> הוא המסנן <strong>הקטן ביותר</strong> שמכיל את <span class="math">\(S\)</span>; פורמלית, <span class="math">\(D\)</span> הוא חיתוך כל המסננים שמכילים את <span class="math">\(S\)</span> (והנה אתגר חדש: להוכיח שחיתוך של מספר כלשהו של מסננים הוא בעצמו מסנן, וש-<span class="math">\(D\)</span> הוא אכן החיתוך הזה). אומרים ש-<span class="math">\(D\)</span> הוא המסנן ש<strong>נוצר</strong> על ידי <span class="math">\(S\)</span>.</p>
<p>עכשיו משהתוודענו קצת למסננים, בואו נעבור לתקל שאלה אחרת - כמה גדול מסנן יכול להיות? נניח שיש לנו מסנן <span class="math">\(D\)</span> ואנחנו רוצים להגדיל אותו ככל הניתן, למסנן "גדול ביותר" <span class="math">\(U\)</span>. מה אפשר להוסיף ל-<span class="math">\(D\)</span>? ובכן, ברור מה <strong>אי אפשר</strong> להוסיף ל-<span class="math">\(D\)</span>: אם <span class="math">\(A\in D\)</span> אז בשום פנים ואופן אי אפשר להוסיף ל-<span class="math">\(D\)</span> את <span class="math">\(\overline{A}\)</span>, כי אחרת נקבל ש-<span class="math">\(A\cap\overline{A}=\emptyset\in U\)</span>. לכן כל מסנן <span class="math">\(U\)</span> שמכיל את <span class="math">\(D\)</span> חייב לקיים את התכונה שלכל קבוצה <span class="math">\(A\in X\)</span>, לא ייתכן שגם <span class="math">\(A\in U\)</span> וגם <span class="math">\(\overline{A}\in U\)</span>. אם זה הדבר <strong>היחיד</strong> שמגביל את <span class="math">\(U\)</span>, כלומר אם <strong>לכל</strong> <span class="math">\(A\in X\)</span> או שמתקיים <span class="math">\(A\in U\)</span> או שמתקיים <span class="math">\(\overline{A}\in U\)</span>, אומרים ש-<span class="math">\(U\)</span> הוא <strong>על-מסנן</strong>.</p>
<p>את הדיון הזה נהוג לפרמל באופן הבא: מסנן <span class="math">\(U\)</span> הוא על-מסנן אם ורק אם <span class="math">\(U\)</span> הוא מקסימלי, כלומר לא קיים מסנן <span class="math">\(U^{\prime}\)</span> כך ש-<span class="math">\(U\subset U^{\prime}\)</span> (הכלה ממש). הכיוון של "אם <span class="math">\(U\)</span> הוא על-מסנן אז הוא מקסימלי" הוא ברור ועליו כבר דיברנו - אם <span class="math">\(U\subset U^{\prime}\)</span> אז יש <span class="math">\(A\in U^{\prime}\)</span> כך ש-<span class="math">\(A\notin U\)</span>, ומכיוון ש-<span class="math">\(U\)</span> הוא על-מסנן אז <span class="math">\(\overline{A}\in U\)</span> ולכן <span class="math">\(A\cap\overline{A}=\emptyset\in U^{\prime}\)</span>. האתגר הוא להוכיח שמסנן מקסימלי יקיים את תכונת העל-מסנניות תמיד. נניח בשלילה ש-<span class="math">\(U\)</span> הוא מסנן מקסימלי אבל יש איזה <span class="math">\(A\in X\)</span> כך ש-<span class="math">\(A\notin U\)</span> וגם <span class="math">\(\overline{A}\notin U\)</span>, אז אפשר פשוט להוסיף את <span class="math">\(A\)</span> ל-<span class="math">\(U\)</span> ולקבל קבוצה שאינה בהכרח מסנן, אבל <strong>היא יוצרת</strong> מסנן <span class="math">\(U^{\prime}\)</span> שמכיל ממש את <span class="math">\(U\)</span>. למה היא בהכרח יוצרת מסנן? כי היא מקיימת את תכונת החיתוכים הסופיים, שהרי אם יש לנו קבוצות <span class="math">\(B_{1},\dots,B_{n}\)</span> כך ש-<span class="math">\(A\cap\bigcap B_{i}=\emptyset\)</span> זה אומר ש-<span class="math">\(\bigcap B_{i}\subseteq\overline{A}\)</span> ולכן היינו צריכים לקבל <span class="math">\(\overline{A}\in U\)</span> (למה הנימוק שנתתי מספיק?).</p>
<p>יפה. כעת, נותנים לנו קבוצה <span class="math">\(S\)</span> שמקיימת את תכונת החיתוכים הסופיים. אנחנו יודעים שאפשר להרחיב אותה למסנן, אבל האם בהכרח ניתן להרחיב אותה לעל-מסנן? התשובה היא "כן, אבל". יש לנו כאן סיטואציה דומה ל"כל קבוצה בלתי תלויה של וקטורים במרחב וקטורי ניתנת להרחבה לבסיס", וכמו שם כך גם כאן ההוכחה תהיה פשוטה, אבל תתבסס על <a href="http://www.gadial.net/2012/06/04/choice_order_zorn/">אקסיומת הבחירה</a>, או ליתר דיוק על הלמה של צורן השקולה לה. הרעיון הוא כזה: מספיק לבנות מסנן מקסימלי שמכיל את <span class="math">\(S\)</span>. אז נסתכל על קבוצת כל המסננים שמכילים את <span class="math">\(S\)</span>; על פי הלמה של צורן, מספיק להראות שכל שרשרת של מסננים (קבוצה של מסננים שמכילים את <span class="math">\(S\)</span> שלכל זוג מביניהם, אחד מהם מוכל בשני) היא בעלת חסם מלעיל בקבוצה (יש מסנן שמכיל את כל המסננים בשרשרת). את זה קל להראות - בהינתן שרשרת, ניקח את האיחוד של כל איבריה ונרחיב אותו למסנן שיהיה החסם מלעיל. כדי להראות שאפשר להרחיב את האיחוד הזה צריך להראות שהאיחוד מקיים את תכונת החיתוכים הסופיים. נניח שהוא לא, אז יש <span class="math">\(A_{1},\dots,A_{n}\)</span> באיחוד כך ש-<span class="math">\(\bigcap A_{n}=\emptyset\)</span>. זה רק מספר סופי של <span class="math">\(A_{i}\)</span>-ים ולכן יש איבר בשרשרת שמכיל את כולם, והופס! סתירה לכך שהוא מסנן. הוכחה סטנדרטית לגמרי שאמורה לנבוע מאליה למי שמכיר את טכניקת ההוכחה הזו והבין מהם מסננים.</p>
<p>שימו לב שבמקרה שבו <span class="math">\(U\)</span> הוא על-מסנן <strong>ראשי</strong>, הוא לא מסנן מעניין במיוחד. נניח ש-<span class="math">\(U\)</span> הוא על-מסנן ראשי, כלומר <span class="math">\(U=\left\{ B\in X\ |\ A\subseteq B\right\} \)</span> עבור איזו שהיא <span class="math">\(A\)</span>, אז אני טוען ש-<span class="math">\(A=\left\{ a\right\} \)</span>, כלומר <span class="math">\(A\)</span> היא יחידון; זאת מכיוון שניקח <span class="math">\(a\in A\)</span> כלשהו ונשים לב לכך שאו <span class="math">\(\left\{ a\right\} \)</span> או <span class="math">\(\overline{\left\{ a\right\} }\)</span> שייכים ל-<span class="math">\(U\)</span>. אם <span class="math">\(\left\{ a\right\} \in U\)</span> אז מכיוון ש-<span class="math">\(A\subseteq\left\{ a\right\} \)</span> נקבל ש-<span class="math">\(A=\left\{ a\right\} \)</span>; מצד שני, פשוט לא ייתכן ש-<span class="math">\(\overline{\left\{ a\right\} }\in U\)</span> כי <span class="math">\(A\not\subseteq\overline{\left\{ a\right\} }\)</span>! לכן העל-מסננים שמתעניינים בהם באמת הם אלו שאינם ראשיים. האם יש לנו דוגמה לעל-מסנן שכזה? ובכן, כן! ניקח את <span class="math">\(D\)</span> להיות מסנן פרשה מעל <span class="math">\(X\)</span> - כזכור, המסנן שכולל את כל הקבוצות הקו-סופיות. נרחיב אותו לעל-מסנן <span class="math">\(U\)</span>. נניח בשלילה ש-<span class="math">\(U=\left\{ B\in X\ |\ A\subseteq B\right\} \)</span>, אז כפי שראינו, <span class="math">\(A=\left\{ a\right\} \)</span>. אבל אז <span class="math">\(\overline{A}\)</span> היא קבוצה קו-סופית, ולכן <span class="math">\(\overline{A}\in D\subseteq U\)</span>, וקיבלנו סתירה.</p>
<p>יופי, אז הגדרנו מסננים וראינו כל מני דברים עליהם, פרט לדבר אחד: <strong>בשביל מה בכלל צריך אותם</strong>? ובכן, נעבור למה שהוא עיקר הפוסט - המושג של <strong>מכפלה מצומצמת</strong>, ובפרט של על-מכפלות. אבל לפני זה, טיפת מוטיבציה.</p>
<p>אם יש לנו שתי קבוצות <span class="math">\(A,B\)</span>, אז <strong>המכפלה הקרטזית</strong> שלהן, שמסומנת <span class="math">\(A\times B\)</span>, היא אוסף הזוגות של איבר מ-<span class="math">\(A\)</span> ואיבר מ-<span class="math">\(B\)</span>. את הרעיון הזה קל להכליל: אם <span class="math">\(A_{1},\dots,A_{n}\)</span> הן קבוצות, אז <span class="math">\(\prod A_{i}\)</span> הוא אוסף ה-<span class="math">\(n\)</span>-יות שבהן האיבר במקום ה-<span class="math">\(i\)</span> שייך ל-<span class="math">\(A_{i}\)</span>. למי שהתרגל לחשוב על מכפלות בתור <span class="math">\(n\)</span>-יות אני רוצה להציע נקודת מבט קצת שונה: נחשוב על כל איבר ב-<span class="math">\(\prod A_{i}\)</span> בתור <strong>פונקציה</strong>, <span class="math">\(f:\left\{ 1,\dots,n\right\} \to\bigcup A_{i}\)</span>, עם הדרישה שלכל <span class="math">\(i\in\left\{ 1,\dots,n\right\} \)</span> מתקיים <span class="math">\(f\left(i\right)\in A_{i}\)</span>.</p>
<p>הטוב בדרך ההתבוננות הזו היא שבעזרתה קל להגדיר מכפלות קרטזיות על אוספים <strong>כלליים</strong> של קבוצות, כל עוד יש לנו דרך כלשהי "לאנדקס" את הקבוצות הללו. אפשר לקחת קבוצה שרירותית <span class="math">\(I\)</span> להיות "קבוצת האינדקסים" שלנו (למשל, <span class="math">\(I=\left\{ 1,\dots,n\right\} \)</span> או <span class="math">\(I=\mathbb{N}\)</span>, אבל אפשר גם <span class="math">\(I=\mathbb{R}\)</span> או דברים מופרעים יותר). עכשיו נניח שלכל <span class="math">\(i\in I\)</span> יש לנו קבוצה <span class="math">\(A_{i}\)</span>; אפשר להגדיר את המכפלה <span class="math">\(\prod_{i\in I}A_{i}\)</span> בתור אוסף הפונקציות <span class="math">\(f:I\to\bigcup_{i\in I}A_{i}\)</span> כך ש-<span class="math">\(f\left(i\right)\in A_{i}\)</span> לכל <span class="math">\(i\in I\)</span>. זה מאפשר לנו לבנות מכפלות די מוזרות למראה, כמו מכפלה של מספר לא בן מניה של קבוצות שכל אחת מאונדקסת על ידי מספר ממשי כלשהו. בפועל אם אתם רוצים לחשוב על מקרה קונקרטי, אפשר להסתפק ב-<span class="math">\(I=\mathbb{N}\)</span>, שהוא יחסית פשוט (<span class="math">\(A_{1}\times A_{2}\times A_{3}\times\dots\)</span>).</p>
<p>עכשיו לפאנץ'. מה קורה אם לקבוצות שמכפילים יש <strong>מבנה</strong>? במתמטיקה אוהבים לבנות מתוך אובייקטים קיימים אובייקטים חדשים, למשל על ידי מכפלה. אפשר להכפיל חבורות ולקבל חבורה, ואפשר להכפיל חוגים ולקבל חוג, אבל האם תמיד מכפלה תיתן לנו אובייקט חדש? ובכן, קחו שדה <span class="math">\(\mathbb{F}\)</span> כלשהו. למרבה הבעסה, <span class="math">\(\mathbb{F}\times\mathbb{F}\)</span> <strong>לא</strong> יהיה שדה. למה? כי לא כל איבר בו יהיה הפיך: <span class="math">\(\left(1,0\right)\)</span> אינו איבר האפס של <span class="math">\(\mathbb{F}\times\mathbb{F}\)</span>, אבל הוא אינו הפיך (כי לא משנה מה נכפיל בו, בקואורדינטה השניה תמיד יהיה 0).</p>
<p>עם זאת, יש דרך <strong>לצמצם</strong> את המכפלה <span class="math">\(\mathbb{F}\times\mathbb{F}\)</span> כך ששוב נקבל שדה: אם <strong>נזהה</strong> את האיברים מהצורה <span class="math">\(\left(a,b\right)\)</span> עם האיברים מהצורה <span class="math">\(\left(a,b^{\prime}\right)\)</span>, כלומר נגיד שאיברים של <span class="math">\(\mathbb{F}\times\mathbb{F}\)</span> הם זהים אם הקואורדינטה הראשונה שלהם זהה, מה שנקבל יהיה עותק של <span class="math">\(\mathbb{F}\)</span>, שהוא שדה. אותו דבר עם <span class="math">\(\mathbb{F}^{3}\)</span> - שוב, כשמזהים איברים אם הקואורדינטה הראשונה שלהם זהה. וכדומה עבור <span class="math">\(\mathbb{F}^{n}\)</span>. אוקיי, זה משעמם לחלוטין; מתי זה מתחיל להיות מעניין? או - כשכופלים <strong>אינסוף</strong> עותקים של <span class="math">\(\mathbb{F}\)</span>. אז יתברר שלא חייבים זהות בקואורדינטה אחת מסויימת כדי עדיין לקבל שדה, אלא אפשר להקל מאוד את הדרישות.</p>
<p>בואו נעבור שניה לדוגמה קצת שונה, שלקוחה מהחיים האמיתיים - אנליזה פונקציונלית, במקרה שלנו. אני מדבר על פונקציות ממשיות - <span class="math">\(f:\mathbb{R}\to\mathbb{R}\)</span>, שכבר ברור מהדיון הקודם שלנו שאפשר לחשוב עליהן בתור איברים ב<strong>מכפלה קרטזית</strong> של עותקים של <span class="math">\(\mathbb{R}\)</span>, כשכל עותק מאונדקס על ידי מספר ממשי כלשהו (<span class="math">\(c\)</span>). מסיבות טכניות שלא אכנס אליהן כאן, נוח מאוד לפעמים לחשוב על שתי פונקציות <span class="math">\(f,g\)</span> כזהות אם קבוצת המספרים שעליהם <span class="math">\(f,g\)</span> לא מסכימים היא <strong>ממידה אפס</strong> (לא אכנס גם להגדרה של מידה כאן; זו הכללה רבת עוצמה של מושג הנפח - או במקרה של <span class="math">\(\mathbb{R}\)</span>, האורך). פורמלית, <span class="math">\(\mu\left(\left\{ x\in\mathbb{R}\ |\ f\left(x\right)\ne g\left(x\right)|\right\} \right)=0\)</span> כאשר <span class="math">\(\mu\)</span> היא פונקצית המידה הרגילה על <span class="math">\(\mathbb{R}\)</span>. אפשר לנסח את זה גם בצורה חיובית: קבוצת הנקודות ש-<span class="math">\(f,g\)</span> מסכימות עליהן היא <strong>מאוד גדולה</strong>. כמה גדולה? עד כדי כך שהמשלימה שלה היא ממידה אפס. נשמע מוכר? ובכן, כן: כל <span class="math">\(\mathbb{R}\)</span> אינו ממידה אפס ואיחוד של שתי קבוצות ממידה אפס הוא ממידה אפס, ומכאן מקבלים די בקלות שקבוצת כל הקבוצות שהמשלימה שלהן היא ממידה אפס הן מסנן על <span class="math">\(\mathbb{R}\)</span>. אז מה עשינו כאן? הגדרנו שהפונקציות <span class="math">\(f,g\)</span> הן זהות אם קבוצת הנקודות שעליהן <span class="math">\(f,g\)</span> הסכימו הייתה שייכת למסנן מסוים שהוגדר מעל <span class="math">\(\mathbb{R}\)</span>. <strong>צמצמנו את המכפלה</strong> <span class="math">\(\prod_{x\in\mathbb{R}}\mathbb{R}_{x}\)</span> ביחס למסנן הזה.</p>
<p>פורמלית העסק הזה מתבצע עם יחסי שקילות. נניח שנתונה לנו מכפלה כלשהי <span class="math">\(\mathcal{A}=\prod_{i\in I}A_{i}\)</span> ונתון לנו מסנן <span class="math">\(D\)</span> על הקבוצה <span class="math">\(I\)</span>. אז נגדיר יחס שקילות <span class="math">\(\equiv_{D}\)</span> על <span class="math">\(\mathcal{A}\)</span> באופן הבא: <span class="math">\(f\equiv_{D}g\)</span> אם <span class="math">\(\left\{ i\in I\ |\ f\left(i\right)=g\left(i\right)\right\} \in D\)</span>.</p>
<p>למה זה יחס שקילות? ובכן, <span class="math">\(\left\{ i\in I\ |\ f\left(i\right)=f\left(i\right)\right\} =I\in D\)</span>, אז רפלקסיביות זה קל, וסימטריה זה עוד יותר קל. אבל מה עם טרנזיטיביות? ובכן, יהיו <span class="math">\(f,g,h\in\mathcal{A}\)</span> ונגדיר <span class="math">\(B=\left\{ i\in I\ |\ f\left(i\right)=g\left(i\right)\right\} \)</span> ו-<span class="math">\(C=\left\{ i\in I\ |\ g\left(i\right)=h\left(i\right)\right\} \)</span>. אולי קצת מפתה לומר שיתקיים <span class="math">\(\left\{ i\in I\ |\ f\left(i\right)=h\left(i\right)\right\} =B\cap C\)</span> אבל זה לא נכון; מה שכן נכון הוא ש-<span class="math">\(B\cap C\subseteq\left\{ i\in I\ |\ f\left(i\right)=h\left(i\right)\right\} \)</span>. לכן אם <span class="math">\(f\equiv_{D}g\)</span> ו-<span class="math">\(g\equiv_{D}h\)</span>, ולכן <span class="math">\(B,C\in D\)</span>, אז גם <span class="math">\(\left\{ i\in I\ |\ f\left(i\right)=h\left(i\right)\right\} \in D\)</span> (זה נובע משילוב אקסיומות 2 ו-3) ולכן <span class="math">\(f\equiv_{D}h\)</span> וקיבלנו גם טרנזיטיביות.</p>
<p>אם <span class="math">\(\equiv_{D}\)</span> הוא יחס שקילות אז אפשר לחלק בו. מקבלים את הקבוצה</p>
<p><span class="math">\(\prod_{i\in I}A_{i}/\equiv_{D}=\left\{ \left[f\right]_{D}\ |f\in\prod_{i\in I}A_{i}\right\} \)</span></p>
<p>כאשר <span class="math">\(\left[f\right]_{D}\)</span> הוא סימון מחלקת השקילות של <span class="math">\(f\)</span> לפי יחס השקילות <span class="math">\(\equiv_{D}\)</span>. לדבר הזה קוראים מכפלה מצומצמת, וכדי לסמן אותו בצורה פשוטה להבא אשתמש בסימון <span class="math">\(\prod_{D}A_{i}\)</span>. במקרה שבו <span class="math">\(D\)</span> הוא על-מסנן קוראים למכפלה המצומצמת הזו על-מכפלה, ובמקרה שבו <span class="math">\(D\)</span> הוא על-מסנן ו-<span class="math">\(A_{i}=A\)</span> לכל <span class="math">\(i\in I\)</span>, כלומר המכפלה היא כולה של עותקים של <span class="math">\(A\)</span> ספציפי אחד, אז לעל-המכפלה קוראים על-חזקה.</p>
<p>רעיון הבניה הזה הוא לטעמי מגניב למדי לכשעצמו (ואני מקווה שכל מי שמכיר את המושג של "פונקציות שקולות אם הן נבדלות רק בקבוצה ממידה אפס" ולא הכיר מסננים עכשיו מרגיש קצת יותר נוח עם המושג הזה), אבל עד כה כל מה שעשינו היה יבש למדי. עכשיו מגיע האקשן האמיתי, בדמות משפט Łoś. קודם כל אצטט את המשפט בלי להיכנס לפרטיו (כולל ההגדרות, שהן חשובות לכשעצמן) ואז ניגש לעבודה.</p>
<p>עד כה הדיון כולו היה דיון טהור בתורת הקבוצות, בלי להכניס מושגים מלוגיקה. אבל אנחנו רוצים לערב במשחק את תורת המודלים, ונעשה זאת כך: נניח שיש לנו שפה כלשהי מסדר ראשון <span class="math">\(\mathcal{L}\)</span>. שפה כזו כוללת, כזכור, סימני יחס, סימני פונקציות וסימני קבועים. <strong>מודל</strong> <span class="math">\(\mathcal{M}\)</span> לשפה הזו כולל קבוצה לא ריקה כלשהי (ה<strong>תחום</strong> של המודל) ופרשנויות שמתאימות לכל סימן ב-<span class="math">\(\mathcal{L}\)</span> אובייקט מתאים - לכל סימן יחס, יחס על התחום של <span class="math">\(\mathcal{M}\)</span>; לכל סימן פונקציה, פונקציה על התחום של <span class="math">\(\mathcal{M}\)</span> ולכל סימן קבוע, איבר מהתחום של <span class="math">\(\mathcal{M}\)</span>. אם יש לנו מודל, אז לכל פסוק <span class="math">\(\varphi\)</span> (פסוק הוא נוסחה ללא משתנים חופשיים) או ש-<span class="math">\(\mathcal{M}\models\varphi\)</span> - המודל <strong>מספק</strong> את <span class="math">\(\varphi\)</span>, כלומר נותן לו ערך אמת - או ש-<span class="math">\(\mathcal{M}\not\models\varphi\)</span>.</p>
<p>כעת בואו נניח שיש לנו קבוצת אינדקסים כללית <span class="math">\(I\)</span> וקבוצת מודלים <span class="math">\(\mathcal{M}_{i}\)</span>, <span class="math">\(i\in I\)</span>, שכולם מודלים של אותה השפה. ונניח שיש לנו על-מסנן <span class="math">\(U\)</span> עבור <span class="math">\(I\)</span>. אז אפשר לבנות את העל-מכפלה <span class="math">\(\mathcal{B}=\prod_{U}\mathcal{M}\)</span>. אני מניח שברור אינטואיטיבית איך עושים את זה - הפרטים הטכניים טיפה יותר מסובכים ואחזור אליהם בהמשך. נשאלת השאלה - אילו פסוקים <span class="math">\(\mathcal{B}\)</span> מספק? התשובה פשוטה, צפויה, אלגנטית ויפהפיה:</p>
<p><span class="math">\(\mathcal{B}\models\varphi\iff\left\{ i\in I\ |\ \mathcal{M}_{i}\models\varphi\right\} \in D\)</span></p>
<p>במילים: <span class="math">\(\mathcal{B}\)</span> מספק נוסחה <span class="math">\(\varphi\)</span> אם ורק אם אוסף האינדקסים של מודלים במכפלה שיוצרת את <span class="math">\(\mathcal{B}\)</span> שמספקים את <span class="math">\(\varphi\)</span> שייך ל-<span class="math">\(D\)</span>. כדי שהתוצאה הזו תתקיים אנחנו חייבים להסתכל על על-מכפלה; המשפט פשוט לא נכון עבור מכפלות מצומצמות כלליות.</p>
<p>בפרט קורה משהו מפתיע כאשר כל ה-<span class="math">\(\mathcal{M}_{i}\)</span> שווים, כלומר כאשר אנו מסתכלים על על-חזקה <span class="math">\(\mathcal{B}\)</span> של <span class="math">\(\mathcal{M}\)</span>: במקרה הזה, <span class="math">\(\mathcal{B}\models\varphi\iff\mathcal{M}\models\varphi\)</span>. במילים אחרות, קיבלנו מ-<span class="math">\(\mathcal{M}\)</span> מודל חדש שמבחינת לוגיקה מסדר ראשון נראה <strong>אותו הדבר בדיוק</strong> כמו <span class="math">\(\mathcal{M}\)</span>, למרות שהוא יכול להיות משמעותית מורכב יותר.</p>
<p>אם לחזור לדוגמה של השדה <span class="math">\(\mathbb{F}\)</span>, בואו ניקח את <span class="math">\(I=\mathbb{N}\)</span>, ואת <span class="math">\(U\)</span> להיות על-מסנן כלשהו. ונסתכל על <span class="math">\(\prod_{U}\mathbb{F}\)</span>. נוסחאות השדה ניתנות לניסוח כולן בלוגיקה מסדר ראשון עם השפה המתאימה, ולכן <span class="math">\(\prod_{U}\mathbb{F}\)</span> יקיים בדיוק את אותן נוסחאות כמו <span class="math">\(\mathbb{F}\)</span>, ובפרט את אקסיומות השדה - כלומר, קיבלנו שדה חדש, <span class="math">\(\prod_{U}\mathbb{F}\)</span>. מצד שני, מנין לנו שהוא אינו זהה ל-<span class="math">\(\mathbb{F}\)</span>? או, טוב ששאלתם. באופן מצער למדי, הוא <strong>עשוי</strong> להיות זהה ל-<span class="math">\(\mathbb{F}\)</span>, במקרה שהעל-מסנן שלנו הוא לא מעניין מספיק - וזה בדיוק המקרה שבו העל-מסנן הוא ראשי. כזכור, במקרה הזה המסנן הוא מהצורה <span class="math">\(U=\left\{ B\subseteq I\ |\ i\in B\right\} \)</span> עבור <span class="math">\(i\in I\)</span> כלשהו, כלומר נקבל ש-<span class="math">\(f\equiv_{U}g\)</span> אם ורק אם <span class="math">\(f\left(i\right)=g\left(i\right)\)</span> וזו הסיטואציה ה"מנוונת" שתיארנו קודם; אבל אם <span class="math">\(U\)</span> מרחיב את מסנן פרשה אז <span class="math">\(U\)</span> אינו ראשי, ולכן אין קבוצה קבועה של אינדקסים שאם <span class="math">\(f,g\)</span> מזדהים עליהם אז הם זהים. קיבלנו מתוך <span class="math">\(\mathbb{F}\)</span> שדה <strong>חדש</strong> ומעניין <span class="math">\(\prod_{U}\mathbb{F}\)</span>.</p>
<p>כמה מעניין? הו הו הו. בואו ניקח את <span class="math">\(\mathbb{F}=\mathbb{R}\)</span> ונתהה איך <span class="math">\(\prod_{U}\mathbb{R}\)</span> נראה. מבלי להיכנס יותר לעובי הקורה, בואו ננסה להבין ראשית כל איך <span class="math">\(\mathbb{R}\)</span> "משתכן" בתוך השדה הזה. את המספר הממשי <span class="math">\(a\in\mathbb{R}\)</span> אפשר לייצג ב-<span class="math">\(\prod_{U}\mathbb{R}\)</span> על ידי הפונקציה הקבועה <span class="math">\(f_{a}\left(i\right)=a\)</span> - ליתר דיוק, על ידי מחלקת השקילות <span class="math">\(\left[f_{a}\right]_{U}\)</span> (זכרו! <span class="math">\(U\)</span> הוא על-מסנן מעל קבוצת האינדקסים <span class="math">\(I=\mathbb{N}\)</span>).</p>
<p>עכשיו, בואו נתבונן בפונקציה <span class="math">\(g\left(i\right)=i\)</span> - זו פונקציה עולה, וקל לראות ש-<span class="math">\(g\not\equiv_{U}f_{a}\)</span> עבור אף <span class="math">\(a\in\mathbb{R}\)</span>, שכן לכל <span class="math">\(a\in\mathbb{R}\)</span>, <span class="math">\(\left\{ i\in\mathbb{N}\ |\ g\left(i\right)=f_{a}\left(i\right)\right\} =\left\{ a\right\} \notin U\)</span>. לכן <span class="math">\(g\)</span> מייצגת "מספר" חדש שאינו ממשי. מצד שני, הוא איבר של <span class="math">\(\prod_{U}\mathbb{R}\)</span>, שהוא שדה סדור שמקיים את כל התכונות של <span class="math">\(\mathbb{R}\)</span>. בפרט אפשר להשוות את <span class="math">\(g\)</span> עם כל <span class="math">\(f_{a}\)</span>. עוד לא נכנסתי להגדרות פורמליות, אבל אתם כבר ודאי מנחשים ש-<span class="math">\(f_{a}&amp;lt;g\)</span> אם ורק אם הקבוצה <span class="math">\(\left\{ i\in\mathbb{N}\ |\ f_{a}\left(i\right)&amp;lt;g\left(i\right)\right\} \)</span> שייכת ל-<span class="math">\(U\)</span>. ומכיוון שהחל מ-<span class="math">\(k\)</span> הראשון שעבורו <span class="math">\(a&lt;k\)</span> יתקיים <span class="math">\(f_{a}\left(i\right)&amp;lt;g\left(i\right)\)</span> לכל <span class="math">\(i\ge k\)</span>, הרי ש-<span class="math">\(\left\{ i\in\mathbb{N}\ |\ f_{a}\left(i\right)&amp;lt;g\left(i\right)\right\} \)</span> היא קו-סופית ואכן שייכת ל-<span class="math">\(U\)</span>. המסקנה: השדה <span class="math">\(\prod_{D}\mathbb{R}\)</span> מכיל מספרים שגדולים מכל מספר ממשי, <strong>אבל הוא עדיין שדה</strong>. אפשר גם למצוא למספרים הללו הופכי, ולקבל מספרים שקטנים מכל מספר ממשי - קיבלנו מודל ל<strong>אנליזה לא סטנדרטית</strong>. כבר הראיתי בבלוג שקיים מודל כזה, כפועל יוצא של <a href="http://www.gadial.net/2013/03/21/fol_completeness_corollaries/">משפט הקומפקטיות</a>; אבל עכשיו אנחנו יכולים להבין איך הוא נראה, בערך (בערך, כי אנחנו לא באמת יודעים איך <span class="math">\(U\)</span> נראה, רק ש-<span class="math">\(U\)</span> הוא על-מסנן של <span class="math">\(\mathbb{N}\)</span> שכולל את כל הקבוצות הקו-סופיות).</p>
<p>האופן שבו העל-חזקה <span class="math">\(\prod_{D}\mathbb{R}\)</span> החליפה את משפט הקומפקטיות אינו מקרי - אני רוצה להראות עכשיו איך משפט הקומפקטיות עצמו נובע מכל מה שעשינו עד כה.</p>
<p>משפט הקומפקטיות, כזכור, אומר שאם יש לנו קבוצת פסוקים <span class="math">\(\Phi\)</span> שלכל תת-קבוצה סופית שלה יש מודל, אז גם ל-<span class="math">\(\Phi\)</span> יש מודל (מודל לקבוצת פסוקים הוא מודל שמספק את כל הפסוקים בקבוצה). באופן "קלאסי" מוכיחים את המשפט הזה בהתבסס על כך ש"ספיק" ו"עקבי" הם מושגים זהים בלוגיקה מסדר ראשון, תוך התבססות על <a href="http://www.gadial.net/2013/02/25/godel_completeness_proof_1/">משפט השלמות של גדל</a>. זו הוכחה שמתבססת על <strong>תורת ההוכחות</strong> והיא יפהפיה; אבל עכשיו אני רוצה לתת הוכחה שהיא לגמרי תורת-מודלים ואין בה בכלל זכר למערכות הוכחה או משפט השלמות של גדל (שאגב, ניתן להוכיח <strong>בעזרת</strong> משפט הקומפקטיות, כך שמה שאני מציג כאן הוא גם צעד ראשון של הוכחה של משפט השלמות בעזרת תורת המודלים).</p>
<p>הרעיון הוא פשוט: אם לכל תת-קבוצה סופית של <span class="math">\(\Phi\)</span> יש מודל <span class="math">\(\mathcal{M}_{i}\)</span>, אז בואו ניקח את כל המודלים הללו וניצור על-מכפלה שלהם ביחס לעל-מסנן <span class="math">\(U\)</span> שנבחר בצורה חכמה. אם נבחר את העל-מסנן כמו שצריך, נקבל ש-<span class="math">\(\prod_{U}\mathcal{M}_{i}\)</span> מספק את <span class="math">\(\Phi\)</span>. במילים אחרות, אנחנו בונים בצורה "חצי-קונסטרוקטיבית" את המודל של <span class="math">\(\Phi\)</span>; אמנם אנחנו לא נדע איך בדיוק <span class="math">\(U\)</span> נראה ולכן זו לא בניה קונסטרוקטיבית מלאה, אבל היא בהחלט יותר קונקרטית באופיה מאשר ההוכחה של משפט הקומפטיות עם משפט השלמות.</p>
<p>ראשית כל, על איזו קבוצה אנחנו רוצים להגדיר את <span class="math">\(U\)</span> בכלל? קבוצת האינדקסים <span class="math">\(I\)</span> שלנו צריכה לאנדקס את כל תת-הקבוצות הסופיות של <span class="math">\(\Phi\)</span>, אז זה בדיוק מה שנעשה: באופן כללי, בהינתן קבוצה <span class="math">\(\Phi\)</span> כלשהי (לאו דווקא של פסוקים), אפשר להגדיר <span class="math">\(I=\left\{ \Phi^{\prime}\subseteq\Phi\ |\ \left|\Phi^{\prime}\right|&amp;lt;\infty\right\} \)</span>, כלומר ה"עולם" שעליו מגדירים מסננים יכלול את כל תת-הקבוצות הסופיות של קבוצה נתונה. יכלתי להציג את העולם הזה כבר בהתחלה, יחד עם יתר הדוגמאות למסננים, אבל העדפתי לחכות עד שתהיה לי דוגמה קונקרטית לסיטואציה שבה הוא צץ מעצמו.</p>
<p>אם כן, <span class="math">\(I\)</span> זו קבוצת האינדקסים, ו-<span class="math">\(\mathcal{M}_{i}\)</span> הוא מודל של <span class="math">\(i\in I\)</span> לכל <span class="math">\(i\in I\)</span> (זכרו שכל <span class="math">\(i\)</span> כזה הוא בעצם <span class="math">\(\Phi^{\prime}\)</span> - תת-קבוצה סופית של <span class="math">\(\Phi\)</span>, ואנו מניחים ש-<span class="math">\(\Phi^{\prime}\)</span> היא ספיקה). איזה על-מסנן <span class="math">\(U\)</span> של <span class="math">\(I\)</span> ניקח? אם ניקח על-מסנן ראשי, נקבל ש-<span class="math">\(\prod_{U}\mathcal{M}_{i}\)</span> זהה לאחד מהמודלים במכפלה ותו לא; זה לא מספיק טוב. אולי ניקח על-מסנן שמרחיב את מסנן פרשה? גם זה לאו דווקא יעבוד. קחו <span class="math">\(\varphi\in\Phi\)</span>: אנחנו רוצים להראות ש-<span class="math">\(\prod_{U}\mathcal{M}_{i}\models\varphi\)</span>. מה שאנחנו יודעים הוא שזה קורה אם <span class="math">\(\left\{ i\in I\ |\ \mathcal{M}_{i}\models\varphi\right\} \in U\)</span>, אבל למה שזה יהיה נכון עבור מסנן פרשה? אנחנו יכולים להיות בטוחים ש-<span class="math">\(\mathcal{M}_{i}\models\varphi\)</span> רק עבור <span class="math">\(i\in I\)</span> שהם קבוצה <span class="math">\(\Phi^{\prime}\)</span> כך ש-<span class="math">\(\varphi\in\Phi^{\prime}\)</span>. יש הרבה כאלו, אבל אוסף כל ה-<span class="math">\(i\)</span>-ים שבהם זה קורה הוא בוודאי לא קבוצה קו-סופית ולכן אי אפשר להיות בטוחים שהוא ב-<span class="math">\(U\)</span>. אין מנוס - צריך מסנן אחר.</p>
<p>איך נגדיר את המסנן החדש? בצורה הכי טבעית שרק אפשר: פשוט <strong>נדרוש </strong>שלכל <span class="math">\(\varphi\in\Phi\)</span>, הקבוצה <span class="math">\(\left\{ i\in I\ |\ \mathcal{M}_{i}\models\varphi\right\} \)</span> תהיה במסנן. במילים אחרות, ניקח את המסנן ש<strong>נוצר</strong> מתוך הקבוצה הזו. כדי להוכיח שבכלל אפשר ליצור מסנן מתוך הקבוצה הזו צריך להראות שהיא מקיימת את תכונת החיתוכים הסופיים: כלומר, שבהינתן קבוצה סופית <span class="math">\(\left\{ \varphi_{1},\varphi_{2},\dots,\varphi_{k}\right\} \)</span>, קיים <span class="math">\(i\in I\)</span> כך ש-<span class="math">\(\mathcal{M}_{i}\models\varphi_{j}\)</span> לכל <span class="math">\(1\le j\le k\)</span>. אבל <span class="math">\(\left\{ \varphi_{1},\varphi_{2},\dots,\varphi_{k}\right\} \)</span> היא תת-קבוצה סופית של <span class="math">\(\Phi\)</span> ולכן היא בעצמה איבר של <span class="math">\(I\)</span>, ועם מודל <span class="math">\(\mathcal{M}_{i}\)</span> כנדרש. לכן אפשר לבנות על-מסנן שמקיים בדיוק את התכונה שנזקקנו לה, וזה מסיים את הוכחת משפט הקומפקטיות.</p>
<p>שני השימושים שראינו היו פשוטים להחריד - איפה העוקץ? הוא נמצא, כמובן, בכך שטרם הוכחתי או אפילו ניסתי במפורש את משפט Łoś. עכשיו אעשה את זה - זה יהיה החלק המסיים של הפוסט, וגם החלק הטכני ביותר בו, כך שאני מקווה שגם מי שילך לאיבוד עכשיו הרוויח מספיק מהפוסט עד כה.</p>
<p>ראשית כל צריך להסביר איך בדיוק בונים על-מכפלה של מודלים (או אפילו "סתם" מכפלה מצומצמת, זה עובד באותה מידה). אז נניח ש-<span class="math">\(I\)</span> היא קבוצת אינדקסים, <span class="math">\(D\)</span> הוא מסנן עליה ולכל <span class="math">\(i\in I\)</span> יש לנו מודל <span class="math">\(\mathcal{M}_{i}\)</span> עבור השפה <span class="math">\(\mathcal{L}\)</span>. כל מודל כזה כולל בפרט קבוצה שהיא התחום של המודל - בדרך כלל הייתי קורא לה <span class="math">\(D^{\mathcal{M}_{i}}\)</span> אבל כאן <span class="math">\(D\)</span> מתאר את המסנן וזה עשוי להיות בעייתי, אז אני אסמן את התחום של <span class="math">\(\mathcal{M}_{i}\)</span> בתור <span class="math">\(\mathcal{U}_{i}\)</span>.</p>
<p>המודל <span class="math">\(\mathcal{M}=\prod_{D}\mathcal{M}_{i}\)</span> ייבנה כך: העולם שלו יהיה <span class="math">\(\mathcal{U}=\prod_{D}\mathcal{U}_{i}\)</span>, שהוא פשוט מכפלה מצומצת של קבוצות אז אנחנו יודעים בדיוק איך לבנות אותו. זכרו - האיברים של העולם הזה הן <strong>מחלקות שקילות</strong> של פונקציות <span class="math">\(f:I\to\bigcup\mathcal{U}_{i}\)</span>. עכשיו נותר להסביר איך מגדירים במודל <span class="math">\(\prod_{D}\mathcal{M}_{i}\)</span> את הפרשנויות של סימני היחס <span class="math">\(R\)</span>, סימני הפונקציה <span class="math">\(F\)</span> וסימני הקבועים <span class="math">\(c\)</span> שיש ב-<span class="math">\(\mathcal{L}\)</span>.</p>
<p>בואו ניקח סימן יחס <span class="math">\(R\)</span>, ולצורך פשטות נניח שהוא דו מקומי: <span class="math">\(R\left(x,y\right)\)</span> (הרי סימני יחס כלליים יותר יטופלו באותו האופן). זכרו שלכל מודל <span class="math">\(\mathcal{M}_{i}\)</span> יש לנו יחס <span class="math">\(R^{\mathcal{M}_{i}}\)</span> מעל העולם של המודל ש"מפרש" את <span class="math">\(R\)</span> באותו מודל. אנחנו צריכים להחליט מתי עבור <span class="math">\(f,g\in\mathcal{U}\)</span> יתקיים ש-<span class="math">\(\left(f,g\right)\in R^{\mathcal{M}}\)</span>, אז ניקח את ההגדרה הטבעית ביותר לכך: <span class="math">\(\left(f,g\right)\in R^{\mathcal{M}}\)</span> אם ורק אם <span class="math">\(\left\{ i\in I\ |\ \left(f\left(i\right),g\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \in D\)</span> (רגע של מחשבה מבהיר לנו שאנחנו <strong>חייבים</strong> להגדיר את היחס ככה אם אנחנו רוצים שמשהו כמו משפט Łoś יתקיים).</p>
<p>עכשיו בואו ניקח סימן פונקציה <span class="math">\(F\in\mathcal{L}\)</span>. שוב, נניח שזו פונקציה חד-מקומית <span class="math">\(F\left(x\right)\)</span> כי המקרה הכללי דומה. אנחנו צריכים להגדיר פונקציה <span class="math">\(F^{\mathcal{M}}:\mathcal{U}\to\mathcal{U}\)</span>. איך נעשה את זה? שוב, בצורה הכי טבעית שאפשר: <span class="math">\(F^{\mathcal{M}}\left(f\right)=g_{f}\)</span>, כך ש-<span class="math">\(g_{f}\left(i\right)=F^{\mathcal{M}_{i}}\left(f\left(i\right)\right)\)</span>.</p>
<p>ומה עם קבועים? ובכן, גם זה פשוט: אם <span class="math">\(c\in\mathcal{L}\)</span> הוא סימן קבוע, עם פרשנויות <span class="math">\(c^{\mathcal{M}_{i}}\)</span> במודלים השונים, אז נגדיר <span class="math">\(c^{\mathcal{M}}=f\)</span> כאשר <span class="math">\(f\)</span> היא הפונקציה <span class="math">\(f\left(i\right)=c^{\mathcal{M}_{i}}\)</span>.</p>
<p>כל ההגדרות שנתתי נראות טבעיות ופשוטות, אבל האמת היא שרימיתי בהן כהוגן כי "שכחתי" שהאיברים של <span class="math">\(\mathcal{U}\)</span> הם לא פונקציות, אלא <strong>מחלקות שקילות</strong> של פונקציות. זה אומר שצריך לבדוק שכל ההגדרות שנתתי הן <strong>מוגדרות היטב</strong> - לא תלויות בבחירת נציגים. למשל, כשכתבתי <span class="math">\(\left(f,g\right)\in R^{\mathcal{M}}\)</span> בעצם התכוונתי לכתוב <span class="math">\(\left(\left[f\right]_{D},\left[g\right]_{D}\right)\in R^{\mathcal{M}}\)</span>. אבל אולי יש פונקציות <span class="math">\(f^{\prime},g^{\prime}\)</span> כך ש-<span class="math">\(f\equiv_{D}f^{\prime}\)</span> ו-<span class="math">\(g\equiv_{D}g^{\prime}\)</span>, וגם <span class="math">\(\left\{ i\in I\ |\ \left(f\left(i\right),g\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \in D\)</span> אבל <span class="math">\(\left\{ i\in I\ |\ \left(f^{\prime}\left(i\right),g^{\prime}\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \notin D\)</span>? במקרה הזה, מצד אחד <span class="math">\(\left(\left[f\right]_{D},\left[g\right]_{D}\right)\in R^{\mathcal{M}}\)</span> ומצד שני <span class="math">\(\left(\left[f^{\prime}\right]_{D},\left[g^{\prime}\right]_{D}\right)\notin R^{\mathcal{M}}\)</span> וזה כמובן אבסורד כי <span class="math">\(\left(\left[f\right]_{D},\left[g\right]_{D}\right)=\left(\left[f^{\prime}\right]_{D},\left[g^{\prime}\right]_{D}\right)\)</span>.</p>
<p>אז איך מוכיחים שההגדרה עובדת? באופן לא מפתיע, אנו נזקקים לשימוש בתכונות שמגדירות מסננים, כפי שנזקקנו להן כשהוכחנו ש-<span class="math">\(\equiv_{D}\)</span> הוא יחס טרנזיטיבי. נגדיר <span class="math">\(B=\left\{ i\in I\ |\ \left(f\left(i\right),g\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \)</span> ונגדיר <span class="math">\(C_{1}=\left\{ i\in I\ |\ f\left(i\right)=f^{\prime}\left(i\right)\right\} \)</span> ונגדיר <span class="math">\(C_{2}=\left\{ i\in I\ |\ g\left(i\right)=g^{\prime}\left(i\right)\right\} \)</span>, אז אם <span class="math">\(B\in D\)</span> נקבל שגם <span class="math">\(B\cap C_{1}\cap C_{2}\in D\)</span>, ולכן גם <span class="math">\(\left\{ i\in I\ |\ \left(f^{\prime}\left(i\right),g^{\prime}\left(i\right)\right)\in R^{\mathcal{U}_{i}}\right\} \in D\)</span> (כי היא מכילה את <span class="math">\(B\cap C_{1}\cap C_{2}\)</span> - למה?) ולכן אם <span class="math">\(\left(\left[f\right]_{D},\left[g\right]_{D}\right)\in R^{\mathcal{M}}\)</span> אז גם <span class="math">\(\left(\left[f^{\prime}\right]_{D},\left[g^{\prime}\right]_{D}\right)\in R^{\mathcal{M}}\)</span>, ובאותו האופן גם הכיוון ההפוך מתקיים.</p>
<p>תעלול דומה צריך לעשות גם כדי להוכיח ש-<span class="math">\(F^{\mathcal{M}}\)</span> מוגדרת היטב, כלומר שאם <span class="math">\(f\equiv_{D}f^{\prime}\)</span> אז <span class="math">\(F^{\mathcal{M}}\left(\left[f\right]_{D}\right)=F^{\mathcal{M}}\left(\left[f^{\prime}\right]_{D}\right)\)</span>. מה נעשה? כזכור, <span class="math">\(F^{\mathcal{M}}\left(f\right)=\left[g_{f}\right]_{D}\)</span> כאשר <span class="math">\(g_{f}\left(i\right)=F^{\mathcal{M}_{i}}\left(f\left(i\right)\right)\)</span> (הפעם כתבתי במפורש ש-<span class="math">\(F^{\mathcal{M}}\)</span> מחזיר מחלקת שקילות). אנחנו רוצים להראות ש-<span class="math">\(g_{f}\equiv_{D}g_{f^{\prime}}\)</span>. בבירור <span class="math">\(\left\{ i\in I\ |\ g_{f}\left(i\right)=g_{f^{\prime}}\left(i\right)\right\} \)</span> <strong>מכילה</strong> את הקבוצה <span class="math">\(\left\{ i\in I\ |\ f\left(i\right)=f^{\prime}\left(i\right)\right\} \)</span>, ומכיוון ש-<span class="math">\(f\equiv_{D}f^{\prime}\)</span> הקבוצה השניה ב-<span class="math">\(D\)</span>, ולכן גם הראשונה ב-<span class="math">\(D\)</span>. אלו פרטים טכניים, אבל כשמתעסקים איתם בידיים סוף סוף אפשר לקבל תחושה אמיתית למה האקסיומות שמגדירות מסננים הן הכרחיות ולמה הן קולעות בול לנקודה שהמושג של מסנן מנסה לתפוס.</p>
<p>עכשיו אפשר להזכיר את משפט Łoś:</p>
<p><span class="math">\(\mathcal{M}\models\varphi\iff\left\{ i\in I\ |\ \mathcal{M}_{i}\models\varphi\right\} \in D\)</span></p>
<p>איך מוכיחים אותו? ובכן, לא בצורה כיפית אלא בצורה סטנדרטית בלוגיקה - אינדוקציה. מכיוון שהפוסט הזה כבר התארך דיו, אתחמק מההוכחה ואסיים אותו כאן.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>