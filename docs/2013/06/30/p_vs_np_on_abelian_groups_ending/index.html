<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>על P=NP מעל חבורות אבליות - סוף דבר - לא מדויק</title>
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <header>
            <h1>על P=NP מעל חבורות אבליות - סוף דבר</h1>
            <div class="post-meta">
                <span class="date">2013-06-30</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אלגברה מופשטת.html">אלגברה מופשטת</a>
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/בעיית P=NP.html">בעיית P=NP</a>
                    
                    <a href="/tags/על-מכפלות.html">על-מכפלות</a>
                    
                    <a href="/tags/תורת החבורות.html">תורת החבורות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בשני <a href="http://www.gadial.net/2013/06/15/p_vs_np_on_abelian_groups_intro/">הפוסטים</a> <a href="http://www.gadial.net/2013/06/21/ultrafilters_and_ultraproducts/">האחרונים</a> אני מכין את הקרקע לקראת הוכחה ש-<span class="math">\(\mbox{P}\ne\mbox{NP}\)</span> במודלים חישוביים שהם מעל חבורות אבליות אינסופיות. בפוסט הראשון הצגתי את הרעיון שמאחורי מודל חישובי שכזה והצגתי הוכחה לכך שעבור המקרה הקונקרטי של <span class="math">\(G=\mathbb{Z}\)</span> אנחנו אכן מקבלים ש-<span class="math">\(\mbox{P}_{G}\ne\mbox{NP}_{G}\)</span>, ובפוסט שלאחריו הצגתי את המושג של על-מכפלה שבו נשתמש הפעם. ברשותכם ניגש הישר לעניינים.</p>
<p>ראשית, אפשר לקחת את ההוכחה ש-<span class="math">\(\mbox{P}_{\mathbb{Z}}\ne\mbox{NP}_{\mathbb{Z}}\)</span> ולהשתמש בה כמעט כמות שהיא כדי לתקוף מחלקה של עוד מספר חבורות שגם להן נזדקק. אני אדלג על הפרטים הטכניים בהוכחה הזו כי ההבדל בינה ובין ההוכחה המקורית (שגם בה דילגתי על פרטים) הוא לא מהותי. מיהן החבורות הנוספות הללו? ובכן, לכל ראשוני <span class="math">\(p\)</span> אפשר להסתכל על החבורה החיבורית <span class="math">\(\mathbb{Z}_{p}\)</span>. זו חבורה סופית ולכן לא רלוונטית אלינו, אבל אנחנו יכולים להסתכל על <strong>הסכום הישר</strong> <span class="math">\(\bigoplus\mathbb{Z}_{p}\)</span> של אינסוף (בן מניה) של חבורות כאלו. מה זה אומר? סכום ישר הוא מושג די דומה למכפלה ישרה, והם זהים עבור מספר סופי של מחוברים/מוכפלים, אבל סכום ישר אינסופי הוא טיפה שונה. בזמן שמכפלה ישרה של אינסוף בן מניה של עותקים של <span class="math">\(\mathbb{Z}_{p}\)</span> הייתה פשוטה סדרות ("וקטורים אינסופיים") של איברים מ-<span class="math">\(\mathbb{Z}_{p}\)</span>, הרי שהסכום הישר כולל רק סדרות <strong>שהן אפס החל ממקום מסויים</strong>, או בניסוח קצת שונה - הסכום הישר כולל את כל האיברים של המכפלה הישרה שמספר הכניסות ששונות מאפס בהן הוא סופי ("בעלות תומך סופי"). דוגמה פשוטה להבהרת העניינים היא המושג של <strong>פולינום</strong>: אפשר לחשוב על כל פולינום כעל סדרה <strong>סופית</strong> של מקדמים, ואפשר גם לחשוב עליו בתור סדרה <strong>אינסופית</strong> של מקדמים שכולם 0 החל ממקום מסויים (וסדרות אינסופיות כלליות? עליהן אפשר לחשוב בתור <strong>טור חזקות</strong>).</p>
<p>ובכן, נסמן ב-<span class="math">\(\mathbb{H}_{p}\)</span> את הסכום הישר של <span class="math">\(\mathbb{Z}_{p}\)</span>, אז אני טוען ללא הוכחה ש-<span class="math">\(\mbox{P}_{\mathbb{H}_{p}}\ne\mbox{NP}_{\mathbb{H}_{p}}\)</span>, ושההוכחה דומה למקרה של <span class="math">\(\mathbb{Z}\)</span>. יפה. מה עכשיו?</p>
<p>עכשיו ניקח חבורה אבלית אינסופית כללית <span class="math">\(G\)</span>, ונבנה את העל-חזקה שלה ביחס לעל-מסנן שמתקבל ממסנן פרשה. כבר ראינו את הבניה הזו בדיוק בפוסט הקודם כשהיא מופעלת על המספרים הממשיים <span class="math">\(\mathbb{R}\)</span>, ואז היא יצרה לנו את המספרים ההיפר-ממשיים שבבסיס האנליזה הלא סטנדרטית. מה יקרה אם נעשה את זה עבור חבורה? ובכן, נקרא לעל-מכפלה שנקבל <span class="math">\(G^{*}\)</span>. לעל-מכפלה כזו יש את התכונה הקריטית לפיה כל פסוק בלוגיקה מסדר ראשון שהוא נכון עבור <span class="math">\(G\)</span> נכון גם עבור <span class="math">\(G^{*}\)</span> וההפך - זה נקרא <strong>שקילות אלמנטרית</strong> של שני המודלים הללו. עכשיו, מה שאנחנו רוצים להראות הוא שבעיית ה-Nullsack פתירה בזמן פולינומי מעל <span class="math">\(G\)</span> אם ורק אם היא פתירה מעל <span class="math">\(G^{*}\)</span>, אבל איך אפשר להשתמש בשקילות האלמנטרית כדי להראות זאת? מה יהיה הפסוק שלנו? ובכן, כאן יש התחכמות קטנה - לכל <span class="math">\(n\)</span> טבעי נבנה פסוק <span class="math">\(\psi_{n}\)</span> שאומר, עבור אלגוריתם נתון, "האלגוריתם פותר נכון את Nullsack לכל הקלטים מאורך <span class="math">\(n\)</span>".</p>
<p>איך כותבים דבר כזה? ובכן, מנצלים את העובדה שזמן הריצה של האלגוריתם הזה חסום (בפרט חסום על ידי פולינום) ולכן עבור <span class="math">\(n\)</span> נתון, מספר השאלות שהאלגוריתם עשוי לשאול הוא מוגבל וחסום על ידי קבוע. עכשיו כותבים פסוק מהצורה <span class="math">\(\psi_{n}=\forall x_{1},\dots x_{n}\left(\bigvee C_{k}\left(x_{1},\dots,x_{n}\right)\iff\exists a_{1}\dots a_{n}\in\left\{ 0,1\right\} \left(\sum a_{i}x_{i}=0\right)\right)\)</span> כאשר כל <span class="math">\(C_{k}\)</span> הוא תת-פסוק שמייצג מסלול חישוב מקבל אפשרי אחד של האלגוריתם. ממה מורכב מסלול חישוב כזה? ובכן, יש הרבה חישובים שהאלגוריתם עשוי לעשות "בצד", אבל החישובים היחידים שמתייחסים לקלטים הם בדיקות מהצורה <span class="math">\(\vec{b}\cdot\vec{x}=0\)</span> שעליהן דיברנו בפוסט הקודם. סדרה נתונה של תשובות לשאלות הללו מגדירה מסלול חישוב, ולכן אפשר לכתוב <span class="math">\(C_{k}=l_{1}^{k}\wedge l_{2}^{k}\wedge\dots\wedge l_{t_{k}}^{k}\)</span> כאשר כל <span class="math">\(l_{i}^{k}\)</span> כזה מתאר את השאלה ה-<span class="math">\(i\)</span> בחישוב, והוא יכול להיות עם סימן שלילה לפני כן (אם מסלול החישוב הספציפי מתאר את מה שקורה כשעל השאלה הזו עונים בשלילה).</p>
<p>כעת, אם קיים אלגוריתם שפותר את בעיית ה-Nullsack עבור <span class="math">\(G\)</span>, אז קיימים פסוקים <span class="math">\(\psi_{1},\psi_{2},\dots\)</span> שמתארים את הריצה שלו על קלטים מכל גודל אפשרי, כך ש-<span class="math">\(G\models\psi_{n}\)</span> לכל <span class="math">\(n\)</span>, ולכן <span class="math">\(G^{*}\models\psi_{n}\)</span> לכל <span class="math">\(n\)</span> ולכן אותו אלגוריתם בדיוק עובד גם על <span class="math">\(G^{*}\)</span>, למרות שב-<span class="math">\(G^{*}\)</span> יכולים להיות קלטים מסובכים הרבה יותר. הנה לכם טעימה מהכוח של תורת המודלים. כל מה שנשאר לנו לעשות הוא להוכיח שלא יכול להיות קיים אלגוריתם פולינומי שפותר את Nullsack עבור <span class="math">\(G^{*}\)</span>, וכדי להראות את זה, מספיק להראות שיש ב-<span class="math">\(G^{*}\)</span> תת-קבוצה <span class="math">\(H\)</span> שעבורה בעיית ה-Nullsack לא פתירה, כי אם יש כזו, ויש אלגוריתם שפותר Nullsack על כל <span class="math">\(G^{*}\)</span>, פשוט נפעיל אותו על קלטים שמגיעים מ-<span class="math">\(H\)</span> (ומה על קלטים שלא שייכים ל-<span class="math">\(H\)</span>? ובכן, כשאנחנו מדברים על בעיית ה-Nullsack מעל <span class="math">\(H\)</span>, אנחנו מראש פוסלים קלטים כאלו - הקלטים היחידים שיכולים להגיע הם קלטים מתוך <span class="math">\(H\)</span>).</p>
<p>לכן על מנת לסיים את ההוכחה, מספיק יהיה להראות שיש ב-<span class="math">\(G^{*}\)</span> עותק של <span class="math">\(\mathbb{Z}\)</span> או עותק של <span class="math">\(\mathbb{H}_{p}\)</span> עבור <span class="math">\(p\)</span> מסויים. ולמה זה נכון?</p>
<p>עבור מחלקה לא קטנה של חבורות ברור מייד שזה נכון. אם <span class="math">\(G\)</span> היא חבורה אבלית <strong>נוצרת סופית</strong>, אז משפט מרכזי בתורת החבורות שממיין את כל החבורות הללו מראה אוטומטית שאם <span class="math">\(G\)</span> אינסופית אז היא מכילה את <span class="math">\(\mathbb{Z}\)</span> כתת-חבורה. כל הקושי הטכני אצלנו מגיע מכך שאנחנו רוצים להוכיח תוצאה חזקה יותר שתקפה לכל החבורות האבליות האינסופיות, נוצרות סופית או לא.</p>
<p>אם ב-<span class="math">\(G\)</span> יש איבר מסדר אינסופי, אז החזקות שלו לבדן יוצרות עותק איזומורפי של <span class="math">\(\mathbb{Z}\)</span> ולכן סיימנו. אחרת, כל האיברים ב-<span class="math">\(G\)</span> הם מסדר סופי, אבל עדיין יש שני מקרים אפשריים: או שקבוצת הסדרים היא לא חסומה (כלומר, לכל <span class="math">\(n\)</span> טבעי יהיה איבר שהסדר שלו הוא לפחות <span class="math">\(n\)</span>) או שהיא חסומה. אם היא לא חסומה, בואו נסתכל על האיבר הבא של <span class="math">\(G^{*}\)</span>: <span class="math">\(g=\left(g_{1},g_{2},g_{3},\dots\right)\)</span> כך שהסדר של <span class="math">\(g_{1}\)</span> קטן ממש מהסדר של <span class="math">\(g_{2}\)</span> שקטן ממש מהסדר של <span class="math">\(g_{3}\)</span> וכן הלאה. כעת, הנוסחה "הסדר של <span class="math">\(g\)</span> הוא לכל הפחות <span class="math">\(n\)</span>" יכולה להיות שגויה רק עבור מספר <strong>סופי</strong> של קואורדינטות ב-<span class="math">\(g\)</span>, ולכן קבוצת הקואורדינטות ב-<span class="math">\(G\)</span> שעבורן הנוסחה נכונה היא קו-סופית, ולכן שייכת לעל-מסנן שהגדיר את <span class="math">\(G^{*}\)</span>, כך ש-<span class="math">\(g\)</span> מקיים את הנוסחה הזו, וזאת לכל <span class="math">\(n\)</span>. מסקנה: הסדר של <span class="math">\(g\)</span> גדול מכל <span class="math">\(n\)</span> טבעי, ולכן הוא אינסופי, והנה שוב מצאנו איבר מסדר אינסופי שיוצר תת-חבורה איזומורפית ל-<span class="math">\(\mathbb{Z}\)</span> וסיימנו.</p>
<p>נשאר רק לטפל במקרה שבו יש רק מספר סופי של סדרים אפשריים לאיברים ב-<span class="math">\(G\)</span>. כעת אני רוצה להכניס לתמונה מושג סטנדרטי מתורת החבורות - <strong>אקספוננט</strong> של חבורה. האקספוננט של חבורה <span class="math">\(G\)</span> הוא המספר הטבעי המינימלי <span class="math">\(n\)</span> כך שכל איבר ב-<span class="math">\(G\)</span> מחזיר את היחידה כאשר מעלים אותו בחזקה <span class="math">\(n\)</span>, דהיינו <span class="math">\(\mbox{exp}G=\min_{n}\left\{ \forall g\in G:g^{n}=e\right\} \)</span>. בחבורה סופית, <span class="math">\(\left|G\right|\)</span> הוא תמיד מועמד טוב להיות אקספוננט כי הוא מקיים את התכונה הזו ולכן לכל היותר האקספוננט יהיה מספר קטן יותר שמחלק אותו; אבל בחבורה אינסופית ייתכן שהאקספוננט בכלל לא יהיה קיים. למשל, ב-<span class="math">\(\mathbb{Z}\)</span> אין אקספוננט. במקרה הזה נוח להגיד שהאקספוננט הוא "אינסוף".</p>
<p>אם ב-<span class="math">\(G\)</span> יש רק מספר סופי של סדרים לאיברים, ודאי שיש לה אקספוננט סופי, כי למשל המכפלה של כל הסדרים האפשריים של איברים היא מספר שמועמד להיות האקספוננט, כמו <span class="math">\(\left|G\right|\)</span> בחבורה סופית. כעת אני יכול לשלוף את הג'וקר שלי מהשרוול - <a href="http://en.wikipedia.org/wiki/Pr%C3%BCfer_theorems">משפט</a> (לא טריוויאלי) בתורת החבורות של Prüfer שאומר שחבורה אבלית סופית מאקספוננט סופי היא בהכרח סכום ישר של חבורות מהצורה <span class="math">\(\mathbb{Z}_{p}\)</span>, כאשר <span class="math">\(p\)</span> הוא ראשוני (אבל יכולות להיות בסכום חבורות שונות עם ראשוניים שונים). די ברור שמספר הראשוניים השונים הרלוונטיים חייב להיות סופי, אחרת היינו מסוגלים למצוא איברים מסדרים גדולים כרצוננו (כי ב-<span class="math">\(\mathbb{Z}_{p}\)</span> יש איבר מסדר <span class="math">\(p\)</span>). כמו כן, סכום של מספר <strong>סופי</strong> של חבורות מהצורה <span class="math">\(\mathbb{Z}_{p}\)</span> הוא חבורה סופית, ולכן מכיוון ש-<span class="math">\(G\)</span> אינסופית, הסכום חייב להיות של מספר אינסופי של מחוברים. המסקנה היא שיש <span class="math">\(p\)</span> כך ש-<span class="math">\(G\)</span> ניתנת לתיאור כסכום ישר של <strong>משהו</strong> ועוד אינסוף עותקים של <span class="math">\(\mathbb{Z}_{p}\)</span>, או במילים אחרות - <span class="math">\(G\)</span> מכילה את <span class="math">\(\mathbb{H}_{p}\)</span> כתת-חבורה, וזה מסיים את ההוכחה. הבטחתי שילוב של סיבוכיות, תורת המודלים ותורת החבורות? הנה תורת החבורות צצה לה ברגע האחרון (ואני מקווה שגם מי שיש לו היכרות בסיסית עם תורת החבורות למד עכשיו על קיומו של משפט חדש).</p>
        </article>
        
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2013/07/01/student_and_computer_5-6-7/" class="nav-link nav-next">
                <span class="nav-label">→ פוסט חדש יותר</span>
                <span class="nav-title">פרוייקט &#34;התלמיד והמחשב&#34;, בעיות 5-6-7</span>
            </a>
            
            
            
            <a href="/2013/06/21/ultrafilters_and_ultraproducts/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר ←</span>
                <span class="nav-title">על על-מסננים ועל-מכפלות</span>
            </a>
            
        </nav>
        
        
        <footer>
            <p>בלוג מתמטיקה בעברית</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>