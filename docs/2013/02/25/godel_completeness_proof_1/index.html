<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט השלמות של גדל, ההוכחה (חלק א&#39;) - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2013/02/25/godel_completeness_proof_1/">
    <meta property="og:title" content="משפט השלמות של גדל, ההוכחה (חלק א&#39;)">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2013/02/25/godel_completeness_proof_1/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="משפט השלמות של גדל, ההוכחה (חלק א&#39;)">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2013/02/23/first_order_logic_proof_system/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">מערכת הוכחה ללוגיקה מסדר ראשון</span>
            </a>
            

            
            <a href="/2013/02/26/godel_completeness_proof_2/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">משפט השלמות של גדל, ההוכחה (חלק ב&#39;)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט השלמות של גדל, ההוכחה (חלק א&#39;)</h1>
            <div class="post-meta">
                <span class="date">2013-02-25</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/לוגיקה מסדר ראשון.html">לוגיקה מסדר ראשון</a>
                    
                    <a href="/tags/משפט השלמות של גדל.html">משפט השלמות של גדל</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>ב<a href="http://www.gadial.net/2013/02/23/first_order_logic_proof_system/">פוסט הקודם</a> הצגתי מערכת הוכחה ללוגיקה מסדר ראשון, והפעם אני רוצה להתחיל את ההוכחה שהמערכת הזו היא שלמה ונאותה. למעשה, אני הולך לדלג על הוכחת הנאותות כי די כיסיתי אותה בפוסט הקודם - שכנעתי אתכם (אני מקווה) שהאקסיומות של המערכת הן אמיתות לוגיות, ושכללי ההיסק משמרים נביעה לוגית, ומכאן ההוכחה היא שגרתית. אם כן, החלק המעניין פה הוא הוכחת השלמות. משפט השלמות הוכח במקור על ידי קורט גדל בשנת 1930 ולכן הוא נקרא "משפט השלמות של גדל" (עם זאת, ההוכחה שאראה היא לא של גדל אלא של הנקין מ-1949); צריך כמובן להיזהר ולא לבלבל את זה עם משפטי אי השלמות של גדל שהוכחו ב-1931 ומדברים על סוג שונה של שלמות. משפטי אי השלמות מדברים על אי-שלמות של <strong>תורות</strong>: על כך שאם קבוצה של פסוקים <span class="math">\(\Phi\)</span> בלוגיקה מסדר ראשון מקיימת אי-אילו תכונות, אז קיים פסוק <span class="math">\(\varphi\)</span>כך ש-<span class="math">\(\Phi\not\vdash\varphi\)</span> וגם <span class="math">\(\Phi\not\vdash\neg\varphi\)</span> - כלומר, <span class="math">\(\Phi\)</span> לא מוכיחה לא אותו ואת שלילתו. משפט השלמות מדבר על שלמות של <strong>מערכת ההוכחה</strong>, והוא אומר שאם <span class="math">\(\Phi\models\varphi\)</span> עבור <span class="math">\(\Phi,\varphi\)</span> כלשהם, אז <span class="math">\(\Phi\vdash\varphi\)</span> - כלומר, כל מה שנובע לוגית גם יכיח.</p>
<p>משטיפלנו בבלבול הזה אפשר לגשת לעבודה. בואו נתחיל בלהיזכר באופן שבו הוכחנו את משפט השלמות עבור תחשיב הפסוקים, כי הרעיון הבסיסי עדיין עובד גם כאן: הוכחנו טענה שנראית ממבט ראשון שונה לגמרי - שאם קבוצה <span class="math">\(\Phi\)</span> היא עקבית, אז קיים לה מודל, כאשר "עקבית" פירושו שהיא אינה מוכיחה דבר והיפוכו. הטענה הזו גוררת מיידית את משפט השלמות באופן הבא: נניח כי <span class="math">\(\Phi\models\varphi\)</span> ונניח בשלילה ש-<span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \)</span> עקבית, אז קיים ל-<span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \)</span> מודל <span class="math">\(\mathcal{M}\)</span>, ובפרט <span class="math">\(\mathcal{M}\models\Phi\)</span> ולכן <span class="math">\(\mathcal{M}\models\varphi\)</span> (זו המשמעות של הטענה ש-<span class="math">\(\varphi\)</span> נובע לוגית מ-<span class="math">\(\Phi\)</span>). מצד שני, <span class="math">\(\mathcal{M}\models\neg\varphi\)</span> וזו סתירה (בהינתן מודל ופסוק, ערך האמת של הפסוק נקבע בצורה יחידה והוא תמיד הפוך מזה של שלילתו). לכן נובע ש-<span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \)</span> אינה עקבית, ומכך נובע ש-<span class="math">\(\Phi\vdash\varphi\)</span>. את השלב האחרון ("משפט ההוכחה בדרך השלילה") הוכחתי עבור תחשיב הפסוקים וההוכחה תקפה באותה מידה גם בלוגיקה מסדר ראשון, עד כדי נקודה קטנה אך מהותית: המשפט הזה מתבסס על מה שנקרא <strong>משפט הדדוקציה</strong>, וההוכחה של משפט הדדוקציה ללוגיקה מסדר ראשון דורשת עוד טיפה עבודה.</p>
<p>משפט הדדוקציה אומר, כזכור, שאם <span class="math">\(\Phi\cup\left\{ \alpha\right\} \vdash\beta\)</span> אז <span class="math">\(\Phi\vdash\alpha\to\beta\)</span>. בתחשיב הפסוקים ראינו כיצד להוכיח זאת במקרה שבו <span class="math">\(\beta\)</span> היא אקסיומה, הנחה מתוך <span class="math">\(\Phi\)</span>, <span class="math">\(\alpha\)</span> בעצמה, או מתקבלת על ידי MP מפסוקים שעבורם אנו כבר יודעים שמשפט הדדוקציה נכון. עם זאת, בלוגיקה מסדר ראשון צריך גם להתייחס למקרה שבו <span class="math">\(\beta\)</span> מתקבלת מהפעלת GEN, כלומר <span class="math">\(\beta=\forall x\gamma\)</span> כאשר <span class="math">\(\gamma\)</span> כבר מקיימת את משפט הדדוקציה, כלומר <span class="math">\(\Phi\vdash\alpha\to\gamma\)</span>.</p>
<p>אם כן, מה עושים? למרבה המזל, יש לנו תבנית אקסיומה שנבחרה בדיוק כדי להתמודד עם הסיטואציה הזו - תבנית אקסיומה מס' 5, <span class="math">\(\forall x\left(\varphi\to\psi\right)\to\left(\varphi\to\forall x\psi\right)\)</span>. הדרישה של תבנית האקסיומה הזו היא ש-<span class="math">\(x\)</span> לא יהיה משתנה חופשי ב-<span class="math">\(\varphi\)</span>. במקרה שלנו <span class="math">\(\varphi\)</span> הוא <span class="math">\(\alpha\)</span>, והרי <span class="math">\(\beta\)</span> מתקבל על ידי הוכחה מ-<span class="math">\(\Phi\cup\left\{ \alpha\right\} \)</span> ודרשתי במפורש שאם GEN יופעל, אז זה יהיה רק עם משתנה שאינו מופיע חופשי ב-<span class="math">\(\Phi\cup\left\{ \alpha\right\} \)</span>, ומכאן ש-<span class="math">\(x\)</span> אינו חופשי ב-<span class="math">\(\alpha\)</span>. לכן אפשר לכתוב את ההוכחה הפורמלית הבאה:</p>
<ol>
    <li><span class="math">\(\alpha\to\gamma\)</span> (הנחה).</li>
    <li><span class="math">\(\forall x\left(\alpha\to\gamma\right)\)</span> (GEN על 1 עם משתנה שאינו מופיע חופשי ב-<span class="math">\(\Phi\)</span>)</li>
    <li><span class="math">\(\forall x\left(\alpha\to\gamma\right)\to\left(\alpha\to\forall x\gamma\right)\)</span> (תבנית אקסיומה 5).</li>
    <li><span class="math">\(\alpha\to\forall x\gamma\)</span> (MP על 2,3).</li>
</ol>
<p>וקיבלנו בדיוק את <span class="math">\(\alpha\to\beta\)</span> כפי שרצינו. זה מסיים את ההעברה של המשפטים מתחשיב הפסוקים ללוגיקה מסדר ראשון ומאפשר לנו להתמקד בעיקר.</p>
<p>אם כן, מעתה היעד שלנו הוא להוכיח שלקבוצה עקבית <span class="math">\(\Phi\)</span> של פסוקים קיים מודל. בתחשיב הפסוקים "מודל" היה דבר פשוט למדי - השמה של ערכי אמת לכל המשתנים, וחסל. בלוגיקה מסדר ראשון מודל הוא עסק מסובך הרבה יותר - צריך להגדיר עולם שהוא קבוצה כלשהי של איברים, ולכל הסימנים במילון של <span class="math">\(\Phi\)</span> צריך להתאים יחסים, פונקציות וקבועים מתוך העולם. על פניו בכלל לא ברור <strong>מאיפה</strong> אנחנו הולכים להמציא את העולם הזה. כאן נכנס לתמונה התעלול הראשון: האיברים של העולם שלנו יהיו (בערך - אני משקר כאן כרגע) הקבועים של המילון של <span class="math">\(\Phi\)</span>. אלא שזה נשמע על פניו מטופש - מה אם במילון אין בכלל קבועים?</p>
<p>ובכן, בתחשיב הפסוקים האופן שבו התמודדנו עם בעיית ה"ממש לא ברור לי מאיפה להתחיל" היה לקחת את קבוצת הפסוקים שלנו ו<strong>להרחיב</strong> אותה כך שנקבל קבוצה שבה יהיה לנו מעט מאוד חופש פעולה - קבוצה כזו שאם קיים לה מודל, אז די ברור לנו איך הוא <strong>חייב</strong> להיראות. צמצום חופש הבחירה עזר לנו מאוד. אותו הדבר יקרה גם כאן - אנחנו ניקח את <span class="math">\(\Phi\)</span> ונרחיב אותה, אבל גם ניקח את <span class="math">\(\tau\)</span>, המילון של <span class="math">\(\Phi\)</span>, ונרחיב גם אותו על ידי הוספה של המון סימני קבועים. אחרי שנקבל את <span class="math">\(\Phi\)</span> המורחבת מעל המילון המורחב כבר יהיה די ברור איך המודל חייב להיראות, וכל מה שיישאר הוא לטפל בפרטים הטכניים.</p>
<p>מה שנרצה לעשות הוא להרחיב את אוסף הקבועים של <span class="math">\(\tau\)</span> ואת <span class="math">\(\Phi\)</span> כך שהם יקיימו את התכונה הבאה: ש-<span class="math">\(\Phi\)</span> המורחבת תוכל להוכיח שלכל נוסחה <span class="math">\(\varphi\left(x\right)\)</span> עם משתנה חופשי יחיד <span class="math">\(x\)</span>, אם <span class="math">\(\exists x\varphi\left(x\right)\)</span> מתקיים אז קיים קבוע ש"מוכיח" את זה, כלומר יש קבוע <span class="math">\(c\)</span> כך ש-<span class="math">\(\varphi\left(c\right)\)</span> מתקיים. פורמלית אנו אומרים שקבוצת סימני קבועים <span class="math">\(C\)</span> היא קבוצת <strong>עדים</strong> עבור <span class="math">\(\Phi\)</span> אם לכל נוסחה <span class="math">\(\varphi\left(x\right)\)</span> עם משתנה חופשי יחיד קיים <span class="math">\(c\in C\)</span> כך שמתקיים</p>
<p><span class="math">\(\Phi\vdash\exists x\varphi\left(x\right)\to\varphi\left(c\right)\)</span></p>
<p>כאן <span class="math">\(\varphi\left(c\right)\)</span> פירושו מה שמקבלים כאשר מציבים ב-<span class="math">\(\varphi\)</span> את הקבוע <span class="math">\(c\)</span> במקום <span class="math">\(x\)</span>.</p>
<p>אז כמו בתחשיב הפסוקים, יש לנו שני שלבים: שלב ההרחבה של <span class="math">\(\Phi\)</span> ו-<span class="math">\(\tau\)</span>, ושלב ההוכחה שלתורה המורחבת יש מודל. מכיוון שמודל לתורה המורחבת מעל המילון המורחב הוא עדיין מודל גם לתורה המקורית מעל המילון המקורי, זה יסיים את ההוכחה.</p>
<p>למרות שמבחינה מעשית שלב ההרחבה קודם לשלב בניית המודל, אני מעדיף לבצע אותם בסדר הפוך, מכיוון ששלב ההרחבה בעייתי יותר טכנית מסיבות שאתאר בהמשך, והרעיון היפה המרכזי בהוכחה נמצא בשלב בניית המודל. אם כן, אני מניח כרגע שנתונה לי תורה (קבוצת פסוקים עקבית) <span class="math">\(\Phi\)</span> מעל מילון <span class="math">\(\tau\)</span> כך שמתקיימות שתי התכונות הבאות:</p>
<ol>
    <li><span class="math">\(\Phi\)</span> עקבית מקסימלית, במובן זה שהוספת כל פסוק ל-<span class="math">\(\Phi\)</span> יהפוך את <span class="math">\(\Phi\)</span> ללא-עקבית.</li>
    <li>קיימת קבוצת עדים <span class="math">\(C\)</span> עבור <span class="math">\(\Phi\)</span>, כלומר לכל נוסחה <span class="math">\(\varphi\left(x\right)\)</span> עם משתנה חופשי יחיד <span class="math">\(x\)</span> קיים קבוע <span class="math">\(c\in C\)</span> כך ש-<span class="math">\(\Phi\vdash\exists x\varphi\left(x\right)\to\varphi\left(c\right)\)</span>.</li>
</ol>
<p>בואו נבנה ל-<span class="math">\(\Phi\)</span> מודל <span class="math">\(\mathcal{M}\)</span>. מודל כולל <strong>עולם</strong> שהוא קבוצה של איברים, ו<strong>פרשנויות</strong> לסימני היחס, הפונקציות והקבועים של <span class="math">\(\tau\)</span>. הרעיון האינטואיטיבי הוא לעשות את הדבר הבא: להגדיר את העולם להיות שווה לקבוצת הקבועים של <span class="math">\(\tau\)</span>, כלומר לקחת את האובייקט ה<strong>סינטקטי</strong> של סימני קבועים, ולהגדיר את המודל <strong>באמצעותו</strong>. אחר כך, בהינתן סימן יחס <span class="math">\(R\left(x,y\right)\)</span> (נניח לצורך הדוגמה שהוא דו-מקומי) להגדיר יחס <span class="math">\(R^{\mathcal{M}}\left(x,y\right)\)</span> במודל על ידי כך שלכל שני איברים <span class="math">\(c,d\)</span> של העולם, <span class="math">\(\left(c,d\right)\in R^{\mathcal{M}}\)</span> אם ורק אם הפסוק <span class="math">\(R\left(c,d\right)\)</span> יכיח מתוך <span class="math">\(\Phi\)</span>. זה הרעיון, והוא פשוט ומבריק ויפהפה. כמובן שהפרטים הטכניים קצת מסתבכים עכשיו.</p>
<p>ההוכחה מתפצלת כאן למעשה לשתי אפשרויות, בהתאם לשאלה אם הגדרנו לוגיקה מסדר ראשון עם סימן השוויון או בלעדיו. אני בחרתי להגדיר עם; כפי שנראה, זה גורם לנו לאי-אלו קשיים, אבל אסביר בהמשך אילו קשיים היו נוצרים אם הייתי בוחר לעבוד בלעדיו (זה היה מוביל לבניית מודל שמרגיש לי מלאכותי יותר).</p>
<p>אז נניח שאנחנו עובדים בלוגיקה עם סימן השוויון. הנה הבעיה - הביטו לרגע בפסוק <span class="math">\(c=d\)</span> כאשר <span class="math">\(c,d\)</span> הם שני איברים של <span class="math">\(C\)</span>. נניח שהוא יכיח מתוך <span class="math">\(\Phi\)</span> (וזה בהחלט יכול לקרות). פירוש הדבר הוא ש<strong>אסור</strong> לנו להגדיר את <span class="math">\(c,d\)</span> בתור איברים שונים בעולם של <span class="math">\(\mathcal{M}\)</span>, כי אז הפסוק <span class="math">\(c=d\)</span> לא יהיה ספיק במודל הזה (ומכיוון שמערכת ההוכחה שלנו נאותה, ינבע מכך ש-<span class="math">\(\mathcal{M}\)</span> אינו מודל של <span class="math">\(\Phi\)</span>). הבעיה הזו מכריחה אותנו להגדיר את העולם של <span class="math">\(\mathcal{M}\)</span> באופן קצת יותר מחוכם. מה שנעשה הוא להגדיר <strong>יחס שקילות</strong> על אברי <span class="math">\(C\)</span>, כך ש-<span class="math">\(c\equiv d\)</span> אם ורק אם <span class="math">\(\Phi\vdash c=d\)</span>. כלומר, אנחנו אומרים שכל הקבועים של <span class="math">\(C\)</span> ש-<span class="math">\(\Phi\)</span> "מוכיחה שהם שווים" יהיו שקולים האחד לשני.</p>
<p>צריך להוכיח שהיחס הזה הוא אכן יחס שקילות. לצורך כך נצטרך להוכיח דברים על יחס השוויון, אז בואו ניזכר באקסיומות שהיו קשורות אליו והכנסנו למערכת ההוכחה שלנו:</p>
<ol>
    <li><span class="math">\(x=x\)</span></li>
    <li><span class="math">\(x=y\to t=s\)</span> כאשר <span class="math">\(s\)</span> מתקבל מ-<span class="math">\(t\)</span> על ידי החלפת מופע אחד או יותר של <span class="math">\(x\)</span> ב-<span class="math">\(y\)</span>.</li>
    <li><span class="math">\(x=y\to\left[\varphi\to\psi\right]\)</span> כאשר <span class="math">\(\psi\)</span> מתקבל מ-<span class="math">\(\varphi\)</span> על ידי החלפת מופע אחד או יותר של <span class="math">\(x\)</span> ב-<span class="math">\(y\)</span>.</li>
</ol>
<p>בואו נתחיל. ראשית, אם <span class="math">\(c\in C\)</span> כלשהו צריך להראות ש-<span class="math">\(\Phi\vdash c=c\)</span>. הנה הוכחה פורמלית:</p>
<ol>
    <li><span class="math">\(x=x\)</span> (אקסיומת שוויון מס' 1)</li>
    <li><span class="math">\(x=x\to c=c\)</span> (אקסיומת שוויון מס' 2 עם <span class="math">\(t=s=c\)</span>)</li>
    <li><span class="math">\(c=c\)</span> (MP על 1,2).</li>
</ol>
<p>עכשיו, אם <span class="math">\(c,d\in C\)</span> הם איברים כלשהם כך ש-<span class="math">\(\Phi\vdash c=d\)</span> צריך להוכיח שגם <span class="math">\(\Phi\vdash d=c\)</span>:</p>
<ol>
    <li><span class="math">\(x=y\to\left(x=x\to y=x\right)\)</span> (אקסיומת שוויון מס' 3 עם <span class="math">\(\varphi=\left(x=x\right)\)</span> ו-<span class="math">\(\psi=\left(y=x\right)\)</span>).</li>
    <li><span class="math">\(\forall x\forall y\left(x=y\right)\to\left(x=x\to y=x\right)\)</span> (Gen על 1).</li>
    <li><span class="math">\(\left[\forall x\forall y\left(x=y\right)\to\left(x=x\to y=x\right)\right]\to\left[\left(c=d\right)\to\left(c=c\to d=c\right)\right]\)</span> (תבנית אקסיומה 4)</li>
    <li><span class="math">\(c=d\to\left(c=c\to d=c\right)\)</span> (MP על 2,3).</li>
    <li><span class="math">\(c=d\)</span> (יכיח מ-<span class="math">\(\Phi\)</span>).</li>
    <li><span class="math">\(c=c\to d=c\)</span> (MP על 4,5).</li>
    <li><span class="math">\(c=c\)</span> (יכיח מ-<span class="math">\(\Phi\)</span>).</li>
    <li><span class="math">\(d=c\)</span> (MP על 6,7).</li>
</ol>
<p>זה היה מבעית למדי, מה שמעלה את החשש שהוכחת טרנזיטיביות תהיה גרועה עוד יותר. נניח ש-<span class="math">\(c,d,e\in C\)</span> מקיימים <span class="math">\(\Phi\vdash c=d\)</span> וגם <span class="math">\(\Phi\vdash d=e\)</span>, אז צריך להוכיח ש-<span class="math">\(\Phi\vdash c=e\)</span>. כפי שאולי הבנתם מההוכחה הקודמת, מספיק להוכיח ש-<span class="math">\(x=y\to\left(y=z\to x=z\right)\)</span> כדי לסיים, אבל זו הרי בדיוק אקסיומת שוויון מס' 3 עם <span class="math">\(\varphi=\left(x=z\right)\)</span> ו-<span class="math">\(\psi=\left(y=z\right)\)</span>, כך שאחסוך מכם את המשך ההוכחה המפלצתית. זה מוכיח לנו שהיחס שהגדרתי לעיל הוא אכן יחס שקילות, ולכן אפשר לדבר על <strong>מחלקות השקילות</strong> שלו. כזכור, אם <span class="math">\(c\in C\)</span> הוא איבר כלשהו, אז מסמנים <span class="math">\(\left[c\right]=\left\{ d\in C\ |\ c\equiv d\right\} \)</span>. הקבוצה <span class="math">\(\left[c\right]\)</span> נקראת <strong>מחלקת השקילות</strong> של <span class="math">\(c\)</span> ולא קשה לראות ש-<span class="math">\(C\)</span> מתפרקת לאיחוד זר של מחלקות שקילות של איברים בה.</p>
<p>כעת אפשר להתחיל את הגדרת המודל <span class="math">\(\mathcal{M}\)</span>. ראשית נגדיר את העולם שלו: <span class="math">\(D^{\mathcal{M}}=\left\{ \left[c\right]\ |\ c\in C\right\} \)</span>. כעת נותר לתת פרשנויות לסימני היחס, הקבועים והפונקציות.</p>
<p>נתחיל מסימני היחס. יהא <span class="math">\(R\left(x_{1},\dots,x_{n}\right)\in\tau\)</span> סימן יחס <span class="math">\(n\)</span>-מקומי. נגדיר יחס <span class="math">\(R^{\mathcal{M}}\subseteq\left(D^{\mathcal{M}}\right)^{n}\)</span> באופן הבא: לכל <span class="math">\(c_{1},\dots,c_{n}\in C\)</span>, <span class="math">\(\left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)\in R^{\mathcal{M}}\)</span> אם ורק אם <span class="math">\(\Phi\vdash R\left(c_{1},\dots,c_{n}\right)\)</span>. זו הגדרה שנראית הגיונית, אבל כמו כל הגדרה שמערבת מחלקות שקילות, יש סכנה שהיא <strong>לא מוגדרת היטב</strong>. למה הכוונה? ייתכן שיש <span class="math">\(d_{1},\dots,d_{n}\in C\)</span> כך ש-<span class="math">\(\left[c_{i}\right]=\left[d_{i}\right]\)</span> (כלומר, מחלקת השקילות של <span class="math">\(c_{i}\)</span> ו-<span class="math">\(d_{i}\)</span> זהות, לכל <span class="math">\(1\le i\le n\)</span>) ועם זאת <span class="math">\(\Phi\vdash R\left(c_{1},\dots,c_{n}\right)\)</span> אבל <span class="math">\(\Phi\not\vdash R\left(d_{1},\dots,d_{n}\right)\)</span>, מה שאומר שההחלטה אם <span class="math">\(\left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)\in R^{\mathcal{M}}\)</span> אינה תלויה במחלקות השקילות בלבד אלא ממש ב<strong>נציגים</strong> שאנחנו בוחרים להן, ואסור לנו לעשות את זה - אנחנו חייבים לקבוע באופן חד משמעי עבור כל מחלקת שקילות מה יקרה איתה.</p>
<p>במקרה שלנו אין בעיה אמיתית שכזו. נניח ש-<span class="math">\(\Phi\vdash R\left(c_{1},\dots,c_{n}\right)\)</span> וכמו כן ש-<span class="math">\(c_{1}\equiv d_{1}\)</span>, כלומר <span class="math">\(\Phi\vdash c_{1}=d_{1}\)</span>. אז מהאקסיומה <span class="math">\(x=y\to R\left(x,c_{2},\dots,c_{n}\right)=R\left(y,c_{2},\dots,c_{n}\right)\)</span> אפשר לקבל חיש קל ש-<span class="math">\(\Phi\vdash R\left(d_{1},\dots,c_{n}\right)\)</span> וכך להחליף בהדרגתיות את כל ה-<span class="math">\(c\)</span>-ים ב-<span class="math">\(d\)</span>-ים. עם זאת, חשוב היה לי להדגיש שזו נקודה שיש לשים לב אליה במהלך ההגדרה, וזה חלק מהסיבוך הנוסף שנגרם לנו מכך שהלוגיקה מסדר ראשון שלנו כוללת שוויון.</p>
<p>נעבור לקבועים. מפתה להגיד שלכל סימן קבוע <span class="math">\(c\in\tau\)</span>, נגדיר את הפרשנות שלו להיות <span class="math">\(c^{\mathcal{M}}=\left[c\right]\)</span>, וזה אכן הרעיון הכללי, אבל זה <strong>לא מספיק</strong>. הבעיה היא שאולי יש סימני קבועים שבכלל לא שייכים ל-<span class="math">\(C\)</span>. הפואנטה היא שגם במקרה זה, הפרשנות שנותנים לסימנים הללו <strong>חייבת</strong> להיות זהה לפרשנות שנותנים לפחות לאחד מהקבועים. למה? או, זו הזדמנות לראות את עניין ה"<span class="math">\(C\)</span> היא קבוצת עדים" בפעולה.</p>
<p>נניח ש-<span class="math">\(d\in\tau\)</span> הוא סימן קבוע כלשהו. אז אנחנו יודעים שהפסוק הבא הוא אמת לוגית: <span class="math">\(\exists x\left(x=d\right)\)</span>. עכשיו, <span class="math">\(\Phi\)</span> היא קבוצה עקבית מקסימלית, מה שאומר (ואת זה אנחנו יודעים עוד מתחשיב הפסוקים) שלכל פסוק היא מוכיחה אותו או את שלילתו (אחרת היה אפשר להוסיף את הפסוק אליה ולקבל קבוצה גדולה יותר שעדיין עקבית). בגלל נאותות מערכת ההוכחה לא ייתכן שהיא תוכיח דבר שהוא סתירה לוגית, ולכן <span class="math">\(\Phi\vdash\exists x\left(x=d\right)\)</span>, ומכיוון ש-<span class="math">\(C\)</span> היא קבוצת עדים, אז קיים <span class="math">\(c\in C\)</span> כך ש-<span class="math">\(\Phi\vdash\exists x\left(x=d\right)\to\left(c=d\right)\)</span>, ומשילוב שני אלו נקבל ש-<span class="math">\(\Phi\vdash c=d\)</span>, וקיבלנו את מה שצריכה להיות הפרשנות של <span class="math">\(d\)</span>: <span class="math">\(d^{\mathcal{M}}=\left[c\right]\)</span>. גם כאן, התהליך היה מוגדר היטב: אם במקום <span class="math">\(c\)</span> היינו מוצאים עד אחר, היינו מקבלים גם עבורו שהוא שווה ל-<span class="math">\(d\)</span> ומהטרנזיטיביות שכבר ראינו של השוויון היינו מקבלים ש-<span class="math">\(\Phi\)</span> מוכיחה את הפסוק שאומר ששני העדים שווים ולכן מחלקת השקילות שלהם שווה.</p>
<p>בפונקציות מטפלים באופן דומה. אם <span class="math">\(f\left(x_{1},\dots,x_{n}\right)\in\tau\)</span> הוא סימן פונקציה <span class="math">\(n\)</span> מקומי, ואנחנו צריכים להגדיר את <span class="math">\(f^{\mathcal{M}}\left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)\)</span> אז נתבונן בפסוק <span class="math">\(\exists x\left(f\left(c_{1},\dots,c_{n}\right)=x\right)\)</span>, ניקח עד <span class="math">\(c\)</span> עבורו ונגדיר <span class="math">\(f^{\mathcal{M}}\left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)=\left[c\right]\)</span>. גם פה צריך להוכיח שהכל מוגדר היטב אבל נדמה לי שכבר הבנתם את הרעיון. זה מסיים את הגדרת המודל <span class="math">\(\mathcal{M}\)</span>.</p>
<p>כמובן שהגדרת המודל היא רק חלק מהעבודה, עכשיו צריך גם להוכיח שהמודל "עובד", כלומר שהוא מספק כל פסוק ב-<span class="math">\(\Phi\)</span>. איך נראים פסוקים באופן כללי? ובכן, פסוק הוא נוסחה שאין בה משתנים חופשיים. אז אפשר להתחיל מנוסחאות שאין בהן משתנים בכלל - כל שמות העצם שמופיעים בהן מורכבים רק מקבועים וסימני פונקציות. פסוק בסיסי מסוג זה חייב לכלול יחס (שם עצם לבדו אינו פסוק; פסוק מורכב מיחסים על שמות עצם, שמעורבבים האחד עם השני עם קשרים וכמתים). אז ראשית כל יש לנו פסוקים מהצורה</p>
<p><span class="math">\(t_{1}=t_{2}\in\Phi\)</span></p>
<p>כאשר <span class="math">\(t_{1},t_{2}\)</span> שמות עצם שאינם כוללים משתנים. אנחנו רוצים לחשב את הערך של שני שמות העצם הללו במודל ולראות שהוא זהה. לא ממש ברור איך לעשות את זה באופן ישיר, אבל קל לעשות את זה באופן עקיף: נסתכל על הפסוק <span class="math">\(\exists x\left(t_{1}=x\right)\)</span> ונקבל, כרגיל, שיש <span class="math">\(c\in C\)</span> כך ש-<span class="math">\(t_{1}=c\in\Phi\)</span>. בדומה נקבל ש-<span class="math">\(t_{2}=d\in\Phi\)</span> עבור <span class="math">\(d\in C\)</span> כלשהו, וכבר ראינו שאפשר להוכיח טרנזיטיביות, כלומר ש-<span class="math">\(c=d\in\Phi\)</span> ולכן <span class="math">\(\left[c\right]=\left[d\right]\)</span> וזהו הערך שהמודל מעניק לשני שמות העצם <span class="math">\(t_{1},t_{2}\)</span> כך שבמקרה הזה טיפלנו.</p>
<p>כעת, הסוג הנוסף של פסוק בסיסי הוא פסוק מהצורה</p>
<p><span class="math">\(R\left(t_{1},\dots,t_{n}\right)\in\Phi\)</span></p>
<p>כאשר <span class="math">\(R\)</span> סימן יחס כלשהו ו-<span class="math">\(t_{1},\dots,t_{n}\)</span> שמות עצם כלשהם שאינם כוללים משתנים. כמקודם, מוצאים <span class="math">\(c_{1},\dots,c_{n}\)</span> כך ש-<span class="math">\(t_{i}=c_{i}\in\Phi\)</span> ומכאן נוכל להוכיח ש-<span class="math">\(R\left(c_{1},\dots,c_{n}\right)\in\Phi\)</span>, מה שיגרור ש-<span class="math">\(\left(\left[c_{1}\right],\dots,\left[c_{n}\right]\right)\in R^{\mathcal{M}}\)</span>, מה שמסיים את המקרה הזה. כדאי לשים לב שבגלל ש-<span class="math">\(\Phi\)</span> עקבית מקסימלית הרי שבשני המקרים הוכחנו יותר מאשר את מה שרצינו - הוכחנו גם שאם <span class="math">\(t_{1}=t_{2}\notin\Phi\)</span> אז הערכים שהמודל מעניק לשמות העצם הללו שונים (אחרת אפשר היה להוסיף את <span class="math">\(t_{1}=t_{2}\)</span> ל-<span class="math">\(\Phi\)</span> מבלי לפגוע בעקביות) וכך גם עבור ה-<span class="math">\(R\)</span>-ים. זה יועיל לנו בהמשך.</p>
<p>כעת אפשר להמשיך באינדוקציה על מבנה יתר הפסוקים הקיימים. לכל פסוק <span class="math">\(\varphi\)</span> נרצה להראות ש-<span class="math">\(\mathcal{M}\models\varphi\)</span> אם ורק אם <span class="math">\(\varphi\in\Phi\)</span>. נתחיל עם פסוקים מהצורה <span class="math">\(\neg\varphi\)</span> כאשר <span class="math">\(\varphi\)</span> הוא פסוק שעליו כבר הוכחנו את הטענה. אז מכיוון ש-<span class="math">\(\Phi\)</span> עקבית מקסימלית, <span class="math">\(\neg\varphi\in\Phi\)</span> אם ורק אם <span class="math">\(\varphi\notin\Phi\)</span> אם ורק אם <span class="math">\(\mathcal{M}\not\models\varphi\)</span>, אם ורק אם <span class="math">\(\mathcal{M}\models\varphi\)</span>. זה היה קל.</p>
<p>עבור פסוק מהצורה <span class="math">\(\varphi\to\psi\)</span> הנימוק ארוך יותר אבל לא באמת מסובך יותר. מכיוון שלמשהו כמו <span class="math">\(\varphi\to\psi\)</span> יש רק השמה לא מספקת אחת, יהיה קל יותר להוכיח ש-<span class="math">\(\varphi\to\psi\notin\Phi\)</span> אם ורק אם <span class="math">\(\mathcal{M}\models\varphi\)</span> וגם <span class="math">\(\mathcal{M}\not\models\psi\)</span>. אם כן, <span class="math">\(\varphi\to\psi\notin\Phi\)</span> אם ורק אם <span class="math">\(\neg\left(\varphi\to\psi\right)\in\Phi\)</span>. כעת, תעלול: הבה ונסתכל על הפסוקים <span class="math">\(\neg\left(\varphi\to\psi\right)\to\varphi\)</span> ו-<span class="math">\(\neg\left(\varphi\to\psi\right)\to\neg\psi\)</span>. בדיקה ישירה תראה לנו שהם טאוטולוגיות, ולכן יכיחים מ-<span class="math">\(\Phi\)</span> בלי הנחות כלל, רק על ידי אקסיומות 1-3 ו-MP. לכן נקבל ש-<span class="math">\(\Phi\vdash\varphi\)</span> ו-<span class="math">\(\Phi\vdash\neg\psi\)</span>, מה שקורה אם ורק אם <span class="math">\(\mathcal{M}\models\varphi\)</span> וגם <span class="math">\(\mathcal{M}\not\models\psi\)</span>, כנדרש.</p>
<p>מה נותרו? כמתים. יהיה יותר פשוט רעיונית לטפל ב-<span class="math">\(\exists\)</span>; הטיפול ב-<span class="math">\(\forall\)</span> יהיה זהה מכיוון ש-<span class="math">\(\exists x\varphi\left(x\right)\)</span> שקול לפסוק <span class="math">\(\neg\forall x\neg\varphi\left(x\right)\)</span>.</p>
<p>אם כן, נוכיח ש-<span class="math">\(\exists x\varphi\left(x\right)\in\Phi\)</span> אם ורק אם <span class="math">\(\mathcal{M}\models\exists x\varphi\left(x\right)\)</span>. הבעיה היא ש-<span class="math">\(\varphi\left(x\right)\)</span> הוא לא פסוק, כי <span class="math">\(x\)</span> חופשי בו, ולכן אי אפשר להשתמש עליו בהנחת האינדוקציה והכל קורס, <strong>אלמלא</strong> היה לנו את התכונה המוזרה והכל כך לא ברורה במבט ראשון של "עד להוכחה". בגלל ש-<span class="math">\(C\)</span> היא קבוצת עדים, אז קיים קבוע <span class="math">\(c\)</span> כך ש-<span class="math">\(\Phi\vdash\exists x\varphi\left(x\right)\to\varphi\left(c\right)\)</span>, ולכן <span class="math">\(\varphi\left(c\right)\in\Phi\)</span> ו-<span class="math">\(\varphi\left(c\right)\)</span> הוא פסוק כך שהנחת האינדוקציה פועלת עליו, ו-<span class="math">\(\mathcal{M}\models\varphi\left(c\right)\)</span>, כלומר <span class="math">\(\mathcal{M}\models\exists x\varphi\left(x\right)\)</span> (פורמלית: אם <span class="math">\(z\)</span> היא השמה כלשהי, אז <span class="math">\(\mathcal{M}\models_{z\left[x\leftarrow\left[c\right]\right]}\varphi\left(x\right)\)</span> ולכן <span class="math">\(\mathcal{M}\models_{z}\exists x\varphi\left(x\right)\)</span>). הטיעון עובד באותו האופן בכיוון השני עד שמגיעים לכך ש-<span class="math">\(\varphi\left(c\right)\in\Phi\)</span> ורוצים להסיק מכך ש-<span class="math">\(\exists x\varphi\left(x\right)\in\Phi\)</span>; את זה עושים באמצעות הפסוק <span class="math">\(\varphi\left(c\right)\to\exists x\varphi\left(x\right)\)</span> שיכיח מ-<span class="math">\(\Phi\)</span>. אם אתם תוהים למה הוא יכיח, הנה הוכחה פורמלית:</p>
<ol>
    <li><span class="math">\(\forall x\neg\varphi\left(x\right)\to\neg\varphi\left(c\right)\)</span> (תבנית אקסיומה 4).</li>
    <li><span class="math">\(\left[\forall x\neg\varphi\left(x\right)\to\neg\varphi\left(c\right)\right]\to\left[\neg\neg\varphi\left(c\right)\to\neg\forall x\neg\varphi\left(x\right)\right]\)</span> (תבנית אקסיומה 3).</li>
    <li><span class="math">\(\neg\neg\varphi\left(c\right)\to\neg\forall x\neg\varphi\left(x\right)\)</span> (MP על 1,2).</li>
    <li><span class="math">\(\neg\neg\varphi\left(c\right)\to\exists x\varphi\left(x\right)\)</span> (סתם שינוי סימון שיהיה קריא).</li>
    <li><span class="math">\(\left[\neg\neg\varphi\left(c\right)\to\exists x\varphi\left(x\right)\right]\to\left[\varphi\left(c\right)\to\exists x\varphi\left(x\right)\right]\)</span> (טאוטולוגיה של תחשיב הפסוקים: <span class="math">\(\left(\neg\neg A\to B\right)\to\left(A\to B\right)\)</span>).</li>
    <li><span class="math">\(\varphi\left(c\right)\to\exists x\varphi\left(x\right)\)</span> (MP על 4,5).</li>
</ol>
<p>וזה <strong>מסיים את ההוכחה</strong>! רק שכמובן, זה לא מסיים את הוכחת משפט השלמות של גדל; זה מסיים את ההוכחה לכך שאם יש לנו תורה <span class="math">\(\Phi\)</span> שהיא עקבית מקסימלית וקיימת לה קבוצת עדים, אז יש לה מודל. עוד נשאר לנו להוכיח שכל תורה עקבית אפשר להרחיב לתורה שכזו, ואת זה נעשה בפוסט הבא.</p>
<p>כעת אפשר לחשוב על האופן שבו ההוכחה מתקלקלת (או הופכת לפשוטה יותר) אם שוויון הוא לא חלק מהלוגיקה שלנו. כדאי להעיר שאנחנו <strong>רוצים</strong> שוויון בלוגיקה שלנו מהרבה סיבות ולכן גם אם הוספת שוויון רק מקשה עלינו חבל לוותר עליו. עדיין, מבחינה רעיונית אולי פשוט יותר להציג קודם כל את ההוכחה עבור לוגיקה ללא שוויון כדי להימנע מיחסי שקילות ואקשן שכזה; מצד שני, במקרה הזה לא מספיק לבנות את המודל מתוך הקבועים של <span class="math">\(C\)</span> - <strong>כל שם עצם</strong> של השפה שלנו יהיה חייב להיות איבר בעולם של המודל. לי זה מרגיש מעט יותר מלאכותי, כאמור, אבל כל אחד ואיך שנוח לו. גם כך וגם כך הרעיון הזה, של בניה של המודל (האובייקט הסמנטי) מתוך השפה עצמה (האובייקט הסינטקטי) הוא אחד מהרעיונות החביבים עלי במתמטיקה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>