<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>פרוייקט &#34;התלמיד והמחשב&#34;, בעיות 16-20 - רובי - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2013/09/03/student_and_computer_16-20-ruby/">
    <meta property="og:title" content="פרוייקט &#34;התלמיד והמחשב&#34;, בעיות 16-20 - רובי">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2013/09/03/student_and_computer_16-20-ruby/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="פרוייקט &#34;התלמיד והמחשב&#34;, בעיות 16-20 - רובי">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- Post-specific social media image -->
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2013/08/30/plague_models/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">מה המתמטיקה שמאחורי התפשטות מחלות מדבקות?</span>
            </a>
            

            
            <a href="/2013/09/10/axiom_of_choice_guessing_riddles/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">איך אקסיומת הבחירה הופכת אותנו ל(כמעט) יודעי כל</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>פרוייקט &#34;התלמיד והמחשב&#34;, בעיות 16-20 - רובי</h1>
            <div class="post-meta">
                <span class="date">2013-09-03</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תכנות.html">תכנות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/פרוייקט &#34;התלמיד והמחשב&#34;.html">פרוייקט &#34;התלמיד והמחשב&#34;</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אני רוצה להתעסק הפעם עם סדרה די ארוכה של תרגילים בבת אחת, כי כולם זהים ברוחם: קראו כמות נתונים גדולה כלשהי לאיזה ייצוג פנימי שלכם, ובצעו מניפולציות על הנתונים הללו. בעיות כאלו הן הלחם והחמאה של שפות סקריפטינג - רבות מהן נולדו מלכתחילה כדי לטפל בבעיות מסוג זה. בפרט Perl, שהיא כנראה שפת הסקריפטינג הידועה ביותר וההשפעות שלה על רובי חזקות מאוד (גילוי נאות: אני שונא, מתעב ממש, את Perl. לדעתי זו שפה שמעודדת כתיבה של קוד דוחה ובלתי קריא. אם הייתי רוצה להיות ממש טרול הייתי אומר שהיא גם מעודדת את המתכנת להתלהב מעצמו יתר על המידה).</p>
<p>התרגילים הם כדלהלן:</p>
<ol>
    <li>בעיה 16: לקרוא רשימת ציונים ולהדפיס את הממוצע שלה.</li>
    <li>בעיה 17: לקלוט סדרת מספרים ולהדפיס אותה בסדר הפוך</li>
    <li>בעיה 18: לקלוט רשימה של מספרים ולהדפיס את המינימלי והמקסימלי מביניהם</li>
    <li>בעיה 19: לקלוט רשימת ציונים ולהדפיס כמה מהציונים הם בין 40 ל-60</li>
    <li>בעיה 20: לקלוט רשימה של שמות תלמידים ולהדפיס את השמות שמתחילים ב-P</li>
</ol>

<p>אלו הבעיות האחרונות בחלק הראשון של הספר.</p>
<p>אני הולך לשלב את כל הבעיות הללו לתרגיל אחד גדול: נתון קובץ טקסט בשם grades.txt שמכיל שמות של תלמידים והציונים שהם קיבלו במבחן; צריך לקרוא אותו ואז לבצע מניפולציות על המידע שנקרא מתוכו: להדפיס את הציון הממוצע של התלמידים; להדפיס את רשימת הציונים (בלי שמות) בסדר הפוך; להדפיס שם של תלמיד שקיבל ציון מקסימלי (ומה הציון) וכך גם עבור תלמיד שקיבל ציון מינימלי; להדפיס כמה מהתלמידים קיבלו ציון בין 40 ו-60; ולהדפיס את שמות כל התלמידים ששם משפחתם מתחיל ב-P (לא שמם הפרטי). בפוסט הזה אפתור את הכל רק ברובי ואדחה את הפתרונות בשפות האחרות לפוסט מאוחר יותר, כי הפוסט יהיה ארוך מספיק גם כך. גם אם הפתרונות ברובי לא מעניינים אתכם קראו לפחות את הדיון שאני מציג עכשיו בתחילת הפוסט, שהוא כללי ויהיה רלוונטי גם בשפות האחרות.</p>
<p>השאלה הראשונה שצריך לענות עליה היא איך המידע כתוב בתוך grades.txt עצמו. הדרך המתבקשת ביותר היא לכתוב קובץ שבו כתוב שם של תלמיד, ואז רווח, ואז הציון שלו. אבל שימו לב שאני רוצה לדעת להבדיל בין שם פרטי של תלמיד ובין שם המשפחה שלו. למה זו בעיה? כי הנה שני שמות: מצד אחד, חורחה לואיס בורחס ומצד שני אורסולה לה גווין. אצל בורחס, "חורחה לואיס" הוא השם הפרטי ו"בורחס" הוא שם המשפחה (השם האמיתי של בורחס מסובך יותר אבל נעזוב את זה) ואצל לה גווין "אורסולה" הוא השם הפרטי ואילו "לה גווין" הוא שם המשפחה. ואיך המחשב יוכל להבחין? סתם רווח לא מספיק. צריך להתייחס לשם פרטי ושם משפחה כאל <strong>שדות מידע שונים</strong>, ולהבדיל בין שדות מידע שונים עם תו שאינו רווח (ואז אותו תו לא יוכל להיכלל בתוך שדה מידע בלי התחכמויות נוספות).</p>
<p>זה מוביל אותנו לפורמט נפוץ ביותר של קבצי מידע שנקרא CSV, שפירושו הסטנדרטי הוא Comma-Separated Values ("ערכים המופרדים בפסיק"). קובץ CSV הוא פשוט קובץ טקסט שבו כל שורה מייצגת רשומת מידע כלשהי המורכבת משדות, כשבין כל שני שדות יש פסיק. אלא שלא כולם אוהבים להשתמש בפסיק דווקא, וכדי שיהיה מעניין וטיפה לא טריוויאלי אני אשתמש דווקא בתו הטאב כדי להפריד בין שדות. טאב הוא המקש הזה שברוב המקלדות נמצא ליד Q ובתוך עורך טקסט בדרך כלל מייצר מין "קפיצה" של כמה רווחים במקום רווח אחד - לא אכנס לדקויות המלאות שלו כרגע.</p>
<p>אז ישבתי ובניתי קובץ ציונים עם שמות של דמויות מסדרת "שיר של אש ושל קרח":</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">Eddard  Stark   43
Catelyn Tully   54
Jon Snow    77
Tyrion  Lannister   100
Jaime   Lannister   73
Ilyn    Payne   89
Cortnay Penrose 33
Cotter  Pyke    78
Hot Pie 99
Jeyne   Poole   21
Xaro Xhoan  Daxos   41
Bran    Stark   60
</code></pre>


</div>

<p>האתגר הראשון הוא לקרוא אותו לתוך מבנה נתונים כלשהו של רובי. במקרה שלנו מתבקש לתחזק מערך של רשומות. אבל מהי רשומה? אפשר לחשוב גם עליה בתור מערך, כמובן, אבל כאן לכל תא במערך יש משמעות מילולית די ברור - "שם פרטי", "שם משפחה", "ציון". זה יותר אינפורמטיבי מאשר "תא 0, תא 1, תא 2" שבו משתמשים כדי לתאר תאים במערך, ולכן מזמין שימוש במבנה נתונים אחר שיש ברובי - Hash. מבנה הנתונים הזה נקרא לפעמים, בשפות אחרות, גם "מילון", או "מערך אסוציאטיבי". מבחינה מעשית הוא דומה למערך, פרט לכך שבמקום אינדקסים שהם מספרים, יש לו אינדקסים שיכולים להיות הרבה מאוד סוגים אחרים של מידע; בהקשר של Hash לאינדקסים הללו לא קוראים "אינדקסים" אלא "מפתחות". הגמישות של Hash בנוגע למי יכול לתפקד כמפתח אצלו היא מאוד גבוהה, אבל לא אכנס כרגע לעובי הקורה הזה.</p>
<p>דרך סטנדרטית ליצור Hash עם ערכים קיימים מראש היא לכתוב סוגריים מסולסלים ובתוכם לכתוב זוגות של מפתח ואז הערך שהמפתח מצביע עליו בתוך ה-Hash, כשכל זוג כזה מופרד בפסיקים מיתר הזוגות, ובין המפתח לערך שהוא מצביע עליו מצויר חץ. כלומר, ה-Hash שמתאים לשורה הראשונה בקובץ שלעיל הוא זה:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">{&quot;first_name&quot; =&gt; &quot;Eddard&quot;, &quot;last_name&quot; =&gt; &quot;Stark&quot;, &quot;grade&quot; =&gt; 43}
</code></pre>


</div>

<p>זה Hash לגיטימי לכל דבר, אבל לא תראו יותר מדי ממנו ברובי בגלל השימוש במחרוזות בתור מפתחות. זה לא ש<strong>אסור</strong> להשתמש במחרוזות בתור מפתחות, פשוט יש משהו יותר טוב שמשתמשים בו והגיע הזמן להציג - סימבולים (Symbols). סימבולים הם משהו יחסית ייחודי לרובי, בגלל שהגישה של רובי למחרוזות היא טיפה שונה מאשר זו של שפות אחרות. ההסבר הקצר, למי שבקיאים בפרטים הטכניים: ברובי מחרוזת הן תמיד mutable ואפשר לחשוב על סימבול בתור מחרוזת שהיא immutable ולכן השימוש בהן חוסך זמן ומקום. הנה ההסבר הארוך, למי שלא בקיאים:</p>
<p>מחרוזת, באופן כללי, היא סדרה של תווים שמאוחסנת אי שם בתוך הזכרון שהתוכנית משתמשת בו. שפת התכנות יכולה לנקוט באחת משלוש גישות: או שמחרוזות יהיו <strong>ניתנות לשינוי</strong>, כלומר יהיה ניתן לגשת לאיזור בזכרון שבו התווים של המחרוזת מאוחסנים ולשנות שם ערכים ולקבל מחרוזת עם ערך חדש; במקרה הזה אומרים שהמחרוזות הן mutable; או שהמחרוזות יהיו <strong>בלתי ניתנות לשינוי</strong>, או שהן יהיו גם וגם - חלק יהיה ניתן לשנות וחלק לא. בג'אווהסקריפט, למשל, אי אפשר לשנות מחרוזות, בכלל (פונקציות ש"משנות" מחרוזות בעצם מחזירות כפלט את המחרוזות-לאחר-השינוי ולא משנו את הקלט); ב-C לעומת זאת יש כאלו שהן const ואי אפשר לשנות אותן, ואחרות שהן לא const ואפשר לשנות אותן. ברובי אפשר לשנות את כל המחרוזות, ולכן יש טיפוס נתונים אחר, שנקרא סימבול, שמזכיר מחרוזת אבל הוא לא ניתן לשינוי.</p>
<p>מה היתרון במחרוזות שאינן ניתנות לשינוי? היתרון הגדול הוא שאם כמה משתנים מכילים <strong>את אותה מחרוזת</strong> אז אין צורך לאחסן את אותה המחרוזת כמה פעמים; מספיק להקצות לה מקום אחסון יחיד בזכרון ושכל המשתנים שמכילים מחרוזות יצביעו לאותו מקום בזכרון. כך גם חוסכים את הזכרון שהמחרוזת דורשת, וגם קל יותר <strong>להשוות</strong> מחרוזות - בהינתן שתי מחרוזות פשוט בודקים אם שתיהן מצביעות לאותו מקום. כשמשתמשים במחרוזות בתור אינדקס, מה שאומר שהן יהיו מעורבות בהרבה השוואות, הדבר גורם כמובן לשיפור משמעותי בביצועים (למעשה, אני משקר כאן בגסות כי אני מסתיר פרטי מימוש של Hash שאדבר עליהם בעתיד - אבל העיקרון עדיין נכון).</p>
<p>בקיצור, בהקשר של מפתחות של Hash, או כל הקשר אחר של מחרוזת שאנחנו לא באמת נרצה לבצע בה שינויים, עדיף להשתמש בסימבול במקום במחרוזת. איך כותבים סימבול? כמו שכותבים מחרוזת, אבל עם נקודותיים בהתחלה; ובמקרה שבו המחרוזת היא משהו שיכול להיות שם חוקי של משתנה או פונקציה (הכללים שקובעים את זה הם לא טריוויאליים - למשל, בהמשך נראה שהסימן + הוא חוקי מהבחינה הזו - אבל כלל אצבע טוב בשבילכם הוא משהו שמכיל רק אותיות, מספרים וקו תחתון ולא מתחיל במספר), אפשר גם להסיר את המרכאות לגמרי. הנה כמה דוגמאות לסימבולים:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">:first_name
:&quot;0-1-2-3-4&quot;
:$23
:___whaat
:&quot;:':':&quot;
</code></pre>


</div>

<p>שמתי כמה סימבולים מאוד מוזרים שם - בדרך כלל סימבולים נראים כמו זה של first_name, בלי התחכמויות מיותרות.</p>
<p>עכשיו אפשר לומר איך הרשומה של השורה הראשונה בקובץ אמורה להיראות ברובי:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">{:first_name =&gt; &quot;Eddard&quot;, :last_name =&gt; &quot;Stark&quot;, :grade =&gt; 43}
</code></pre>


</div>

<p>שימו לב שאת הערכים של השמות אני כן שומר כמחרוזות ולא כסימבולים, פשוט כי במקרה שלהם זה הרבה פחות חשוב (מה שכדאי שיהיה סימבול הוא <strong>המפתחות</strong>). עוד סיבה שבגללה לא כדאי לשמור את הערכים הללו כסימבולים הוא שמרגע שסימבול נוצר, הוא הולך להמשיך להתקיים לאורך כל חיי התוכנית (להבדיל ממחרוזת, שברגע שהתוכנית מפסיקה להשתמש בה - ויש לרובי דרך לגלות את זה - היא הופכת ל"זומבי" שעלול להיות מושמד כל רגע כדי לפנות מקום כחלק מתהליך שנקרא "איסוף אשפה").</p>
<p>החל מגרסה 1.9.1 של רובי יש גם תחביר נוסף שבו אפשר להשתמש כשמגדירים Hash שנראה קצת "נקי" יותר:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">{first_name: &quot;Eddard&quot;, last_name: &quot;Stark&quot;, grade: 43}
</code></pre>


</div>

<p>יש כאן מוסכמה שצריך להיות מודעים אליה - אם בתוך הגדרה של Hash יש לנו מפתח ש<strong>נראה כמו משתנה</strong> אבל אחריו במקום החץ הרגיל שיש ב-Hash מופיעות נקודותיים, אז המפתח הזה הוא בעצם סימבול. <strong>אי אפשר</strong> לעשות תעלול כמו לכתוב מחרוזת במרכאות ואחריה נקודותיים; התעלול הזה עובד רק עם סימבולים שמלכתחילה אפשר היה לכתוב בלי מרכאות. המון אנשים מתעבים את התחביר החדש הזה, אבל אני די מחבב אותו.</p>
<p>כל ההקדמה הזו לא הסבירה לנו איך אפשר לקחת קובץ CSV ולקבל ממנו מערך של Hash-ים שמתאימים לשורות שלו. אז הנה:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">lines = File.open(ARGV[0], &quot;r&quot;){|f| f.read.split(&quot;\n&quot;)}
data = lines.collect do |line|
    parsed_line = line.split(&quot;\t&quot;)
    {:first_name =&gt; parsed_line[0], :last_name =&gt; parsed_line[1], :grade =&gt; parsed_line[2].to_i}
end
</code></pre>


</div>

<p>בשורה הראשונה אני פותח את הקובץ לקריאה בלבד (זו המשמעות של ה-r), קורא את כולו בבת אחת ואז מפצל על פי שורות. התוצאה היא מערך של מחרוזות, מחרוזת לכל שורה, ששמור ב-lines. בשורה הבאה אני מתחיל תהליך שבו לוקחים כל שורה line בתוך lines, ובונים ממנה את הרשומה המתאימה: קודם כל לוקחים את השורה ומפרסרים אותה על ידי כך שמפרקים את השורה למערך של מחרוזות כשהפירוק הוא בדיוק בין תווי הטאב (t). בשורה הבאה אני בונה את ה-Hash מתוך השורה המפורסרת, ועל הדרך גם ממיר את הציון ממחרוזת למספר.</p>
<p>התהליך הזה הוא לא מסובך, כמובן, אבל קצת מייגע לכתוב את כל הטקסט הזה בכל פעם שבה רוצים לפרסר קובץ CSV - הרי המקום היחיד שהוא לא גנרי אלא באמת יש בו התייחסות לתוכן ה-CSV הספציפי הוא השורה שבה מייצרים את ה-Hash. אז למה שלא תהיה ספריה סטנדרטית שעושה את זה? ובכן, באמת יש ספריה סטנדרטית לטיפול בקבצי CSV (גם קריאה וגם כתיבה שלהם וגם עוד דברים). יחד איתה אפשר להחליף את הקוד שלעיל בשורה אחת:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">data = CSV.read(ARGV[0], col_sep: &quot;\t&quot;).collect{|p| {:first_name =&gt; p[0], :last_name =&gt; p[1], :grade =&gt; p[2].to_i}}
</code></pre>


</div>

<p>השורה הזו תמימה למראה ודי ברור מה אני עושה בה - אני משתמש בפונקציה read של הספריה CSV שלוקחת קובץ שהשם שלו נתון בתור הפרמטר הראשון, ואת סוג התו המפריד בתור פרמטר שני (פרמטר שאפשר לוותר עליו אם התו המפריד הוא אכן פסיק) ומחזירה מערך-של-מערכים כשכל מערך פנימי כזה הוא שורה אחת של הקובץ אחרי פרסור. את זה אני מעביר ל-collect שממיר את המערכים הפנימיים ב-Hash וחסל. אבל האמת היא שבשורה הזו מסתתר קסם מאוד לא טריוויאלי שיש ברובי ונוגע להעברת פרמטרים לפונקציות: ה-col_sep הזה שמופיע שם. זה נראה כאילו אני לא סתם מעביר פרמטר, אלא מעביר פרמטר <strong>עם שם</strong>. מה בעצם קורה פה?</p>
<p>הנה עוד מוסכמה שפועלת מאחורי הקלעים ברובי: כשמעבירים פרמטרים לפונקציה, אם הפרמטר האחרון הוא Hash, אפשר לכתוב אותו בלי הסוגריים המסולסלים. הנה דוגמא:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">def f(a,b)
  puts a.inspect
  puts b.inspect
end

f({x: 1, y: 2}, {z: 3, w: 4})
f({x: 1, y: 2}, z: 3, w: 4)
f(x: 1, y: 2, z: 3, w: 4)
</code></pre>


</div>

<p>שתי הקריאות הראשונות ל-f ידפיסו בדיוק את אותו הדבר; לעומת זאת, הקריאה השלישית פשוט תיכשל ורובי תגיד שהיא ציפתה לקבל שני פרמטרים אבל קיבלה רק אחד.</p>
<p>שיטת הכתיבה הזו נראית קצת מוזרה ממבט ראשון, אבל היא נפוצה מאוד בשימושים של רובי בעולם האמיתי (ובראשם Rails) ולכן חשוב להכיר אותה. גם ב-CSV זה המצב (בגרסת רובי 1.9.1; בגרסאות ישנות יותר זה היה שונה): פקודת read מקבלת שני פרמטרים שהראשון מביניהם הוא שם הקובץ שצריך לפעול עליו, והשני הוא Hash (עם ערך דיפולטי של Hash ריק, כך שהוא יכול לא להיות מועבר כלל) של כל מני אופציות שמשפיעות על אופן הפרסור. למשל, יש גם פרמטר של row_sep שבורר את הסימן המפריד בין השורות.</p>
<p>למה נוקטים בדרך העברת פרמטרים שכזו? פשוט, כי יש הרבה מאוד אפשרויות שאפשר להעביר ל-read, אבל ברוב המקרים המשתמש לא יצטרך את כולן. ברור לגמרי שאי אפשר להעביר אותן בתור פרמטרים בצורה הרגילה, כי זה יכריח את המשתמש לכתוב ערכים לכל האפשרויות (שימוש בערכי ברירת מחדל הוא בעייתי כי מה אם האפשרות שהמשתמש רוצה לשנות היא אחרונה?) וזה יצריך אותו לבדוק מה הסדר הנכון של הפרמטרים בחתימה של הפונקציה שהוא מפעיל, וזה יהיה סיוט אחד גדול. לכן צריך להעביר את כל האפשרויות כשהן מקובצות למשתנה יחיד שלא חייב להכיל את כולן במפורש, ו-Hash הוא הבחירה המתאימה לשם כך. התחביר החדש של כתיבת Hash-ים גורם לקריאה הזו להיראות נחמד; בגרסאות ישנות יותר של רובי היינו צריכים לכתוב</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">CSV.read(ARGV[0], :col_sep =&gt; &quot;\t&quot;)
</code></pre>


</div>

<p>שגם הוא לא נורא בכלל אבל נראה קצת פחות טוב לטעמי.</p>
<p>עכשיו אפשר להציג סוף סוף את הקוד שפותר את התרגיל במלואו:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">require 'csv'
data = CSV.read(ARGV[0], col_sep: &quot;\t&quot;).collect{|p| {:first_name =&gt; p[0], :last_name =&gt; p[1], :grade =&gt; p[2].to_i}}

grades = data.collect{|d| d[:grade]}
average = grades.inject(:+).to_f / grades.length
best = data.max{|a,b| a[:grade] &lt;=&gt; b[:grade]}
worst = data.max{|a,b| b[:grade] &lt;=&gt; a[:grade]}
last_name_p_students = data.find_all{|d| d[:last_name] =~ /^P/}

puts &quot;Average = #{average}&quot;
puts &quot;Reversed grade list: #{grades.reverse.inspect}&quot;
puts &quot;Best student: #{best[:first_name]} #{best[:last_name]} (#{best[:grade]})&quot;
puts &quot;Worst student: #{worst[:first_name]} #{worst[:last_name]} (#{worst[:grade]})&quot;
puts &quot;#{grades.find_all{|g| (40..60).include? g}.length} students got between 40 and 60&quot;
puts &quot;#{last_name_p_students.length} students whose last name starts with P: #{last_name_p_students.collect{|d| d[:first_name] + &quot; &quot; + d[:last_name]}.join(&quot;, &quot;)}&quot;
</code></pre>


</div>

<p>כאשר מפעילים את הקוד הזה על קובץ הטקסט שהצגתי קודם, הפלט הוא:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">Average = 64.0
Reversed grade list: [60, 41, 21, 99, 78, 33, 89, 73, 100, 77, 54, 43]
Best student: Tyrion Lannister (100)
Worst student: Jeyne Poole (21)
4 students got between 40 and 60
5 students whose last name starts with P: Ilyn Payne, Cortnay Penrose, Cotter Pyke, Hot Pie, Jeyne Poole
</code></pre>


</div>

<p>בתוך הקוד הכנסתי כמה התחכמויות חדשות, אז בואו נעבור עליו שורה שורה כדי להבין מה הולך שם.</p>
<p>שורות 1-2 מוקדשות לקריאת קובץ ה-CSV - בעצם, הן מסכמות את כל הדיון עד כה. בשורה 4 אני "גוזר" מתוך המידע הכללי מערך שכולל רק את הציונים ותו לא - זה שימוש סטנדרטי ב-collect.</p>
<p>שורה 5 היא מעניינת בגלל האופן שבו אני קורא ל-inject כדי לסכום את הציונים. בצורת הקריאה המלאה שלו, inject שעושה את זה ייראה ככה:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">grades.inject(0){|sum, x| sum + x}
</code></pre>


</div>

<p>בצורת הקריאה הזו, inject מקבל שני פרמטרים - פרמטר אחד שהוא "ערך התחלתי" ופרמטר שני שהוא בלוק. הוא מאתחל את sum להיות הערך ההתחלתי, ואז מריץ סדרתית את הבלוק כאשר הוא מעביר לו את sum ובתור x מעביר לו את אברי המערך, ואחרי כל הרצה של הבלוק הוא מעדכן את sum להיות הערך שהבלוק החזיר.</p>
<p>לעומת זאת, בתוך הקוד הנוכחי לא <strong>העברתי בלוק</strong>. רובי יודעת לזהות את זה, ולכן היא גם יודעת למה לצפות - הוא מצפה שאעביר לו פרמטר שהוא סימבול, שמתאר את <strong>שם</strong> הפונקציה שאני רוצה שהוא יפעיל. אפשר לפני הסימבול להעביר לו ערך התחלתי, אבל אם לא עושים את זה הוא פשוט משתמש בערך של האיבר הראשון במערך בתור הערך ההתחלתי.</p>
<p>ייתכן מאוד שאתם אומרים עכשיו "אבל רגע! זה לא מספיק להעביר את סימן הפלוס! הרי אותו הסימן מייצג פונקציות שונות - למשל, חיבור של מספרים וחיבור של מערכים ואלו שני דברים שונים!" וזה כמובן נכון, אבל רובי יודעת להתמודד עם זה - הטיפוס של sum יקבע מה תהיה הפונקציה שתופעל (הסבר יותר מקיף לעניינים הללו אוכל לתת אחרי שאסביר סוף סוף מה זה class).</p>
<p>הקטע הזה, של להעביר מחרוזת שהיא שם של פונקציה שרוצים להפעיל, ועוד כשמדובר על פונקציה עם שם "מוזר" כמו +, הוא די חריג בשפות תכנות, ובהחלט מהווה את אחת מהסיבות שרובי כל כך מגניבה לטעמי. אבל אין צורך להתעמק בפרטים כרגע - בינתיים אפשר לחשוב על זה בתור דרך מקוצרת לבצע סכום ותו לא.</p>
<p>בשורות 6-7 אני מנסה להשיג את הרשומות של תלמידים עם ציון גדול וקטן ביותר, בהתאמה. שימו לב - כל הרשומה, לא רק הציון. לכן סתם להשתמש בפונקציה max לא הולך לעבוד - לא ברור לרובי איך להשוות שתי רשומות. לכן אני מצרף ל-max בלוק, שמקבל כקלט שני איברים שיכולים להופיע ברשימה - a,b - ומטרתו היא להשוות ביניהם. הוא צריך להחזיר ערך שקטן מ-0 אם a בא לפני b; ערך שגדול מ-0 אם b בא לפני a; וערך ששווה ל-0 אם a שווה ל-b או שאנחנו אדישים בנוגע לסדר ביניהם. בשביל לעשות את זה, אני ראשית "מחלץ" את הציון מתוך שתי הרשומות הללו, ואז משווה את שני המספרים שקיבלתי עם אופרטור מיוחד של רובי, שמסומן &lt;=&gt;, ומבצע בדיוק השוואה מהסוג שתיארתי ומחזיר 1, 0 או מינוס 1. האופרטור הזה הוא עוד פיסת סינטקס שאני מאוד מחבב ברובי.</p>
<p>בשורה 7 אני מתחכם - במקום להשתמש ב-min ולהעביר את אותו הבלוק כמו בשורה 6, אני משתמש שוב ב-max ומשנה משהו בבלוק - האם תוכלו להבין מה ולמה זה עושה את מה שזה צריך לעשות? (ואתגר נוסף - האם יש דרך לתת קלט לסקריפט שלי כך שהשימוש הזה ב-max לא יחזיר את אותו פלט כמו השימוש ב-min עם הבלוק של שורה 6?)</p>
<p>בשורה 8 אני משתמש ב-find_all כדי למצוא את כל רשומות התלמידים ששם משפחתם מתחיל ב-P. אבל איך אני בודק ששם מתחיל ב-P? כאן שוב יש התחכמות חדשה: אני לוקח את המחרוזת של השם ומפעיל עליה את האופרטור ~=. האופרטור הזה מקבל בצד ימין <strong>ביטוי רגולרי</strong>. לא אסביר עכשיו מה זה בדיוק ביטוי רגולרי כי זה דבר שדורש פוסט בפני עצמו, אבל בקצרה: ביטוי רגולרי מתאר <strong>תבנית</strong> כלשהי שמילים יכולות להתאים או לא להתאים לה. הביטוי הרגולרי הספציפי שכתבתי אומר בדיוק "מילים שהאות הראשונה בהן היא P (ה-^ שמופיע שם פירושו "תחילת המילה").</p>
<p>כל יתר הקוד הוא הדפסות. בשורה 11 אני הופך את הרשימה בעזרת פקודת reverse ואחר כך מפעיל עליה את פקודת inspect שמשמשת להמרת מערך למחרוזת יפה, עם סוגריים מרובעים שתוחמים את המערך, ומדפיס את זה. אני מקווה שיתר הקוד ברור.</p>
<p>זה מסיים עם הבעיות הללו ואני מקווה שנותן טעימה קטנה מהכוח האמיתי של רובי, שעד כה לא ממש הוצג; בהמשך אנצל את התרגילים הקלים של חלק ב' כדי להתחיל להציג באופן מסודר חלק מהרעיונות שהראיתי כאן ברמז.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>