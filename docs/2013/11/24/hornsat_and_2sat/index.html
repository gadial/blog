<!DOCTYPE html>
<html lang="he" dir="rtl"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>פותרים את SAT: המקרים של HORNSAT ו-2SAT | לא מדויק</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="פותרים את SAT: המקרים של HORNSAT ו-2SAT" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
<meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
<link rel="canonical" href="http://gadial.net/2013/11/24/hornsat_and_2sat/" />
<meta property="og:url" content="http://gadial.net/2013/11/24/hornsat_and_2sat/" />
<meta property="og:site_name" content="לא מדויק" />
<meta property="og:image" content="http://gadial.net/assets/img/main/default-card.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-11-24T16:54:19+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="http://gadial.net/assets/img/main/default-card.png" />
<meta property="twitter:title" content="פותרים את SAT: המקרים של HORNSAT ו-2SAT" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://gadial.net/2013/11/24/hornsat_and_2sat/","image":"http://gadial.net/assets/img/main/default-card.png","headline":"פותרים את SAT: המקרים של HORNSAT ו-2SAT","dateModified":"2013-11-24T16:54:19+00:00","datePublished":"2013-11-24T16:54:19+00:00","description":"לא מדויק - בלוג על מתמטיקה ומדעי המחשב","mainEntityOfPage":{"@type":"WebPage","@id":"http://gadial.net/2013/11/24/hornsat_and_2sat/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/favicon.ico" type="image/x-icon"><link type="application/atom+xml" rel="alternate" href="http://gadial.net/feed.xml" title="לא מדויק" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-3924539-2', 'auto');
  ga('send', 'pageview');
}
</script>
  
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        processEscapes: true
      },
      TeX: {extensions: ["AMSmath.js","AMSsymbols.js"]},
      "HTML-CSS": { 
        linebreaks: { automatic: true }
      },
      SVG: { 
        linebreaks: { automatic: true } 
      }
    });
  </script>
  <!-- "https://www.gadial.net/wp-includes/js/xypic.js" -->

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

</head>
<body><header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <a class="navbar-brand" href="/">לא מדויק</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarCollapse">
      <ul class="navbar-nav mr-auto">
        
            
            <li class="nav-item">
                <a class="nav-link" href="/lecture_notes">סיכומי הרצאות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/">דף הבית</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/categories">קטגוריות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/random">דף אקראי</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">אודות</a>
            </li>
            
        
      </ul>
      <form class="form-inline mt-2 mt-md-0" action="/post_list/" method="get">
        <input class="form-control mr-sm-2" type="text" placeholder="חיפוש" aria-label="חיפוש" name="s">
        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">חיפוש</button>
      </form>
    </div>
  </nav>
</header><main class="page-content" aria-label="Content" role="main">
      <div class="wrapper text-right">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><div class="PageNavigation">
    
      <a class="prev" href="/2013/11/14/resolution_proof_system/">&laquo; רזולוציה - איך אפשר להוכיח שאי אפשר?</a>
    
    
      <a class="next" href="/2013/12/11/dpll_algorithm/">פותרים את SAT - אלגוריתם DPLL &raquo;</a>
    
  </div><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">פותרים את SAT: המקרים של HORNSAT ו-2SAT</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-11-24T16:54:19+00:00" itemprop="datePublished">Nov 24, 2013
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>בפוסטים הקודמים דיברתי על בעיית SAT ועל השיטה שבה ניתן להוכיח שפסוק CNF אינו ספיק, אבל כל מה שעשיתי עד כה היה מאוד באוויר - עדיין לא הסברתי איך אפשר בפועל לקחת פסוק CNF ולקבוע אם הוא ספיק או לא.</p>

<p>ובכן, באופן כללי הבעיה היא קשה, לפחות מבחינה תיאורטית, אבל יש <strong>מקרים פרטיים</strong> מסויימים של פסוקי CNF שהם פתירים באופן יעיל, גם מנקודת המבט התיאורטית של זמן הריצה הגרוע ביותר. בפוסט הזה אני רוצה להציג שני מקרים פרטיים שכאלו ואיך פותרים אותם; הרעיונות שנראה כאן יעזרו לנו להבין את הרעיון הכללי של האלגוריתמים לפתרון SAT (בפועל, לא במובן התיאורטי) שאציג בהמשך.</p>

<p>נתחיל עם בעיה שנקראת HORNSAT, על שם הלוגיקאי אלפרד הורן. בבעיה הזו נתון לנו CNF מצורה מיוחדת מאוד: כל פסוקית שלו מכילה לכל היותר ליטרל חיובי אחד - כל יתר הליטרלים הם בשלילה. פסוקית כזו נקראת <strong>פסוקית הורן</strong>. למשל, <span>\( \left(\neg x\vee y\vee\neg z\vee\neg w\right) \)</span> היא פסוקית הורן; גם <span>\( \left(\neg x\vee\neg y\right) \)</span> שאין בה בכלל ליטרלים חיוביים היא פסוקית הורן.</p>

<p>בואו נסתכל לרגע על הפסוקית <span>\( \left(\neg x\vee y\vee\neg z\vee\neg w\right) \)</span>. אם נציב 0 ב-<span>\( x \)</span>, או 0 ב-<span>\( z \)</span>, או 0 ב-<span>\( w \)</span>, זה יספק את הפסוקית. אבל מה יקרה אם נציב 1 בשלושתם? במקרה זה, כדי לספק את הפסוקית אנחנו חייבים להציב 1 ב-<span>\( y \)</span>. כלומר, הפסוקית ממדלת טענה מהצורה “אם <span>\( x,w,z \)</span> מתקיימים כולם אז גם <span>\( y \)</span> מתקיים”. פורמלית כותבים את זה כך: <span>\( \left(x\wedge w\wedge z\to y\right) \)</span>. באופן כללי, את הקשר <span>\( \to \)</span> אפשר “לקודד” עם שלילה ו-<span>\( \vee \)</span>: <span>\( \alpha\to\beta \)</span> שקול לוגית ל-<span>\( \neg\alpha\vee\beta \)</span>, ומכאן האופן שבו פסוקית כמו <span>\( \left(x\wedge w\wedge z\to y\right) \)</span> מוצגת כ-CNF. עם זאת, אני חושב שהרבה יותר קל להבין פסוקיות הורן כשחושבים עליהן כעל משהו מהצורה <span>\( \left(x\wedge w\wedge z\to y\right) \)</span>.</p>

<p>איך בודקים את הספיקות של פסוק הורן שכזה? הפתרון פשוט עד להפתיע: באופן איטרטיבי, אם יש משתנה ש<strong>חייב</strong> לקבל 1, מציבים בו 1; אחרת, מציבים 0 בכל המשתנים וסיימנו.</p>

<p>מה זה אומר “חייב” לקבל 1? זה אומר שאם הוא לא מקבל 1, תהיה לנו פסוקית שאינה מסתפקת. אבל כדי שהדרך היחידה לספק פסוקית CNF היא על ידי הצבת 1 במשתנה <span>\( x \)</span> כלשהו, הפסוקית חייבת להיות מהצורה <span>\( \left(x\right) \)</span> (כי אם היה בה ליטרל נוסף, היינו מקבלים דרכים נוספות לספק את הפסוקית). פסוקית כזו נקראת <strong>פסוקית יחידה</strong> (Unit clause).</p>

<p>אם אין בפסוק שלנו אף פסוקית יחידה עם משתנה חיובי, אז הצבה של 0 לכל המשתנים תספק בודאות את כל הפסוקיות. למה? כי בואו ניקח פסוקית כלשהי: היא לא פסוקית יחידה עם משתנה חיובי, ולכן יש בה לפחות משתנה שלילי אחד, או לפחות שני משתנים חיוביים. המקרה השני בלתי אפשרי עבור פסוקיות הורן, כי בפסוקית הורן על פי הגדרה יש לכל היותר ליטרל חיובי אחד. מסקנה: בפסוקית יש ליטרל שלילי אחד לפחות, ובהשמה שנותנת 0 לכל המשתנים הוא יקבל 1. סיימנו.</p>

<p>אם בפסוק שלנו יש פסוקית יחידה עם משתנה חיובי <span>\( x \)</span>, מבצעים את מה שנקרא Unit Propagation ובעברית פשוט אקרא לו “פעפוע”: מבחינה רעיונית, אנחנו מציבים 1 ב-<span>\( x \)</span> (כי אין לנו ברירה!). בפועל, אנחנו פשוט מסלקים מה-CNF שלנו את כל הפסוקיות שבהן הופיע הליטרל <span>\( x \)</span> (כי הן סופקו) ומסירים את הליטרל <span>\( \neg x \)</span> מכל הפסוקיות שבהן הוא הופיע (כי <span>\( \neg x \)</span> קיבל את הערך 0 וכבר לא יספק את הפסוקית). אם קיבלנו פסוקית ריקה, הפסדנו; הפסוק לא ספיק. אם קיבלנו פסוק ריק, כלומר סילקנו ממנו את כל הפסוקיות, הצלחנו; מצאנו השמה מספקת (משתנים שהערך שלהם טרם נקבע יכולים להיות בעלי כל אחד משני הערכים האפשריים - זה לא ישנה).</p>

<p>אחרי שגמרנו עם <span>\( x \)</span>, צריך לבדוק אם יש לנו עוד פסוקיות יחידה חיוביות. ייתכן שקודם לא היו כאלו אבל הן נוצרו במהלך הפעפוע (למשל, אם קודם הייתה לנו הפסוקית <span>\( \left(\neg x\vee y\right) \)</span>). אם כן, מפעפעים גם את המשתנה החדש, וכן הלאה וכן הלאה. אם אין עוד פסוקיות יחידה חיוביות, אז כאמור פשוט מציבים 0 בכל המשתנים שנותרו וסיימנו.</p>

<p>האלגוריתם הזה ממש, ממש פשוט. בביצוע נאיבי זמן הריצה שלו הוא <span>\( O\left(n^{2}\right) \)</span>, אבל עם קצת התחכמויות אפשר גם לבצע אותו בזמן לינארי (<span>\( O\left(n\right) \)</span>) מה שאומר שהוא גם יעיל מאוד. זה מעניין, כי מצד שני זו גם בעיה שהיא במובן מסויים “הכי קשה ב-P’’ (כאן P מייצג את אוסף הבעיות עם אלגוריתם פולינומי שפותר אותן), במובן זה שכל בעיה אחרת שיש אלגוריתם פולינומי המכריע אותה ניתנת לתרגום ל-HORNSAT תוך שימוש בכמות קטנה יחסית של זכרון - פולי-לוגריתמית (כלומר, כמות זכרון שהיא פולינום בלוגריתם של <span>\( n \)</span>). פורמלית אומרים שזו שפה שהיא P-שלמה (כמו שיש NP-שלמה) ביחס לרדוקציות logspace (ולכן, למשל, אם קיים אלגוריתם שפותר אותה בזכרון פולי-לוגריתמי - לא סביר בכלל - אז לכל שפה ב-P קיים אלגוריתם עם דרישות זכרון מצומצמות שכאלה).</p>

<p>בואו נעבור עכשיו לוריאנט אחר של SAT, שנקרא 2SAT. הפעם אנחנו מרשים לליטרל חיובי להופיע פעמיים בתוך פסוקית, אבל מטילים על הפסוק מגבלה די קשיחה: בכל פסוקית יש <strong>בדיוק</strong> שני ליטרלים (אנחנו מרשים גם פסוקיות כמו <span>\( \left(x\vee x\right) \)</span> שהן בפועל פסוקית עם ליטרל יחיד). ייתכן שהמגבלה הזו נראית לנו קשיחה <strong>מדי</strong>, כי אנחנו מגבילים את המספר המקסימלי של ליטרלים שיכולים להופיע בתוך פסוקית, אבל האינטואיציה שלנו בעייתית בהקשר הזה: וריאנט אחר הוא 3SAT שבו כל פסוקית מכילה בדיוק שלושה ליטרלים, ומסתבר שאפשר לקודד <strong>כל</strong> פסוק CNF כפסוק 3CNF במחיר של הגדלה לא משמעותית (לינארית באורך הכולל של הפסוקיות בפסוק המקורי) של גודל הפסוק. כך שהמגבלה פחות קטלנית מאשר היא נראית במבט ראשון, ועדיין - פסוקי 2CNF הם משמעותית יותר פשוטים ולכן אני יכול להציג אלגוריתם יעיל שבודק את הספיקות שלהם.</p>

<p>הסיבה שבגללה פסוקי 2CNF הם פשוטים ברמה שעוזרת לנו היא שאפשר לחשוב על כל פסוק כזה בתור אוסף אילוצים מהצורה “ליטרל אחד גורר ליטרל אחר”. את <span>\( \left(x\vee y\right) \)</span> אפשר לכתוב גם כ-<span>\( \neg x\to y \)</span> וגם כ-<span>\( \neg y\to x \)</span>, כלומר כל פסוקית נותנת לנו שתי גרירות שמערבות ליטרלים. היופי פה הוא שגרירה היא <strong>יחס טרנזיטיבי</strong>: אם <span>\( x\to y \)</span> ו-<span>\( y\to z \)</span> אז גם <span>\( x\to z \)</span> גם אם הם לא מופיעים יחד באף פסוקית (אם תחשבו על זה לרגע, תראו שזה בעצם כלל הרזולוציה בתחפושת: מ-<span>\( \left(\neg x\vee y\right) \)</span> ו-<span>\( \left(\neg y\vee z\right) \)</span> אנו מסיקים את <span>\( \left(\neg x\vee z\right) \)</span>).</p>

<p>עכשיו, נניח שעל ידי שרשרת של הסקות כאלו קיבלנו את הגרירה <span>\( x\to\neg x \)</span>. מה זה אומר? זה אומר שאם <span>\( x \)</span> שווה 1 אז גם <span>\( \neg x \)</span> צריך להיות שווה 1, אבל זה כמובן בלתי אפשרי, והמסקנה היא ש-<span>\( x \)</span> חייב לקבל 0 על ידי כל השמה שאנחנו מקווים שתספק את הפסוק שלנו (<span>\( x\to\neg x \)</span> הוא פשוט הפסוקית <span>\( \left(\neg x\vee\neg x\right) \)</span> בתחפושת, כלומר פסוקית היחידה <span>\( \left(\neg x\right) \)</span>).</p>

<p>ומה קורה אם קיבלנו גם את <span>\( x\to\neg x \)</span> וגם את <span>\( \neg x\to x \)</span>? הגרירה הראשונה מראה ש-<span>\( x \)</span> לא יכול לקבל 1, והשניה מראה ש-<span>\( x \)</span> לא יכול לקבל 0, ולכן המשחק נגמר - הפסוק אינו ספיק. במונחי רזולוציה, קיבלנו את <span>\( \left(x\right),\left(\neg x\right) \)</span> ואחרי רזולוציה לשניהם נקבל את הפסוקית הריקה. אם כן, יש לנו קריטריון להכרעה מתי פסוק 2CNF אינו ספיק: אם קיימת שרשרת גרירות מ-<span>\( x \)</span> אל <span>\( \neg x \)</span> וקיימת שרשרת גרירות מ-<span>\( \neg x \)</span> אל <span>\( x \)</span> עבור משתנה <span>\( x \)</span> כלשהו. מה שיפה כאן הוא שהקריטריון הזה הוא קריטריון של אם ורק אם: אם לאף משתנה אין שתי שרשראות גרירה כאלו, הפסוק ספיק. בואו נוכיח את זה.</p>

<p>בואו ניקח פסוק <span>\( \varphi \)</span> עם התכונה המבוקשת, כלומר שאין משתנה שגורר את שלילתו וגם שלילתו גוררת אותו. נתחיל לבנות לו השמה. נבחר שרירותית משתנה <span>\( x \)</span>. אם לא מתקיים <span>\( x\to\neg x \)</span>, נציב ב-<span>\( x \)</span> 1; אם כן מתקיים <span>\( x\to\neg x \)</span> אז מובטח לנו שלא מתקיים ההפך, <span>\( \neg x\to x \)</span>, ואז נציב 0 ב-<span>\( x \)</span>.</p>

<p>בואו נניח שהצבנו 1 ב-<span>\( x \)</span>; עבור הצבה של 0 ההמשך דומה. מה שיקרה עכשיו הוא שכל פסוקית שבה <span>\( x \)</span> הופיע תוסר מ-<span>\( \varphi \)</span>, ואילו כל פסוקית שבה <span>\( \neg x \)</span> הופיע תיוותר עם ליטרל יחיד, שנהיה חייבים להציב בו 1. ואז אולי נקבל פסוקיות יחידה נוספות שגם בליטרלים שלהן נצטרך להציב 1, וכן הלאה. בקיצור, יש לנו פעפוע כמו קודם. האבחנה היא שאם <span>\( ,l \)</span> הוא ליטרל כלשהו שקיבל 1 כחלק מהפעפוע, אז <span>\( x\to l \)</span> ניתן להסקה מתוך אוסף הגרירות שהפסוק מגדיר.</p>

<p>תהליך הפעפוע יכול להסתיים בשתי דרכים שונות: או שניוותר לבסוף בלי פסוקיות יחידה, ואז נוכל לבחור משתנה חדש ולהציב בו ערך (אם עוד יש כזה שטרם הצבנו בו ערך), או שנגיע לפסוקית ריקה ולסתירה. אני רוצה לשכנע אתכם שאי אפשר להגיע לפסוקית ריקה. כדי להגיע לפסוקית ריקה, צריכים להיות שני ליטרלים <span>\( l_{1},l_{2} \)</span> כך ש-<span>\( \left(l_{1}\vee l_{2}\right) \)</span> היא פסוקית של <span>\( \varphi \)</span>, ובנוסף לכך <span>\( x\to\neg l_{1} \)</span> ו-<span>\( x\to\neg l_{2} \)</span>.</p>

<p>עכשיו, שימו לב לתעלול הבא: אם <span>\( \left(l_{1}\vee l_{2}\right) \)</span> היא פסוקית של <span>\( \varphi \)</span>, אז למאגר הגרירות שלנו אפשר להוסיף את <span>\( \neg l_{1}\to l_{2} \)</span>. כעת, מכיוון ש-<span>\( x\to\neg l_{1} \)</span> נקבל <span>\( x\to l_{2} \)</span>. שקול לוגי של הפסוק הזה הוא <span>\( \neg l_{2}\to\neg x \)</span> (בדקו זאת!) ומכיוון ש-<span>\( x\to\neg l_{2} \)</span> נסיק <span>\( x\to\neg x \)</span>, אבל הנחנו שזה לא קורה - סתירה! לכן תהליך הפעפוע לא יכול להיגמר עם פסוקית ריקה, וההצלחה של האלגוריתם מובטחת.</p>

<p>עד כאן התיאוריה, אבל איך מבצעים את האלגוריתם בפועל? ובכן, צריך למצוא משתנה <span>\( x \)</span> שאינו גוזר את <span>\( \neg x \)</span>, צריך להציב בו ובכל מה שנגזר ממנו 1, ולוודא שלא נגרמו בעיות בשל כך. הדרך הנוחה לחשוב על זה (וגם לממש בפועל) היא בתור אלגוריתם שפועל על <strong>גרף מכוון</strong>. הצמתים של הגרף יהיו הליטרלים של הפסוק שלנו, כלומר כל צומת הוא מהצורה <span>\( x \)</span> או מהצורה <span>\( \neg x \)</span> עבור משתנה <span>\( x \)</span> כלשהו, והקשתות מייצגות גרירה: אם <span>\( \left(l_{1}\vee l_{2}\right) \)</span> היא פסוקית ב-<span>\( \varphi \)</span>, אז מוסיפים לגרף את הקשתות <span>\( \neg l_{1}\to l_{2} \)</span> ו-<span>\( \neg l_{2}\to l_{1} \)</span>. כעת יש לנו פירוש פשוט לכך שליטרל אחד נגרר על ידי אחר: נסתכל על צומת <span>\( l \)</span> ואז נסתכל על כל צומת ש<strong>ישיג</strong> ממנו, כלומר שיש מסלול מכוון ממנו אליו. כל הצמתים הללו מייצגים ליטרלים שנובעים מ-<span>\( l \)</span>.</p>

<p>כעת האלגוריתם ברור: בוחרים משתנה <span>\( x \)</span> באופן שרירותי, ומריצים עליו אלגוריתם DFS, שמוצא את כל הצמתים הישיגים ממנו. אם <span>\( \neg x \)</span> הוא לא בין הצמתים שהיו ישיגים מ-<span>\( x \)</span>, אז מציבים 1 ב-<span>\( x \)</span> ובכל ליטרל אחר שצץ במהלך ה-DFS. לא ייתכן שנצטרך להציב 1 גם בליטרל וגם בשלילתו, כי כפי שכבר ראינו, זה היה גורם לכך שמ-<span>\( x \)</span> כן אפשר יהיה להגיע אל <span>\( \neg x \)</span>.</p>

<p>אם כן ראינו שאפשר להגיע אל <span>\( \neg x \)</span> מתוך <span>\( x \)</span>, אז נריץ DFS חדש מ-<span>\( \neg x \)</span> ונפעל באותו האופן כמו קודם. אם הגענו אל <span>\( x \)</span> במהלך ה-DFS אפשר לסיים - זו הוכחה שהפסוק לא ספיק (וקל לזקק ממנה הוכחת רזולוציה אמיתית).</p>

<p>אחרי שסיימנו לעשות כל מה שאפשר עם <span>\( x \)</span>, אם יש משתנים שטרם הצבנו בהם ערכים בוחרים אחד מהם - נאמר, <span>\( y \)</span> - וחוזרים על הסיפור יחד איתו. על פניו יכולה לצוץ בעיה חדשה: אולי יש איזה שהוא משתנה <span>\( z \)</span> שכבר הצבנו בו ערך בשלב של הטיפול ב-<span>\( x \)</span> - נניח שהצבנו בו 1, אבל גם עבור 0 זה אותו עקרון - אבל עכשיו בשלב הטיפול ב-<span>\( y \)</span> נצטרך להציב בו 0? זה יקרה אם נגלה ש-<span>\( \neg z \)</span> ישיג מ-<span>\( y \)</span> ולכן נרצה להציב 1 ב-<span>\( \neg z \)</span>, מה שמכריח אותנו להציב 0 ב-<span>\( z \)</span>.</p>

<p>ובכן, התשובה לכך פשוטה מאוד: אם <span>\( \neg z \)</span> ישיג מ-<span>\( y \)</span>, אז זה אומר ש-<span>\( \neg y \)</span> ישיג מ-<span>\( z \)</span> (למה?) ולכן אם <span>\( \neg z \)</span> היה ישיג מ-<span>\( x \)</span>, אז <span>\( \neg y \)</span> היה ישיג מ-<span>\( x \)</span>, מה שאומר שכבר בשלב הקודם של <span>\( x \)</span> היינו אמורים להציב ערך ב-<span>\( y \)</span> ולא ייתכן שהוא שרד עד לשלב הזה. זה מסיים עם החששות שלנו; מי שעדיין מודאג מוזמן להוכיח פורמלית לעצמו שזה עובד.</p>

<p>אם כן, ראינו אלגוריתמים שעובדים טוב מאוד על מקרים פרטיים של SAT. מה עושים במקרה הכללי? על כך נדבר בפוסט הבא.</p>

  </div>

  <hr />
  <p>
    נהניתם? התעניינתם? אם תרצו, אתם מוזמנים לתת טיפ:
  </p>
  <a href='https://ko-fi.com/H2H5XFBQ' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://az743702.vo.msecnd.net/cdn/kofi2.png?v=2' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a><div class="PageNavigation">
    
      <a class="prev" href="/2013/11/14/resolution_proof_system/">&laquo; רזולוציה - איך אפשר להוכיח שאי אפשר?</a>
    
    
      <a class="next" href="/2013/12/11/dpll_algorithm/">פותרים את SAT - אלגוריתם DPLL &raquo;</a>
    
  </div><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://gadial.net/2013/11/24/hornsat_and_2sat/';
      this.page.identifier = 'http://gadial.net/2013/11/24/hornsat_and_2sat/';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://not-precise.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/2013/11/24/hornsat_and_2sat/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">לא מדויק</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">לא מדויק</li><li><a class="u-email" href="mailto:gadial@gmail.com">gadial@gmail.com</a></li><li>&copy; כל הזכויות שמורות לגדי אלכסנדרוביץ'</li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/%D7%9C%D7%90-%D7%9E%D7%93%D7%95%D7%99%D7%A7-163347110378474"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">לא מדויק</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>RSS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>בלוג על מתמטיקה ומדעי המחשב</p>
      </div>
    </div>

  </div>

</footer><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script>

<!-- Default Statcounter code for New blog
http://www.gadial.net/ -->
<script type="text/javascript">
  var sc_project=5444342; 
  var sc_invisible=1; 
  var sc_security="4a89cbe4"; 
  </script>
  <script type="text/javascript"
  src="https://www.statcounter.com/counter/counter.js"
  async></script>
  <noscript><div class="statcounter"><a title="Web Analytics"
  href="https://statcounter.com/" target="_blank"><img
  class="statcounter"
  src="https://c.statcounter.com/5444342/0/4a89cbe4/1/"
  alt="Web Analytics"></a></div></noscript>
  <!-- End of Statcounter Code --></body>

</html>
