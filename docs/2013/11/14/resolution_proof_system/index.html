<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>רזולוציה - איך אפשר להוכיח שאי אפשר? - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2013/11/11/sat_intro/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">מה זו בעיית SAT ולמה חשוב לפתור אותה?</span>
            </a>
            

            
            <a href="/2013/11/24/hornsat_and_2sat/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">פותרים את SAT: המקרים של HORNSAT ו-2SAT</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>רזולוציה - איך אפשר להוכיח שאי אפשר?</h1>
            <div class="post-meta">
                <span class="date">2013-11-14</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                    <a href="/categories/מבני נתונים ואלגוריתמים.html">מבני נתונים ואלגוריתמים</a>
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/SAT.html">SAT</a>
                    
                    <a href="/tags/מערכות הוכחה.html">מערכות הוכחה</a>
                    
                    <a href="/tags/רזולוציה.html">רזולוציה</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>ב<a href="http://www.gadial.net/2013/11/11/sat_intro/">פוסט הקודם</a> תיארתי את בעיית SAT וסיימתי בכך שהבטחתי להסביר איך אפשר להשתכנע בכך שפסוק CNF <strong>אינו</strong> ספיק, מבלי שיהיה צורך לבדוק את כל ההשמות האפשריות עבורו. בפוסט הזה אציג את השיטה הנפוצה ביותר לשימוש כדי להוכיח זאת - <strong>רזולוציה</strong>. מובטח לנו שאם <span class="math">\(\varphi\)</span> הוא פסוק CNF לא ספיק, אז קיימת הוכחה לכך המבוססת על רזולוציה. זה עדיין לא מבטיח שיהיה קל למצוא את ההוכחה הזו, או שההוכחה תהיה קצרה (על חשיבות ה<strong>אורך</strong> של ההוכחה אדבר בהמשך), אבל זה יהיה לרוב שיפור אל מול בדיקת כל ההשמות האפשריות, ובעולם האמיתי יש להוכחות כאלו שימושים רבים.</p>
<p>מהי רזולוציה? פשוט מאוד - זה כלל שבו משתי פסוקיות CNF מסיקים פסוקית חדשה. הכלל אומר כך: אם יש לי פסוקית <span class="math">\(C\)</span> שבה מופיע משתנה <span class="math">\(x\)</span>, ויש לי פסוקית <span class="math">\(D\)</span> שבה מופיע אותו המשתנה, אבל בשלילה - כלומר, היא כוללת את הליטרל <span class="math">\(\neg x\)</span>, אז אפשר לבנות משתי הפסוקיות הללו פסוקית חדשה (שלפעמים מסמנים <span class="math">\(C\otimes D\)</span>) שכוללת את כל הליטרלים ב-<span class="math">\(C\)</span> פרט ל-<span class="math">\(x\)</span> וכל הליטרלים ב-<span class="math">\(D\)</span> פרט ל-<span class="math">\(\neg x\)</span>.</p>
<p>כלומר, פורמלית, אם <span class="math">\(C=\left(x\vee l_{1}^{c}\vee\dots\vee l_{k}^{c}\right)\)</span> ו-<span class="math">\(D=\left(\neg x\vee l_{1}^{d}\vee\dots\vee l_{t}^{d}\right)\)</span> אז <span class="math">\(C\otimes D=\left(l_{1}^{c}\vee\dots\vee l_{k}^{c}\vee l_{1}^{d}\vee\dots\vee l_{t}^{d}\right)\)</span>.</p>
<p>חדי העין שביניכם אולי יתריעו כעת שהסימון בעייתי כי הוא לא מבהיר מה המשתנה שעל פיו עושים רזולוציה - אולי יש יותר ממשתנה אחד שמופיע בפסוק אחד ושלילתו מופיעה בשני? ובכן, אנחנו מניחים תמיד שברור מההקשר מה המשתנה הרלוונטי, אבל כשאהיה ממש ממש פורמלי אכתוב <span class="math">\(C\otimes_{x}D\)</span> כדי שלא יהיה מקום לספק.</p>
<p>מה ההגיון מאחורי הכלל הזה? הרעיון הוא שכל השמה שמספקת בו זמנית גם את <span class="math">\(C\)</span> וגם את <span class="math">\(D\)</span> חייבת לספק גם את <span class="math">\(C\otimes D\)</span>. מדוע? ובכן, נניח לרגע שההשמה הזו נותנת 1 ל-<span class="math">\(x\)</span>, אז היא אוטומטית מספקת את <span class="math">\(C\)</span>, אבל מה עם <span class="math">\(D\)</span>? ל-<span class="math">\(\neg x\)</span> ההשמה תיתן 0, ולכן כדי לספק את <span class="math">\(D\)</span> חייבים לספק אחד מבין הליטרלים של <span class="math">\(D\)</span>. אותו ליטרל מופיע גם ב-<span class="math">\(C\otimes D\)</span> ולכן ההשמה מספקת את <span class="math">\(C\otimes D\)</span>. באופן דומה, אם ההשמה נתנה 0 ל-<span class="math">\(x\)</span> אז כדי שהיא תספק את <span class="math">\(C\)</span> היא הייתה חייבת לספק את אחד מהליטרלים האחרים של <span class="math">\(C\)</span>, שמופיע ב-<span class="math">\(C\otimes D\)</span>. כפי שאתם רואים, אין שום רעיון גאוני כאן - זו אבחנה בסיסית למדי. זה מה שהופך את העובדה שבעצם די בפעולה הפשוטה הזו כדי להוכיח שפסוק הוא לא ספיק למעניינת.</p>
<p>איך מתנהלת "הוכחה" כזו? פשוט מאוד - מייצרים בעזרת רזולוציה עוד ועוד פסוקיות (תוך הפעלת רזולוציה על הפסוקיות שכבר יש לנו - בהתחלה אלו רק הפסוקיות של <span class="math">\(\varphi\)</span>). אם מתישהו קיבלנו את הפסוקית הריקה, זה מוכיח שהפסוק המקורי היה לא ספיק. למה? כי כל השמה שסיפקה את <span class="math">\(\varphi\)</span> מספקת גם את כל מה שאפשר לגזור מ-<span class="math">\(\varphi\)</span> על ידי רזולוציה (זה בדיוק מה שהוכחנו), אבל אי אפשר לספק את הפסוקית הריקה.</p>
<p>האמירה האחרונה אולי עשויה להישמע לכם חשודה, ובצדק - הטענה ש"אי אפשר לספק את הפסוקית הריקה" נשמעת קצת שרירותית. אם כן, חשבו לרגע איך רזולוציה יכולה בכלל ליצור את הפסוקית הריקה מלכתחילה: בהכרח אנחנו חייבים להפעיל אותה על שתי פסוקיות מהצורה <span class="math">\(C=\left(x\right)\)</span> ו-<span class="math">\(D=\left(\neg x\right)\)</span>, כלומר פסוקיות שכוללות כל אחת רק ליטרל יחיד, שהוא של משתנה כלשהו באחת מהן, ושלילתו בשני. בבירור אף השמה אינה יכולה לספק את שתי הפסוקיות הללו בו זמנית, ולכן כבר כאן ברור ש"אי אפשר לספק את <span class="math">\(\varphi\)</span>" (אם <span class="math">\(C,D\)</span> נגזרו מ-<span class="math">\(\varphi\)</span> על ידי רזולוציה). מכאן שהגיוני להגדיר את הפסוקית הריקה ככזו שאינה מסתפקת לאף השמה. עוד דרך לחשוב על זה היא זו: פסוקית מסתפקת על ידי השמה כלשהי אם <strong>קיים</strong> משתנה כלשהו שמקבל 1 תחת ההשמה הזו. אם אין משתנים בפסוקית, אז לא יכול להיות קיים משתנה כזה.</p>
<p>עכשיו, הבנו את הרעיון הכללי, אבל אני רוצה לקשר אותו לדברים שכבר ראינו בעבר בבלוג בכל הנוגע ללוגיקה. בעבר <a href="http://www.gadial.net/2012/04/04/propositional_caclulus_proofs/">הצגתי בבלוג</a> מערכת הוכחה לתחשיב הפסוקים - בואו נחזור שניה על מה היא כללה. היו בה <strong>אקסיומות</strong>, שהן פסוקים שמהווים טאוטולוגיות (כלומר, שמסתפקים עבור כל השמה) - היו אינסוף אקסיומות שכאלו, אבל הן היו שייכות לשלוש תבניות אפשריות. כמו כן היה לנו <strong>כלל היסק</strong> יחיד - מודוס פוננס. הוכחה במערכת הזו הייתה סדרה של פסוקים, כך שכל פסוק הוא אקסיומה או נובע מפסוקים קודמים בהוכחה באמצעות הפעלת מודוס פוננס. מערכת ההוכחה הזו הייתה עקבית ושלמה, במובן זה שניתן היה להוכיח מתוכה <strong>רק</strong> טאוטולוגיות (עקביות), ואת <strong>כל </strong>הטאוטולוגיות (שלמות). אחר כך ראינו שאפשר להשתמש במערכת ההוכחה גם למשהו יותר מורכב - אם יש לנו קבוצה <span class="math">\(\Phi\)</span>של פסוקים, אפשר לחשוב עליהן בתור <strong>הנחות</strong> - משהו שאנחנו מצרפים זמנית לקבוצת האקסיומות שלנו - ועם קבוצת האקסיומות ה"משודרגת" הזו כל הפסוקים שיכלנו להוכיח הם בדיוק כל הפסוקים ש<strong>נובעים לוגית</strong> מ-<span class="math">\(\Phi\)</span> (<span class="math">\(\varphi\)</span> נובע לוגית מ-<span class="math">\(\Phi\)</span> אם כל השמה שמספקת את כל הפסוקים ב-<span class="math">\(\Phi\)</span> בו זמנית מספקת גם את <span class="math">\(\varphi\)</span>). מערכת הוכחה מסוג זה - עם אקסיומות, הנחות וכללי היסק - נקראת לפעמים <strong>מערכת הוכחה מסוג הילברט</strong>.</p>
<p>ההוכחה שמערכת ההוכחה שהצגתי היא אכן שלמה ונאותה הייתה די מורכבת, כך שלא סביר לצפות שרזולוציה תיתן לנו מערכת הוכחה חזקה באותה מידה בלי שנצטרך לעבוד די קשה לשם כך, אבל המטרות שלי בפוסט הזה הן צנועות יותר. הרעיון הוא כזה: מתחילים עם פסוק CNF <span class="math">\(\varphi\)</span>, שעליו חושבים בתור קבוצה של פסוקיות שהיא קבוצת ה"הנחות" שלנו. אחר כך בונים הוכחה שהיא סדרה של פסוקים שכל אחד מהם הוא פסוקית CNF שהיא הנחה או נובעת מקודמותיה על ידי רזולוציה. כלומר, גם פה יש לנו מערכת הוכחה מסוג הילברט, אבל ויתרנו על דרישת השלמות של המערכת ה"כללית" - יהיה די קל למצוא פסוקים שנובעים לוגית מ-<span class="math">\(\varphi\)</span> אבל לא יכיחים ממנה במערכת. עם זאת, נאותות עדיין תתקיים - כל פסוק שמתקבל במערכת אכן ינבע לוגית מ-<span class="math">\(\varphi\)</span>, ותתקיים תכונת שלמות <strong>מוחלשת</strong>, שמספיקה לצרכינו: אם <span class="math">\(\varphi\)</span> אינה ספיקה, אז <span class="math">\(\varphi\vdash\text{F}\)</span> כאשר <span class="math">\(\text{F}\)</span> הוא הסימון שלי לפסוקית הריקה שאינה כוללת ליטרלים. במילים פשוטות, <strong>אם <span class="math">\(\varphi\)</span> לא ספיק המערכת תוכל להוכיח זאת</strong>, על ידי גזירה של הפסוקית הריקה. לכן אולי יותר נכון לחשוב על רזולוציה בתור "מערכת הפרכה" ולא מערכת הוכחה.</p>
<p>הבה ונוכיח את הטענה הזו. ההוכחה די קלה מבחינה רעיונית אבל הפרטים הטכניים יכולים להקשות על ההבנה שלה, אז בואו נתחיל מהרעיון. זוכרים איך במטריקס אמרו "Guns, lots of guns''? אז כאן זה "רזולוציה, הרבה רזולוציה". הרעיון הוא לעשות כמה רזולוציה שרק אפשר ובסוף <span class="math">\(\text{F}\)</span> יהיה חייב לצוץ.</p>
<p>אה... לא משכנע במיוחד, נכון? אז הנה הטריק: אם תשימו לב, מה שרזולוציה עושה ל-<span class="math">\(C,D\)</span> כשהיא יוצרת מהם את <span class="math">\(C\otimes D\)</span> הוא <strong>לסלק את המשתנה</strong> <span class="math">\(x\)</span> מתוכם. הדרך היחידה שבה ב-<span class="math">\(C\otimes D\)</span> יופיע המשתנה <span class="math">\(x\)</span> היא שב-<span class="math">\(C\)</span> או ב-<span class="math">\(D\)</span> יופיעו גם <span class="math">\(x\)</span> וגם <span class="math">\(\neg x\)</span>, אבל זה אומר שהפסוקית שבה זה קורה היא ממילא חסרת ערך עבורנו - היא טאטולוגיה, כלומר מסתפקת על ידי כל השמה, ולכן לא תעזור לנו <strong>להגביל</strong> את כמות ההשמות שאולי יש להן פוטנציאל לספק את <span class="math">\(\varphi\)</span>.</p>
<p>אז הרעיון הוא כזה: קודם כל ניקח את כל הפסוקיות ב-<span class="math">\(\varphi\)</span> (פרט לטאוטולוגיות שנזרקות לפח) ונבצע כמה שיותר רזולוציות שרק אפשר ביחס למשתנה כלשהו, נאמר <span class="math">\(x_{1}\)</span>. אחר כך נזרוק לפח את כל הפסוקיות שבהן הופיע <span class="math">\(x_{1}\)</span>, וניוותר עם אוסף פסוקיות CNF שבהן המשתנה <span class="math">\(x_{1}\)</span> פשוט לא מופיע. באופן הזה נמשיך גם למשתנה הבא, ולזה שאחריו, וכן הלאה - בדרך הזו נחסל את כל המשתנים. בשלב האחרון יוכל לקרות אחד משני דברים: או שנסיים עם הפסוקית הריקה ביד ואז נדע ש-<span class="math">\(\varphi\)</span> הוא לא ספיק; או שנסיים בלי פסוקיות כלל (כי נקבל טאוטולוגיות שנזרוק לפח) ואז <span class="math">\(\varphi\)</span> ספיק.</p>
<p>זה אולי נשמע נחמד ברמת נפנופי הידיים, אבל אני בהחלט מבין את מי שזה עדיין נראה לו חשוד. אז בואו נעבור לפורמליסטיקה. אני הולך לחשוב על כל פסוק CNF בתור קבוצה של פסוקיות. נניח ש-<span class="math">\(\varphi\)</span> המקורי מכיל את המשתנים <span class="math">\(x_{1},\dots,x_{n}\)</span>, אז אני הולך להגדיר סדרה של פסוקי CNF <span class="math">\(\varphi_{0},\varphi_{1},\varphi_{2},\dots,\varphi_{n}\)</span> כך ש-<span class="math">\(\varphi_{0}=\varphi\)</span> ובאופן כללי <span class="math">\(\varphi_{k}\)</span> מכיל רק את המשתנים עם אינדקס גדול מ-<span class="math">\(k\)</span> (<span class="math">\(x_{k+1},\dots,x_{n}\)</span>) ולכן בפרט <span class="math">\(\varphi_{n}\)</span> לא יכול להכיל משתנים בכלל ומכאן שהוא או פסוק שמכיל פסוקית אחת, ריקה, ולכן אינו ספיק, או שהוא פסוק שאינו מכיל פסוקיות כלל, ולכן הוא טאוטולוגיה.</p>
<p>כדי להגדיר את <span class="math">\(\varphi_{k+1}\)</span> מתוך <span class="math">\(\varphi_{k}\)</span> אני הולך לחלק את הפסוקיות של <span class="math">\(\varphi_{k}\)</span> לארבע קבוצות זרות ומשלימות: פסוקיות שבהן מופיעים גם <span class="math">\(x_{k}\)</span> וגם <span class="math">\(\neg x_{k}\)</span>, כלומר הן טאוטולוגיות ואני הולך להתעלם מהן; פסוקיות שבהן לא <span class="math">\(x_{k}\)</span> ולא <span class="math">\(\neg x_{k}\)</span> מופיעים ואני הולך להעביר אותן כמות שהן ל-<span class="math">\(\varphi_{k+1}\)</span> ; פסוקיות שבהן <span class="math">\(x_{k}\)</span> מופיע אבל לא <span class="math">\(\neg x_{k}\)</span>, ופסוקיות שבהן <span class="math">\(\neg x_{k}\)</span> מופיע אבל לא <span class="math">\(x_{k}\)</span>. בבירור אלו כל המקרים האפשריים. אז בואו נגדיר: <span class="math">\(\varphi_{k}=T_{k}\cup N_{k}\cup A_{k}\cup B_{k}\)</span> כך ש-</p>
<p><span class="math">\(T_{k}=\left\{ C\in\varphi_{k}\ |\ x_{k}\in C\wedge\neg x_{k}\in C\right\} \)</span></p>
<p><span class="math">\(N_{k}=\left\{ C\in\varphi_{k}\ |\ x_{k}\notin C\wedge\neg x_{k}\notin C\right\} \)</span></p>
<p><span class="math">\(A_{k}=\left\{ C\in\varphi_{k}\ |\ x_{k}\in C\wedge\neg x_{k}\notin C\right\} \)</span></p>
<p><span class="math">\(B_{k}=\left\{ C\in\varphi_{k}\ |\ x_{k}\notin C\wedge\neg x_{k}\in C\right\} \)</span></p>
<p>עכשיו נגדיר את <span class="math">\(A_{k}\otimes B_{k}\)</span> בתור "מה שמקבלים כשעושים את כל הרזולוציות שרק אפשר עם <span class="math">\(A_{k},B_{k}\)</span>":</p>
<p><span class="math">\(A_{k}\otimes B_{k}=\left\{ C\otimes_{x_{k}}D\ |\ C\in A_{k},D\in B_{k}\right\} \)</span></p>
<p>ועכשיו נגדיר:</p>
<p><span class="math">\(\varphi_{k+1}=N_{k}\cup A_{k}\otimes B_{k}\)</span></p>
<p>כלומר, זרקנו לפח את כל הפסוקיות שהיו טאוטולוגיות ב-<span class="math">\(\varphi_{k}\)</span>, זרקנו לפח את כל הפסוקיות שהכילו את <span class="math">\(x_{k}\)</span> בצורה זו או אחרת, ובתור פיצוי הכנסנו פנימה את התוצר של כל הרזולוציות של פסוקיות ב-<span class="math">\(A_{k},B_{k}\)</span>. מצד אחד, <span class="math">\(\varphi_{k+1}\)</span> יכול להיות הרבה יותר מסובך מ-<span class="math">\(\varphi_{k}\)</span> במובן זה שהוא יכיל הרבה יותר פסוקיות; מצד שני, הוא יו תר פשוט מ-<span class="math">\(\varphi_{k}\)</span> במובן זה שהפסוקיות שלו כוללות משתנה אחד פחות - לא כוללות את <span class="math">\(x_{k}\)</span>.</p>
<p>עכשיו, בגלל הנאותות של רזולוציה, כל השמה שמספקת את <span class="math">\(\varphi\)</span> מספקת כל אחד מה-<span class="math">\(\varphi_{k}\)</span>-ים. לכן בפרט ברור שאם <span class="math">\(\varphi_{n}\)</span> כולל את הפסוקית הריקה (שאין אף השמה שמספקת אותה) הרי ש-<span class="math">\(\varphi\)</span>לא ספיק. אנחנו רוצים להוכיח גם את הכיוון השני: שאם <span class="math">\(\varphi\)</span> לא ספיק אז <span class="math">\(\varphi_{n}\)</span> יכיל את הפסוקית הריקה. נוכיח את זה על ידי הוכחה של טענה שקולה לוגית: שאם <span class="math">\(\varphi_{n}\)</span> לא מכיל את הפסוקית הריקה אז <span class="math">\(\varphi\)</span> ספיק. ואת זה נוכיח במעין אינדוקציה הפוכה: נתחיל עם השמה שמספקת את <span class="math">\(\varphi_{n}\)</span> ואז נוכיח שבאופן כללי אם יש לנו השמה שמספקת את <span class="math">\(\varphi_{k}\)</span> אז אפשר לקבל ממנה השמה שמספקת את <span class="math">\(\varphi_{k-1}\)</span>. וכך נמשיך עד <span class="math">\(\varphi_{0}\)</span> שהוא <span class="math">\(\varphi\)</span> המקורי.</p>
<p>איזו השמה מספקת את <span class="math">\(\varphi_{n}\)</span> שאין בו בכלל משתנים? ובכן, לא תאהבו את זה אבל ההשמה הריקה - השמה שלא נותנת ערך לאף משתנה. אם זה מפריע לכם, אפשר לתקן את הניסוח ל"כל השמה למשתנים <span class="math">\(x_{1},\dots,x_{n}\)</span> מספקת את <span class="math">\(\varphi_{n}\)</span>" וזה תקין באותה המידה, אבל אני מעדיף מבחינה רעיונית לדבר על השמה ריקה. עכשיו, בואו נניח שיש לנו השמה <span class="math">\(\tau\)</span> שמספקת את <span class="math">\(\varphi_{k}\)</span> ומוגדרת רק עבור המשתנים <span class="math">\(x_{k+1},\dots,x_{n}\)</span> (או לחילופין, לא משנה איך נגדיר אותה עבור <span class="math">\(x_{1},\dots,x_{k}\)</span>, עדיין נקבל שהיא מספקת את <span class="math">\(\varphi_{k}\)</span>). עכשיו השאלה שעומדת בפנינו היא זו: איך נקבל מתוך <span class="math">\(\tau\)</span> השמה שמספקת את <span class="math">\(\varphi_{k-1}\)</span>?</p>
<p>יש בסך הכל שתי השמות שנראות כמו מועמדות מתאימות לספק את <span class="math">\(\varphi_{k-1}\)</span> - אקרא להן <span class="math">\(\tau_{0},\tau_{1}\)</span>. הן זהות ל-<span class="math">\(\tau\)</span> על המשתנים <span class="math">\(x_{k+1},\dots,x_{n}\)</span> שעליהם <span class="math">\(\tau\)</span> מוגדרת, ונבדלים בהגדרתם על <span class="math">\(x_{k}\)</span>: <span class="math">\(\tau_{0}\left(x_{k}\right)=0\)</span> ו-<span class="math">\(\tau_{1}\left(x_{k}\right)=1\)</span>. עכשיו אני רוצה לטעון שלפחות אחת מההשמות הללו מספקת את <span class="math">\(\varphi_{k-1}\)</span> - לשם כך אני אניח בשלילה שאף אחת מהן לא מספקת את <span class="math">\(\varphi_{k-1}\)</span> ואסיק מכך שלא ייתכן ש-<span class="math">\(\tau\)</span> סיפקה את <span class="math">\(\varphi_{k}\)</span>.</p>
<p>מה זה אומר ש-<span class="math">\(\tau_{0}\)</span> אינה מספקת את <span class="math">\(\varphi_{k-1}\)</span>? זה אומר שקיימת פסוקית <span class="math">\(C\in\varphi_{k-1}\)</span> שאותה <span class="math">\(\tau_{0}\)</span> אינה מספקת, כלומר לא קיים ליטרל ב-<span class="math">\(C\)</span> ש-<span class="math">\(\tau_{0}\)</span> נותנת לו 1. עכשיו, לא ייתכן ש-<span class="math">\(C\in T_{k-1}\)</span> כי ב-<span class="math">\(T_{k-1}\)</span> היו רק טאוטולוגיות שמסתפקות על ידי כל השמה. כמו כן, אם <span class="math">\(C\in N_{k-1}\)</span> אז על פי הגדה, <span class="math">\(C\in\varphi_{k}\)</span> ו-<span class="math">\(C\)</span> לא כוללת ליטרל עבור המשתנה <span class="math">\(x_{k}\)</span> ולכן <span class="math">\(\tau\)</span> נותנת ל-<span class="math">\(C\)</span> אותו ערך כמו <span class="math">\(\tau_{0}\)</span>, כלומר <span class="math">\(\tau\)</span> אינה מספקת את <span class="math">\(C\)</span> ולכן לא מספקת את <span class="math">\(\varphi_{k}\)</span>, כפי שרצינו. אז סיימנו גם עם המקרה הזה. לבסוף, האם ייתכן ש-<span class="math">\(C\in B_{k-1}\)</span>? שוב לא, כי אם <span class="math">\(C\in B_{k-1}\)</span> אז <span class="math">\(C\)</span> היא מהצורה <span class="math">\(C=\left(\neg x_{k}\vee l_{1}\vee\dots\vee l_{t}\right)\)</span> ולכן <span class="math">\(\tau_{0}\)</span> מספקת את הליטרל <span class="math">\(\neg x_{k}\)</span> של <span class="math">\(C\)</span>. מסקנה: בהכרח <span class="math">\(C\in A_{k-1}\)</span>.</p>
<p>בדיוק באותו האופן, מכך ש-<span class="math">\(\tau_{1}\)</span> אינה מספקת את <span class="math">\(\varphi_{k-1}\)</span> אנחנו מסיקים שקיימת פסוקית <span class="math">\(D\in B_{k-1}\)</span> שאינה מסתפקת על ידי <span class="math">\(\tau_{1}\)</span>. עכשיו מגיע הפאנץ': בואו נסתכל על <span class="math">\(C\otimes D\)</span>. זו פסוקית ששייכת ל-<span class="math">\(\varphi_{k}\)</span>, מה שאומר ש-<span class="math">\(\tau\)</span> מספקת אותה. אבל זה בלתי אפשרי: על כל המשתנים שאינם <span class="math">\(x_{k}\)</span>, ההשמה <span class="math">\(\tau\)</span> זהה להשמות <span class="math">\(\tau_{0},\tau_{1}\)</span>, וההשמות הללו נותנות 0 לכל הליטרלים ב-<span class="math">\(C,D\)</span> למעט <span class="math">\(x_{k},\neg x_{k}\)</span> שאינם מופיעים ב-<span class="math">\(C\otimes D\)</span>. הגענו לסתירה, והמסקנה היא שלפחות אחת מבין שתי ההשמות <span class="math">\(\tau_{0},\tau_{1}\)</span> מספקת את <span class="math">\(\varphi_{k-1}\)</span>, וזה משלים את האינדוקציה ואת ההוכחה כולה.</p>
<p>ההוכחה הזו היא מאוד תיאורטית. היא משכנעת אותנו שתמיד קיימת הוכחה, אבל הגישה שהיא נוקטת כדי למצוא את ההוכחה הזו היא מאוד ברוטלית - פשוט לעשות כל מה שאפשר בערך (אבל רק בערך; להקפדה על חיסול משתנים לפי הסדר יש חשיבות גדולה כאן). מכיוון שיש לנו <span class="math">\(n\)</span> שלבים בהוכחה שבכל אחד מהם מבצעים רזולוציה על שתי קבוצות, לא קשה להשתכנע שבמקרה הגרוע מספר הפסוקיות שלנו עלול לגדול בערך בצורה ריבועית בכל שלב, ולכן האלגוריתם כולו הוא אקספוננציאלי - גם מבחינת זמן הריצה שלו וגם מבחינת כמות הזכרון שהוא דורש. אשאיר לכם לבצע את החישובים המדוייקים אם זה מסקרן אתכם. השאלה המעניינת היא, אם כן, האם בהכרח <strong>קיימת</strong> הוכחה קצרה ברזולוציה תמיד? והאם אפשר למצוא אותה תמיד ביעילות?</p>
<p>מציאה של הוכחה קצרה בפרט גם דורשת שההוכחה עצמה תהיה קצרה, כך שהשאלה השניה היא חזקה יותר מהראשונה ופחות סביר שהתשובה לה תהיה חיובית: אם התשובה חיובית אז אפשר יהיה להכריע את בעיית SAT בזמן יעיל, מה שגורר ש-P=NP, וזו <a href="http://www.gadial.net/2010/08/15/p_vs_np_overview/">תוצאה מאוד לא סבירה</a>. מצד שני, אולי יש הוכחות קצרות אבל פשוט אי אפשר למצוא אותן בזמן יעיל? כאן כדי להשוות את זה לבעיה ה"משלימה" - בהינתן פסוק CNF ספיק, האם יש לכך הוכחה קצרה? כאן התשובה היא בוודאי חיובית: ההשמה שמספקת את הפסוק כוללת בסך הכל <span class="math">\(n\)</span> ביטים, אחד לכל משתנה. אז זו דוגמה לבעיה שבה יש הוכחה קצרה אבל כנראה (אם P שונה מ-NP) אין אלגוריתם יעיל שמוצא אותה.</p>
<p>ובכן, אם תמיד קיימות הוכחות קצרות לכך שפסוק CNF <strong>אינו</strong> ספיק, גם זה יגרור תשובה לא צפויה לבעיה פתוחה בסיבוכיות - השאלה האם NP=coNP. גם לשאלה הזו התשובה הצפויה היא שלילית (אם כי תמיד מעניין להזכיר כאן את <a href="http://www.gadial.net/2011/03/05/immerman_theorem/">משפט אימרמן</a> שמראה שעבור סיבוכיות <strong>זכרון</strong> התשובה היא דווקא חיובית). עבור רזולוציה יש גם בעיות שאפשר להוכיח שאין להן הוכחות קצרות - זה נושא בסיסי בתחום שנקרא Proof Complexity ואני מקווה להזכיר אותו בהמשך. באופן מעניין למדי, הפסוקים "הקשים ביותר" עבור רזולוציה (כאלו שעבורם ההוכחות הקצרות ביותר הקיימות הן הכי ארוכות) הם כאלו שמקודדים את <strong>בעיית שובך היונים</strong>, שלכאורה נשמעת כמו דבר פשוט. כאמור - נתעסק בזה בהמשך, אני מקווה.</p>
<p>אז באופן כללי אין לצפות למצוא הוכחות רזולוציה קצרות. אבל מה קורה בעולם האמיתי? מוצאים, ומשתמשים בהן. אלגוריתמים מודרניים לפתרון SAT לעתים קרובות מסוגלים ליצור הוכחת רזולוציה לאי-ספיקות הפסוק שהם בודקים; גם לזה אני מקווה שנגיע בהמשך.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>