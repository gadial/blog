<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מכסחי הכמתים - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/blog/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/blog/">דף הבית</a>
                <a href="/blog/random.html">פוסט אקראי</a>
                <a href="/blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/blog/2013/04/27/adjoint_unitary_hermitian_matrices/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">מטריצות צמודות, הרמיטיות, אוניטריות</span>
            </a>
            

            
            <a href="/blog/2013/05/13/modular_arithmetic/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">אז מה זה חשבון מודולרי?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מכסחי הכמתים</h1>
            <div class="post-meta">
                <span class="date">2013-05-06</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/חילוץ כמתים.html">חילוץ כמתים</a>
                    
                    <a href="/tags/לוגיקה מסדר ראשון.html">לוגיקה מסדר ראשון</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסטים שלי על לוגיקה הגעתי עד למשפטי השלמות והקומפקטיות של לוגיקה מסדר ראשון, וזה מביא אותנו אל הסף של מה שנקרא "תורת המודלים". הפעם אני רוצה לדבר על אחת מהטכניקות הבסיסיות שרואים כשמתחילים ללמוד את תורת המודלים - חילוץ כמתים. מכיוון שבאנגלית הטכניקה נקראת Quantifier Elimination ואני רוצה להשתעשע, אני אקרא לה כאן "חיסול כמתים".</p>
<p>מה זה? שניה לפני שאפציץ עם ההגדרות הפורמליות, אינטואיציה: הנוסחאות בלוגיקה מסדר ראשון נבנות מתוך כל מני רכיבים בסיסיים שמחוברים עם פעולות לוגיות כמו "וגם", "או", "שלילה", "גורר", וגם שני <strong>כמתים</strong> - "לכל" ו"קיים". הכמתים הללו אחראים לחלק לא מבוטל מהסיבוך שיש לתורות בלוגיקה מסדר ראשון. הנה דוגמה פשוטה, ואני מזהיר מראש שאני הולך לשקר בה קצת ולגלות איך שיקרתי רק בסוף: את הטענה "<span class="math">\(t\)</span> הוא פתרון של המשוואה <span class="math">\(ax^{2}+bx+c=0\)</span>" קל לבדוק אם נותנים לנו ליד את הערכים של <span class="math">\(t\)</span> ושל <span class="math">\(a,b,c\)</span>. לעומת זאת, הטענה "<strong>קיים</strong> <span class="math">\(t\)</span> שהוא פתרון של המשוואה <span class="math">\(ax^{2}+bx+c=0\)</span>" היא כבר טענה מורכבת משמעותית יותר, שמצריכה אותנו <strong>להבין</strong> את המשוואה הזו.</p>
<p>איך "מבינים" משוואה כזו? קודם כל צריך להבין מה בכלל ה<strong>הקשר</strong> של המשוואה. האם זו משוואה מעל המספרים הממשיים? מעל המרוכבים? מעל המספרים השלמים בלבד? מודולו 7? האם אנחנו ב-<span class="math">\(p\)</span>-אדיים? על הירח? במאדים? בואו נניח שאנחנו מדברים על המשוואה מעל <span class="math">\(\mathbb{R}\)</span>, כדי שיהיה מעניין. פורמלית, האופן שבו כותבים את הטענה הלוגית שטוענת שקיים פתרון למשוואה הוא פשוט הנוסחה<span class="math">\(\exists x\left(ax^{2}+bx+c=0\right)\)</span>, והשאלה שלנו היא אם ב<strong>מודל</strong> של המספרים הממשיים (שבו פעולות החיבור והכפל הן הפעולות ה"רגילות" על ממשיים) הפסוק הזה הוא בעל ערך אמת. ואיך יודעים דבר כזה? הרי ברור שאי אפשר לעבור על <strong>כל</strong> המספרים הממשיים ולנסות אחד אחד להציב אותם במשוואה, <a href="http://www.gadial.net/2010/11/08/hilberts_hotel/">יש הרבה יותר מדי</a> מהם.</p>
<p>ובכן, קרוב לודאי שרובכם זוכרים משהו על משוואות ריבועיות ויודעים שהתשובה לשאלה תלויה איכשהו בערכים של <span class="math">\(a,b,c\)</span>, שהם "משתנים חופשיים" של הפסוק. עבור הצבות מסויימות של ערכים למשתנים יהיה פתרון למשוואה, ועבור הצבות אחרות - לא. איך יודעים? ובכן, <a href="http://www.gadial.net/2008/01/26/solving_quadratic_equations/">נוסחת השורשים</a> מלמדת אותנו שפתרונות המשוואה <span class="math">\(ax^{2}+bx+c=0\)</span> הם <span class="math">\(\frac{-b\pm\sqrt{b^{2}-4ac}}{2a}\)</span>. הפתרונות הללו עשויים להיות מספרים מרוכבים ולא ממשיים טהורים; מתי זה עשוי לקרות אם <span class="math">\(a,b,c\)</span> הם ממשיים טהורים? ובכן, רק אם <span class="math">\(b^{2}-4ac&lt;0\)</span> ואז הוצאת השורש תחזיר מספר מרוכב (או, למקרה שלא שמעתם על מספרים מרוכבים, היא פשוט תהיה "פעולה לא חוקית" ולכן לא יהיה פתרון - ממשי - למשוואה). אם <span class="math">\(b^{2}-4ac\ge0\)</span> אז בודאות מוחלטת יש פתרון למשוואה (בגלל החשיבות של הביטוי <span class="math">\(b^{2}-4ac\)</span> יש לו שם וסימון מיוחדים: <strong>דיסקרימיננטה</strong>, והוא מסומן ב-<span class="math">\(\Delta\)</span>). זה אומר שהנוסחה <span class="math">\(\exists x\left(ax^{2}+bx+c=0\right)\)</span> שקולה לוגית לנוסחה <span class="math">\(b^{2}-4ac\ge0\)</span>. למה הכוונה ב"שקולה לוגית"? בחרו ערכים קונקרטיים עבור <span class="math">\(a,b,c\)</span>; מובטח לנו שלשתי הנוסחאות יהיה אותו ערך אמת עבור הערכים הללו.</p>
<p>מה ההבדל בין שתי הנוסחאות? ובכן, <span class="math">\(b^{2}-4ac\ge0\)</span> היא נוסחה פשוטה משמעותית יותר מ-<span class="math">\(\exists x\left(ax^{2}+bx+c=0\right)\)</span> כי אין בה כמתים - כדי לבדוק אם היא נכונה או לא, פשוט מבצעים חישוב קצר שכולל את <span class="math">\(a,b,c\)</span>, ואת זה אפשר לעשות חיש קל, בזמן שעבור <span class="math">\(\exists x\left(ax^{2}+bx+c=0\right)\)</span> לא הייתה לנו שום שיטה ישירה לדעת אם היא נכונה או לא. הצלחנו "לחסל" את הכמת שהופיע בנוסחה הזו ולהחליף אותה בנוסחה שקולה, פשוטה יותר, ובכך הפכנו בעייה שנראתה בלתי אפשרית מבחינה חישובית (לבדוק אם יש פתרון למשוואה) לבעיה טריוויאלית מבחינה חישובית. זה, על רגל אחת, כל הרעיון שמאחורי חיסול כמתים.</p>
<p>כמובן שמייד צצות כמה שאלות. הנוסחה <span class="math">\(b^{2}-4ac\ge0\)</span> בכלל לא נראית דומה לנוסחה <span class="math">\(\exists x\left(ax^{2}+bx+c=0\right)\)</span>, אז איך הגענו אליה? האם יש שיטה כללית לחיסול כמתים? האם תמיד אפשר לבצע חיסול כמתים? כמה זה מסובך? התשובה היא שחיסול כמתים הוא עניין <strong>קשה</strong>. לעתים קרובות צריך ידע נוסף כדי לבצע אותו עבור מקרים קונקרטיים, וברוב המקרים אי אפשר לבצע אותו <strong>בכלל</strong>. אבל לפעמים כן אפשר לעשות אותו באופן כללי מאוד - להראות שעבור תורה מסויימת קיים חילוץ כמתים עבור <strong>כל</strong> הנוסחאות (תכף אסביר מה זה בדיוק אומר - זו לא הגדרה טריוויאלית) וכשהפלא הזה קורה, קורים דברים מגניבים למדי. גולת הכותרת שאני חותר אליה (אבל לא אגיע אליה בפוסט הזה) היא ההוכחה ש<strong>אריתמטיקת פרסבורגר</strong> היא כריעה, וההוכחה עוברת דרך חילוץ כמתים. מה זו אריתמטיקת פרסבוגר? זו <strong>כמעט</strong> התורה שעליה חל משפט אי השלמות של גדל (שמוכיח שתורת המספרים <strong>אינה</strong> כריעה), רק בלי כפל. אסביר יותר כשאגיע לשם.</p>
<p>לפני שנעבור לפורמליזם, זמן להסביר איך שיקרתי לכם, ואני בטוח שחלקכם שמו לב לזה. נוסחת השורשים היא נכונה אך ורק כאשר <span class="math">\(a\ne0\)</span>. אם <span class="math">\(a=0\)</span> אז <span class="math">\(ax^{2}+bx+c=0\)</span> היא בכלל משוואה ממעלה ראשונה, והתנאי <span class="math">\(b^{2}-4ac\ge0\)</span> תמיד מתקיים למרות שייתכן שלמשוואה לא יהיה פתרון. מתי ייתכן שאין לה פתרון? ובכן, באופן כללי למשוואה <span class="math">\(bx+c=0\)</span> יש את הפתרון <span class="math">\(x=-\frac{c}{b}\)</span>, אז די בבירור יש לה פתרון תמיד, למעט המקרה שבו <span class="math">\(b=0\)</span> אבל <span class="math">\(c\ne0\)</span>. לכן הנוסחה השקולה האמיתית ל-<span class="math">\(\exists x\left(ax^{2}+bx+c=0\right)\)</span> היא לא <span class="math">\(b^{2}-4ac\ge0\)</span> אלא <span class="math">\(\left(a\ne0\wedge b^{2}-4ac\ge0\right)\vee\left(a=0\wedge\left(b\ne0\vee c=0\right)\right)\)</span>, שהיא יותר גדולה ומסורבלת (ולכן לא הצגתי אותה מייד אלא שיקרתי) אבל גם כן חסרת כמתים.</p>
<p>ועכשיו בואו נעבור להגדרות. כפי שהדוגמה שנתתי רומזת, כשמדברים על חילוץ כמתים תמיד עושים את זה ביחס ל<strong>תורה</strong> ספציפית. מה זו תורה? בואו נזכיר בקצרה. בלוגיקה מסדר ראשון תמיד יש לנו <strong>מילון</strong> שאנחנו עובדים ולפיו ואומר לנו מהם סימני היחסים, הפונקציות והקבועים שבהם אנחנו יכולים להשתמש. למשל, בדוגמה שלעיל, המילון כלל סימני פונקציה עבור חיבור וכפל (<span class="math">\(ax^{2}\)</span>, למשל, הוא קיצור של <span class="math">\(a\cdot x\cdot x\)</span>) וסימן יחס עבור <span class="math">\(\ge\)</span> (וגם עבור <span class="math">\(=\)</span> אבל אני נוהג להניח ש-<span class="math">\(=\)</span> מגיע עם כל תורה מסדר ראשון ומפורש תמיד כ"שווה"). בעזרת הסימונים של המילון והסימונים הלוגיים הסטנדרטיים (למשל <span class="math">\(\wedge\)</span> עבור "וגם", או סימונים עבור משתנים) אפשר לבנות נוסחאות. תורה <span class="math">\(T\)</span> היא בסך הכל אוסף של פסוקים, כש"פסוק" הוא נוסחה בלי משתנים חופשיים, ולכן משהו שעבור כל מבנה אפשרי יש לו ערך אמת או שקר. אה, מה זה מבנה? טוב, זו כבר חזרה די ארוכה... <a href="http://www.gadial.net/2012/06/17/first_order_logic/">יש לי פוסט</a> שמציג את הכל במסודר, ואפשר גם לקרוא בכל ספר לוגיקה סטנדרטי.</p>
<p>עכשיו, אם <span class="math">\(T\)</span> היא תורה ו-<span class="math">\(\varphi\left(\overline{x}\right)\)</span> היא נוסחה שאולי יש בה משתנים חופשיים (אני מסמן ב-<span class="math">\(\overline{x}\)</span> "וקטור של משתנים חופשיים"), אנחנו משתמשים בסימון <span class="math">\(T\models\varphi\left(\overline{x}\right)\)</span> ("<span class="math">\(\varphi\)</span> נובעת לוגית מ-<span class="math">\(T\)</span>") אם לכל מודל <span class="math">\(\mathcal{M}\)</span> שמספק את <span class="math">\(T\)</span>, וכל וקטור של איברים <span class="math">\(\overline{a}\)</span> שנלקחים מתוך <span class="math">\(D^{\mathcal{M}}\)</span>, <span class="math">\(\varphi\left(\overline{a}\right)\)</span> מסתפקת (מקבלת את הערך True). עד כאן, הכל ברור. זה מוביל אותנו להגדרה האולטרה-חשובה הבאה: שתי נוסחאות <span class="math">\(\varphi,\psi\)</span> הן שקולות <strong>מודולו התורה</strong> <span class="math">\(T\)</span>, אם <span class="math">\(T\models\varphi\leftrightarrow\psi\)</span>. כלומר, לכל מודל של <span class="math">\(T\)</span> וכל השמה מתוך המודל למשתנים של <span class="math">\(\varphi,\psi\)</span> (יכולים להיות להם משתנים משותפים וגם משתנים לא משותפים), או ששתי הנוסחאות מסתפקות, או ששתיהן אינן מסתפקות. חשוב מאוד להדגיש שזו אינה שקילות "אבסולוטית" אלא היא מאוד תלויה בתורה <span class="math">\(T\)</span>, שכן התורה היא מעין "מסננת" שקובעת אילו מודלים בכלל רלוונטיים לצורך השקילות של <span class="math">\(\varphi,\psi\)</span>. הנה דוגמה ממש מטופשת להבהרת הנקודה: הנוסחה <span class="math">\(\exists x\left(x^{2}=a\right)\)</span> שקולה לנוסחה <span class="math">\(a=a\)</span> (שהיא נוסחה שתמיד מקבלת את ערך האמת True) כאשר המודל הרלוונטי הוא המספרים המרוכבים עם הפרשנות ה"רגילה"; אבל במודל של המספרים הממשיים, הנוסחה אינה נכונה אם <span class="math">\(a\)</span> הוא שלילי. לכן המודל הוא קריטי כאן.</p>
<p>והנה הגענו להגדרה. לתורה <span class="math">\(T\)</span> יש חיסול כמתים אם לכל נוסחה <span class="math">\(\varphi\)</span> בשפה של התורה קיימת נוסחה <span class="math">\(\psi\)</span> שקולה מודולו <span class="math">\(T\)</span> שהיא חסרת כמתים. אפשר לחדד טיפה את ההגדרה הזו ולהגדיר אוסף של "נוסחאות בסיסיות" שהן עצמן יכולות להכיל כמתים, וחיסול כמתים פירושו יהיה שאפשר לקבל מ-<span class="math">\(\varphi\)</span> נוסחה שקולה שבנויה מתוך הנוסחאות הבסיסיות באמצעות פעולות בוליאניות בלבד (<span class="math">\(\wedge,\vee,\neg,\to,\leftrightarrow\)</span>) ובלי כמתים. לא נצטרך את זה בהמשך, אז מבחינתי "חסר כמתים" זה אכן חסר כמתים. לגמרי.</p>
<p>בואו נתחיל עם קצת עבודה טכנית. ראשית, הסימנים הלוגיים <span class="math">\(\wedge,\vee,\neg,\to,\leftrightarrow\)</span> הם נחמדים אבל רובם מיותרים: אפשר להסתפק ב-<span class="math">\(\wedge,\vee,\neg\)</span> בלבד, כי <span class="math">\(\alpha\to\beta\equiv\left(\neg\alpha\vee\beta\right)\)</span> ו-<span class="math">\(\alpha\leftrightarrow\beta\equiv\left(\alpha\to\beta\right)\wedge\left(\beta\to\alpha\right)\)</span> (למעשה, אפשר גם לוותר על אחד מבין <span class="math">\(\vee,\wedge\)</span> אבל אשתמש בשניהם בהמשך מטעמי נוחות). שנית, גם <span class="math">\(\forall\)</span> מיותר כי <span class="math">\(\forall x\alpha\left(x\right)\equiv\neg\exists x\neg\alpha\left(x\right)\)</span>. לכן מלכתחילה נתעניין בפועל רק בנוסחאות שמורכבות מ-<span class="math">\(\neg,\wedge,\vee,\exists\)</span> ורק עליהן נצטרך להוכיח דברים (מטעמי נוחות אני עדיין אשתמש בסימנים האחרים כשזה מקל עלי, מתוך הבנה שהם בסך הכל סימונים מקוצרים לנוסחאות לעיל).</p>
<p>עכשיו, בדוגמה שלמעלה עיקר האתגר היה לעבור מנוסחה עם כמת "קיים" יחיד לנוסחה בלי כמת כזה בכלל. מסתבר שזה גם האתגר באופן כללי - אם יודעים לטפל רק בכמת "קיים" אחד, אז יש חיסול כמתים. פורמלית, אשתמש במילה "ליטרל" כדי לתאר נוסחה אטומית (כזו שהיא יחס שמופעל על שמות עצם) או שלילה של נוסחה אטומית. אני טוען שאם עבור תורה <span class="math">\(T\)</span> ניתן להמיר כל נוסחה מהצורה <span class="math">\(\exists x\left(\alpha_{1}\wedge\dots\wedge\alpha_{n}\right)\)</span>, כאשר כל <span class="math">\(\alpha\)</span> הוא ליטרל, לנוסחה שקולה חסרת כמתים מודולו <span class="math">\(T\)</span>, אז ל-<span class="math">\(T\)</span> יש חיסול כמתים. ההוכחה של הטענה היא באינדוקציה על מבנה כל הנוסחאות, ובואו נעשה אותה כדי לקבל תחושה עד כמה זה פשוט:</p>
<p>ראשית, אם <span class="math">\(\alpha\)</span> היא נוסחה אטומית, אז אין בה כמתים, ולכן היא מהווה את חיסול הכמתים של עצמה (כמובן ש-<span class="math">\(T\models\alpha\leftrightarrow\alpha\)</span>).</p>
<p>עכשיו, אם <span class="math">\(\alpha=\neg\beta\)</span> כאשר ל-<span class="math">\(\beta\)</span> כבר יש חיסול כמתים, כלומר יש <span class="math">\(\beta^{\prime}\)</span> חסרת כמתים ששקולה ל-<span class="math">\(\beta^{\prime}\)</span>, אז <span class="math">\(\alpha^{\prime}=\neg\beta^{\prime}\)</span> היא נוסחה שקולה חסרת כמתים עבור <span class="math">\(\alpha\)</span>. בדומה, השקול של נוסחה מהצורה <span class="math">\(\alpha\wedge\beta\)</span> הוא הנוסחה <span class="math">\(\alpha^{\prime}\wedge\beta^{\prime}\)</span> כך ש-<span class="math">\(\alpha^{\prime}\)</span> ו-<span class="math">\(\beta^{\prime}\)</span> הם השקולים של <span class="math">\(\alpha,\beta\)</span>.</p>
<p>נשאר לנו לטפל בנוסחה מהצורה <span class="math">\(\exists x\alpha\)</span>, כאשר ל-<span class="math">\(\alpha\)</span> קיימת נוסחה שקולה <span class="math">\(\alpha^{\prime}\)</span> חסרת כמתים (למרות - וזו נקודה מהותית - שב-<span class="math">\(\alpha\)</span> יכולים להיות כמתים). אז <span class="math">\(\exists x\alpha\)</span> שקול ל-<span class="math">\(\exists x\alpha^{\prime}\)</span> (את זה כדאי להוכיח אם לא משוכנעים בכך). עכשיו, <span class="math">\(\alpha^{\prime}\)</span> חסר כמתים, אז אפשר לכתוב אותו בצורה קנונית של פסוק בתחשיב הפסוקים: DNF. כלומר, לכתוב <span class="math">\(\alpha^{\prime}=\bigvee C_{i}\)</span> כך שכל <span class="math">\(C_{i}\)</span> הוא מהצורה <span class="math">\(\left(\alpha_{1}\wedge\dots\wedge\alpha_{n}\right)\)</span> כאשר ה-<span class="math">\(\alpha\)</span> הם ליטרלים (כאן קריטי שהם יהיו ליטרלים ולא "סתם" פסוקים אטומיים - בלי היכולת להשתמש בשלילה זה לא עובד). עכשיו, לא קשה לראות ש-<span class="math">\(\exists x\left(\bigvee C_{i}\right)\)</span> שקול ל-<span class="math">\(\bigvee\exists xC_{i}\)</span>, וכל <span class="math">\(\exists xC_{i}\)</span> הוא מהצורה <span class="math">\(\exists x\left(\alpha_{1}\wedge\dots\wedge\alpha_{n}\right)\)</span> שעליה הנחנו שאנחנו יודעים למצוא נוסחה שקולה חסרת כמתים, כך שזה מסיים את ההוכחה. נקודה שיש לתת עליה את הדעת היא שפסוק ה-DNF ששקול ל-<span class="math">\(\alpha^{\prime}\)</span> עשוי להיות גדול לאין שיעור יותר מ-<span class="math">\(\alpha^{\prime}\)</span>, וזה בעייתי מאוד למי שמתעניינים ב<strong>סיבוכיות</strong> של הליך חיסול הכמתים (כי יש לזה השפעה ישירה על השאלה עד כמה נוכל להשתמש בחיסול כמתים בפועל) אבל אני לא אומר על זה כמעט כלום בינתיים.</p>
<p>סיכום ביניים: כדי להוכיח שלתורה יש חיסול כמתים, מספיק לדעת לחסל כמת אחד. הגיע הזמן לראות דוגמה של איך עושים את זה בפועל.</p>
<p>התורה שאציג עשויה להיראות מלאכותית ממבט ראשון, אבל היא לא - היא מגניבה ומעניינת. תתביישו לכם שהשמצתם אותה! זו התורה של סדר צפוף לינארי בלי נקודות קצה. מה זה אומר? ראשית, שהמילון שלנו כולל סימן יחס יחיד: <span class="math">\(<\)</span>. אין קבועים ואין פונקציות. התורה <span class="math">\(T\)</span> כוללת פסוקים שאומרים ש-<span class="math">\(<\)</span> הוא יחס סדר לינארי, שאין נקודות קצה ליחס הסדר, ושהוא צפוף (כלומר, בין כל שני איברים יש עוד אחד). הנה איך כותבים את זה פורמלית:</p>
<ol>
    <li><span class="math">\(\forall x\forall y\forall z\left(x<y\wedge y&lt;z\to x&lt;z\right)\)</span> (טרנזיטיביות היחס <span class="math">\(<\)</span>)</li>
    <li><span class="math">\(\forall x\neg\left(x<x\right)\)</span> (אי-רפלקסיביות היחס).</li>
    <li><span class="math">\(\forall x\forall y\left(x=y\vee x<y\vee y&lt;x\right)\)</span> (לינאריות היחס - אפשר להשוות כל שני איברים).</li>
    <li><span class="math">\(\forall x\forall y\left(x<y\to\exists z\left(x&lt;z\wedge z&lt;y\right)\right)\)</span> (צפיפות היחס - אם <span class="math">\(x<y\)</span> אז יש ביניהם איבר).</li>
    <li><span class="math">\(\forall x\exists y\exists z\left(y<x\wedge x&lt;z\right)\)</span> (אין נקודות קצה: לכל <span class="math">\(x\)</span> קיים איבר גדול ממנו ואיבר קטן ממנו).</li>
</ol>
<p>אילו מודלים אנחנו מכירים לתורה הזו? ובכן, יחס הסדר על המספרים הטבעיים הוא בוודאי לא טוב כי 0 היא נקודת קצה; גם על השלמים הוא לא טוב כי הוא לא צפוף (אין כלום בין 0 ו-1, למשל). דוגמה טובה אחת למודל של התורה הזו היא המספרים הרציונליים <span class="math">\(\mathbb{Q}\)</span> עם יחס הסדר הרגיל, ודוגמה טובה אחרת היא המספרים הממשיים <span class="math">\(\mathbb{R}\)</span> עם יחס הסדר הרגיל (לעומת זאת המרוכבים <span class="math">\(\mathbb{C}\)</span> אינם דוגמה טובה כי אין עליהם יחס סדר לינארי טבעי).</p>
<p>בואו נעבור להוכיח שלתורה הזו יש חילוץ כמתים. מילת אזהרה קטנה מראש: ההוכחה היא מאוד פשוטה, אבל היא תרגיש טיפה טכנית, וקרוב לודאי שלא תרגישו שאתם מקבלים תובנה "כללית" חזקה מדי על איך עושים חיסול כמתים באופן כללי. זה בגלל שזהו טבע הדברים כאן - כל תורה היא סיפור בפני עצמו. עדיין, יש עקרונות בסיס דומים שהדוגמה הנוכחית ממחישה יפה.</p>
<p>אז מה אנחנו רוצים לעשות? לקחת נוסחה מהצורה <span class="math">\(\exists x\left(\alpha_{1}\wedge\dots\wedge\alpha_{n}\right)\)</span> כאשר כל <span class="math">\(\alpha\)</span> הוא ליטרל, ולהמיר אותה למשהו שקול מודולו <span class="math">\(T\)</span> ללא כמתים. ראשית כל, מהו פסוק אטומי בשפה של התורה <span class="math">\(T\)</span>? יש לנו רק שני סימני יחס ואין בכלל סימני קבועים או פונקציות, אז פסוק אטומי חייב להיות מאוד פשוט: או <span class="math">\(x<y\)</span> או <span class="math">\(x=y\)</span>, עבור שני משתנים <span class="math">\(x,y\)</span> כלשהם. לכן כל <span class="math">\(\alpha\)</span> הוא מאחת מארבע צורות אפשריות: <span class="math">\(x<y\)</span> או <span class="math">\(x=y\)</span> או <span class="math">\(\neg\left(x<y\right)\)</span> או <span class="math">\(\neg\left(x=y\right)\)</span>.</p>
<p>נתחיל מכך שאפשר להיפטר מהשלילות. שימו לב ש-<span class="math">\(\neg\left(x<y\right)\)</span> שקול מודולו <span class="math">\(T\)</span> ל-<span class="math">\(\left(x=y\vee y<x\right)\)</span>. כאן ה"מודולו <span class="math">\(T\)</span>" קריטי, כי השקילות הזו נובעת מאקסיומה 3 של <span class="math">\(T\)</span> ובלעדיה היא פשוט לא נכונה. בדומה, <span class="math">\(\neg\left(x=y\right)\)</span> שקול מודולו <span class="math">\(T\)</span> ל-<span class="math">\(\left(x<y\vee y&lt;x\right)\)</span>, גם כן מאקסיומה 3. שימו לב שכאן כבר השתמשנו באופן חזק בפרטים הספציפיים הן של השפה שלנו, והן של התורה <span class="math">\(T\)</span>.</p>
<p>הבעיה היא שאמנם נפטרנו מהשלילות, אבל במחיר של החלפת ה-<span class="math">\(\alpha\)</span>-ות שלנו, שהיו נוסחאות אטומיות או שלילות שלהן, בנוסחאות שכוללות <span class="math">\(\vee\)</span>-ים. פורמלית, קיבלנו CNF שהוא <strong>מונוטוני</strong>, כלומר אין בו ליטרלים שליליים (השם "מונוטוני" מגיע מכך שאם ניקח השמה מסויימת לפסוק ונחליף בה 0 ל-1, הערך של הפסוק יכול רק להשתנות מ-0 ל-1 ולא ההפך). מה שנחמד ב-CNF-ים כאלו הוא שניתן להמיר אותם ב-DNF-ים מונוטוניים (איך? ובכן, לכל השמה שמספקת את הפסוק בונים פסוקית DNF מהצורה <span class="math">\(\left(x_{1}\wedge\dots\wedge x_{n}\right)\)</span> כאשר <span class="math">\(x_{1},\dots,x_{n}\)</span> הם בדיוק המשתנים שמקבלים 1 בהשמה המספקת - בדקו שזה עובד!). לכן נקבל בסופו של דבר <span class="math">\(\bigvee\)</span> של נוסחאות מהצורה <span class="math">\(\exists x\left(\alpha_{1}\wedge\dots\wedge\alpha_{n}\right)\)</span> כאשר הפעם מובטח לנו שכל הליטרלים <span class="math">\(\alpha\)</span> הם ללא שלילה, כלומר או מהצורה <span class="math">\(x<y\)</span> או מהצורה <span class="math">\(x=y\)</span>. כל שנותר לעשות הוא לחסל את הכמת בנוסחאות כאלו.</p>
<p>עכשיו, אם <span class="math">\(\alpha_{1}\)</span> שפשוט לא מכילה את המשתנה <span class="math">\(x\)</span>, אז הנוסחה <span class="math">\(\exists x\left(\alpha_{1}\wedge\dots\wedge\alpha_{n}\right)\)</span> שקולה לנוסחה <span class="math">\(\exists x\left(\alpha_{2}\wedge\dots\wedge\alpha_{n}\right)\wedge\alpha_{1}\)</span>, ובאופן דומה אפשר יהיה להוציא מהסוגריים כל <span class="math">\(\alpha\)</span> שלא מכילה את <span class="math">\(x\)</span>. בואו נעבור לדבר על <span class="math">\(\alpha\)</span>-ות שכן כוללות את <span class="math">\(x\)</span>. ראשית בואו נטפל בכאלו שהן שוויון. אם <span class="math">\(\alpha\)</span> כלשהי היא מהצורה <span class="math">\(x=x\)</span> אז היא תמיד נכונה, בלי תלות ב-<span class="math">\(x\)</span>, ואפשר פשוט להסיר אותה (אם כל הנוסחה "נעלמת" בגלל הסרות כאלו אפשר להחליף אותה בנוסחה <span class="math">\(z=z\)</span> עבור משתנה <span class="math">\(z\)</span> כלשהו שלא יהיה מכומת). מה עוד אפשרי? <span class="math">\(x=y\)</span> עבור משתנה <span class="math">\(y\)</span> כלשהו שאיננו <span class="math">\(x\)</span>, כלומר איננו מכומת. זה מקרה משמח במיוחד, כי פירוש הדבר הוא שאפשר למחוק את <span class="math">\(x\)</span> מכל ה-<span class="math">\(\alpha\)</span>-ות ולהחליף אותו ב-<span class="math">\(y\)</span> וחסל.</p>
<p>הנה דוגמה: נניח שיש לנו את הנוסחה <span class="math">\(\exists x\left(\left(x=y\right)\wedge\left(x<z\right)\wedge\left(z&lt;w\right)\right)\)</span>; אפשר להחליף אותה בנוסחה <span class="math">\(\left(y=y\right)\wedge\left(y<z\right)\wedge\left(z&lt;w\right)\)</span> ולקבל משהו חסר כמתים ששקול לנוסחה המקורית, ואז סיימנו. לכן נשאר רק לטפל במקרים של <span class="math">\(\alpha\)</span>-ות שהן יחס סדר (התעלול הזה, של "אם המשתנה המכומת שווה למשתנה לא מכומת אז הגיע חזון אחרית הימים" הוא כן משהו סטנדרטי שחוזר על עצמו גם בחיסולי כמתים אחרים).</p>
<p>אז סיימנו עם ליטרלים של <span class="math">\(=\)</span>, ונשאר לטפל באלו של <span class="math">\(<\)</span>, כלומר ליטרלים מהצורה <span class="math">\(x<y\)</span> או <span class="math">\(z<x\)</span>, או <span class="math">\(x<x\)</span>, אבל מכיוון שהליטרל האחרון אף פעם לא מסתפק במודל <span class="math">\(T\)</span> (בגלל אקסיומה 2), אם הוא מופיע אפשר להחליף את כל הנוסחה פשוט ב-<span class="math">\(z<z\)</span> (שהוא תמיד False) וחסל. אם כן, אפשר לפצל את הליטרלים שלנו לשתי קבוצות - אלו של "משהו קטן מ-<span class="math">\(x\)</span>" ואלו של "משהו גדול מ-<span class="math">\(x\)</span>". כלומר, הנוסחה שלנו היא <span class="math">\(\exists x\left(\bigwedge_{i}\left(z_{i}&lt;x\right)\wedge\bigwedge_{j}\left(x&lt;y_{j}\right)\right)\)</span>. עצרו לשניה וחשבו איך אפשר לחסל את הכמת בנוסחה הזו. זה כבר קל מספיק כדי שאפשר יהיה לראות את זה בעיניים.</p>
<p>התשובה היא זו:</p>
<p><span class="math">\(\bigwedge_{i,j}\left(z_{i}&lt;y_{j}\right)\)</span>. כלומר, לכל זוג של משתנה <span class="math">\(z_{i}\)</span> ומשתנה <span class="math">\(y_{j}\)</span> שהופיעו בנוסחה המקורית, אנו כותבים את אי השוויון <span class="math">\(z_{i}&lt;y_{j}\)</span>. למה הנוסחה הזו שקולה לנוסחה המקורית? או, כאן אנחנו משתמשים באופן חזק בתכונות של הסדר. כיוון אחד הוא טריוויאלי: אם <span class="math">\(\exists x\left(\bigwedge_{i}\left(z_{i}&lt;x\right)\wedge\bigwedge_{j}\left(x&lt;y_{j}\right)\right)\)</span> הסתפקה, ברור שגם <span class="math">\(\bigwedge_{i,j}\left(z_{i}&lt;y_{j}\right)\)</span> תסתפקת בגלל טרנזיטיביות יחס הסדר (אקסיומה 1), אבל בכיוון השני הייתה עשויה להיות בעיה, בתיאוריה, אם ה-<span class="math">\(z_{i}\)</span> הגדול ביותר היה "צמוד" ל-<span class="math">\(y_{j}\)</span> הקטן ביותר. למשל, אם המודל שלנו היה הטבעיים, <span class="math">\(z_{i}=5\)</span> ו-<span class="math">\(y_{j}=6\)</span>. אלא שהמודל של הטבעיים הוא בלתי אפשרי שכן הסדר הוא <strong>צפוף</strong> (אקסיומה 4), ולכן תמיד אפשר יהיה למצוא <span class="math">\(x\)</span> בין ה-<span class="math">\(z_{i}\)</span> הגדול ביותר וה-<span class="math">\(y_{j}\)</span> הקטן ביותר.</p>
<p>רגע, רגע, רגע! איפה השתמשנו באקסיומה 5, שאומרות שאין נקודות קצה? היא הכרחית לגמרי, אבל באופן קצת עקיף ומחוכם. נניח שהנוסחה שאנחנו רוצים לחסל בה את הכמת היא פשוטה: <span class="math">\(\exists x\left(x<y\right)\)</span>, כלומר אין לנו כאן ליטרלים משני הסוגים (גם <span class="math">\(x<y\)</span> וגם <span class="math">\(z<x\)</span>). במה אנחנו אמורים להחליף אותה? ובכן, ב-<span class="math">\(\bigwedge\)</span> "ריק", שהוא פשוט True (אז אפשר לשים את הנוסחה <span class="math">\(z=z\)</span>). אבל זה נכון רק אם <span class="math">\(\exists x\left(x<y\right)\)</span> היא אכן True; וזה כך רק אם אין בסדר שלנו נקודות קצה, כי אם <span class="math">\(y\)</span> היא נקודת הקצה השמאלית - האיבר הקטן ביותר בסדר - אז <span class="math">\(x\)</span> שמקיים <span class="math">\(x<y\)</span> לא קיים. אם כן, כל חמש האקסיומות נחוצות לנו כאן. זה לא מוכיח, כמובן, שאי אפשר לקבל חיסול כמתים אם אני מסיר את אחת מהאקסיומות; רק ששיטת ההוכחה שבה השתמשתי כאן לא תעבוד.</p>
<p>עכשיו, בואו נקטוף את הפירות. יש שתי מסקנות מיידיות שנובעות מכך שיש חיסול כמתים עבור <span class="math">\(T\)</span>: האחד הוא ש-<span class="math">\(T\)</span> היא שלמה, והשני הוא ש-<span class="math">\(T\)</span> היא כריעה. נתחיל משלמות. שלמות פירושה שכל פסוק <span class="math">\(\varphi\)</span> מקיים ש-<span class="math">\(T\models\varphi\)</span> או ש-<span class="math">\(T\models\neg\varphi\)</span>. עכשיו, אם יש לנו פסוק <span class="math">\(\varphi\)</span> (כלומר, אין בו משתנים חופשיים), אז אחרי חיסול כמתים נקבל ממנו נוסחה <span class="math">\(\psi\)</span> בלי כמתים, ושהמופעים היחידים של משתנים בה הם מהצורה <span class="math">\(z=z\)</span> או <span class="math">\(z<z\)</span> (שהם פשוט דרך עקומה לציין את הנוסחאות הקבועות True ו-False). כלומר, ערך האמת של <span class="math">\(\psi\)</span> בכלל לא תלוי במודל, ולכן <span class="math">\(T\models\psi\)</span> או <span class="math">\(T\models\neg\psi\)</span> (או שכל המודלים של <span class="math">\(T\)</span> מספקים את <span class="math">\(\psi\)</span>, או שכולם מספקים את <span class="math">\(\neg\psi\)</span>), ומכיוון ש-<span class="math">\(\psi\)</span> שקול ל-<span class="math">\(\varphi\)</span> מודולו <span class="math">\(T\)</span> קיבלנו את מה שרצינו ולכן <span class="math">\(T\)</span> שלמה. זה די נחמד לראות תורה שלמה שהיא גם לא טריוויאלית לחלוטין; בפעם הבאה שמישהו יגיד לכם שמשפטי אי השלמות של גדל מוכיחים שכל תורה מתמטית היא לא שלמה, תדעו מה לענות לו!</p>
<p>נעבור לכריעות. לומר ש-<span class="math">\(T\)</span> כריעה פירושו שלכל פסוק <span class="math">\(\varphi\)</span> ניתן לקבוע <strong>אלגוריתמית</strong> אם הוא יכיח מ-<span class="math">\(T\)</span> או לא, מה ששקול לכך שהוא נובע לוגית מ-<span class="math">\(T\)</span> (בגלל <a href="http://www.gadial.net/2013/02/25/godel_completeness_proof_1/">משפט השלמות של גדל</a>). כאן האלגוריתם די מובן מאליו: נתון <span class="math">\(\varphi\)</span>? בנו ממנו את הנוסחה <span class="math">\(\psi\)</span> חסרת הכמתים השקולה ותבדקו אם היא True או False. סוף הסיפור. את הליך הבניה תיארתי קודם - הוא היה קונסטרוקטיבי למהדרין (אבל כלל כמה שלבים לא יעילים של מציאת DNF של דברים - זה חשוב כשנכנסים לשאלות של סיבוכיות, אבל אני לא עושה את זה הפעם).</p>
<p>מה צפוי לנו בהמשך? ובכן, עוד חיסולי כמתים, אבל לתורות חדשות ומרגשות!</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>