<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אז מה זה חשבון מודולרי? - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2013/05/06/quantifier_busters/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">מכסחי הכמתים</span>
            </a>
            

            
            <a href="/2013/05/27/student_and_computer_1/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">פרוייקט &#34;התלמיד והמחשב&#34; יוצא לדרך!</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>אז מה זה חשבון מודולרי?</h1>
            <div class="post-meta">
                <span class="date">2013-05-13</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת המספרים.html">תורת המספרים</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/האלגוריתם האוקלידי.html">האלגוריתם האוקלידי</a>
                    
                    <a href="/tags/חשבון מודולרי.html">חשבון מודולרי</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אני רוצה להקדיש פוסט לנושא שלא כתבתי לו מעולם פוסט ייעודי בבלוג, למרות שהוא הופיע בשלל פוסטים מכאן ועד להודעה חדשה - חשבון מודולרי. מכיוון שהמתמטיקה הבסיסית שמאחורי חשבון מודולרי איננה מסובכת, אני מתכוון לפתח את הכל בתוך הפוסט - מה שאומר שהוא יהפוך די מהר לטכני; עם זאת, אני מקווה שכמעט כל אדם שמתעניין במתמטיקה יוכל להבין את הטכניקה גם אם אין לו השכלה מתמטית מיוחדת, ואני חושב שהרווח מהבנה של המתמטיקה הזו הוא אדיר.</p>
<p>לפני שנתחיל להיכנס לפרטים, הנה האינטואיציה הקלאסית: חשבון מודולורי הוא מה שכולנו עושים כשאנחנו מנסים לדעת מה תהיה השעה עוד כך וכך שעות. אם עכשיו השעה היא 19:00 ואנחנו שואלים "מה תהיה השעה עוד 10 שעות?" אנחנו מוסיפים 10 ל-19, מקבלים 29, ואז מחלקים ב-24 (מספר השעות ביממה), לוקחים את השארית - 5, וזו התשובה. חלקנו עושים את זה אחרת, כמובן; ראשית שואלים "עוד כמה שעות יש עד 24?", רואים שזה 5, ואומרים "אוקיי, אז אחרי חצות יש עוד 5 שעות להוסיף, ומגיעים ל-5" אבל האפקט בשני המקרים הוא אותו אפקט, ואנחנו מקבלים את המספר שמתקבל מפעולת החשבון ה"רגילה" כשאחריה מחלקים ב-24 ולוקחים את השארית. חשבון מודולרי זה בדיוק זה, רק לאו דווקא עם 24 בתור מה שמחלקים בו.</p>
<p>ועכשיו בואו נעבור לפרטים.</p>
<p>מה זה חשבון "רגיל", כולנו יודעים - יש לנו מספרים, יש לנו פעולות של חיבור, כפל, חיסור וחילוק, ואנחנו עושים איתן... דברים. בדרך כלל אנחנו מתחילים את המשחק מהמספרים הטבעיים - <span class="math">\(0,1,2,3,\dots\)</span> (שאני כולל בהם גם את 0). עכשיו, אני רוצה שתשימו לב לכך שבמובן מסויים אפשר להסתפק רק בפעולות של חיבור וכפל, ולהגדיר חיסור וחילוק באמצעותן. למשל, הפתרון למשוואה <span class="math">\(x=5-2\)</span> הוא מספר <span class="math">\(x\)</span> אשר מקיים <span class="math">\(2+x=5\)</span> (כלומר 3), והפתרון למשוואה <span class="math">\(x=6:3\)</span> הוא מספר אשר מקיים <span class="math">\(3\cdot x=6\)</span> (כלומר 2). לא תמיד קיימים פתרונות למשוואות הללו במספרים הטבעיים, למשל למשוואה <span class="math">\(x=2-5\)</span> אין פתרון במספרים הטבעיים, ולכן אנחנו מכניסים לתמונה <strong>מספרים שליליים</strong> ו<strong>שברים</strong>; אבל בפוסט הזה לא אדבר עליהם בכלל כי לא יהיה בכך צורך.</p>
<p>אם כן, נדבר על המספרים הטבעיים ועל פעולות החיבור והכפל. יש להודות שאפילו על הכפל אפשר לוותר ולתאר אותו עם חיבור בלבד, אבל אני מעדיף לדבר על שתי הפעולות הללו גם כי זה יהיה פשוט יותר, וגם כי במתמטיקה כללית יותר (שלא תופיע בפוסט) יש לחיבור ולכפל משמעויות נוספות ולא תמיד ניתן להגדיר את הכפל בעזרת החיבור.</p>
<p>עכשיו, אם יש לנו מספר טבעי <span class="math">\(a\)</span> ומספר טבעי <span class="math">\(n\)</span> שהוא גדול מאפס, אז אפשר <strong>לחלק עם שארית</strong> את <span class="math">\(a\)</span> ב-<span class="math">\(n\)</span>, כפי שרובנו למדנו בבית הספר היסודי. המשמעות של זה היא שאפשר למצוא מספרים שלמים <span class="math">\(q\)</span> ("מנה") ו-<span class="math">\(r\)</span> ("שארית") כך שמתקיים השוויון <span class="math">\(a=nq+r\)</span>, ובנוסף לכך <span class="math">\(0\le r<n\)</span>. דרך נוחה להוכיח שאפשר לעשות זאת היא באינדוקציה על הגודל של <span class="math">\(a\)</span>: אם <span class="math">\(0\le a<n\)</span> אז <span class="math">\(a=n\cdot0+a\)</span> הוא השוויון שלנו (כלומר, <span class="math">\(q=0,r=a\)</span> עובד במקרה הזה). אם <span class="math">\(a\ge n\)</span> אז נתבונן על <span class="math">\(a-n\)</span>: מהנחת האינדוקציה אנחנו יודעים שקיימים <span class="math">\(q,r\)</span> כך ש-<span class="math">\(a-n=nq+r\)</span> כך ש-<span class="math">\(0\le r<n\)</span>, ולכן (על ידי העברת אגפים) נקבל ש-<span class="math">\(a=n\left(q+1\right)+r\)</span> וזה שוב שוויון כפי שרצינו לקבל.</p>
<p>אם <span class="math">\(a=nq\)</span>, כלומר השארית של חלוקת <span class="math">\(a\)</span> ב-<span class="math">\(n\)</span> היא 0, אומרים (באופן מתבקש למדי) ש-<span class="math">\(n\)</span> <strong>מחלק</strong> את <span class="math">\(a\)</span> והסימון המקובל לכך הוא <span class="math">\(n|a\)</span>.</p>
<p>כעת נציג הגדרה חשובה במיוחד: שני מספרים <span class="math">\(a,b\)</span> (טבעים או אפילו שלמים - כלומר, כולל שליליים, שלא תיארתי בפוסט הזה) הם <strong>שקולים מודולו <span class="math">\(n\)</span></strong>, ואני כותב זאת <span class="math">\(a\equiv_{n}b\)</span>, אם השארית שלהם בחלוקה ב-<span class="math">\(n\)</span> היא זהה. כלומר, אם קיים <span class="math">\(0\le r<n\)</span> וקיימים <span class="math">\(q_{1},q_{2}\)</span> כך ש-<span class="math">\(a=nq_{1}+r\)</span> ו-<span class="math">\(b=nq_{2}+r\)</span> אז <span class="math">\(a\equiv_{n}b\)</span>. שימו לב שאם השוויונות הללו מתקיימים אז <span class="math">\(a-b=n\left(q_{1}-q_{2}\right)+\left(r-r\right)=n\left(q_{1}-q_{2}\right)\)</span>, כלומר <span class="math">\(n|a-b\)</span>, וגם ההפך נכון: אם <span class="math">\(n|a-b\)</span> אז <span class="math">\(a-b=nq\)</span> עבור איזה שהוא <span class="math">\(q\)</span>, כלומר <span class="math">\(a=nq+b\)</span>. נכתוב <span class="math">\(b=nt+r\)</span> כך ש-<span class="math">\(0\le r<n\)</span> ונקבל ש-<span class="math">\(a=n\left(q+t\right)+r\)</span>, כלומר השארית של חלוקת <span class="math">\(a\)</span> ב-<span class="math">\(n\)</span> שווה לשארית של חלוקת <span class="math">\(b\)</span> ב-<span class="math">\(n\)</span> והיא <span class="math">\(r\)</span>. מסקנה: <span class="math">\(a\equiv_{n}b\)</span> אם ורק אם <span class="math">\(n|a-b\)</span>. זה תנאי נוח יותר לבדיקה לעתים קרובות ולכן הצגתי אותו. עוד הערה קטנה היא שלרוב בספרות המתמטית כותבים <span class="math">\(a\equiv b\left(\text{mod }n\right)\)</span> כדי לציין שקילות מודולו <span class="math">\(n\)</span>; אני אישית פחות אוהב את הסימון הזה והוא פחות נוח לי ולכן אני משתמש ב-<span class="math">\(a\equiv_{n}b\)</span> (שגם הוא סימון סטנדרטי אבל הרבה פחות מקובל).</p>
<p>עכשיו, שקילות מודולו <span class="math">\(n\)</span> היא מה שנקרא במתמטיקה <strong>יחס שקילות</strong>. זה אומר שהיא מקיימת שלוש תכונות: ראשית, <span class="math">\(a\equiv_{n}a\)</span> לכל <span class="math">\(a,n\)</span> טבעיים (כש-<span class="math">\(n>0\)</span>; לא אטרח לציין זאת במפורש כל פעם). זאת מכיוון ש-<span class="math">\(a-a=0\)</span> וכמובן ש-<span class="math">\(n|0\)</span>. התכונה לפיה כל <span class="math">\(a\)</span> שקול מודולו <span class="math">\(n\)</span> לעצמו נקראת <strong>רפלקסיביות</strong>.</p>
<p>כמו כן, שקילות מודולו <span class="math">\(n\)</span> היא <strong>סימטרית</strong>, כלומר אם <span class="math">\(a\equiv_{n}b\)</span> אז זה אומר ש-<span class="math">\(n|a-b\)</span> ולכן <span class="math">\(n=q\left(a-b\right)\)</span> עבור <span class="math">\(q\)</span> כלשהו, ולכן <span class="math">\(n=-q\left(b-a\right)\)</span> ולכן <span class="math">\(b\equiv_{n}a\)</span>, כלומר השאלה מי בצד ימין ומי בצד שמאל אינה ממש חשובה כשמדברים על שקילות מודולו <span class="math">\(n\)</span>.</p>
<p>לבסוף, שקילות מודולו <span class="math">\(n\)</span> היא <strong>טרנזיטיבית</strong>, ומשמעות הדבר היא זו: אם <span class="math">\(a\equiv_{n}b\)</span> וגם <span class="math">\(b\equiv_{n}c\)</span> אז זה אומר שקיימים <span class="math">\(q_{1},q_{2}\)</span> כך ש-<span class="math">\(q_{1}n=a-b\)</span> ו-<span class="math">\(q_{2}n=b-c\)</span>. נחבר את שתי המשוואות ונקבל ש-<span class="math">\(\left(q_{1}+q_{2}\right)n=\left(a-b\right)+\left(b-c\right)=a-c\)</span> ולכן <span class="math">\(a\equiv_{n}c\)</span>.</p>
<p>באופן כללי במתמטיקה, כל יחס שקילות שמוגדר על קבוצה כלשהי - במקרה שלנו, קבוצת המספרים הטבעיים <span class="math">\(\mathbb{N}\)</span>, אבל באותה מידה זה יעבוד עבור השלמים <span class="math">\(\mathbb{Z}\)</span> - משרה על הקבוצה <strong>חלוקה למחלקות שקילות</strong>. מחלקת שקילות של מספר <span class="math">\(a\)</span> כלשהי, שמסומנת בתור <span class="math">\(\left[a\right]\)</span>, היא קבוצת כל המספרים ששקולים לו על פי יחס השקילות הזה. זה מושג לא קל להבנה, אז בואו נראה מה הוא עבור המקרים שלנו. נתחיל בקטן - שקילות מודולו <span class="math">\(2\)</span>. מהי מחלקת השקילות של 0 מודולו 2? היא כוללת את כל המספרים <span class="math">\(a\)</span> כך ש-<span class="math">\(2|a-0\)</span>, כלומר ש-<span class="math">\(2|a\)</span>, כלומר את כל הזוגיים. מסמנים זאת <span class="math">\(\left[0\right]=\left\{ 0,2,4,6,8,\dots\right\} \)</span>. באופן דומה, <span class="math">\(\left[1\right]=\left\{ 1,3,5,7,9,\dots\right\} \)</span>, כלומר מחלקת השקילות של 1 כוללת את כל האי זוגיים (כי אי זוגי הוא תמיד מהצורה <span class="math">\(2k+1\)</span>, ולכן כשנחסר ממנו 1 נקבל משהו שמתחלק ב-2), ואלו כל מחלקות השקילות של היחס "שקילות מודולו 2".</p>
<p>אפשר לעשות את אותו דבר עבור 3, ונגלה שיש שלוש מחלקות שקילות מודולו 3: <span class="math">\(\left[0\right]=\left\{ 0,3,6,9,12,\dots\right\} \)</span> של כל המספרים שמתחלקים ב-3; <span class="math">\(\left[1\right]=\left\{ 1,4,7,10,13,\dots\right\} \)</span> של כל המספרים שמתחלקים ב-3 עם שארית 1, ו-<span class="math">\(\left[2\right]=\left\{ 2,5,8,11,14,\dots\right\} \)</span> של כל המספרים שמתחלקים ב-3 עם שארית 2. ומה קורה באופן כללי? עבור שקילות מודולו <span class="math">\(n\)</span> יהיו לנו <span class="math">\(n\)</span> מחלקות שקילות, שנוח לתאר בתור <span class="math">\(\left[0\right],\left[1\right],\dots,\left[n-1\right]\)</span> - כאן המספרים <span class="math">\(0,1,2,\dots,n-1\)</span> משמשים בתור <strong>נציגים</strong> של מחלקות השקילות.</p>
<p>ועכשיו נכנסת לתמונה ההגדרה המתמטית המרכזית בפוסט: לכל <span class="math">\(n\)</span> טבעי, אנו מגדירים את הקבוצה <span class="math">\(\mathbb{Z}_{n}=\left\{ \left[0\right],\left[1\right],\dots,\left[n-1\right]\right\} \)</span> של כל מחלקות השקילות מודולו <span class="math">\(n\)</span> של מספרים טבעיים (אם לחדד, לרוב מדברים על מחלקות שקילות של מספרים שלמים, כלומר כולל השליליים, אבל לא היה לי צורך בזה כאן). הקבוצה הזו לכשעצמה היא לא מעניינת; מה שמעניין הוא שאפשר להגדיר עליה פעולות חדשות של חיבור וכפל ש"מושרות" באופן טבעי מהפעולות עבור מספרים רגילים. איך? ובכן, בהינתן <span class="math">\(\left[a\right],\left[b\right]\)</span>, איך אפשר להגדיר בצורה הטבעית ביותר את <span class="math">\(\left[a\right]+\left[b\right]\)</span>? בבירור מתבקש להגדיר זאת על ידי <span class="math">\(\left[a\right]+\left[b\right]=\left[a+b\right]\)</span>. כלומר, מחלקת השקילות שתוחזר מהחיבור של מחלקות השקילות <span class="math">\(\left[a\right]\)</span> ו-<span class="math">\(\left[b\right]\)</span> תהיה מחלקת השקילות של האיבר <span class="math">\(a+b\)</span>. אלא שיש כאן בעיה שצצה באופן כללי כשמגדירים דברים על מחלקות שקילות בעזרת נציגים שלהן: לא מובטח שההגדרה עובדת, כי ייתכן שהיא <strong>תלויה בנציג</strong>, וצריך להוכיח במפורש שהיא לא.</p>
<p>למה אני מתכוון? ובכן, אני צריך להוכיח שהסיטואציה הבאה אינה אפשרית: שיש לנו <span class="math">\(a,a^{\prime}\)</span> שמייצגים אותה מחלקת שקילות, כלומר <span class="math">\(\left[a\right]=\left[a^{\prime}\right]\)</span>, ושיש <span class="math">\(b,b^{\prime}\)</span> כך ש-<span class="math">\(\left[b\right]=\left[b^{\prime}\right]\)</span>, אבל שמתקיים <span class="math">\(\left[a+b\right]\ne\left[a^{\prime}+b^{\prime}\right]\)</span>. כי אם שתי אלו הן מחלקות שונות, אני אקבל ש-<span class="math">\(\left[a\right]+\left[b\right]=\left[a+b\right]\ne\left[a^{\prime}+b^{\prime}\right]=\left[a^{\prime}\right]+\left[b^{\prime}\right]=\left[a\right]+\left[b\right]\)</span> וקיבלתי סתירה במתמטיקה, שמצביעה על כך שפעולת החיבור של מחלקות שקילות שהגדרתי היא לא חוקית. למרבה המזל, זה לא מה שקורה בפועל; בואו נוכיח את זה.</p>
<p>אני רוצה להראות ש-<span class="math">\(\left[a+b\right]=\left[a^{\prime}+b^{\prime}\right]\)</span>, כלומר ש-<span class="math">\(a+b\equiv_{n}a^{\prime}+b^{\prime}\)</span>, כלומר ש-<span class="math">\(n|\left(a-a^{\prime}\right)+\left(b-b^{\prime}\right)\)</span>. כעת, אני יודע ש-<span class="math">\(a\equiv_{n}a^{\prime}\)</span> ולכן יש <span class="math">\(q_{1}\)</span> כך ש-<span class="math">\(a-a^{\prime}=nq_{1}\)</span>. בדומה, <span class="math">\(b\equiv_{n}b^{\prime}\)</span> ולכן <span class="math">\(b-b^{\prime}=nq_{2}\)</span> עבור איזה שהוא <span class="math">\(q_{2}\)</span>. מסקנה: <span class="math">\(\left(a-a^{\prime}\right)+\left(b-b^{\prime}\right)=n\left(q_{1}+q_{2}\right)\)</span> ולכן באמת מתקיים <span class="math">\(a+b\equiv_{n}a^{\prime}+b^{\prime}\)</span> ופעולת החיבור מוגדרת היטב. מעולה. ומה עם כפל?</p>
<p>כפל יעבוד באותו האופן: <span class="math">\(\left[a\right]\left[b\right]=\left[ab\right]\)</span>, אבל ההוכחה טיפה יותר טריקית. כמקודם, אנחנו יודעים ש-<span class="math">\(a-a^{\prime}=nq_{1}\)</span> ו-<span class="math">\(b-b^{\prime}=nq_{2}\)</span>, אבל איך מגיעים מכאן לכך ש-<span class="math">\(ab-a^{\prime}b^{\prime}=nq\)</span> עבור <span class="math">\(q\)</span> כלשהו? נסו לעשות זאת בעצמכם לרגע כדי להרגיש את ה"בעיה".</p>
<p>הפתרון, למרבה המזל, אינו מסובך, ומשתמש בתעלול אלגברי נפוץ שחלקכם ודאי זוכרים מבית הספר: להוסיף ולהחסיר איבר "ביניים" כלשהו שמקל עלינו לפשט את הביטוי:</p>
<p><span class="math">\(ab-a^{\prime}b^{\prime}=ab-ab^{\prime}+ab^{\prime}-a^{\prime}b^{\prime}=a\left(b-b^{\prime}\right)+b^{\prime}\left(a-a^{\prime}\right)=n\left(aq_{2}+b^{\prime}q_{1}\right)\)</span></p>
<p>זה מוכיח שפעולת הכפל של מחלקות שקילות מוגדרת היטב. אם כל זה קצת אבסטרקטי מדי עבורכם, הנה ניסוח "ברמת המשוואה" של מה שראינו: אם <span class="math">\(a\equiv_{n}a^{\prime}\)</span> ו-<span class="math">\(b\equiv_{n}b^{\prime}\)</span>, אז</p>
<p><span class="math">\(a+b\equiv_{n}a^{\prime}+b^{\prime}\)</span></p>
<p><span class="math">\(ab\equiv_{n}a^{\prime}b^{\prime}\)</span></p>
<p>מה שאומר שבכל פעם שיש לנו משוואה פולינומית מודולרית, אפשר לקחת כל מספר שמופיע בה ולהחליף אותו במספר ששקול לו, מה שלעתים קרובות עוזר לפשט את התוצאה. הנה דוגמא: נניח שאנו רוצים לדעת מהו <span class="math">\(10^{100}\)</span> מודולו 9. אז אנחנו כותבים את המשוואה <span class="math">\(x\equiv_{9}10^{100}\)</span>. מה עכשיו? מכיוון ש-<span class="math">\(10\equiv_{9}1\)</span>, אפשר להמשיך את המשוואה ולכתוב:</p>
<p><span class="math">\(x\equiv_{9}10^{100}\equiv_{9}1^{100}\equiv_{9}1\)</span></p>
<p>קלי קלות, כי אנחנו יודעים ש-1 בחזקת כל דבר הוא 1. גם בחשבון מודולרי.</p>
<p>אם כן, חשבון מודולרי מודולו <span class="math">\(n\)</span> הוא חשבון שמתבצע עם האיברים של <span class="math">\(\mathbb{Z}_{n}\)</span> במקום עם מספרים טבעיים רגילים, או מנקודת מבט קצת אחרת - זה חשבון שמתבצע עם מספרים טבעיים רגילים, אבל כזה שבו אנחנו מחליטים על קבוצת נציגים (שהם מספרים טבעיים) למחלקות השקילות שמהוות את <span class="math">\(\mathbb{Z}_{n}\)</span>, עובדים רק עם הנציגים הללו, ובכל פעם שבה אנחנו "חורגים" מהם, אנחנו חוזרים אליהם (על ידי חלוקה ולקיחת שארית). מכיוון שלכתוב <span class="math">\(\left[0\right]\)</span> ו-<span class="math">\(\left[a\right]\)</span> וכדומה כל הזמן זה מסורבל, אנחנו לרוב נוקטים בפועל בשיטה השניה.</p>
<p>עכשיו בואו נדבר על שתי הפעולות שעליהן טרם דיברתי - חיסור וחילוק. מה זה חיסור, באופן כללי? ובכן, נתחיל מחיבור דווקא: יש לנו איבר שהוא "אדיש" לחיבור, במובן זה שאם מחברים אותו עם <span class="math">\(x\)</span> כלשהו, מקבלים <span class="math">\(x\)</span>. האיבר הזה הוא 0. עכשיו, לכל מספר טבעי <span class="math">\(a\)</span> קיים מספר <strong>נגדי</strong>, שאם מחברים אותו עם <span class="math">\(a\)</span> מקבלים את האיבר האדיש לחיבור, כלומר <span class="math">\(0\)</span>. אנחנו מסמנים את המספר הנגדי הזה ב-<span class="math">\(-a\)</span>, ואנחנו יודעים שהוא לא מספר טבעי (אלא <strong>מספר שלילי</strong>). אלא שבחשבון מודולרי מתרחש "קסם" - אנחנו לא צריכים להרחיב את מערכת המספרים שלנו כדי לקבל איברים נגדיים: הנגדי של <span class="math">\(a\)</span> הוא פשוט <span class="math">\(n-a\)</span>. מה שאומר שלפעמים איבר יכול להיות אפילו הנגדי של עצמו. למשל, בחשבון מודולו <span class="math">\(6\)</span>, הנגדי של 2 הוא 4, והנגדי של 3 הוא 3. זה אומר שאפשר לכתוב משוואות כמו <span class="math">\(3\equiv_{6}-3\)</span> והן יהיו תקינות לחלוטין.</p>
<p>איך זה קשור לחיסור? ובכן, כי חיסור אפשר תמיד לראות כפעולה של "חיבור עם נגדי". בואו ננסה להיזכר מאיפה נוצר הצורך בפעולת חיסור בכלל: נניח שיש לנו משוואה מהצורה <span class="math">\(x+a=b\)</span>; הדרך לפתור אותה היא לחסר <span class="math">\(a\)</span> משני האגפים ולקבל <span class="math">\(x=b-a\)</span>. הסיבה שאנחנו מחסרים היא שאנחנו רוצים להיפטר מ-<span class="math">\(a\)</span> באגף שמאל; אבל מה שאנחנו בעצם עושים כאן הוא <strong>לחבר</strong> לאגף שמאל את ה<strong>נגדי</strong> של <span class="math">\(a\)</span>, ש"מאפס" אותו. לכן בחשבון מודולרי אפשר לחסר בלי בעיות - פשוט מחברים עם הנגדי. למשל, אם יש לנו את המשוואה <span class="math">\(x+2\equiv_{6}5\)</span> פשוט מחברים 4 לשני האגפים ומקבלים <span class="math">\(x\equiv_{6}5+4\equiv_{6}9\equiv_{6}3\)</span>. לרוב אנחנו מרשים לעצמנו לכתוב דברים כמו <span class="math">\(-2\)</span> גם בחשבון מודולרי, מתוך הבנה שזה ייצוג של הנגדי של <span class="math">\(2\)</span> (שמודולו 6, למשל, הוא 4). אגב, דרך פשוטה אחרת לחשוב על זה היא ש-<span class="math">\(-2\)</span> הוא פשוט מחלקת השקילות של <span class="math">\(-2\)</span> על פי יחס השקילות מודולו (כאשר מגדירים אותו על כל <span class="math">\(\mathbb{Z}\)</span>; אבל חלק מהפואנטה שלי בפוסט הזה היא שאפשר לחשוב על חשבון מודולרי גם בלי לדבר על שלילייים).</p>
<p>חילוק הוא כבר סיפור מעניין יותר. ראשית, התיאוריה הכללית, שמאוד דומה לזו של חיבור. יש לנו איבר אדיש לכפל - 1. לכל מספר <span class="math">\(a\)</span> אפשר להגדיר את <strong>ההופכי</strong> שלו בתור מספר <span class="math">\(a^{\prime}\)</span>כך ש-<span class="math">\(aa^{\prime}=1\)</span>. מסמנים את ההופכי לרוב בתור <span class="math">\(a^{-1}\)</span>. עכשיו אפשר להגדיר חילוק בתור כפל בהופכי: אם <span class="math">\(ax=b\)</span> אז <span class="math">\(x=a^{-1}b\)</span> (למה?). לרוע המזל, כאן יש לנו בעיה: ל-0 אין הופכי. אפשר להוכיח בקלות ש-<span class="math">\(0\)</span> כפול כל מספר יהיה 0, ולכן לא נוכל לקבל אף פעם 1 באופן הזה. הנה הוכחה קצרה:</p>
<p><span class="math">\(0\cdot a=\left(0+0\right)\cdot a=0\cdot a+0\cdot a\)</span></p>
<p>ועל ידי העברת אגפים מקבלים <span class="math">\(0\cdot a=0\)</span>.</p>
<p>הדרך היחידה לפתור את הבעיה הזו בצורה שעדיין מותירה תקווה שיהיה הופכי ל-0 היא לטעון ש-<span class="math">\(0=1\)</span>, אבל אז לכל <span class="math">\(a\)</span> נקבל <span class="math">\(0=0\cdot a=1\cdot a=a\)</span>, כלומר <strong>הכל</strong> שווה לאפס ואנחנו בוודאי לא רוצים את זה. אז אין ברירה: אנחנו מצהירים ש-0 אינו הפיך, ולכן גם לא ניתן לחלק ב-0.</p>
<p>הבעיה בחשבון מודולרי היא שזה יכול לקרות לעוד איברים חוץ מ-0.</p>
<p>נתחיל ממקרה פשוט שבו זה דווקא לא קורה, חשבון מודולו 7: מי הוא, למשל, ההופכי של 3 מודולו 7? קל לראות שזה 5, כי <span class="math">\(3\cdot5\equiv_{7}15\equiv_{7}1\)</span>. אבל האם יש דרך שיטתית ומסודרת למצוא הופכי של מספרים מודולו משהו? התשובה חיובית ואסביר זאת בקרוב.</p>
<p>כעת, אם אני רוצה לחלק ב-3 מודולו 7, אני פשוט כופל ב-5. למשל, כדי לחלק את 6 ב-3 אני כופל ב-5 ומקבל 30, ששקול מודולו 7 ל-2. קסם! בדרך דומה אפשר לחלק בכל מספר מ-1 עד 6, אבל לא ב-0. אם כן, איפה כן יש בעיות עם מספרים ששונים מאפס?</p>
<p>בואו נעבור לדבר על חשבון מודולו 6. בחשבון מודולו 6 לא קשה לראות ש-5 הוא הפיך - תכפלו אותו <strong>בעצמו</strong> ותקבלו 1. אז כפל ב-5 וחלוקה ב-5 זה בעצם אותו דבר. כנ"ל עבור 1. אבל מה עם שאר המספרים? בואו נתחיל מ-2 ו-3. שימו לב שהמכפלה של שניהם נותנת 6, ששקול מודולו 6 לאפס, כלומר <span class="math">\(2\cdot3\equiv_{6}0\)</span>. זו תופעה שפשוט לא קיימת בחשבון "רגיל" - כופלים שני מספרים שונים מאפס, ומקבלים אפס. למספרים כאלו קוראים <strong>מחלקי אפס</strong>, ואני טוען שאם מספר הוא מחלק אפס מודולו <span class="math">\(n\)</span> הוא לא יכול להיות הפיך מודולו <span class="math">\(n\)</span>. הסיבה פשוטה: אם <span class="math">\(ab\equiv_{n}0\)</span> ו-<span class="math">\(b\not\equiv_{n}0\)</span>, ואם <span class="math">\(a\)</span> הפיך, אז אפשר לחלק ב-<span class="math">\(a\)</span> ולקבל <span class="math">\(b\equiv_{n}0\)</span>, בסתירה למה שהנחנו.</p>
<p>במי עוד לא טיפלנו מודולו 6? ב-4. קל לראות שגם הוא מחלק 0, כי <span class="math">\(4\cdot3=12\equiv_{6}0\)</span>. זה מסיים את הסיפור: האיברים שהם הפיכים מודולו <span class="math">\(6\)</span> הם רק <span class="math">\(1,5\)</span>. באופן כללי, את האיברים ב-<span class="math">\(\mathbb{Z}_{n}\)</span> שהם הפיכים מודולו <span class="math">\(n\)</span> נהוג לסמן בתור <span class="math">\(\mathbb{Z}_{n}^{*}\)</span>. כלומר, ראינו ש-<span class="math">\(\mathbb{Z}{}_{7}^{*}=\left\{ 1,2,3,4,5,6\right\} \)</span> ואילו <span class="math">\(\mathbb{Z}_{6}^{*}=\left\{ 1,5\right\} \)</span>. אבל האם יש הגיון כללי שמאפשר לדעת מתי איבר הוא הפיך או מחלק אפס מודולו <span class="math">\(n\)</span>? והאם איבר הוא בהכרח או זה או זה? (שימו לב לכך שבמספרים השלמים הטענה "איבר הוא או מחלק אפס או הפיך" אינה נכונה - למשל, 2 אינו הפיך ואינו מחלק אפס). כאן צריך להכניס לתמונה עוד קצת מתמטיקה; בפרט את מה שנקרא <strong>האלגוריתם האוקלידי</strong>.</p>
<p>בואו נתחיל מלדבר על שאלה שבמבט ראשון אולי נראית לא קשורה. נניח שיש לנו שני מספרים שלמים <span class="math">\(a,b\)</span>, ואנחנו מסתכלים על כל המספרים שניתן לקבל מחיבורים וחיסורים שלהם, כלומר על כל <strong>הצירופים הלינאריים</strong> <span class="math">\(ax+by\)</span> כאשר <span class="math">\(x,y\)</span> הם מספרים שלמים. האם יש דרך פשוטה לתאר את כל המספרים שיכולים להתקבל בצורה הזו?</p>
<p>יש שלל סיבות שבגללן השאלה הזו מעניינת, אבל בהקשר שלנו היא מעניינת כי תשובה לה נותנת לנו תשובה לשאלה "אילו ערכים מודולו <span class="math">\(n\)</span> יש לכפולות של <span class="math">\(a\)</span>?". מה שנעשה הוא להתבונן על כל המספרים מהצורה <span class="math">\(t=ax+ny\)</span>, וכשניקח את המשוואה מודולו <span class="math">\(n\)</span> נקבל <span class="math">\(t\equiv_{n}ax\)</span> (כי <span class="math">\(ny\equiv_{n}0\)</span>). בפרט, <span class="math">\(a\)</span> הפיך מודולו <span class="math">\(n\)</span> אם ורק אם קיימים <span class="math">\(x,y\)</span> כך ש-<span class="math">\(ax+ny=1\)</span>. אם כן, שווה לחקור בצורה קצת יותר כללית את אוסף כל הצירופים הלינאריים <span class="math">\(ax+by\)</span> ולהבין איך הוא מתנהג עבור <span class="math">\(a,b\)</span> כלשהם.</p>
<p>נתחיל מאבחנה פשוטה: אם <span class="math">\(d\)</span> הוא מספר טבעי כלשהו כך ש-<span class="math">\(d|a\)</span> וגם <span class="math">\(d|b\)</span> אז <span class="math">\(d|ax+by\)</span> (זה תרגיל קל שדומה לחישובים שכבר עשינו בפוסט). לכן אפשר להציג את כל המספרים מהצורה <span class="math">\(ax+ny\)</span> בתור כפולה של כל <span class="math">\(d\)</span> אשר מחלק את <span class="math">\(a,b\)</span>. האם זה אומר גם ההפך - שכל כפולה של <span class="math">\(d\)</span> ניתן לייצג כצירוף לינארי שכזה? הבה ונראה דוגמה. ניקח את המספרים <span class="math">\(a=12,b=8\)</span>. שניהם מתחלקים על ידי 2 ולכן ברור שכל צירוף לינארי שלהם יהיה זוגי, אבל האם אפשר לכתוב את 2 כצירוף לינארי שלהם? על פניו לא ברור איך. את 4 קל לכתוב: <span class="math">\(4=12-8\)</span>. אבל את 2? אפשר לנסות לפעול שיטתית כך: ראשית "נקפיא" את <span class="math">\(12\)</span> ונראה אילו מספרים אפשר לקבל כשמחברים ומחסרים את 8 ממנו: נגלה את הסדרה <span class="math">\(\dots,-20,-12,-4,4,12,20,\dots\)</span>. נראה ש"פספסנו" את 2. עכשיו, בואו נחבר את 12 לעצמו ונקבל 24. איזו סדרה אפשר לקבל כשמחברים או מחסרים כפולות של 8 מ-24? הסדרה <span class="math">\(\dots,-16,-8,0,8,16,24,32,\dots\)</span>. שוב "פספסנו" את 2. אבל אולי אם נתחיל מ-36? הבנתם את הרעיון.</p>
<p>בואו נעצור לרגע ונתבונן בכל המספרים שמצאנו עד כה כצירופים לינאריים של 8 ו-12. כולם מתחלקים ב-2 וזה לא מפתיע, אבל כולם גם מתחלקים ב-4. גם זה לא מפתיע, שכן 4 מחלק גם הוא את 8 ו-12; מה שמעניין הוא שנראה שאכן הצלחנו לתפוס את <strong>כל</strong> הכפולות של 4, למרות שלא תפסנו את כל הכפולות של 2. מה הופך את 4 למיוחד מבין המחלקים המשותפים של 8 ו-12 כדי שהתכונה הזו תתקיים עבורו? התשובה פשוטה: 4 הוא <strong>המחלק המשותף המקסימלי</strong> של 12 ו-8. אין להם מחלק משותף גדול יותר.</p>
<p>הסיבה שבגללה כל כפולה של 4 יכולה להתקבל היא שאפשר לקבל את 4 עצמו בתור צירוף לינארי של 12 ו-8. באופן כללי, אם עבור <span class="math">\(d\)</span> כלשהו מתקיים <span class="math">\(d=ax+by\)</span> אז כדי לקבל כפולה כלשהי של <span class="math">\(d\)</span> פשוט נכפיל את המשוואה במה שאנו זקוקים לו, ונקבל <span class="math">\(td=axt+aty\)</span>. מה שהופך את 4 למיוחד הוא שמצד אחד, אפשר לקבל את כל הכפולות שלו כצירוף לינארי של 8 ו-12, ומצד שני הוא מחלק כל צירוף לינארי של 8 ו-12, ולכן קבוצת "הצירופים הלינאריים של 8 ו-12" וקבוצת "הכפולות של 4" הן בדיוק אותה קבוצה. זה גם מבהיר מדוע אנחנו לא מסוגלים לקבל את 2 כצירוף לינארי של 8 ו-12: פשוט מאוד, 4 אינו מחלק את 2.</p>
<p>הטענה הזו עובדת באופן כללי. בהינתן <span class="math">\(a,b\)</span> אנו מסמנים ב-<span class="math">\(d=\text{gcd}\left(a,b\right)\)</span> את המחלק המשותף המקסימלי של <span class="math">\(a,b\)</span>. כדי להוכיח שכל כפולה של <span class="math">\(d\)</span> מתקבלת כצירוף לינארי של <span class="math">\(a,b\)</span> צריך להוכיח שקיים צירוף לינארי שלהם שנותן את <span class="math">\(d\)</span> עצמו, כלומר שקיימים <span class="math">\(x,y\)</span> כך ש-<span class="math">\(ax+by=d\)</span>. אציג כעת אלגוריתם, <strong>האלגוריתם האוקלידי</strong> שבהינתן <span class="math">\(a,b\)</span> גם מוצא את <span class="math">\(d\)</span> וגם כותב אותו כצירוף לינארי של <span class="math">\(a,b\)</span>, ובנוסף לכך הוא גם עושה זאת ביעילות, מה שקריטי לחלוטין עבור תורת המספרים החישובית.</p>
<p>האלגוריתם הוא רקורסיבי באופיו, כלומר מתבסס על קריאה לעצמו על מקרה פשוט יותר. בואו נניח שאנחנו מקבלים כקלט <span class="math">\(a,b\)</span> שהם טבעיים ומקיימים <span class="math">\(a>b\)</span>. אז אפשר לחלק את <span class="math">\(a\)</span> ב-<span class="math">\(b\)</span> עם שארית ולקבל <span class="math">\(a=qb+r\)</span>. כעת, אם <span class="math">\(r=0\)</span> זה אומר ש-<span class="math">\(b\)</span> מחלק את <span class="math">\(a\)</span> ולכן המחלק המשותף הגדול ביותר של שניהם הוא <span class="math">\(b\)</span> עצמו, שאפשר להציג בתור צירוף לינארי טריוויאלי: <span class="math">\(a\cdot0+b\cdot1=b\)</span>.</p>
<p>כעת, אם <span class="math">\(r\)</span> גדול מ-0, מגיעה האבחנה המרכזית הבאה: <span class="math">\(\text{gcd}\left(a,b\right)=\text{gcd}\left(b,r\right)\)</span>. כדי לראות זאת, מספיק לשים לב לכך ש-<span class="math">\(a=qb+r\)</span> ולכן אם מישהו מחלק את <span class="math">\(b,r\)</span> הוא בוודאי מחלק את <span class="math">\(a\)</span>, וש-<span class="math">\(r=a-qb\)</span> ולכן אם מישהו מחלק את <span class="math">\(a,b\)</span> הוא בוודאי מחלק את <span class="math">\(r\)</span>. לכן הקבוצה "המחלקים המשותפים של <span class="math">\(a,b\)</span>" והקבוצה "המחלקים המשותפים של <span class="math">\(b,r\)</span>" שוות. הוכחנו את האבחנה, וממנה נובעת שארית האלגוריתם: באופן רקורסיבי, אנו מוצאים <span class="math">\(x^{\prime},y^{\prime}\)</span> כך ש-<span class="math">\(\text{gcd}\left(a,b\right)=bx^{\prime}+ry^{\prime}\)</span>, וכעת אנו מציבים <span class="math">\(a-qb\)</span> במקום <span class="math">\(r\)</span>, ומקבלים <span class="math">\(\text{gcd}\left(a,b\right)=ay^{\prime}+b\left(x^{\prime}-qy^{\prime}\right)\)</span>, כלומר <span class="math">\(\text{gcd}\left(a,b\right)=ax+by\)</span> כאשר <span class="math">\(x=y^{\prime}\)</span> ו-<span class="math">\(y=x^{\prime}-qy^{\prime}\)</span>. קל מאוד לתכנת את זה בפועל.</p>
<p>חזרה לענייננו: יהא <span class="math">\(n\)</span> טבעי כלשהו ונרצה לדעת מתי <span class="math">\(a\)</span> הפיך מודולו <span class="math">\(n\)</span>. כפי שהראיתי כבר, אם <span class="math">\(\text{gcd}\left(a,n\right)=1\)</span> אז קיימים <span class="math">\(x,y\)</span> כך ש-<span class="math">\(ax+ny=1\)</span> ולכן <span class="math">\(ax\equiv_{n}1\)</span> ומכאן ש-<span class="math">\(a\)</span> הפיך ו-<span class="math">\(x\)</span> הוא ההופכי שלו ויש לנו אלגוריתם יעיל למצוא אותו (ולכן אלגוריתם יעיל לביצוע פעולות חילוק מודולו <span class="math">\(n\)</span>). ומה אם <span class="math">\(\text{gcd}\left(a,n\right)=d&gt;1\)</span>? במקרה הזה <span class="math">\(a\)</span> הוא מחלק אפס, כי בואו נסתכל על <span class="math">\(a\cdot\frac{n}{d}\)</span>: מכיוון ש-<span class="math">\(d\)</span> מחלק את <span class="math">\(n\)</span>, הרי ש-<span class="math">\(\frac{n}{d}\)</span> הוא מספר שלם, וקטן מ-<span class="math">\(n\)</span> (כי <span class="math">\(d>1\)</span>). מצד שני, הביטוי הזה שווה ל-<span class="math">\(\frac{a}{d}\cdot n\equiv_{n}0\)</span> כי <span class="math">\(d\)</span> מחלק גם את <span class="math">\(a\)</span>. אז מצאנו ש-<span class="math">\(a\)</span> כפול משהו שאיננו 0 מודולו <span class="math">\(n\)</span> שווה ל-0 מודולו <span class="math">\(n\)</span>, והמסקנה היא ש-<span class="math">\(a\)</span> אינו הפיך.</p>
<p>אם כן, מצאנו ש-<span class="math">\(a\)</span> הפיך מודולו <span class="math">\(n\)</span> אם ורק אם המחלק המשותף הגדול ביותר שלהם הוא 1; זו תכונה כל כך חשובה שנותנים לה שם: <span class="math">\(a\)</span> ו-<span class="math">\(n\)</span> הם <strong>זרים</strong> אם המחלק המשותף המקסימלי שלהם הוא 1. לכן <span class="math">\(\mathbb{Z}_{n}^{*}\)</span> היא קבוצת כל המספרים שזרים ל-<span class="math">\(n\)</span> וקטנים ממנו. זה מסביר למה <span class="math">\(\mathbb{Z}{}_{7}^{*}=\left\{ 1,2,3,4,5,6\right\} \)</span>: עבור מספר ראשוני, כל מספר חיובי קטן ממנו זר לו. זה גם מסביר למה <span class="math">\(\mathbb{Z}_{6}^{*}=\left\{ 1,5\right\} \)</span>: 2 מחלק את 6 וכך גם 3, ואילו ל-4 יש מחלק משותף גדול מ-1 עם 6: 2.</p>
<p>אם כן, זהו חשבון מודולרי על קצה המזלג; ראינו מה ה"עולם" שבו הוא מתרחש ואיך לבצע במסגרתו את ארבע פעולות החשבון - חיבור, כפל, חיסור וחילוק. כמובן שזו רק ההתחלה (אפשר למשל לשאול מה קורה עבור הוצאת שורשים, וזה סיפור מרתק בפני עצמו) וכמובן שהשאלה המעניינת באמת היא איך משתמשים בכל זה. התשובה היא שיש שלל שימושים, שאת חלקם כבר הראיתי בבלוג; בזכות הפוסט הזה יהיה לי נוח יותר להראות שימושים נוספים בעתיד.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>