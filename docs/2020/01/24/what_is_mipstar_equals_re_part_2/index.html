<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מה זה אומר ש-MIP*=RE? (חלק ב&#39;: מה זה אומר MIP*?) - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2020/01/24/what_is_mipstar_equals_re_part_2/">
    <meta property="og:title" content="מה זה אומר ש-MIP*=RE? (חלק ב&#39;: מה זה אומר MIP*?)">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2020/01/24/what_is_mipstar_equals_re_part_2/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="מה זה אומר ש-MIP*=RE? (חלק ב&#39;: מה זה אומר MIP*?)">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2020/01/23/what_is_mipstar_equals_re_part_1/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">מה זה אומר ש-MIP*=RE? (חלק א&#39;: מה זה אומר RE?)</span>
            </a>
            

            
            <a href="/2020/01/31/mermin_peres_magic_square/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">ריבוע הקסם של פרס-מרמין (או: איך תורת הקוונטים עוזרת לטלפתיה)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מה זה אומר ש-MIP*=RE? (חלק ב&#39;: מה זה אומר MIP*?)</h1>
            <div class="post-meta">
                <span class="date">2020-01-24</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                    <a href="/categories/חישוב קוונטי.html">חישוב קוונטי</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/מערכת הוכחה אינטראקטיבית.html">מערכת הוכחה אינטראקטיבית</a>
                    
                    <a href="/tags/חישוב קוונטי.html">חישוב קוונטי</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p><a href="https://gadial.net/2020/01/23/what_is_mipstar_equals_re_part_1/">בפוסט הקודם</a>התחלתי לדבר על ההוכחה ש-<span class="math">\(\text{MIP}^{*}=\text{RE}\)</span> והסברתי מה זו <span class="math">\(\text{RE}\)</span>. הפעם אני ארצה לנסות להבין מה זו <span class="math">\(\text{MIP}^{*}\)</span>, ולשם כך נבין קודם כל מה זו <span class="math">\(\text{MIP}\)</span> ולשם כך נבין קודם כל מה זו <span class="math">\(\text{IP}\)</span> ולשם כך קודם כל ניזכר במה שקרה בפוסט הקודם.</p>
<p>"נקודת המוצא" שלי בפוסט הקודם הייתה המחלקה <span class="math">\(\text{NP}\)</span> שכוללת את כל בעיות ההכרעה <span class="math">\(L\)</span> שיש להן "מוודא" יעיל. כלומר, שקיים <span class="math">\(V\)</span> שפועל בזמן ריצה יעיל (פולינומי בגודל הקלט שלו) כך ש:</p>
<ol> <li>(שלמות) אם <span class="math">\(x\in L\)</span> אז <strong>קיים</strong> <span class="math">\(\pi\)</span> כך ש-<span class="math">\(V\left(x,\pi\right)=\text{T}\)</span></li>


<li>(נאותות) אם <span class="math">\(x\notin L\)</span> אז <strong>לכל</strong> <span class="math">\(\pi\)</span> מתקיים ש-<span class="math">\(V\left(x,\pi\right)=\text{F}\)</span></li>

</ol>

<p>כאשר <span class="math">\(\pi\)</span> - ה"הוכחה" לשייכות <span class="math">\(x\)</span> ל-<span class="math">\(L\)</span> - פולינומי בגודל של <span class="math">\(x\)</span>.</p>
<p>אחרי הגדרת <span class="math">\(\text{NP}\)</span> הגדרתי את <span class="math">\(\text{RE}\)</span> בצורה דומה מאוד, רק בלי דרישות הסיבוכיות - לא הגבלתי את האורך של <span class="math">\(\pi\)</span> ולא דרשתי ש-<span class="math">\(V\)</span> ירוץ בזמן יעיל. בצורה הזו נראה ש-<span class="math">\(\text{RE}\)</span> היא מעין הכללה של <span class="math">\(\text{NP}\)</span> שמתקבלת מהקלה ב"כללי המשחק" של <span class="math">\(\text{NP}\)</span>. בפועל קרה ההפך - המחלקה <span class="math">\(\text{RE}\)</span> הייתה מוכרת הרבה לפני שהתחילו לדבר על <span class="math">\(\text{NP}\)</span>, מהטעם הפשוט ש-<span class="math">\(\text{RE}\)</span> הייתה <strong>גדולה מדי</strong>. אבל אחרי ש-<span class="math">\(\text{NP}\)</span> הפכה לבת בית רגילה בתורת הסיבוכיות, אכן התחילו לשאול איך עוד אפשר להקל ב"כללי המשחק" של <span class="math">\(\text{NP}\)</span> ומה מקבלים אז.</p>
<p>דרך אחת שבה אפשר להקל בכללי המשחק של <span class="math">\(\text{NP}\)</span> היא על ידי הוספת <strong>אינטראקטיביות</strong> לתהליך הוידוא. מה קורה ב-<span class="math">\(\text{NP}\)</span>? אני הוא המוודא <span class="math">\(V\)</span>. אני מקבל לידיים "הוכחה" <span class="math">\(\pi\)</span>. מה זו ההוכחה הזו? מהיכן היא הגיעה? מהשמיים? ממולטיוואק? מהראש של זאוס? זה לא חלק מהסיפור. יש הוכחה. כל האתגר שלי הוא לבדוק בסיועה האם <span class="math">\(x\in L\)</span> או לא. במילים אחרות, אין <strong>מוכיח</strong> שהוא חלק מהסיפור. קיבלתי ספר ואני קורא אותו וזהו.</p>
<p>אבל נניח שיש מוכיח. כאן זה כבר פחות לימוד עצמי ויותר כמו לשבת בהרצאה של מתמטיקה ולהציק כל הזמן למרצה בשאלות. אם אני לא מעצבן אותה, היא אפילו תענה לי. יש כאן <strong>תהליך אינטראקטיבי</strong> של למידה, ולחלקנו זה עוזר ללמוד. האם זה עוזר גם להוכיח דברים יותר טוב?</p>
<p>קודם כל נשאל את עצמנו - איך מפרמלים את זה? עד עכשיו היה לי בתמונה אלגוריתם אחד, <span class="math">\(V\)</span>- "המוודא". עכשיו אני מכניס לתמונה אלגוריתם חדש, <span class="math">\(P\)</span> - "המוכיח". על <span class="math">\(V\)</span> יש דרישות סיבוכיות; הוא צריך לרוץ בזמן יעיל. על <span class="math">\(P\)</span> לעומת זאת אני לא אדרוש שום דבר כזה, כי אם <span class="math">\(P\)</span> לא יותר חזק מ-<span class="math">\(V\)</span> מה היתרון שבהכנסת <span class="math">\(P\)</span> למשחק מלכתחילה? אז אני מניח ש-<span class="math">\(P\)</span> יכול לפעול באיזו סיבוכיות זמן שבא לו, אבל <strong>העיקר שיעצור בסוף עם תשובה</strong>.</p>
<p>עכשיו מה ש-<span class="math">\(V\)</span> עושה על קלט <span class="math">\(x\)</span> הוא לבצע חישובים משל עצמו, ובנוסף לכך לשלוח "שאלות" ל-<span class="math">\(P\)</span> (בפועל - פשוט מחרוזות; זה לא חייב להיות משהו שמנוסח כשאלה) ולקבל "תשובות" מ-<span class="math">\(P\)</span> שהוא יכול להמשיך את החישוב עליהן. אנחנו חושבים על הצעד של "לשלוח שאלה ולקבל תשובה" מ-<span class="math">\(P\)</span> בתור משהו שדורש צעד חישוב אחד של <span class="math">\(V\)</span> ולא משנה כמה זמן לוקח ל-<span class="math">\(P\)</span> לחשוב על תשובה; כך המגבלה שלנו על זמן הריצה של <span class="math">\(V\)</span> נשארת הגיונית.</p>
<p>המודל הזה חביב ונחמד <strong>ולא תורם לנו שום דבר חדש</strong> כי כל מה שאפשר לעשות בו, אפשר לעשות גם ב-<span class="math">\(\text{NP}\)</span>. פשוט תחשבו על ההוכחה <span class="math">\(\pi\)</span> כאילו היא כוללת את התשובות של המוכיח לשאלות של המוודא - בשביל מה צריך אינטראקטיביות כאן אם המוודא צפוי ואפשר לדעת מראש מה ישאל? תחשבו על ספר ש"מדבר עם הקורא" כי הוא ניחש מצויין מה הקורא הולך להגיד.</p>
<p>אם כן, כדי שהעניינים יהיו יותר מעניינים, אנחנו הופכים את המוודא ל<strong>הסתברותי</strong> - מעכשיו מותר לו להטיל מטבעות ולשאול שאלות בהתאם לתוצאות ההטלה. על פניו לא שיניתי הרבה כי הוכחה <span class="math">\(\pi\)</span> עדיין יכולה לכלול את התשובות לכל השאלות האפשריות של המוודא - אבל אם המוודא הוא הסתברותי יכולות להיות <strong>המון</strong> שאלות שונות, ולכן ההוכחה <span class="math">\(\pi\)</span> הזו תהיה <strong>ארוכה מדי</strong> ממה שמותר לה להיות במסגרת <span class="math">\(\text{NP}\)</span>. חשבו על זה כך: אם אני מטיל מטבע <span class="math">\(n\)</span> פעמים יש לי <span class="math">\(2^{n}\)</span> תוצאות אפשריות של ההטלה, ולכן <span class="math">\(2^{n}\)</span> שאלות אפשריות - זה מספר לא פולינומי ב-<span class="math">\(n\)</span>. אם <span class="math">\(\pi\)</span> כוללת תשובה לכל שאלה כזו אז הגודל שלה יהיה מסדר גודל <span class="math">\(2^{n}\)</span> ואם <span class="math">\(n\)</span> הוא בערך מסדר הגודל של <span class="math">\(x\)</span>, אז קיבלנו הוכחה ארוכה מדי.</p>
<p>העניין הוא שאם כל מה ששינינו הוא רק את היכולת של המוודא להטיל מטבעות, זה <strong>עדיין לא תרם שום דבר חדש</strong> כי כדי לוודא ש-<span class="math">\(x\in L\)</span> <strong>לא צריך</strong> את כל התשובות לשאלות. בואו נראה במדויק למה. נניח שיש לנו מערכת הוכחה אינטראקטיבית עם מוודא הסתברותי <span class="math">\(V\)</span> ומוכיח כל יודע <span class="math">\(P\)</span>. עכשיו אני בונה מוכיח <strong>חדש</strong> שאקרא לו <span class="math">\(V^{\prime}\)</span>, שמקבל ליד הוכחה <span class="math">\(\pi\)</span> לשייכות <span class="math">\(x\)</span> ל-<span class="math">\(L\)</span> ובודק אותה באופן הבא:</p>
<p>ההוכחה <span class="math">\(\pi\)</span> של <span class="math">\(V^{\prime}\)</span> תהיה בעצם תעתיק של שיחה בין <span class="math">\(V\)</span> המקורי ובין <span class="math">\(P\)</span>. כלומר - אני אראה את השאלות ש-<span class="math">\(V\)</span> שאל את <span class="math">\(P\)</span> ואת מה ש-<span class="math">\(P\)</span> ענה לו, ובנוסף לכך אראה גם את תוצאות הטלת המטבע של <span class="math">\(V\)</span>. עכשיו אני יכול לבדוק שהתעתיק הזה באמת אמין, במובן זה שאני יכול לבצע סימולציה של <span class="math">\(V\)</span> המקורי ולראות אם הוא באמת שואל את אותן שאלות כמו בתעתיק, ובסוף אני אענה כמו שהוא ענה.</p>
<p>עכשיו, אם <span class="math">\(x\in L\)</span> אז קיימת סדרת שאלות ותשובות שבה <span class="math">\(P\)</span> הצליח לשכנע את <span class="math">\(V\)</span> לומר <span class="math">\(\text{T}\)</span> - ולכן גם אני אומר <span class="math">\(\text{T}\)</span> על התעתיק שמתאר את הסדרה הזו. זה מטפל בדרישת ה"שלמות". כמו כן, אם <span class="math">\(x\notin L\)</span> אז לא משנה מה <span class="math">\(P\)</span> אומר ל-<span class="math">\(V\)</span>; אסור ל-<span class="math">\(V\)</span> לטעות, בכלל, אז הוא בודאות יאמר <span class="math">\(\text{F}\)</span> בסוף וכך גם אני אגיד. בקיצור, גם כל הסיפור הזה נופל בתוך המסגרת של <span class="math">\(\text{NP}\)</span>. אם רוצים להתרחב מעבר אליה חייבים לוותר על עוד משהו. ומה שמוותרים עליו הוא ה<strong>אמינות</strong> של התשובה של <span class="math">\(V\)</span>. כלומר, מרשים ל-<span class="math">\(V\)</span> <strong>לטעות</strong> בהסתברות מסויימת.</p>
<p>באופן כללי, אם אלגוריתם הסתברותי שעונה "כן/לא" טועה בהסתברות שהיא טובה יותר מ-<span class="math">\(\frac{1}{2}\)</span> בפער כלשהו - למשל, <span class="math">\(\frac{1}{3}\)</span> זה המספר שאוהבים לתת בדרך כלל - אז על ידי מספיק חזרות על האלגוריתם ולקיחת התוצאה שהוא החזיר יותר פעמים אפשר <strong>לנפח</strong> את ההסתברות שנענה תשובה נכונה, ומספיק שנחזור על האלגוריתם מספר <strong>פולינומי</strong> של פעמים כדי להשיג שיפור <strong>אקספוננציאלי</strong> בהסתברות להצליח (זה דורש טיעון הסתברותי כלשהו שמערב משהו שנקרא <strong>חסם צ'רנוף</strong> ולא אכנס אליו כאן). בגלל זה מסתפקים בלדרוש הסתברות טעות של לכל היותר <span class="math">\(\frac{1}{3}\)</span> ולא משהו נמוך יותר (כמו לכל היותר <span class="math">\(0.000000000001\)</span>) - כי מבחינה תיאורטית זה כמעט אותו הדבר. </p>
<p>אחרי שהנקודה הזו הובהרה אפשר לעבור להגדרה הפורמלית. אנחנו אומרים שבעיה <span class="math">\(L\)</span> שייכת למחלקה IP (ראשי תיבות של Interactive Proof) אם קיים מוודא הסתברותי יעיל <span class="math">\(V\)</span> כך שלכל <span class="math">\(x\)</span>:</p>
<ol> <li>(שלמות) אם <span class="math">\(x\in L\)</span> אז <strong>קיים</strong> מוכיח <span class="math">\(P\)</span> כך שההסתברות ש-<span class="math">\(V\)</span> יגיד "כן" על <span class="math">\(x\)</span> בסוף הפרוטוקול עם <span class="math">\(P\)</span> היא לפחות <span class="math">\(\frac{2}{3}\)</span>.</li>


<li>(נאותות) אם <span class="math">\(x\notin L\)</span> אז <strong>לכל</strong> מוכיח <span class="math">\(P\)</span> ההסתברות ש-<span class="math">\(V\)</span> יגיד "כן" על <span class="math">\(x\)</span> בסוף הפרוטוקול עם <span class="math">\(P\)</span> היא לכל היותר <span class="math">\(\frac{1}{3}\)</span>.</li>

</ol>

<p>שימו לב להבדל בין שלמות ונאתות - בשלמות, מספיק שיהיה <span class="math">\(P\)</span> <strong>מסויים</strong> שעבורו האפקט החיובי מושג (כמו שב-<span class="math">\(\text{NP}\)</span> הספיקה הוכחה אחת נכונה) ולעומת זאת בנאותות צריך להבטיח ש<strong>כל</strong> מוכיח כל יודע, לא משנה כמה הוא תחמן ורמאי, לא יצליח לעבוד על <span class="math">\(V\)</span> יותר מדי. זו גם החשיבה שצריך לאמץ על מערכות הוכחה כאלו באופן כללי: <span class="math">\(P\)</span> <strong>הוא לא חבר שלנו</strong>. הוא האויב. הוא הרוע. הוא מי שמנסה להטעות אותנו בכל צעד ושעל. פרוטוקולי הוכחה אינטראקטיביים בנויים הרבה יותר על להבטיח ש-<span class="math">\(P\)</span> רמאי לא יצליח לרמות אותנו, והרבה פחות על "הו ידידי הטוב בוא תעזור לי להרחיב את הידע שלנו יחד".</p>
<p>האם כל הזוועה הזו מהווה שיפור ביחס ל-<span class="math">\(\text{NP}\)</span>? ובכן, <strong>כנראה שכן</strong>. אחת מהתוצאות היפות והמפתיעות בתורת הסיבוכיות (<a href="https://gadial.net/2011/03/17/ip_equals_pspace_overview/">ויש לי עליה פוסט</a>) הייתה ש-<span class="math">\(\text{IP=PSPACE}\)</span>. בפשטות, הטענה הזו אומרת ש-<span class="math">\(\text{IP}\)</span> היא <strong>הרבה יותר חזקה ממה שחשבו במבט ראשון</strong>. כמובן, קודם כל צריך להסביר מה זו בכלל <span class="math">\(\text{PSPACE}\)</span>, וזה קל - זו מחלקת כל בעיות הההכרעה שאפשר לפתור עם אלגוריתם שפועל <strong>בסיבוכיות זיכרון פולינומית</strong> (כלומר, המקום שהוא צריך בשביל לאחסן מידע הוא פולינומי בגודל הקלט). העניין הוא שההגדרה היבשה הזו לא מעבירה טוב עד כמה המחלקה הזו גדולה יחסית - רוב האקשן של תורת הסיבוכיות מתרחש בתוכה. <a href="https://gadial.net/2011/04/04/what_is_pspace/">הנה פוסט שלי על המחלקה הזו</a> שאולי יעזור להבהיר את זה יותר.</p>
<p>אם כן, זו <span class="math">\(\text{IP}\)</span>, אבל מהי <span class="math">\(\text{MIP}\)</span>? זו הכללה די מתבקשת של <span class="math">\(\text{IP}\)</span> ששואלת את השאלה - מה קורה אם יש לנו שני מוכיחים במקום מוכיח אחד? על פניו, לא אמור לקרות שום דבר חדש. הרי כבר מוכיח אחד הוא כל-יכול מבחינה חישובית, הוא לא צריך שעוד אחד יעזור לו. אבל כזכור, נקודת המבט שלנו על הוכחות אינטראקטיביות היא ש<strong>המוכיח הוא האויב</strong> ולכן המטרה של שני מוכיחים במקום אחד היא דווקא לעזור לנו להפיל בפח "מוכיחים" רמאים שמנסים לעבוד עלינו.</p>
<p>לרעיון הזה יש אנלוגיה פשוטה מחיי היום יום, שהיא כל כך מתבקשת עד שהופיעה כבר במאמר המקורי שבו <span class="math">\(\text{MIP}\)</span> הוגדרה: פושעים. חשבו על שני פושעים שביצעו ביחד פשע ולאחר מכן תיאמו ביניהם את האליבי. ואז המשטרה תופסת אותם וחוקרת אותם <strong>בנפרד</strong>. החקירה הזו נותנת <strong>יתרון</strong> לחוקרי המשטרה על פני חקירה של אחד מהפושעים ותו לא, כי כך ניתן לגלות <strong>סתירות</strong> בין הגרסאות שלהם, אם תיאום האליבי לא היה טוב מספיק.</p>
<p>את ההגדרה היבשה קל לתת, היא כמעט זהה להגדרה של <span class="math">\(\text{IP}\)</span>: אנחנו אומרים שבעיה <span class="math">\(L\)</span> שייכת למחלקה MIP (ראשי תיבות של Multiprover Interactive Proof) אם קיים מוודא הסתברותי יעיל <span class="math">\(V\)</span> כך שלכל <span class="math">\(x\)</span>:</p>
<ol> <li>(שלמות) אם <span class="math">\(x\in L\)</span> אז <strong>קיימים</strong> זוג מוכיחים <span class="math">\(P_{1},P_{2}\)</span> כך שההסתברות ש-<span class="math">\(V\)</span> יגיד "כן" על <span class="math">\(x\)</span> בסוף הפרוטוקול עם המוכיחים היא לפחות <span class="math">\(\frac{2}{3}\)</span>.</li>


<li>(נאותות) אם <span class="math">\(x\notin L\)</span> אז <strong>לכל</strong> זוג מוכיחים <span class="math">\(P_{1},P_{2}\)</span> ההסתברות ש-<span class="math">\(V\)</span> יגיד "כן" על <span class="math">\(x\)</span> בסוף הפרוטוקול עם המוכיחים היא לכל היותר <span class="math">\(\frac{1}{3}\)</span>.</li>

</ol>

<p>אפשר כמובן לשאול למה רק שני מוכיחים ולא יותר מכך - הסיבה היא פשוט שלא צריך יותר מכך; כבר במאמר שהציג את <span class="math">\(\text{MIP}\)</span> ניתנה ההוכחה לכך שהוספת מוכיחים נוספים לא מגדילה את המחלקה <span class="math">\(\text{MIP}\)</span>.</p>
<p>כמה שנים אחרי שהוגדרה, התברר שגם <span class="math">\(\text{MIP}\)</span> גדולה בצורה מרשימה: היא שווה למחלקה שנקראת <span class="math">\(\text{NEXP}\)</span>, שהיא כמו <span class="math">\(\text{NP}\)</span> רק שהמוודא יכול לרוץ בזמן <strong>אקספוננציאלי</strong>. כדי להבין עד כמה זה גדול, חשבו על זה כך: נכון שאמרתי ש-<span class="math">\(\text{PSPACE}\)</span> גדולה ועצומה? למרות כל זה, אין לנו שום הוכחה כרגע ש-<span class="math">\(\text{P}\ne\text{PSPACE}\)</span>, כלומר ייתכן שכל מה שקורה בתוך <span class="math">\(\text{PSPACE}\)</span> "יקרוס" לכך שהכל פשוט קל לחישוב וזהו (זה מאוד, מאוד לא סביר שזה מה שיקרה; התעלומה היא פחות האם המחלקות באמת שונות ויותר איך לכל הרוחות אפשר להוכיח דבר כזה). לעומת זאת עבור <span class="math">\(\text{NEXP}\)</span> יש הוכחה פשוטה יחסית לכך שהיא שונה מ-<span class="math">\(\text{NP}\)</span>, כך ש-<span class="math">\(\text{MIP}\)</span> היא <strong>באמת יותר חזקה</strong> מ-<span class="math">\(\text{NP}\)</span> (לעומת <span class="math">\(\text{IP}\)</span> שאנחנו פשוט לא יודעים לגביה).</p>
<p>עכשיו אנחנו מגיעים סוף כל סוף אל <span class="math">\(\text{MIP}^{*}\)</span>. המחלקה הזו נולדת משאלה פשוטה יחסית - כשאנחנו מתארים אינטואיטיבית את <span class="math">\(\text{MIP}\)</span> אנחנו אומרים שהמוכיחים יכולים להסכים על דרך פעולה משותפת <strong>לפני</strong> שהחקירה מתחילה אבל לא יכולים לתקשר זה עם זה אחריה. כלומר, יש שלב של "שיתוף מידע" לפני שהפרוטוקול מתחיל. מה בדיוק המידע המשותף הזה? בניסוח המקורי של <span class="math">\(\text{MIP}\)</span> מרשים למוכיחים לשתף ביניהם אינסוף ביטים הסתברותיים - כאילו מטבע הוטל אינסוף פעמים ויש לכל המוכיחים גישה לסדרת התוצאות של ההטלה (זה אומר שהמוכיחים יכולים לבצע חישובים הסתברותיים "מתואמים"). אלא שהיכולת הנוספת הזו לא באמת רלוונטית לרוב הדברים שעושים עם המחלקה הזו ולא מוסיפה לה כוח ולכן לפעמים פשוט משמיטים אותה.</p>
<p><span class="math">\(\text{MIP}\)</span> הופכת ל-<span class="math">\(\text{MIP}^{*}\)</span> כשהמידע שמשותף לפני תחילת הפרוטוקול הוא <strong>מצב קוונטי שזור</strong>. הופס, ביצענו את החטא הקדמון - הוספנו באזוורדס לעולם היפה והנקי של תורת הסיבוכיות! ואכן, "מצב קוונטי" נראה במבט ראשון כמו איזה מושג זר לכל מה שדיברנו עליו עד כה - קוונטים זה משהו בפיזיקה ומה בכלל הקשר לאבסטרקציות של חישוב.</p>
<p>בפועל, "מצב קוונטי" זה לא משהו שונה במיוחד ברמה העקרונית מהוספת יכולת הסתברותית ולקרוא לה "מחשב שיכול להטיל מטבעות". בשני המקרים יש כאן ניצול של תופעת טבע "חיצונית" לאלגוריתם כדי לאפשר לו לשפר ביצועים. בשני המקרים זה מגיע עם תורה מתמטית רלוונטית - תורת ההסתברות במקרה של מכונות שמטילות מטבעות, ותורת האינפורמציה הקוונטית במקרה של מצב קוונטי. הבעיה היא שמצב קוונטי קצת יותר קשה להסביר. י<a href="https://gadial.net/2014/07/17/quantum_computing_intro/">ש לי סדרת פוסטים על חישוב קוונטי</a> ואולי גם אכתוב עוד אחת בעתיד הקרוב אז פה אנסה לתת רק טיפה אינטואיציה.</p>
<p>תורת הקוונטים היא נסיון לעשות סדר בבלאגן שהוא האופן המוזר שבו דברים מתנהגים בסקלות גודל נמוכות - נסיון שהצליח בצורה מרשימה ביותר. הכלי המתמטי הבסיסי שבו משתמשים לצורך עשיית הסדר הזה הוא <strong>סופרפוזיציה</strong>: אם יש לנו מערכת שכשאנחנו מודדים אותה אנחנו מגלים שהיא נמצאת באחד מכמה "מצבי בסיס" אפשריים - למשל <span class="math">\(\left|0\right\rangle \)</span> ו-<span class="math">\(\left|1\right\rangle \)</span> - אז התיאור הכללי של מצב המערכת הוא בתור <strong>צירוף לינארי</strong> של המצבים הללו, כשהמרחב שלנו חי מעל המספרים המרוכבים <span class="math">\(\mathbb{C}\)</span>. כלומר, מצב קוונטי "כללי" עבור שני מצבי הבסיס הללו הוא <span class="math">\(\alpha\left|0\right\rangle +\beta\left|1\right\rangle \)</span> כעוד דרישה היא שהמצב יהיה <strong>מנורמה </strong><strong>1</strong>, כלומר <span class="math">\(\left|\alpha\right|^{2}+\left|\beta\right|^{2}=1\)</span>.</p>
<p>בסיטואציה כזו אפשר לעשות שני דברים עם המצב: לשנות אותו בצורה שלא "שוברת" את הסופרפוזיציה - זה ניתן לתיאור על ידי הפעלת טרנספורמציה לינארית אוניטרית על המצב - או "למדוד" אותו, מה שמכריח את הסופרפוזיציה "לקרוס": אחד משני מצבי היסוד נבחר באופן אקראי והמצב משתנה אליו. ה"מידע" על <span class="math">\(\alpha,\beta\)</span> פשוט נמחק. הדרך היחידה שבה הוא מתבטא היא בכך שהמצב <span class="math">\(\left|0\right\rangle \)</span> נבחר לתוצאת המדידה בהסתברות <span class="math">\(\left|\alpha\right|^{2}\)</span> והמצב <span class="math">\(\left|1\right\rangle \)</span> נבחר בהסתברות <span class="math">\(\left|\beta\right|^{2}\)</span>.</p>
<p>במבט ראשון לא ברור בשביל מה כל זה טוב, אז הנה סיבוך של הסיפור. מה שתיארתי כרגע נקרא "קיוביט" - מערכת עם שני מצבי בסיס שקצת מזכירה ביט קלאסי שהוא או 0 או 1. אבל אפשר גם לבנות מערכות של שני קיוביטים או יותר, והסיפור בהן מסתבך. ל-3 קיוביטים, למשל, כבר יש שמונה מצבי יסוד אפשריים: <span class="math">\(\left|000\right\rangle ,\left|001\right\rangle ,\ldots,\left|111\right\rangle \)</span> ולכן סופרפוזיציה של שלושה קיוביטים היא כבר משהו שחי במרחב וקטורי ממימד 8, ואם תקחו <span class="math">\(n\)</span> קיוביטים תקבלו מרחב ממימד <span class="math">\(2^{n}\)</span> - יש כאן <strong>גידול אקספוננציאלי</strong> של מה שאנחנו יודעים לייצג. זה לא מתורגם בקלות ליתרון חישובי כלשהו כי יש לנו מגבלות גדולות לגבי מה שאפשר לעשות עם המצב הזה - אבל יש דרכים להפיק ממנו תועלת, כשהמפורסמת שבהם היא <strong>האלגוריתם של שור</strong> לפירוק לגורמים של מספרים בזמן פולינומי. לא נדבר על זה הפעם.</p>
<p>על מה אני כן רוצה לדבר? שזירות. נדבר שניה על מערכת בת שני קיוביטים. נניח שסתם לקחנו שני קיוביטים ושמנו אותם אחד באיזור של השני ואנחנו מנסים לחשוב עליהם בתור מערכת אחת - מה יקרה? אם הראשון הוא <span class="math">\(\alpha_{1}\left|0\right\rangle +\beta_{1}\left|1\right\rangle \)</span> והשני הוא <span class="math">\(\alpha_{2}\left|0\right\rangle +\beta_{2}\left|1\right\rangle \)</span> אז אפשר לחשוב על המערכת המשולבת שלהם בתור מין מכפלה של שני אלו:</p>
<p><span class="math">\(\left(\alpha_{1}\left|0\right\rangle +\beta_{1}\left|1\right\rangle \right)\left(\alpha_{2}\left|0\right\rangle +\beta_{2}\left|1\right\rangle \right)=\alpha_{1}\alpha_{2}\left|00\right\rangle +\alpha_{1}\beta_{2}\left|01\right\rangle +\beta_{1}\alpha_{2}\left|10\right\rangle +\beta_{1}\beta_{2}\left|11\right\rangle \)</span></p>
<p>אלא שזה <strong>לא כל מה שאפשר לעשות עם קיוביטים</strong>. בעזרת מניפולציה קצת יותר מתוחכמת אפשר לייצר את המצב הקוונטי הבא:</p>
<p><span class="math">\(\frac{\left|00\right\rangle +\left|11\right\rangle }{\sqrt{2}}\)</span></p>
<p>וזה מצב שאם תבדקו קצת תראו שפשוט <strong>אי אפשר לקבל</strong> בעזרת הנוסחה שכתבתי למעלה עם ה-<span class="math">\(\alpha\)</span>-ות וה-<span class="math">\(\beta\)</span>-ות: אפשר לייצר מצבים קוונטים שהם מהותית יותר מאשר "שני קיוביטים יושבים אחד ליד השני". שני הקיוביטים איכשהו "מעורבבים" זה עם זה בצורה בלתי פריקה: קוראים לזה <strong>מצב שזור</strong>. אם אני לוקח את המצב השזור בדוגמא שלי ומודד את הקיוביט הראשון ומקבל <span class="math">\(\left|0\right\rangle \)</span> זה מעביר <strong>את כל המערכת</strong> למצב <span class="math">\(\left|00\right\rangle \)</span>, כלומר משפיע גם על מצב הקיוביט השני. והדבר הזה קורה <strong>לא משנה איפה ביקום הקיוביט השני הזה נמצא</strong>. גם אם לקחתי שני עצירים לתאי חקירה נפרדים, אבל לכל אחד מהם יש קיוביט משלו מתוך מערכת שזירה, ואחד מהם מודד את הקיוביט הזה, <strong>הקיוביט של העציר השני יושפע מזה</strong>.</p>
<p>זה מחזיר אותנו אל <span class="math">\(\text{MIP}^{*}\)</span>. אנחנו עדיין לא מבינים את הפורמליזם המתמטי (ולא אכנס אליו בפוסט הזה), אבל תוספת המצב הקוונטי השזור פותחת פתח לתקשורת בין המוכיחים שלא הייתה אפשרית קודם. וכאן מגיע החלק המוזר ביותר בכל הסיפור. על פניו, הוספת היכולת הזו <strong>מחזקת</strong> את המוכיחים. אבל כזכור, <strong>המוכיח הוא האויב</strong>. בכך שאנחנו מחזקים אותם ונותנים להם פתח <strong>כלשהו</strong> לתקשורת, אנחנו עוזרים להם לעבוד עלינו ורק <strong>מחלישים</strong> את מה שאנחנו יודעים לעשות עם הוכחות אינטראקטיביות. במאמר שבו <span class="math">\(\text{MIP}^{*}\)</span> נולדה, זה מה שעשו - הראו איך פרוטוקולים מסויימים של הוכחות אינטראקטיביות לא יכולות לעבוד יותר. עם זאת, הצביעו גם על כך שזה לא מוכיח ש-<span class="math">\(\text{MIP}^{*}\)</span> חלשה יותר מ-<span class="math">\(\text{MIP}\)</span>; זה שנפסלו פרוטוקולים מסויימים לא אומר שלא יכולים להיות אחרים שמשתמשים איכשהו בשזירות <strong>לטובת המוודא</strong>.</p>
<p>בשנים מאז הגדרת <span class="math">\(\text{MIP}^{*}\)</span> הגיעו שלל תוצאות מרהיבות שהראו ש<strong>זה בדיוק המצב</strong>. ראשית, הוכחה ש-<span class="math">\(\text{NEXP}\subseteq\text{MIP}^{*}\)</span>, כלומר שמערכות הוכחה קוונטיות שכאלו חזקות <strong>לפחות כמו</strong> מערכות הוכחה קלאסיות. אחר כך, הוכחה ש-<span class="math">\(\text{NEEXP}\subseteq\text{MIP}^{*}\)</span> כאשר NEEXP (שימו לב ל-E הנוסף!) היא ההכללה של <span class="math">\(\text{NP}\)</span> למוודא עם זמן ריצה אקספוננציאלי-כפול (אקספוננציאלי זה סדר גודל של <span class="math">\(2^{n}\)</span>; אקספוננציאלי כפול זה סדר גודל של <span class="math">\(2^{2^{n}}\)</span>). כאן כבר היה שמשהו מאוד מוזר קורה פה וש-<span class="math">\(\text{MIP}^{*}\)</span> היא מחלקה חזקה עד להפתיע - אבל עד כמה? מה הגבול העליון? גבול עליון "טריוויאלי" היה <span class="math">\(\text{RE}\)</span>, כי עם הכוח החישובי הבלתי מוגבל של מוודא <span class="math">\(\text{RE}\)</span> אפשר לקבל מה שנראה כמו תעתיק של פרוטוקול <span class="math">\(\text{MIP}^{*}\)</span> ולבדוק שהכל עובד בו כמו שצריך - אבל <span class="math">\(\text{RE}\)</span> הוא חסם עליון מפחיד בגובהו. ואז <span class="math">\(\text{MIP}^{*}\)</span> הגיעה בבום אל החסם העליון הזה. זו התוצאה <span class="math">\(\text{MIP}^{*}=\text{RE}\)</span>. הרעיון, כפי שרמזתי בפוסט הקודם, היה להציג פרוטוקול <span class="math">\(\text{MIP}^{*}\)</span> עבור <strong>בעיית העצירה</strong>.</p>
<p>אני עדיין לא מבין איך זה עובד. קראתי כבר סקירות כלליות של הרעיונות הכלליים בלי להיכנס לעומק הפרטים, וזה עדיין מאוד, מאוד מוזר לי. הראש שלי עדיין אומר לי שאם הוספנו למוכיחים שזירות אז רק עזרנו להם לעבוד עלינו, וזהו. המאמרים מנסים לתת אינטואיציה לכך שזה לא המצב: שעכשיו המוודא יכול לערוך למוכיחים מבחנים שלא היה אפשר לבצע קודם, כאלו שיאלצו אותם להוכיח שהמצב הקוונטי המשותף להם קרוב למצב קוונטי <strong>ספציפי</strong>. אבל הפרטים עדיין לא מתחברים לי עד הסוף. אם אצליח לחבר אותם קצת יותר טוב, זה יופיע בתור פוסט המשך לשני הפוסטים הנוכחיים.</p>
<p>בכל זאת, לסיום, אני רוצה להבהיר כמה נקודות מבלבלות שכבר ראיתי שצצו בהקשר הזה.</p>
<p>ראשית, מה שקוונטי בסיפור הזה הוא <strong>המוכיחים</strong>, לא המוודא. המוודא ממשיך להיות אלגוריתם הסתברותי רגיל. זה שונה מדברים כמו האלגוריתם של שור, שבהם האלגוריתם שפותר את הבעיה הוא בעצמו קוונטי. אם ניקח מערכת הוכחה אינטראקטיבית ונוסיף יכולת קוונטית למוודא אבל לא למוכיחים, <strong>זה לא יוסיף כוח למערכת</strong>. כלומר, המחלקה <span class="math">\(\text{QIP}\)</span> שהוגדרה בתור ההכללה של <span class="math">\(\text{IP}\)</span> למוודא קוונטי מקיימת <span class="math">\(\text{QIP}=\text{IP}=\text{PSPACE}\)</span>. בדומה, <span class="math">\(\text{QMIP}_{\text{NE}}=\text{NEXP}\)</span> כאשר <span class="math">\(\text{QMIP}_{\text{NE}}\)</span> היא המחלקה של חישוב מרובה מוכיחים שבו המוודא קוונטי אבל למוכיחים אין מצב שזור קוונטית (זה ה-<span class="math">\(\text{NE}\)</span> שלמטה).</p>
<p>שנית, אני לא רוצה שיהיה בלבול כלשהו בנקודה הזו - התוצאה הזו <strong>לא מראה</strong> שאפשר להשתמש איכשהו בתורת הקוונטים בשביל לפתור את בעיית העצירה! לא, לא, לא! בעיית העצירה הייתה ונותרה בלתי פתירה. כל ההקשר של הדיון הוא <strong>מערכת הוכחה</strong> עבור בעיית העצירה, וכבר ראינו שמערכת הוכחה "קלאסית", שבה המוודא מקבל ליד הוכחה כתובה ותו לא - היא עצמה מספיקה בשביל <strong>לוודא</strong> את בעיית העצירה (לא לפתור - לוודא). מה שקורה ב-<span class="math">\(\text{MIP}^{*}=\text{RE}\)</span> הוא שאנחנו רואים שאפשר <strong>להחליש מאוד את המוודא</strong> ועדיין להצליח לוודא את בעיית העצירה, אם המוכיחים הם חזקים מספיק. אז בבקשה, אני לא רוצה לראות עוד כותרות כמו "'Remarkable' Mathematical Proof Describes How to Solve Seemingly Impossible Computing Problem". המציאות מספיק יפה, לא צריך לגלוש לפנטזיות.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>