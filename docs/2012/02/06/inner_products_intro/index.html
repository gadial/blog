<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מכפלות פנימיות - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/new_blog/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/new_blog/">דף הבית</a>
                <a href="/new_blog/random.html">פוסט אקראי</a>
                <a href="/new_blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_blog/2012/02/02/scalar_products/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">עם קצת עבודה, מגיעים למכפלה סקלרית</span>
            </a>
            

            
            <a href="/new_blog/2012/02/25/bad_math_law_of_large_numbers/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">חוק המספרים הגדולים עושה אותך כזה קטן</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מכפלות פנימיות</h1>
            <div class="post-meta">
                <span class="date">2012-02-06</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אלגברה לינארית.html">אלגברה לינארית</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/בסיס אורתונורמלי.html">בסיס אורתונורמלי</a>
                    
                    <a href="/tags/מכפלה פנימית.html">מכפלה פנימית</a>
                    
                    <a href="/tags/תהליך גרם-שמידט.html">תהליך גרם-שמידט</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסט הקודם הצגתי את מושג המכפלה הסקלרית, והפעם אני רוצה לקפוץ ישר להכללה בלי לתת יותר מדי מוטיבציה. אז בואו נחזור לדבר על ההקשר הרגיל של אלגברה לינארית - מרחבים וקטוריים מעל שדה <span class="math">\(\mathbb{F}\)</span>. נתחיל מלדבר על המרחב <span class="math">\(\mathbb{F}^{n}\)</span>. וקטור ממוצע בו נראה כך: <span class="math">\(x=\left(x_{1},x_{2},\dots,x_{n}\right)\)</span> כאשר <span class="math">\(x_{i}\in\mathbb{F}\)</span>. בהינתן וקטור אחר <span class="math">\(y=\left(y_{1},\dots,y_{n}\right)\)</span>, <strong>נגדיר</strong> את המכפלה הסקלרית שלהם להיות <span class="math">\(x\cdot y=\sum_{i=1}^{n}x_{i}y_{i}\)</span>. כלומר, כופלים כל "רכיב" לחוד, וסוכמים את התוצאה.</p>
<p>יפה. הגדרנו פונקציה חשובה ושימושית בהקשרים רבים ושונים שלא אציג כעת. אלא שלפונקציה הזו יש הכללה רבת עוצמה ביותר, שפותחת פתח לתחום נרחב באלגברה לינארית שטרם נגעתי בו - מרחבי מכפלה פנימית - ולכן אני רוצה להבין קצת איך הפונקציה הזו מתנהגת.</p>
<p>האבחנה הראשונה היא שהכפל הזה מקיים דיסטריביוטיביות: <span class="math">\(\left(x+y\right)\cdot z=x\cdot z+y\cdot z\)</span> (בדקו זאת - זה נובע ישירות מההגדרה), אבל כבר צריך להיזהר כאן - החיבור שבאגף שמאל הוא חיבור וקטורים, בעוד שהחיבור באגף ימין הוא חיבור סקלרים, מכיוון שמכפלה סקלרית לוקחת זוג וקטורים והופכת אותו לסקלר. לכן אין שום משמעות לביטוי כמו <span class="math">\(x\cdot y\cdot z\)</span>: שכן <span class="math">\(x\cdot y\)</span> הוא סקלר, ולכן אי אפשר לכפול אותו סקלרית ב-<span class="math">\(z\)</span>. מה שכן, אם <span class="math">\(\lambda\)</span> הוא סקלר, אז קל לראות ש-<span class="math">\(\lambda\times\left(x\cdot y\right)=\left(\lambda\otimes x\right)\cdot y\)</span>. כאן מופיעים שלושה כפלים שונים בו זמנית ולכן הרשיתי לעצמי לסמן אותם בסימונים מוזרים: <span class="math">\(\cdot\)</span> היא המכפלה הסקלרית (של שני וקטורים), <span class="math">\(\times\)</span> היא מכפלה של שני סקלרים ב-<span class="math">\(\mathbb{F}\)</span> ו-<span class="math">\(\otimes\)</span> היא המכפלה של סקלר בוקטור. הערבוב הגדול הזה של סוגי המכפלות השונות הוא כנראה אחת מהסיבות שבגללן נשתמש בעיקר בסימון <span class="math">\(\left\langle x,y\right\rangle \)</span> כדי לתאר מכפלה פנימית של וקטורים.</p>
<p>פעולה כזו, שלוקחת וקטורים ומחזירה סקלר, אינה חדשה לנו - כבר ראינו בעבר פוסטים על <a href="http://www.gadial.net/2011/11/02/linear_functionals/">פונקציונלים לינאריים</a> שהן טרנספורמציות לינארית שלוקחות וקטור ומחזירות סקלר, וגם ראינו ש<a href="http://www.gadial.net/2011/11/10/determinants/">דטרמיננטה</a> היא טרנספורמציה מולטי-לינארית שלוקחת וקטורים ומחזירה סקלר. מכפלה סקלרית היא מה שנקרא פונקציה בילינארית ("דו-לינארית") כי היא על שני משתנים (חשבו על הפונקציה <span class="math">\(f\left(x,y\right)=x\cdot y\)</span>).</p>
<p>תכונה אחת שיש למכפלה סקלרית ולא קיימת אצל חלק מהפונקציות הבילינאריות היא <strong>סימטריה</strong>: <span class="math">\(x\cdot y=y\cdot x\)</span>. טבעי יהיה להכניס גם את התכונה הזו להכללה שלנו (ומן הסתם נראה בהמשך כיצד היא מסייעת).</p>
<p>התכונה האחרונה היא הבעייתית ביותר. הבה ונשאל את עצמנו מה קורה ב-<span class="math">\(\mathbb{R}\)</span> כאשר אנחנו כופלים וקטור סקלרית עם עצמו. מכיוון שהזווית בינו לעצמו היא 0, נקבל פשוט <span class="math">\(\left|v\right|^{2}\)</span>, כלומר את האורך של <span class="math">\(\left|v\right|\)</span> בריבוע. לכן אנחנו יכולים לצפות שהאורך של וקטור תמיד יהיה נתון על ידי שורש של המכפלה הפנימית שלו בעצמו. עם מושג של אורך אפשר לעשות דברים נפלאים, אבל כדי שאפשר יהיה לעשות אותם האורך צריך להיות מה שאנחנו מצפים שהוא יהיה - מספר ממשי, וכזה שגדול מאפס אם הוקטור שונה מאפס (שוב, קשה להצדיק את זה כרגע בלי שתראו מה עושים עם זה, אבל סמכו עלי שזהו המצב).</p>
<p>לרוע המזל, מעל שדה <span class="math">\(\mathbb{F}\)</span> כללי אין שום סיבה להניח שנקבל ש-<span class="math">\(\left|v\right|^{2}\)</span> הוא בכלל איבר של <span class="math">\(\mathbb{R}\)</span>, לא כל שכן איבר חיובי ששונה מאפס אם <span class="math">\(v\)</span> שונה מאפס. זה מוביל אותנו להגבלה המצערת הראשונה שלנו - אנחנו הולכים להגדיר מכפלה פנימית אך ורק במקרים שבהם <span class="math">\(\mathbb{F=R}\)</span> או <span class="math">\(\mathbb{F=C}\)</span>, ושום מקרה אחר. היינו יכולים לנסות ולעשות את זה גם במקרים אחרים, אבל התיאוריה פשוט לא הייתה עובדת. זו דוגמה לסיטואציה במתמטיקה שבה אנחנו צריכים להיות אבסטרקטיים <strong>פחות</strong>, כי תוצאות יפות וחזקות ספציפיות תקפות רק במקרה פרטי מסויים.</p>
<p>עכשיו אני יכול להציג את ההכללה סוף סוף. אם <span class="math">\(V\)</span> הוא מרחב וקטורי מעל <span class="math">\(\mathbb{R}\)</span>, אז <strong>מכפלה פנימית</strong> היא פונקציה <span class="math">\(\left\langle \cdot,\cdot\right\rangle :V\times V\to\mathbb{R}\)</span> אשר מקיימת:</p>
<ol>
    <li> <span class="math">\(\left\langle x+y,z\right\rangle =\left\langle x,z\right\rangle +\left\langle y,z\right\rangle \)</span> לכל <span class="math">\(x,y,z\in V\)</span>.</li>
    <li> <span class="math">\(\left\langle \lambda x,y\right\rangle =\lambda\left\langle x,y\right\rangle \)</span> לכל <span class="math">\(x,y\in V\)</span> ו-<span class="math">\(\lambda\in\mathbb{R}\)</span>.</li>
    <li> <span class="math">\(\left\langle x,y\right\rangle =\left\langle y,x\right\rangle \)</span> לכל <span class="math">\(x,y\in V\)</span>.</li>
    <li> <span class="math">\(\left\langle x,x\right\rangle \ge0\)</span> לכל <span class="math">\(x\in V\)</span> ו-<span class="math">\(x=0\iff\left\langle x,x\right\rangle =0\)</span>.</li>
</ol>
<p>שימו לב שהסימטריה נותנת לי מייד תכונות כמו <span class="math">\(\left\langle x,y+z\right\rangle =\left\langle x,y\right\rangle +\left\langle x,z\right\rangle \)</span> ו-<span class="math">\(\left\langle x,\lambda y\right\rangle =\lambda\left\langle x,y\right\rangle \)</span>.</p>
<p>טוב, אז הגדרנו הגדרה. כדי שהיא תהיה מעניינת, צריך להראות שיש לה באמת דוגמאות לא טריוויאליות, חוץ מהמכפלה הסקלרית שכבר ראינו. הנה הדוגמה הקלאסית שקופצת לי לראש: נסתכל במרחב <span class="math">\(V=\text{C}\left[0,1\right]\)</span> - מרחב הפונקציות <span class="math">\(f:\left[0,1\right]\to\mathbb{R}\)</span> (<span class="math">\(\left[0,1\right]\)</span> הוא הקטע הסגור שכולל את כל הממשיים בין 0 ל-1 כולל) שהן רציפות (אני מניח שהמושג מוכר לקוראים - אם לא, אני ממליץ לקרוא על פונקציות רציפות; ואם לא, לא סוף העולם - זו רק דוגמה). לא קשה לראות שזה אכן מרחב וקטורי מעל <span class="math">\(\mathbb{R}\)</span>. את המכפלה הפנימית נגדיר כך:</p>
<p><span class="math">\(\left\langle f,g\right\rangle =\int_{0}^{1}f\left(x\right)g\left(x\right)dx\)</span></p>
<p>קל למדי לראות שתכונות 1-3 מתקיימות, בזכות תכונות הלינאריות של האינטגרל. תכונה 4 היא מאתגרת קצת יותר - אנחנו רוצים לטעון שאם <span class="math">\(f\not\equiv0\)</span> (כאן <span class="math">\(0\)</span> היא הפונקציה שמחזירה 0 לכל אברי <span class="math">\(\left[0,1\right]\)</span>) אז <span class="math">\(\int_{0}^{1}f^{2}\left(x\right)dx&amp;gt;0\)</span>. כאן הרציפות של <span class="math">\(f\)</span> קריטית; אם היינו מרשים ל-<span class="math">\(f\)</span> להיות לא רציפה, ולו בנקודה אחת, היינו מקבלים פונקציות שונות מאפס שהמכפלה הפנימית שלהן עם עצמן היא 0 (פשוט תבחרו פונקציה שהיא 0 בכל מקום חוץ מבנקודת האי-רציפות, ושם היא תהיה 1 למשל).</p>
<p>אם כן, <span class="math">\(f\)</span> רציפה. בנוסף, <span class="math">\(f^{2}\left(x\right)\ge0\)</span> לכל <span class="math">\(x\in\left[0,1\right]\)</span>, ולכן <span class="math">\(\int_{0}^{1}f^{2}\left(x\right)dx\)</span> חיובי או אפס. מה שאני הולך לעשות עכשיו הוא פשוט לטעון שיש סביבה כלשהי שבה כל ערכי <span class="math">\(f\)</span> גדולים מאפס ולכן השטח שלה חיובי: מכיוון ש-<span class="math">\(f\)</span> רציפה ושונה מאפס, אז קיים <span class="math">\(c\in\left[0,1\right]\)</span> כך ש-<span class="math">\(f\left(c\right)&gt;0\)</span>. מכיוון שהיא רציפה, אז עבור <span class="math">\(\varepsilon=\frac{f\left(c\right)}{2}\)</span> קיימת <span class="math">\(\delta&gt;0\)</span> כך ש-<span class="math">\(\left|f\left(x\right)-f\left(c\right)\right|&lt;\varepsilon\)</span> אם <span class="math">\(\left|x-c\right|&lt;\delta\)</span>. לכן יש לנו קטע, מאורך <span class="math">\(\delta\)</span> לכל הפחות, שלכל הנקודות בו מתקיים <span class="math">\(f\left(x\right)&lt;\varepsilon-f\left(c\right)=\frac{1}{2}f\left(c\right)\)</span> (למה מאורך <span class="math">\(\delta\)</span> ולא <span class="math">\(2\delta\)</span>? כי <span class="math">\(c\)</span> יכולה להיות גם בקצוות). מכאן שהאינטגרל מקיים <span class="math">\(\int_{0}^{1}f^{2}\left(x\right)dx\ge\delta\cdot\left(\frac{1}{2}f\left(c\right)\right)^{2}&amp;gt;0\)</span> וסיימנו.</p>
<p>לפני שאמשיך, אני רוצה לדבר על מה קורה מעל <span class="math">\(\mathbb{C}\)</span>. אפשר היה לקוות שנוכל לקחת את ההגדרה שלעיל ופשוט להחליף כל מופע של <span class="math">\(\mathbb{R}\)</span> ב-<span class="math">\(\mathbb{C}\)</span>, אבל לרוע המזל זה לא עובד. בואו ונראה למה:</p>
<p><span class="math">\(\left\langle i,i\right\rangle =i\left\langle 1,i\right\rangle =i\left\langle i,1\right\rangle =i^{2}\left\langle 1,1\right\rangle =-\left\langle 1,1\right\rangle \)</span></p>
<p>ומה קיבלנו כאן? מצד אחד, <span class="math">\(\left\langle 1,1\right\rangle &gt;0\)</span> כי <span class="math">\(1\ne0\)</span> ותכונה 4; מצד שני, זה אומר ש-<span class="math">\(\left\langle i,i\right\rangle \)</span> חייב להיות שלילי, בסתירה לתכונה 4. משהו נשתבש בהגדרות שלנו, ומסתבר שהתכונה הסוררת היא 3, וניתן לתקנה די בקלות, אם כי במחיר של אובדן חלק מה"טבעיות" של ההגדרה (אחרי שמתרגלים מבינים שזה כן טבעי). בואו נזכור שאם <span class="math">\(z=a+bi\)</span> הוא מספר מרוכב (<span class="math">\(a,b\in\mathbb{R}\)</span>) אז ה<strong>צמוד</strong> שלו מוגדר כ-<span class="math">\(\overline{z}=\overline{a+bi}=a-bi\)</span>. את תכונה 3 נגדיר כעת מחדש כך: <span class="math">\(\left\langle x,y\right\rangle =\overline{\left\langle y,x\right\rangle }\)</span> לכל <span class="math">\(x,y\in V\)</span>. זה הכל, ובמקרה שאנחנו מעל השדה <span class="math">\(\mathbb{R}\)</span> לא שינינו כלום כי <span class="math">\(\overline{\left\langle x,y\right\rangle }=\left\langle x,y\right\rangle \)</span> עבור מספרים ממשיים. לתכונה 3 המשודרגת קוראים <strong>הרמיטיות</strong> (על שם המתמטיקאי הרמיט). שימו לב שבמקרה של <span class="math">\(\mathbb{C}\)</span>, תכונה 4 היא משמעותית חזקה יותר מאשר קודם - אם <span class="math">\(\left\langle x,x\right\rangle \ge0\)</span> זה בפרט אומר ש-<span class="math">\(\left\langle x,x\right\rangle \)</span> הוא מספר ממשי (מספרים מרוכבים לא ממשיים לא ניתנים להשוואה עם אפס).</p>
<p>מה שכן, עלינו להיות טיפה זהירים. אמנם, עדיין מתקיים ש-<span class="math">\(\left\langle \lambda x,y\right\rangle =\lambda\left\langle x,y\right\rangle \)</span>, אבל לחלוטין לא מתקיים <span class="math">\(\left\langle x,\lambda y\right\rangle =\lambda\left\langle x,y\right\rangle \)</span>; אם נשתמש בהרמיטיות נקבל <span class="math">\(\left\langle x,\lambda y\right\rangle =\overline{\lambda}\left\langle x,y\right\rangle \)</span>.</p>
<p>מעכשיו אמשיך לפתח את כל התורה עבור <span class="math">\(\mathbb{C}\)</span> בלבד, והסימן של הצמוד יופיע לא מעט, אבל זכרו שאפשר לעשות את אותם דברים בדיוק שאעשה כאן גם עבור <span class="math">\(\mathbb{R}\)</span> ופשוט להסיר את הצמוד.</p>
<p>מכפלה סקלרית על <span class="math">\(\mathbb{C}^{n}\)</span> נראית כמעט כמו מכפלה סקלרית "רגילה", רק שצריך להכניס את הצמוד לתמונה אחרת נאבד את ההרמיטיות. כלומר, אם <span class="math">\(x,y\in\mathbb{C}^{n}\)</span> אז נגדיר <span class="math">\(x\cdot y=\sum_{i=1}^{n}x_{i}\overline{y_{i}}\)</span>, וזו תהיה ההגדרה שנעבוד איתה מעתה למכפלה סקלרית.</p>
<p>בואו ניגש לעבודה האמיתית - נתחיל מלהבין איך נראות <strong>כל</strong> המכפלות הפנימיות על מרחב וקטורי <span class="math">\(V\)</span> שהוא סוף-ממדי (במרחבים אינסוף ממדיים הסיפור, כרגיל, מסובך פי כמה וכמה). יהי אם כן <span class="math">\(V\)</span> מרחב וקטורי כלשהו ממימד <span class="math">\(n\)</span> ו-<span class="math">\(B=\left\{ b_{1},\dots,b_{n}\right\} \)</span> בסיס סדור כלשהו שלו. כזכור, לכל <span class="math">\(v\in V\)</span> אני מגדיר <strong>וקטור קואורדינטות</strong> <span class="math">\(\left[v\right]_{B}=\left(\lambda_{1},\dots,\lambda_{n}\right)\)</span> כך ש-<span class="math">\(\sum\lambda_{i}b_{i}=v\)</span> (מכיוון ש-<span class="math">\(B\)</span> בסיס אז קיים צירוף לינארי של אבריו שנותן את <span class="math">\(v\)</span> והוא יחיד, כך שההגדרה הגיונית). כעת אפשר להגדיר מכפלה פנימית <span class="math">\(\left\langle x,y\right\rangle _{B}\)</span> באופן הבא: <span class="math">\(\left\langle x,y\right\rangle _{B}=\left[x\right]_{B}\cdot\left[y\right]_{B}\)</span>. כלומר: אנחנו לוקחים את וקטורי הקואורדינטות של <span class="math">\(x,y\)</span> וכופלים אותם מכפלה סקלרית "רגילה" ב-<span class="math">\(\mathbb{C}^{n}\)</span>. הגדרה טבעית למדי, יש להודות, והיא דוגמה לרעיון נפוץ במתמטיקה - אם יש לך שני מבנים שהם איזומורפיים (במקרה שלנו, <span class="math">\(V\)</span> איזומורפי ל-<span class="math">\(\mathbb{C}^{n}\)</span>, כשכל בסיס <span class="math">\(B\)</span> קובע איזומורפיזם אחר) אפשר להשתמש באיזומורפיזם ובפעולה שכבר קיימת באחד מהמבנים כדי להגדיר פעולה במבנה השני (הפעולה תיקבע גם על פי הפעולה על המבנה הראשון, אבל גם על פי האיזומורפיזם עצמו - שני איזומורפיזמים שונים יתנו פעולות שונות).</p>
<p>אם כן, ראינו שאפשר לקבל מכפלות פנימיות על כל מרחב <span class="math">\(V\)</span> סוף-ממדי מעל <span class="math">\(\mathbb{C}\)</span> באמצעות בסיס. אני רוצה לטעון שגם ההפך נכון - ש<strong>כל</strong> מכפלה פנימית על על מרחב וקטורי סוף ממדי <span class="math">\(V\)</span> ניתן להציג בתור מכפלה סקלרית ביחס לבסיס מסוים. במקום להוכיח את זה מייד, אני רוצה לעצור לרגע ולהבין איך נראים בסיסים כאלו.</p>
<p>ובכן, נניח שיש לי בסיס <span class="math">\(B\)</span> והגדרתי מכפלה פנימית <span class="math">\(\left\langle \cdot,\cdot\right\rangle \)</span> באמצעות <span class="math">\(B\)</span>. השאלה הראשונה היא מהם <span class="math">\(\left\langle b_{i},b_{j}\right\rangle \)</span> כאשר <span class="math">\(b_{i},b_{j}\)</span> הם עצמם איברי <span class="math">\(B\)</span>. התשובה פשוטה: <span class="math">\(\left[b_{i}\right]_{B}=\left(0,0,\dots,1,\dots,0\right)\)</span> כאשר ה-1 היחיד הוא בקואורדינטה ה-<span class="math">\(i\)</span>-ית, ולכן <span class="math">\(\left\langle b_{i,},b_{j}\right\rangle =0\)</span> אם <span class="math">\(i\ne j\)</span> ו-<span class="math">\(\left\langle b_{i},b_{i}\right\rangle =1\)</span> (בקיצור אפשר לכתוב זאת <span class="math">\(\left\langle b_{i},b_{j}\right\rangle =\delta_{ij}\)</span>). בסיס שאיבריו מקיימים תכונות אלו (ביחס למכפלה פנימית מסויימת) נקרא <strong>בסיס אורתונורמלי</strong> (ביחס לאותה מכפלה פנימית). מבחינה גיאומטרית נכון לחשוב עליו כעל בסיס שהוקטורים השונים בו מאונכים - <strong>אורתוגונליים - </strong>זה לזה (זו משמעות <span class="math">\(\left\langle b_{i},b_{j}\right\rangle =0\)</span>) ואורכם הוא 1 (זו משמעות <span class="math">\(\left\langle b_{i},b_{i}\right\rangle =1\)</span>) - אסביר זאת יותר בפוסט הבא שבו אדבר על ההיבטים הגיאומטריים של מרחבי מכפלה פנימית.</p>
<p>בואו נניח עתה שיש לנו מרחב מכפלה פנימית <span class="math">\(V\)</span> עם מכפלה <span class="math">\(\left\langle \cdot,\cdot\right\rangle \)</span> שלאו דווקא התקבלה מתוך בסיס מסויים. כל מה שאני יודע עליה הוא שהיא מקיימת את תכונות 1-4. אם אני אצליח למצוא בסיס <span class="math">\(B\)</span> של <span class="math">\(v\)</span> שמקיים <span class="math">\(\left\langle b_{i},b_{j}\right\rangle =\delta_{ij}\)</span> - כלומר, בסיס אורתונורמלי ביחס למכפלה הפנימית הזו - אני טוען שינבע מכך שהמכפלה הפנימית היא בדיוק <span class="math">\(\left\langle \cdot,\cdot\right\rangle _{B}\)</span>. מדוע? ובכן, נניח ש-<span class="math">\(x,y\)</span> הם שני וקטורים כלשהם ב-<span class="math">\(V\)</span> וניתן להציג אותם כ-<span class="math">\(x=\sum x_{i}b_{i}\)</span> ו-<span class="math">\(y=\sum y_{i}b_{i}\)</span> כאשר <span class="math">\(x_{i},y_{i}\)</span> הם סקלרים. אז מתקיים:</p>
<p><span class="math">\(\left\langle x,y\right\rangle =\left\langle \sum x_{i}b_{i},\sum y_{i}b_{j}\right\rangle =\sum_{i,j}x_{i}\overline{y_{j}}\left\langle b_{i},b_{j}\right\rangle =\sum_{i=1}^{n}x_{i}\overline{y_{i}}=\left[x\right]_{B}\cdot\left[y\right]_{B}\)</span></p>
<p>המעבר השני מתבסס על תכונות 1-3 של המכפלה הפנימית, והמעבר שאחריו נובע מכך ש-<span class="math">\(B\)</span> הוא בסיס אורתונורמלי.</p>
<p>אם תחשבו על זה, מה שקורה כאן די דומה למה שקרה בלכסון מטריצות. שם חיפשנו בסיס שבו טרנספורמציה לינארית מסויימת היא "פשוטה" - מיוצגת על ידי מטריצה אלכסונית; כאן אנחנו רואים שאם יש לנו מכפלה פנימית אז יש בסיס - בסיס אורתונורמלי - שבו היא "פשוטה" - ניתן לחשוב עליה כעל מכפלה סקלרית (השיא כמובן יהיה בשילוב של שני הדברים הללו - בסיס אורתונורמלי שגם מלכסן טרנספורמציה מסויימת; זה יהיה מה שנקרא <strong>משפט הפירוק הספקטרלי</strong> והוא אחד מהגביעים הקדושים של סדרת הפוסטים הזו).</p>
<p>הבה ונחדד את הנקודה הזו על ידי כך שנראה שכל מכפלה פנימית במרחב ממימד סופי אכן ניתנת לייצוג באופן מסויים באמצעות מטריצה. בואו ניקח מכפלה פנימית כלשהי <span class="math">\(\left\langle \cdot,\cdot\right\rangle \)</span> ובסיס <span class="math">\(B\)</span> כלשהו למרחב; ובואו נגדיר מטריצה <span class="math">\(B\)</span> על ידי <span class="math">\(B_{ij}=\left\langle b_{j},b_{i}\right\rangle \)</span> (שימו לב להיפוך סדר האינדקסים!). כבר ראינו ש-<span class="math">\(\left\langle x,y\right\rangle =\sum_{i,j}x_{i}\overline{y_{j}}\left\langle b_{i},b_{j}\right\rangle \)</span>; דרך אחרת לכתוב את המשוואה הזו היא בתור <span class="math">\(\left\langle x,y\right\rangle =y^{*}Bx\)</span> כאשר <span class="math">\(y^{*}\)</span> מסמן הצמדה של כל רכיבי <span class="math">\(y\)</span> (אני לא כותב <span class="math">\(\overline{y}\)</span> כי לפעמים פשוט משתמשים בקו עליון כדי להבהיר ש-<span class="math">\(y\)</span> הוא וקטור). אם כן, בסיס אורתונורמלי הוא בסיס שבו המכפלה הפנימית מיוצגת על ידי מטריצת היחידה (ובסיס אורתוגונלי - שבו כל שני וקטורים הם אורתוגונליים אבל לא בהכרח מקיימים <span class="math">\(\left\langle b_{i},b_{i}\right\rangle =1\)</span> - הוא בסיס שבו המטריצה המייצגת היא אלכסונית).</p>
<p>נשאלת אם כן השאלה - האם לכל מרחב מכפלה פנימית סוף ממדי קיים בסיס אורתונורמלי? התשובה חיובית, ולא רק שהיא חיובית - ההוכחה שלה קונסטרוקטיבית לגמרי. אנחנו נראה כיצד ניתן להתחיל מבסיס כלשהו ל-<span class="math">\(V\)</span> ולבנות מתוכו בסיס אורתונורמלי - לאלגוריתם הזה קוראים "תהליך גרם-שמידט".</p>
<p>נתחיל בשאלה תמימה. נניח ש-<span class="math">\(B=\left\{ b_{1},\dots,b_{n}\right\} \)</span> הוא בסיס למרחב וקטורי <span class="math">\(B\)</span>, ו-<span class="math">\(v\in V\)</span> הוא וקטור תמים כלשהו ב-<span class="math">\(V\)</span>. אנחנו יודעים ש-<span class="math">\(v=\sum\lambda_{i}b_{i}\)</span> ושצירוף לינארי זה הוא יחיד. אבל האם אנחנו יודעים למצוא את <span class="math">\(\lambda_{i}\)</span> לכל <span class="math">\(i\)</span>?</p>
<p>השאלה הזו ערמומית הרבה יותר משנדמה במבט ראשון. נסו שניה לפתור אותה ותראו אילו בעיות מתעוררות מייד. בכלל לא ברור לנו איך <span class="math">\(V\)</span> מיוצג; איך <span class="math">\(v\)</span> נתון לנו; מה בדיוק אנחנו יודעים על <span class="math">\(B\)</span>. במקרה שבו <span class="math">\(V=\mathbb{C}^{n}\)</span> עוד אפשר לעשות משהו - כל הוקטורים הם סדרות סופיות של מרוכבים, ולמצוא את ה-<span class="math">\(\lambda_{i}\)</span> -ים דורש לפתור מערכת של משוואות לינאריות מעל המרוכבים. אבל במרחבים כלליים יותר, שבהם אין לנו איזומורפיזם ברור ל-<span class="math">\(\mathbb{C}^{n}\)</span>, פתאום השאלה נהיית בעייתית ותלויה מאוד בייצוג שיש לנו של <span class="math">\(V\)</span>. ובכלל, לפתור מערכת משוואות זה גם כן לא הדבר הכי אינפורמטיבי בעולם.</p>
<p>אבל, אם <span class="math">\(B\)</span> הוא בסיס <strong>אורתונורמלי</strong> ביחס למכפלה פנימית שאנו יודעים לחשב, פתאום העסק הופך לפשוט בצורה בלתי רגילה. כי בואו נראה מה קורה כשכופלים את <span class="math">\(v\)</span> ב-<span class="math">\(b_{i}\)</span>:</p>
<p><span class="math">\(\left\langle v,b_{i}\right\rangle =\left\langle \sum\lambda_{j}b_{j},b_{i}\right\rangle =\sum\lambda_{j}\left\langle b_{j},b_{i}\right\rangle =\lambda_{i}\)</span></p>
<p>כל הגורמים <span class="math">\(\lambda_{j}\left\langle b_{j},b_{i}\right\rangle \)</span> עבור <span class="math">\(j\ne i\)</span> מתאפסים ואנחנו נשארים בדיוק עם המכפלה הפנימית של <span class="math">\(v\)</span> עם <span class="math">\(b_{i}\)</span>. חשבו על זה בתור <strong>הטלה</strong> של <span class="math">\(v\)</span> על מערכת צירים, כאשר כל ציר מוגדר על ידי אחד מ-<span class="math">\(b_{i}\)</span>-ים. מה שאנחנו רואים כאן הוא שכדי לדעת את הקואורדינטה ה-<span class="math">\(i\)</span> של <span class="math">\(v\)</span> בבסיס האורתונורמלי <span class="math">\(B\)</span> אנחנו צריכים לדעת רק את <span class="math">\(b_{i}\)</span> ולא שום דבר אחר. בפרט, וזה לב הרעיון בגרם-שמידט, אם אנחנו באמצע תהליך הבנייה של <span class="math">\(B\)</span> ובנינו עד כה רק <strong>חלק</strong> מהוקטורים בו, אז לכל וקטור חדש אנחנו כבר יודעים <strong>חלק</strong> מהצירוף הלינארי שייצג את <span class="math">\(v\)</span> בבסיס ה"מלא", ואותו חלק לא הולך להשתנות יותר אף פעם.</p>
<p>עוד מושג אחד ודי. אם <span class="math">\(v\in V\)</span> הוא וקטור כלשהו השונה מאפס, אנחנו נרצה למצוא <span class="math">\(\lambda\)</span> כך ש-<span class="math">\(\left\langle \lambda v,\lambda v\right\rangle =1\)</span>. מתכונות המכפלה הפנימית אנחנו רואים חיש קל שנובע מכך כי <span class="math">\(\left|\lambda\right|^{2}=\frac{1}{\left\langle v,v\right\rangle }\)</span>, ולכן טבעי לבחור ש-<span class="math">\(\lambda=\frac{1}{\sqrt{\left\langle v,v\right\rangle }}\)</span>. שימו לב שתכונה 4 של המכפלה הפנימית ש-<span class="math">\(\left\langle v,v\right\rangle \)</span> מבטיחה יהיה מספר ממשי חיובי ולכן יהיה ניתן להוציא לו שורש. אם אנחנו מעל שדה שאינו <span class="math">\(\mathbb{R}\)</span> או <span class="math">\(\mathbb{C}\)</span>, הנקודה הזו היא בדיוק אחת מהנקודות שבהן "הכל קורס" - בכלל לא בטוח שיהיה לנו בסיס אורתונורמלי במרחבים כאלו.</p>
<p>לסקלר <span class="math">\(\sqrt{\left\langle v,v\right\rangle }\)</span> הזה יש סימון ושם, שנעמוד על משמעותם המלאה רק בפוסט הבא - <span class="math">\(\|v\|\)</span>, <strong>הנורמה</strong> של <span class="math">\(v\)</span>. בפשטות, נורמה היא הכללה של מושג האורך, אבל על המבנה המעניין שקיומה משרה על <span class="math">\(V\)</span> אני לא אדבר עכשיו; העניין שלי בה נובע מכך שאם <span class="math">\(v\)</span> הוא וקטור שונה מאפס כלשהו, אז כפי שראינו - <span class="math">\(\frac{v}{\|v\|}\)</span> הוא וקטור שהמכפלה הפנימית שלו עם עצמו היא 1. לחלוקת <span class="math">\(v\)</span> ב-<span class="math">\(\|v\|\)</span> קוראים <strong>לנרמל</strong> את <span class="math">\(v\)</span>.</p>
<p>עכשיו בואו נראה את גרם-שמידט. אנחנו מתחילים מבסיס כלשהו <span class="math">\(\left\{ v_{1},\dots,v_{n}\right\} \)</span> למרחב מכפלה פנימית מסויים ובונים בסיס אורתונורמלי <span class="math">\(\left\{ b_{1},\dots,b_{n}\right\} \)</span> לאותו מרחב. הבניה היא אינדוקטיבית; בשלב ה-<span class="math">\(i\)</span> כבר בנינו את <span class="math">\(\left\{ b_{1},\dots,b_{i-1}\right\} \)</span> כך שהם אורתונורמליים ופורשים בדיוק את אותו מרחב כמו <span class="math">\(\left\{ v_{1},\dots,v_{i-1}\right\} \)</span>, ואל הקבוצה הזו אנו מוסיפים את <span class="math">\(b_{i}\)</span>. איך? ראשית אנו לוקחים את <span class="math">\(v_{i}\)</span>. כעת, לכל <span class="math">\(1\le j&lt;i\)</span> אנו יודעים ש-<span class="math">\(\left\langle v_{i},b_{j}\right\rangle \)</span> יהיה המקדם של <span class="math">\(b_{j}\)</span> בצירוף הלינארי שפורש את <span class="math">\(v_{i}\)</span>; כלומר, <span class="math">\(\left\langle v_{i},b_{j}\right\rangle b_{j}\)</span> הוא בדיוק אותו חלק של <span class="math">\(v_{i}\)</span> ש"כבר מטופל" על ידי <span class="math">\(b_{j}\)</span>, ולכן אפשר להחסיר אותו מ-<span class="math">\(v_{i}\)</span> בלב שקט. כלומר, אנו מגדירים וקטור חדש <span class="math">\(u_{i}=v_{i}-\left(\sum_{j=1}^{i-1}\left\langle v_{i},b_{j}\right\rangle b_{j}\right)\)</span>.</p>
<p>כעת נשים לב לכך שעבור <span class="math">\(1\le j&lt;i\)</span>, <span class="math">\(\left\langle u_{i},b_{j}\right\rangle =\left\langle v_{i},b_{j}\right\rangle -\left(\sum_{k=1}^{i-1}\left\langle v_{i},b_{k}\right\rangle \left\langle b_{k},b_{j}\right\rangle \right)=\left\langle v_{i},b_{j}\right\rangle -\left\langle v_{i},b_{j}\right\rangle =0\)</span>, כלומר <span class="math">\(u_{i}\)</span> הוא אורתוגונלי לכל האיברים שבנינו עד כה של <span class="math">\(B\)</span>. עם זאת, קיימת הסכנה ש-<span class="math">\(u_{i}=0\)</span> וחסל. אבל אמרנו ש-<span class="math">\(b_{1},\dots,b_{i-1}\)</span> פורשים את אותו מרחב כמו <span class="math">\(v_{1},\dots,v_{i-1}\)</span>, ואם <span class="math">\(u_{i}=0\)</span> זה אומר ש-<span class="math">\(v_{i}=\sum_{j=1}^{i-1}\left\langle v_{i},b_{j}\right\rangle b_{j}\in\text{span}\left\{ v_{1},\dots,v_{i-1}\right\} \)</span> בסתירה לכך ש-<span class="math">\(v_{i}\)</span> היה בלתי תלוי באיברים אלו (כי <span class="math">\(\left\{ v_{1},\dots,v_{n}\right\} \)</span> היא <strong>בסיס</strong>). כל שנותר לעשות הוא לנרמל אותו ולהוסיף לקבוצה: נגדיר <span class="math">\(b_{i}=\frac{u_{i}}{\|u_{i}\|}\)</span> וסיימנו. אנחנו עדיין צריכים להוכיח ש-<span class="math">\(\text{span}\left\{ v_{1},\dots,v_{i}\right\} =\text{span}\left\{ b_{1},\dots,b_{i}\right\} \)</span>, אבל אני עצל מכדי לכתוב במפורש את ההוכחה ומשאיר לכם את זה כתרגיל.</p>
<p>אחרי שהתהליך יסיים לזלול את כל הבסיס <span class="math">\(\left\{ v_{1},\dots,v_{n}\right\} \)</span> נקבל קבוצה <span class="math">\(\left\{ b_{1},\dots,b_{n}\right\} \)</span> שפורשת את אותו מרחב כמו <span class="math">\(\left\{ v_{1},\dots,v_{n}\right\} \)</span> (ולכן היא בסיס), ובנוסף היא אורתונורמלית, בדיוק מה שרצינו. למען הדורות הבאים, בואו נכתוב את התהליך במפורש בתור אלגוריתם:</p>
<ol>
    <li> לכל <span class="math">\(i=1,2,\dots,n\)</span>:
<ol>
    <li> הגדר <span class="math">\(u_{i}=v_{i}-\left(\sum_{j=1}^{i-1}\left\langle v_{i},b_{j}\right\rangle b_{j}\right)\)</span></li>
    <li> הגדר <span class="math">\(b_{i}=\frac{u_{i}}{\|u_{i}\|}\)</span></li>
</ol>
</li>
    <li> החזר את <span class="math">\(\left\{ b_{1},\dots,b_{n}\right\} \)</span></li>
</ol>
<p>די פשוט, כשחושבים על זה. לרוע המזל, כשעושים את התהליך בפועל בעולם האמיתי, מהר מאוד מקבלים גועל נפש שאין כדוגמתו (כשמנרמלים וקטור לרוב צצים שורשים מזוויעים). תודה לאל על קיומם של מחשבים.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>