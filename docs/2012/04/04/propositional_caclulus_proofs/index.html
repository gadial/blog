<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>תחשיב הפסוקים - על נביעה לוגית והוכחות - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/new_blog/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/new_blog/">דף הבית</a>
                <a href="/new_blog/random.html">פוסט אקראי</a>
                <a href="/new_blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_blog/2012/03/28/propositional_calculus_intro/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">תחשיב הפסוקים</span>
            </a>
            

            
            <a href="/new_blog/2012/04/08/propositional_calculus_completeness/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">משפט השלמות לתחשיב הפסוקים</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>תחשיב הפסוקים - על נביעה לוגית והוכחות</h1>
            <div class="post-meta">
                <span class="date">2012-04-04</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/תחשיב הפסוקים.html">תחשיב הפסוקים</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסט הקודם הצגתי את התחביר של תחשיב הפסוקים - האופן שבו בונים נוסחאות מאוסף של סימנים, על פי כללים מסויימים, והתוצאה הייתה קבוצה שקראתי לה WFF ("נוסחאות בנויות היטב" או סתם "נוסחאות" מכאן ואילך). הצגתי גם את הסמנטיקה, אבל לא קראתי לה "סמנטיקה" מספיק בבירור, אז בואו נקדיש לזה כמה רגעים.</p>
<p>האובייקט הבסיסי בתחשיב הפסוקים היה <strong>משתנים לוגיים</strong>, <span class="math">\(X_{1},X_{2},X_{3},\dots\)</span>. ההנחה היא שאנחנו מייחסים למשתנים הללו משמעות כלשהי, אבל מבחינה פורמלית תחשיב הפסוקים לא מתעניין במשמעות הזו. כל מה שהוא מתעניין בו הוא האם המשתנים מקבלים ערך <span class="math">\(\text{T}\)</span> או <span class="math">\(\text{F}\)</span>. בואו נתחיל עם דוגמה קונקרטית כדי להבין איך זה הולך. את המושג של <strong>גרף</strong> אני מניח שרוב הקוראים מכירים, אבל למי שלא: גרף <span class="math">\(G=\left(V,E\right)\)</span> מורכב מקבוצה כלשהי (לא בהכרח סופית) של <strong>צמתים</strong> <span class="math">\(V\)</span>, ושל זוגות של צמתים <span class="math">\(E\subseteq V^{2}\)</span> שנקראים <strong>קשתות</strong>. חושבים על כך כאילו אם <span class="math">\(\left(u,v\right)\in E\)</span> אז הצמתים <span class="math">\(u,v\)</span> מחוברים בקשת, ואחרת לא. עכשיו, את הצמתים של <span class="math">\(G\)</span> אפשר <strong>לצבוע</strong>; אני אניח לצורך פשטות שמותר לצבוע אותם רק באדום, כחול או ירוק. פורמלית, צביעה היא פונקציה <span class="math">\(f:V\to\left\{ \text{R,G,B}\right\} \)</span> שלכל צומת מתאימה את הצבע שבו הוא נצבע (כל צומת חייב להיצבע). האתגר בדרך כלל הוא למצוא צביעה "חוקית" שבה אין שני צמתים שמחוברים בקשת וצבועים באותו הצבע - כלומר, <span class="math">\(f\left(u\right)\ne f\left(v\right)\)</span> לכל קשת <span class="math">\(\left(u,v\right)\in E\)</span> בגרף. לא תמיד יש צביעה כזו; למעשה, הבעיה "האם ניתן לצבוע גרף <span class="math">\(G\)</span> נתון באופן חוקי באמצעות שלושה צמתים" היא בעיה <span class="math">\(\text{NP}\)</span>-שלמה, מה שאומר שהיא ככל הנראה קשה לפתרון מבחינה חישובית. למה זה בכלל מעניין מישהו? ובכן, בעולם הגדול צביעה של גרפים היא הפשטה נאה לבעיות של הקצאת משאבים; בעולם הקטן שלנו היא פשוט דוגמה יפה למה שאני רוצה לדבר עליו.</p>
<p>נניח שנתון לי גרף <span class="math">\(G\)</span>. כעת, לכל צומת <span class="math">\(v\)</span> אני הולך להגדיר שלושה משתנים: <span class="math">\(X_{R}^{v},X_{G}^{v},X_{B}^{v}\)</span>. אם <span class="math">\(X_{R}^{v}=\text{T}\)</span>, אני מפרש את זה בתור האמירה "הצומת <span class="math">\(v\)</span> נצבע בצבע <span class="math">\(\text{R}\)</span>". מבחינת תחשיב הפסוקים עצמו, כל מה שהוא יודע זה ש"המשתנה <span class="math">\(X_{R}^{v}\)</span> קיבל את הערך <span class="math">\(\text{T}\)</span> בהשמה" - כל היתר הוא בדמיון שלי (גם לקרוא למשתנה הזה <span class="math">\(X_{R}^{v}\)</span> זה בדמיון שלי; בפועל כל המשתנים הם מהצורה <span class="math">\(X_{k}\)</span> כאשר <span class="math">\(k\)</span> הוא מספר טבעי כלשהו).</p>
<p>כעת, כל השמה למשתנים מגדירה צביעה של הגרף <span class="math">\(G\)</span>, אבל אף אחד לא מבטיח לי שהצביעה הזו הגיונית בכלל; ייתכן שיש צומת שנצבע ביותר מאשר צבע אחד; ייתכן שיש צומת שלא נצבע באף צבע; וכמובן, אף אחד לא מבטיח שהצביעה תהיה חוקית במובן זה שכל שני צמתים שכנים לא צבועים באותו הצבע. בכדי להבטיח שהצביעה תהיה בסדר אני צריך להוסיף <strong>מגבלות</strong> על הצביעה - כלומר, על ההשמות החוקיות. האופן שבו אני עושה את זה הוא להגדיר קבוצה של פסוקים, <span class="math">\(,\Phi_{G}\)</span> כך שכל השמה שמספקת <strong>את כל</strong> הפסוקים של <span class="math">\(\Phi_{G}\)</span> חייבת להיות, בפרשנות שלי, צביעה חוקית. אילו פסוקים <span class="math">\(\Phi_{G}\)</span> תכיל?</p>
<p>ובכן, לכל צומת <span class="math">\(v\in V\)</span>, <span class="math">\(\Phi_{G}\)</span> תכיל את הפסוק <span class="math">\(X_{R}^{v}\vee X_{G}^{v}\vee X_{B}^{v}\)</span> שאומר "הצומת <span class="math">\(v\)</span> צבוע לפחות בצבע אחד". היא תכיל את הפסוק <span class="math">\(\neg\left(X_{R}^{v}\wedge X_{G}^{v}\right)\wedge\neg\left(X_{R}^{v}\wedge X_{B}^{v}\right)\wedge\neg\left(X_{G}^{v}\wedge X_{B}^{v}\right)\)</span> שאומר "הצומת <span class="math">\(v\)</span> אינה צבועה ביותר מצבע אחד"; ולכל קשת <span class="math">\(\left(u,v\right)\in E\)</span>, <span class="math">\(\Phi_{G}\)</span> תכיל את הפסוק <span class="math">\(\neg\left(X_{R}^{v}\wedge X_{R}^{u}\right)\wedge\neg\left(X_{G}^{v}\wedge X_{G}^{u}\right)\wedge\neg\left(X_{B}^{v}\wedge X_{B}^{u}\right)\)</span> שאומר "הצמתים <span class="math">\(v,u\)</span> אינם צבועים באותו הצבע".</p>
<p>זה משלים את התיאור של <span class="math">\(\Phi_{G}\)</span>, אבל הכיף רק מתחיל. לא קשה להוכיח (באופן מתמטי "רגיל", לא באופן פורמלי) שאם הגרף <span class="math">\(G\)</span> מכיל ולו קשת יחידה, אז לא כל הצמתים בגרף בעלי אותו צבע (כי מה עם שני הצמתים שמחוברים בקשת?). בואו נניח לצורך פשטות ש-<span class="math">\(G\)</span> סופי וקבוצת הקשתות שלו לא ריקה, אז הפסוק הבא נכון עבור כל השמה שמספקת את כל פסוקי <span class="math">\(\Phi_{G}\)</span>: <span class="math">\(\neg\left(\bigwedge_{v\in V}X_{R}^{v}\right)\wedge\neg\left(\bigwedge_{v\in V}X_{G}^{v}\right)\wedge\neg\left(\bigwedge_{v\in V}X_{B}^{v}\right)\)</span>. הפסוק הזה כמובן <strong>דומה</strong> לפסוקים שהוספנו ל-<span class="math">\(\Phi_{G}\)</span>, אבל הוא לא נמצא ב-<span class="math">\(\Phi_{G}\)</span>. מצד שני, די בבירור הוא "נובע" מתוך <span class="math">\(\Phi_{G}\)</span> - גם מבחינה אינטואיטיבית, אבל גם מבחינה פורמלית; באופן כללי אנחנו אומרים שפסוק <span class="math">\(\varphi\)</span> נובע לוגית מקבוצת פסוקים <span class="math">\(\Phi\)</span> אם כל השמה שמספקת את <span class="math">\(\Phi\)</span> (דהיינו, מספקת את כל הפסוקים ב-<span class="math">\(\Phi\)</span>) מספקת גם את <span class="math">\(\varphi\)</span>. מסמנים זאת <span class="math">\(\Phi\models\varphi\)</span>. בפרט, פסוקים ש<strong>כל השמה</strong> מספקת אותם נקראים <strong>טאוטולוגיות</strong> ומסמנים זאת <span class="math">\(\models\varphi\)</span> (אבל כמובן שאם <span class="math">\(\varphi\)</span> טאוטולוגיה אז אפשר לכתוב גם <span class="math">\(\Phi\models\varphi\)</span> לכל <span class="math">\(\Phi\)</span> שרק נרצה).</p>
<p>כעת עולה מאליה השאלה - נניח שנתונה <span class="math">\(\Phi\)</span>. איך מוצאים את כל ה-<span class="math">\(\varphi\)</span> שנובעים ממנה? ואם יש <span class="math">\(\varphi\)</span>, איך בודקים אם <span class="math">\(\Phi\models\varphi\)</span>? האם יש דרך פשוטה להשתכנע בכך, או שחייבים לעבור על מי יודע כמה השמות? (יש רק מספר סופי של משתנים ה-<span class="math">\(\varphi\)</span> ולכן רק מספר סופי של השמות שצריך לבדוק, אבל זה יכול להיות מספר גדול מאוד, ויש גם את העניין הזה ש-<span class="math">\(\Phi\)</span> יכולה להיות אינסופית). מה שאנחנו רוצים כאן הוא <strong>מערכת הוכחה</strong> פשוטה עבור תחשיב הפסוקים.</p>
<p>מה זו מערכת הוכחה, באופן כללי? זו שאלה מצויינת, מהטעם הפשוט שיש סוגים רבים ושונים ביותר של מערכות הוכחה. בשורה התחתונה, אני חושב שאפשר להצביע על שלוש תכונות בסיסיות שפחות או יותר כל מערכת הוכחה תקיים, ברמה זו או אחרת: נאותות, שלמות ואפקטיביות.</p>
<p>נאותות ושלמות קל לתאר: נאותות אומרת "כל מה שניתן להוכחה, נכון", שבהקשר שלנו פירושו "כל מה שניתן להוכחה מתוך <span class="math">\(\Phi\)</span> במערכת ההוכחה שלנו נובע לוגית מ-<span class="math">\(\Phi\)</span> ". אני אשתמש בסימון <span class="math">\(\Phi\vdash\varphi\)</span> כדי לומר "<span class="math">\(\Phi\)</span> מוכיח (במערכת הוכחה ספציפית) את <span class="math">\(\varphi\)</span>", ולכן אפשר לנסח את דרישת הנאותות פשוט בתור <span class="math">\(\Phi\vdash\varphi\Rightarrow\Phi\models\varphi\)</span>. דרישת השלמות היא הכיוון השני, <span class="math">\(\Phi\vdash\varphi\Leftarrow\Phi\models\varphi\)</span>: כאן אני דורש שכל מה שנובע לוגית מ-<span class="math">\(\Phi\)</span> יהיה ניתן להוכחה. כבר אינטואיטיבית אפשר להרגיש שזו הדרישה הקשה יותר, אבל נדון על כך בהמשך.</p>
<p>דרישת האפקטיביות היא קצת יותר מעורפלת. אפקטיביות פירושה שהוכחות תהיינה <strong>פשוטות</strong>, במובן זה שלא יהיו בהן קפיצות מחשבתיות שדורשות יצירתיות או אינטואיציה; אנחנו רוצים שכל רכיב בהוכחה יהיה פשוט דיו עד כדי כך שניתן יהיה לתת אלגוריתם שמסוגל לבדוק הוכחות "בלי לחשוב" - במילים אחרות, אפשר לומר שאנחנו רוצים לדרוש שההוכחות תהיינה ניתנות לבדיקה על ידי מחשב. הוכחות מתמטיות בספרי מתמטיקה אמיתיים אינם כאלו; הן כתובות בשפה טבעית ומכילות הרבה קפיצות שהקורא אמור להשלים בעצמו. זו בדיוק הנקודה שבה מערכות הוכחה פורמליות מתנתקות מהמושג האינטואיטיבי שלנו של "הוכחה".</p>
<p>שלוש הדרישות שלעיל לא באמת מגדירות בשום צורה <strong>איך</strong> מערכת ההוכחה תעשה את מה שאנחנו דורשים ממנה, ובצדק; למה להגביל את עצמנו? תחת זאת, אפשר פשוט לדבר על מערכות הוכחה קונקרטיות ולראות שהן מקיימות את הדרישות הבסיסיות שלנו. מה שאציג כעת תהיה מקרה פרטי של מחלקה גדולה של מערכות הוכחה "מערכות הילברט" (שהקרדיט על תיאורן הפורמלי, פחות או יותר, מגיע להילברט ולפרגה). במערכת כזו יש לנו <strong>אקסיומות</strong>, ויש לנו <strong>כללי היסק</strong>, והוכחה של <span class="math">\(\varphi\)</span> מתוך קבוצת <strong>הנחות <span class="math">\(\Phi\)</span> </strong>היא סדרה סופית של פסוקים <span class="math">\(\psi_{1},\dots,\psi_{n}\)</span> כך ש-<span class="math">\(\psi_{n}=\varphi\)</span>, וכל <span class="math">\(\psi_{i}\)</span> הוא או אקסיומה, או הנחה מתוך <span class="math">\(\Phi\)</span>, או שהוא נובע מ-<span class="math">\(\psi_{j}\)</span>-ים קודמים על ידי הפעלת <strong>כלל היסק</strong>. כדי שהמערכת תהיה אפקטיבית רק צריך לבחור אקסיומות שניתן לזהות אותן באופן אלגוריתמי (כלומר, או שתהיה קבוצה סופית של אקסיומות, או - אם זו קבוצה אינסופית - שלפחות יהיה קל לזהות מהי אקסיומה, למשל כי היא מתאימה לאיזו שהיא תבנית ברורה) ולבחור כללי היסק שניתן לזהות את<br />
הפעלתם באופן אלגוריתמי.</p>
<p>מראש ברור שאנחנו מוגבלים בבחירת האקסיומות שלנו - אנחנו יכולים לבחור <strong>רק</strong> טאוטולוגיות בתור אקסיומות, אחרת אפשר לשכוח מהנאותות (כי לכל <span class="math">\(\varphi\)</span> שהוא אקסיומה, מתקיים <span class="math">\(\vdash\varphi\)</span>, כלומר יש הוכחה ל-<span class="math">\(\varphi\)</span> ללא שום הנחות; ההוכחה הזו היא פשוט הסדרה <span class="math">\(\varphi\)</span> עצמה. מנאותות כעת נובע ש-<span class="math">\(\models\varphi\)</span>). עכשיו אפשר אולי להבין במשהו את הקושי שלנו בהוכחת שלמות - יש לנו רק סט מוגבל למדי של מחרוזות - אלו שמייצגות טאוטולוגיות ואלו של <span class="math">\(\Phi\)</span> עצמה - ואנחנו יכולים לבצע רק סדרות סופיות של שינויים פשוטים במחרוזות הללו, ואיכשהו אנחנו צריכים לקבל מזה <strong>כל</strong> מחרוזת אפשרית שנובעת מ-<span class="math">\(\Phi\)</span>? זה נשמע לא פשוט. כדי להקל עלינו, אפשר לפשט קצת את השפה: מספיק להרשות רק משתנים ואת הקשרים <span class="math">\(\neg,\to\)</span>, וה"אתגר" שלנו יהיה לבנות רק פסוקים שכתובים בעזרת קשרים אלו (מכיוון שזוהי מערכת קשרים שלמה אנחנו לא "מאבדים כוח" - עדיין נוכל להביע את כל טבלאות האמת כך). כדאי להדגיש שהפישוט הזה הוא אכן רק פישוט; אפשר לקחת את מערכת ההוכחה שאציג עכשיו ולהרחיב אותה כך שתתמודד גם עם שאר הקשרים. זה פשוט לא מעניין במיוחד, כי אחרי שנסיים עם מערכת הוכחה עבור <span class="math">\(\neg,\to\)</span> בלבד כבר נבין את העיקרון.</p>
<p>נעבור להצגת כלל ההיסק שלנו. יש לנו בחירה לא קטנה בנוגע לכללי ההיסק, אבל אני מעדיף להיות שמרן וללכת על כלל מוכר ופופולרי - מודוס פוננס, MP. הרעיון ב-MP הוא זה: נניח שכבר הוכחנו את <span class="math">\(\alpha\to\beta\)</span> וגם הוכחנו את <span class="math">\(\alpha\)</span>; משני אלו אפשר להסיק את <span class="math">\(\beta\)</span>. ההגיון פשוט: אם הוכחנו ש"אם יורד גשם, אז אנחנו נרטבים" והוכחנו ש"יורד גשם", אז בעצם הוכחנו ש"אנחנו נרטבים". גם מבחינה פורמלית, קל לראות ש-MP משמר את הנאותות של מערכת ההוכחה שלנו: אם <span class="math">\(\Phi\models\alpha\)</span> וגם <span class="math">\(\Phi\models\alpha\to\beta\)</span> ויש לנו השמה כלשהי שמספקת את <span class="math">\(\Phi\)</span>, אז היא מספקת בו זמנית את <span class="math">\(\alpha\)</span> ואת <span class="math">\(\alpha\to\beta\)</span>. אם היא לא הייתה מספקת את <span class="math">\(\beta\)</span>, אז <span class="math">\(\alpha\to\beta\)</span> היה פסוק שבו הרישא (<span class="math">\(\alpha\)</span>) היא <span class="math">\(\text{T}\)</span> אבל הסיפא היא <span class="math">\(\text{F}\)</span> - וזה, על פי הסמנטיקה של תחשיב הפסוקים, אומר שהפסוק כולו מקבל <span class="math">\(\text{F}\)</span> בהשמה, בסתירה לכך שכל השמה שמספקת את <span class="math">\(\Phi\)</span> מספקת את <span class="math">\(\alpha\to\beta\)</span>. לכן <span class="math">\(\Phi\models\beta\)</span>.</p>
<p>טענה ראשונה שאפשר להוכיח על מערכת ההוכחה שלנו כעת היא זו: אם <span class="math">\(\Phi\vdash\alpha\to\beta\)</span> אז <span class="math">\(\Phi\cup\left\{ \alpha\right\} \vdash\beta\)</span>; כלומר, אם אנחנו יודעים להוכיח את <span class="math">\(\alpha\to\beta\)</span> מתוך <span class="math">\(\Phi\)</span>, אז אם נוסיף ל-<span class="math">\(\Phi\)</span> את <span class="math">\(\alpha\)</span> בתור הנחה, נוכל להוכיח את <span class="math">\(\beta\)</span>. הנה ההוכחה הפורמלית:</p>
<ol>
    <li><span class="math">\(\alpha\to\beta\)</span> (ניתן להוכחה מ-<span class="math">\(\Phi\)</span>).</li>
    <li><span class="math">\(\alpha\)</span> (הנחה).</li>
    <li><span class="math">\(\beta\)</span> (<span class="math">\(\text{MP}\)</span> על 1,2).</li>
</ol>
<p>לא מסובך, נכון? שימו לב שלא נזקקנו כלל לאקסיומות; התוצאה הזו נובעת ישירות מ-<span class="math">\(\text{MP}\)</span>. למעשה, כל מערכת הוכחה שמקיימת את התכונה הזו בעצם מכילה את MP, גם אם היא לא הצהירה על כך במפורש בכללי ההיסק שלה; דה פקטו, במערכת כזו אם הצלחנו להוכיח את <span class="math">\(\alpha\to\beta\)</span> והצלחנו להוכיח את <span class="math">\(\alpha\)</span> אז תנבע מכך הוכחה ל-<span class="math">\(\beta\)</span>. אם לעומת זאת מערכת ההוכחה שלנו <strong>לא</strong> מקיימת את התכונה הזו - כלומר, יש <span class="math">\(\alpha,\beta\)</span> כך ש-<span class="math">\(\Phi\vdash\alpha\to\beta\)</span> וגם <span class="math">\(\Phi\vdash\alpha\)</span> אבל לא <span class="math">\(\Phi\vdash\beta\)</span> אז אפשר לשכוח מכך שמערכת ההוכחה תהיה שלמה, שהרי <span class="math">\(\Phi\models\beta\)</span> בסיטואציה הזו. המסקנה מהדיון הקצרצר הזה הוא ש-<span class="math">\(\text{MP}\)</span> הוא כלל גזירה שמתבקש מאוד לצרף אלינו; ולא נזדקק לשום כלל גזירה פרט אליו.</p>
<p>עכשיו, ראינו ש-<span class="math">\(\Phi\vdash\alpha\to\beta\Rightarrow\Phi\cup\left\{ \alpha\right\} \vdash\beta\)</span>; מה בדבר הכיוון השני? האם, אם <span class="math">\(\Phi\cup\left\{ \alpha\right\} \vdash\beta\)</span> אז נובע מכך ש-<span class="math">\(\Phi\vdash\alpha\to\beta\)</span>? זה כבר לחלוטין לא מובן מאליו; אני טוען שמכך שאני יודע לייצר את המחרוזת <span class="math">\(\beta\)</span> עם הוכחה שמורכבת מאברי <span class="math">\(\Phi\)</span> ומ-<span class="math">\(\alpha\)</span> אז אני אוכל לייצר את המחרוזת <span class="math">\(\alpha\to\beta\)</span> שהיא לכאורה מורכבת <strong>יותר</strong>, וזאת תוך שימוש ב<strong>פחות</strong> הנחות, שהרי אין לי את <span class="math">\(\alpha\)</span> כהנחה יותר. זו לא תוצאה מובנית מאליה, והיא מועילה למדי שכן היא מסייעת מאוד בפישוט הוכחות של טענות; במקום שנצטרך להוכיח משהו כמו <span class="math">\(\Phi\vdash\left(\alpha\to\beta\right)\to\left(\alpha\to\gamma\right)\)</span> יהיה לנו מספיק להוכיח ש-<span class="math">\(\Phi\cup\left\{ \alpha\to\beta\right\} \vdash\alpha\to\gamma\)</span>, ואפילו די יהיה להוכיח ש-<span class="math">\(\Phi\cup\left\{ \alpha\to\beta,\alpha\right\} \vdash\gamma\)</span> - פחות עבודה, יותר הנחות. לתוצאה הזו - <span class="math">\(\Phi\vdash\alpha\to\beta\Leftarrow\Phi\cup\left\{ \alpha\right\} \vdash\beta\)</span> - קוראים <strong>משפט הדדוקציה</strong>, וזה הדבר הלא טריוויאלי הראשון שאני רוצה להוכיח. כרגע מערכת ההוכחה שלי (שהיא נטולת אקסיומות) לא יכולה לבצע את הקסם הזה; במהלך ההוכחה של משפט הדדוקציה נראה לאילו אקסיומות אני נזקק.</p>
<p>בואו נתחיל מהדבר המטופש ביותר. <span class="math">\(\Phi\cup\left\{ \alpha\right\} \vdash\alpha\)</span> תמיד, בלי קשר ל-<span class="math">\(\Phi\)</span>, ולכן <span class="math">\(\Phi\vdash\alpha\to\alpha\)</span> תמיד; מה שאנחנו בעצם רוצים לעשות הוא להראות שאפשר להוכיח את <span class="math">\(\alpha\to\alpha\)</span> במערכת ההוכחה שלנו, עבור <strong>כל</strong> פסוק, ובלי <strong>שום</strong> הנחות (אלא רק בעזרת אקסיומות שהן חלק ממערכת ההוכחה). הפיתוי הראשון הוא להגיד ש-<span class="math">\(\alpha\to\alpha\)</span> עצמה תהיה אקסיומה, לכל פסוק <span class="math">\(\alpha\)</span>. מותר לנו לעשות את זה - <span class="math">\(\alpha\to\alpha\)</span> היא טאוטולוגיה בלי קשר ל-<span class="math">\(\alpha\)</span> - אבל זו אינה אקסיומה שימושית במיוחד ואנו מעדיפים שמערכת ההוכחה שלנו תהיה פשוטה ככל האפשר. בואו נחכה קצת עם ההוכחה של <span class="math">\(\alpha\to\alpha\)</span> כדי לראות לאילו אקסיומות נזדקק בהוכחה של יתר המשפט ונראה אם הן יעבדו גם כאן.</p>
<p>אם <span class="math">\(\beta\)</span> היא אקסיומה או הנחה ב-<span class="math">\(\Phi\)</span>, איך נוכיח ש-<span class="math">\(\Phi\vdash\alpha\to\beta\)</span>? שימו לב שגם כאן לא עוזרת לנו הידיעה ש-<span class="math">\(\Phi\cup\left\{ \alpha\right\} \vdash\beta\)</span> מהטעם הפשוט שאם <span class="math">\(\beta\)</span> היא אקסיומה או הנחה אז <span class="math">\(\Phi\vdash\beta\)</span> ממילא, בלי קשר ל-<span class="math">\(\alpha\)</span>. מכאן אנחנו נתקלים בתכונה כללית שמערכת ההוכחה שלנו צריכה לקיים: אם הוכחנו כבר את <span class="math">\(\beta\)</span>, אז לכל <span class="math">\(\alpha\)</span> אנחנו צריכים להיות מסוגלים להוכיח גם את <span class="math">\(\alpha\to\beta\)</span>. אפשר אולי להוסיף את זה גם כן כמעין כלל גזירה, אבל אני מעדיף לחשוב על כללי גזירה כפונקציות שלקוחות פסוקים קיימים ומוציאות פלט יחיד, ואילו כאן כלל הגזירה יהיה משהו רב-ערכי שכזה: "<strong>לכל</strong> <span class="math">\(\alpha\)</span> אפשר להוסיף אותו לפני <span class="math">\(\beta\)</span>". אז בואו במקום להוסיף כלל גזירה חדש, נוסיף אקסיומה חדשה: אני ארצה להיות מסוגל להוכיח את <span class="math">\(\alpha\to\beta\)</span> באמצעות <span class="math">\(\text{MP}\)</span> ובאמצעות זה שאני יודע את <span class="math">\(\beta\)</span>. האקסיומה שמתאימה כאן כמו כפפה ליד היא <span class="math">\(\beta\to\left(\alpha\to\beta\right)\)</span> (בדיקה ישירה מראה כי זוהי טאוטולוגיה), אז זו בדיוק האקסיומה שאוסיף למערכת ההוכחה שלי. ליתר דיוק, הוספתי כאן <strong>תבנית אקסיומה</strong>; לא משנה איזה פסוקים נשתיל במקום <span class="math">\(\alpha,\beta\)</span>, התוצאה גם היא תהיה אקסיומה של מערכת ההוכחה שלי. לתבנית האקסיומה הזו אני קורא <strong>תבנית אקסיומה מס' </strong><strong>1</strong>. בעזרתה אפשר להוכיח בקלות את מה שרצינו:</p>
<ol>
    <li><span class="math">\(\beta\)</span> (אקסיומה/הנחה).</li>
    <li><span class="math">\(\beta\to\left(\alpha\to\beta\right)\)</span> (תבנית אקסיומה מס' 1).</li>
    <li><span class="math">\(\alpha\to\beta\)</span> (<span class="math">\(\text{MP}\)</span> על 1,2)</li>
</ol>
<p>אוקיי, זה היה קל. אז טיפלנו במקרה שבו <span class="math">\(\beta\)</span> היא אקסיומה/הנחה; דחינו לעת עתה את המקרה שבו <span class="math">\(\beta=\alpha\)</span>; מה נותר? המקרים שבהם <span class="math">\(\beta\)</span> אינה אקסיומה/הנחה/<span class="math">\(\alpha\)</span> ועם זאת מוכיחים את <span class="math">\(\beta\)</span> מתוך <span class="math">\(\Phi\cup\left\{ \alpha\right\} \)</span>. מסקנה: בסיטואציה כזו, <span class="math">\(\beta\)</span> חייבת להתקבל על ידי הפעלת <span class="math">\(\text{MP}\)</span> על שני פסוקים שניתן להניח באינדוקציה (על אורך ההוכחה) שעליהם משפט הדדוקציה כבר חל. כלומר, יש איזה שהוא פסוק <span class="math">\(\gamma\)</span> כך ש-<span class="math">\(\Phi\cup\left\{ \alpha\right\} \vdash\gamma\to\beta\)</span> וגם <span class="math">\(\Phi\cup\left\{ \alpha\right\} \vdash\gamma\)</span>, ובגלל שאפשר להניח שמשפט הדדוקציה מתקיים עבורם, אז <span class="math">\(\Phi\vdash\alpha\to\gamma\)</span> ו-<span class="math">\(\Phi\vdash\alpha\to\left(\gamma\to\beta\right)\)</span>. האם די לנו בשני אלו, בתבנית האקסיומה הנוכחית וב-<span class="math">\(\text{MP}\)</span> כדי להוכיח את <span class="math">\(\alpha\to\beta\)</span>? ובכן, לא. אז מה עושים? מוסיפים עוד תבנית אקסיומה שתפורה בדיוק לסיטואציה הזו: התבנית <span class="math">\(\left[\alpha\to\left(\gamma\to\beta\right)\right]\to\left[\left(\alpha\to\gamma\right)\to\left(\alpha\to\beta\right)\right]\)</span>. תסתכלו על הרכיבים של התבנית ותראו אם אתם מזהים מהיכן היא מגיעה; ובדקו באופן כלשהו שהתבנית הזו היא אכן טאוטולוגיה. לתבנית האקסיומה הזו אני קורא <strong>תבנית אקסיומה מס' </strong><strong>2</strong>.</p>
<p>עכשיו ההוכחה היא טריוויאלית:</p>
<ol>
    <li><span class="math">\(\alpha\to\gamma\)</span> (ניתן להוכחה מ-<span class="math">\(\Phi\)</span>).</li>
    <li><span class="math">\(\alpha\to\left(\gamma\to\beta\right)\)</span> (ניתן להוכחה מ-<span class="math">\(\Phi\)</span>).</li>
    <li><span class="math">\(\left[\alpha\to\left(\gamma\to\beta\right)\right]\to\left[\left(\alpha\to\gamma\right)\to\left(\alpha\to\beta\right)\right]\)</span> (תבנית אקסיומה מס' 2).</li>
    <li><span class="math">\(\left(\alpha\to\gamma\right)\to\left(\alpha\to\beta\right)\)</span> (<span class="math">\(\text{MP}\)</span> על 2,3).</li>
    <li><span class="math">\(\alpha\to\beta\)</span> (<span class="math">\(\text{MP}\)</span> על 1,4).</li>
</ol>
<p>נשאר לנו רק לטפל בחוב מההתחלה - להראות שאפשר להוכיח את <span class="math">\(\alpha\to\alpha\)</span>. עכשיו יש לנו כלי נשק חדש - שתי תבניות אקסיומה שנמצאות ברשותנו ואנחנו לא מהססים להשתמש בהן. מפתה להשתמש בתבנית הראשונה כשמציבים בה <span class="math">\(\alpha\)</span> במקום <span class="math">\(\beta\)</span> ומקבלים <span class="math">\(\alpha\to\left(\alpha\to\alpha\right)\)</span>, רק שזה לא עוזר לנו במיוחד כי אנחנו <strong>לא</strong> יכולים להוכיח את <span class="math">\(\alpha\)</span> בשום צורה. כנראה שתבנית אקסיומה 1 לבדה לא ממש תעזור לנו וצריך להשתמש גם ב-2. בואו נציב גם ב-2 <span class="math">\(\alpha\)</span> במקום<br />
הכל ונראה מה נקבל:</p>
<ol>
    <li><span class="math">\(\alpha\to\left(\alpha\to\alpha\right)\)</span> (תבנית אקסיומה מס' 1).</li>
    <li><span class="math">\(\left[\alpha\to\left(\alpha\to\alpha\right)\right]\to\left[\left(\alpha\to\alpha\right)\to\left(\alpha\to\alpha\right)\right]\)</span> (תבנית אקסיומה מס' 2).</li>
    <li><span class="math">\(\left(\alpha\to\alpha\right)\to\left(\alpha\to\alpha\right)\)</span> (<span class="math">\(\text{MP}\)</span> על 1,2).</li>
</ol>
<p>ו.. נתקענו. כדי להפיק תועלת מ-<span class="math">\(\left(\alpha\to\alpha\right)\to\left(\alpha\to\alpha\right)\)</span> נצטרך להוכיח את <span class="math">\(\alpha\to\alpha\)</span>, וזה בדיוק מה שאנחנו מנסים להוכיח! אז מה יצא לנו מכל זה?</p>
<p>אם כן, אולי לא כדאי מייד להציב גם ב-<span class="math">\(\beta\)</span> וגם ב-<span class="math">\(\gamma\)</span> את <span class="math">\(\alpha\)</span>? אולי יש הצבה קצת יותר מועילה שאפשר לעשות? עם זאת, לא כדאי להציב דברים מופרעים יותר מדי: אם אנחנו מתכננים להשתמש ב-<span class="math">\(\left[\alpha\to\left(\gamma\to\beta\right)\right]\to\left[\left(\alpha\to\gamma\right)\to\left(\alpha\to\beta\right)\right]\)</span>, זה אומר שנצטרך להפעיל עליה <span class="math">\(\text{MP}\)</span>. זה אומר שנצטרך להוכיח איכשהו את <span class="math">\(\left[\alpha\to\left(\gamma\to\beta\right)\right]\)</span>, וזה אומר ש-<span class="math">\(\left[\alpha\to\left(\gamma\to\beta\right)\right]\)</span> חייב להתאים למבנה של תבנית אקסיומה כלשהי - מן הסתם, תבנית אקסיומה מס' 1. שימו לב איך <strong>אין לנו ברירה</strong> ואנחנו ממש נדחפים לכך שנהיה חייבים לבחור <span class="math">\(\beta=\alpha\)</span>, אחרת <span class="math">\(\left[\alpha\to\left(\gamma\to\beta\right)\right]\)</span> לעולם לא תתאים לתבנית של אקסיומה מס' 1. לעומת זאת, ל-<span class="math">\(\gamma\)</span> יש לנו חופש בחירה מוחלט; בואו נתחיל נסיון הוכחה חדש ונראה מה ישתלם לנו לבחור בתור ערכו של <span class="math">\(\gamma\)</span>.</p>
<ol>
    <li><span class="math">\(\left[\alpha\to\left(\gamma\to\alpha\right)\right]\to\left[\left(\alpha\to\gamma\right)\to\left(\alpha\to\alpha\right)\right]\)</span> (תבנית אקסיומה מס' 2).</li>
    <li><span class="math">\(\alpha\to\left(\gamma\to\alpha\right)\)</span> (תבנית אקסיומה מס' 1).</li>
    <li><span class="math">\(\left(\alpha\to\gamma\right)\to\left(\alpha\to\alpha\right)\)</span> (<span class="math">\(\text{MP}\)</span> על 1,2).</li>
</ol>
<p>אנחנו כמעט שם! רק צריך לבחור ערך ל-<span class="math">\(\gamma\)</span> כך ש-<span class="math">\(\alpha\to\gamma\)</span> ייראה כמו תבנית האקסיומה <span class="math">\(\alpha\to\left(\beta\to\alpha\right)\)</span>. אם כן, מתבקש לבחור <span class="math">\(\gamma=\alpha\to\alpha\)</span>, ולקבל:</p>
<ol>
    <li><span class="math">\(\left[\alpha\to\left(\alpha\to\alpha\right)\right]\to\left(\alpha\to\alpha\right)\)</span> (הצבנו <span class="math">\(\gamma=\alpha\to\alpha\)</span>).</li>
    <li><span class="math">\(\alpha\to\left(\alpha\to\alpha\right)\)</span> (תבנית אקסיומה מס' 1).</li>
    <li><span class="math">\(\alpha\to\alpha\)</span> (<span class="math">\(\text{MP}\)</span> על 1,2).</li>
</ol>
<p>זה מסיים את הוכחת משפט הדדוקציה, וממחיש איך נראות הוכחות על מערכת ההוכחה הפורמלית שלנו; אלו הוכחות מילוליות, שפה ושם מציגות "קטעי קוד" מתוך מערכת ההוכחה הפורמלית עצמה. זו גם ככל הנראה ההוכחה הכי "כבדה" מבחינת כמות קטעי הקוד שמופיעים בה.</p>
<p>משפט הדדוקציה הוא כלי חשוב בדרך להוכחת משפט השלמות; יש עוד כלי אחד שאזדקק לו ויכריח אותנו להוסיף תבנית אקסיומה שלישית ואחרונה למערכת ההוכחה שלנו. בפוסט הבא נוכיח את הכלי הזה, נסיים את הצגת מערכת ההוכחה שלנו, ונוכיח את משפט השלמות.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>