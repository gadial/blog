<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מרחבי מכפלה פנימית - לפעמים הצמדה היא באמת הצמדה - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2012/04/29/inner_product_space_adjoint/">
    <meta property="og:title" content="מרחבי מכפלה פנימית - לפעמים הצמדה היא באמת הצמדה">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2012/04/29/inner_product_space_adjoint/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="מרחבי מכפלה פנימית - לפעמים הצמדה היא באמת הצמדה">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2012/04/24/propositional_calculus_compactness/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">תחשיב הפסוקים - משפט הקומפקטיות ואיך משפט השלמות דומה למשפט טיכונוף</span>
            </a>
            

            
            <a href="/2012/05/11/valiant-vazirani/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">משפט Valiant-Vazirani, או: איך להרוג השמות מספקות עם פונקציות תמצות אקראיות</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מרחבי מכפלה פנימית - לפעמים הצמדה היא באמת הצמדה</h1>
            <div class="post-meta">
                <span class="date">2012-04-29</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אלגברה לינארית.html">אלגברה לינארית</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אופרטור הרמיטי.html">אופרטור הרמיטי</a>
                    
                    <a href="/tags/מרחבי מכפלה פנימית.html">מרחבי מכפלה פנימית</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בסוף <a href="http://www.gadial.net/2012/03/01/inner_product_spaces_geometry/">הפוסט האחרון שלי</a> על אלגברה לינארית הבטחתי שנדבר על מה שקורה כשלוקחים מרחב מכפלה פנימית ומתחילים לדבר על טרנספורמציות לינאריות מעליו. אני רוצה להתחיל עם הסוג הפשוט ביותר של טרנספורמציות לינאריות - פונקציונלים לינאריים.</p>
<p>תזכורת קצרה: <span class="math">\(V\)</span> הוא מרחב מכפלה פנימית אם הוא מרחב וקטורי מעל <span class="math">\(\mathbb{C}\)</span> שמוגדרת בו פונקציה <span class="math">\(\left\langle \cdot,\cdot\right\rangle :V\times V\to\mathbb{C}\)</span> שהיא לינארית במשתנה הראשון (כלומר, <span class="math">\(\left\langle \lambda x+y,z\right\rangle =\lambda\left\langle x,z\right\rangle +\left\langle y,z\right\rangle \)</span>), הרמיטית - <span class="math">\(\left\langle x,y\right\rangle =\overline{\left\langle y,x\right\rangle }\)</span> ("כמעט" סימטרית עד כדי הצמוד למעלה, שאת הסיבות לו הסברתי בעבר) וחיובית, כלומר <span class="math">\(\left\langle x,x\right\rangle \ge0\)</span> ושוויון הוא רק כש-<span class="math">\(x=0\)</span>. פונקציונל לינארי במקרה שלנו הוא פונקציה לינארית <span class="math">\(f:V\to\mathbb{C}\)</span>. הדמיון למכפלה פנימית די ברור - פונקציונל פועל על איבר אחד ואילו מכפלה פנימית על שניים, אבל שניהם מחוייבים ללינאריות מסוג כלשהו. אם המרחב <span class="math">\(V\)</span> הוא סוף-ממדי (ואני מתכנן לדבר רק על מרחבי מכפלה פנימית סוף ממדיים; מה שקורה במרחבים אינסוף מימדיים הוא נושא לסדרת פוסטים ארוכה אף יותר מהנוכחית), הדמיון הוא לחלוטין לא מקרי - מסתבר ש<strong>כל </strong>פונקציונל לינארי על <span class="math">\(V\)</span> ניתן לתיאור באופן יחיד באמצעות המכפלה הפנימית (במרחב אינסוף ממדי זה פשוט לא נכון, אם כי לא אציג דוגמאות נגדיות כעת).</p>
<p>בואו ראשית כל נשחק במשחק הבא: ניקח <span class="math">\(y\in V\)</span> כלשהו ונחשוב עליו כעל "קבוע". אז אפשר להגדיר פונקציה <span class="math">\(f_{y}:V\to\mathbb{C}\)</span> של "מכפלה פנימית ב-<span class="math">\(y\)</span>", כלומר <span class="math">\(f_{y}\left(x\right)=\left\langle x,y\right\rangle \)</span>. קל לראות ש-<span class="math">\(f_{y}\)</span> היא פונקציונל לינארי, פשוט בגלל הלינאריות של המכפלה הפנימית; מה שקורה במרחב סוף ממדי הוא ש<strong>כל</strong> פונקציונל לינארי <span class="math">\(f\)</span> ניתן להצגה כ-<span class="math">\(f_{y}\)</span> עבור <span class="math">\(y\)</span> אחד ויחיד ספציפי. איך מוצאים אותו? בעזרת הכלי הסטנדרטי שלנו להתמודדות עם מרחבי מכפלה פנימית - בסיסים אורתונורמליים.</p>
<p>ניקח בסיס אורתונורמלי <span class="math">\(u_{1},\dots,u_{n}\)</span> למרחב. בהינתן <span class="math">\(x\in V\)</span> כלשהו, אנחנו יודעים ש-<span class="math">\(x=\sum\left\langle x,u_{i}\right\rangle u_{i}\)</span> (זוכרים? כשמייצגים איבר בבסיס אורתונורמלי, המקדם של איבר הבסיס <span class="math">\(u_{i}\)</span> בצירוף הלינארי הוא בדיוק המכפלה הפנימית של <span class="math">\(x\)</span> ב-<span class="math">\(u_{i}\)</span>. קוראים לזה "מקדם פורייה" של <span class="math">\(x\)</span> בבסיס <span class="math">\(u_{1},\dots,u_{n}\)</span>). אנחנו גם יודעים איך מכפלה פנימית של שני איברים כלליים נראית: אם <span class="math">\(y=\sum\left\langle y,u_{i}\right\rangle u_{i}\)</span> הוא איבר תמים אחר של <span class="math">\(V\)</span> ואנו כופלים אותו ב-<span class="math">\(x\)</span>, נקבל:</p>
<p><span class="math">\(\left\langle x,y\right\rangle =\left\langle \sum\left\langle x,u_{i}\right\rangle u_{i},\sum\left\langle y,u_{j}\right\rangle u_{j}\right\rangle =\sum_{i,j}\left\langle x,u_{i}\right\rangle \overline{\left\langle y,u_{j}\right\rangle }\left\langle u_{i},u_{j}\right\rangle =\sum_{i}\left\langle x,u_{i}\right\rangle \overline{\left\langle y,u_{i}\right\rangle }\)</span></p>
<p>כעת, אם נפעיל את <span class="math">\(f\)</span> על <span class="math">\(x\)</span> ונשתמש בלינאריות שלו, נקבל ש-<span class="math">\(f\left(x\right)=\sum\left\langle x,u_{i}\right\rangle f\left(u_{i}\right)\)</span>. זה מאוד מזכיר את המשוואה שלמעלה, אם <span class="math">\(f\left(u_{i}\right)=\overline{\left\langle y,u_{i}\right\rangle }\)</span>, ובניסוח אחר <span class="math">\(\left\langle y,u_{i}\right\rangle =\overline{f\left(u_{i}\right)}\)</span>. זה מוביל אותנו ל<strong>הגדרה</strong> הבאה: <span class="math">\(y=\sum\overline{f\left(u_{i}\right)}u_{i}\)</span>. כעת קל לוודא שאכן <span class="math">\(f\left(x\right)=\left\langle x,y\right\rangle \)</span> לכל <span class="math">\(x\in V\)</span>. כדי לוודא ש-<span class="math">\(y\)</span> הוא יחיד, נניח כי ישנם <span class="math">\(y_{1},y_{2}\)</span> כך ש-<span class="math">\(\left\langle x,y_{1}\right\rangle =f\left(x\right)=\left\langle x,y_{2}\right\rangle \)</span> לכל <span class="math">\(x\)</span>, כלומר <span class="math">\(\left\langle x,y_{1}-y_{2}\right\rangle =0\)</span> לכל <span class="math">\(x\)</span>. במרחב סוף ממדי זה יכול לקרות רק אם <span class="math">\(y_{1}-y_{2}=0\)</span>, כלומר <span class="math">\(y_{1}=y_{2}\)</span> (למה בעצם אם <span class="math">\(\left\langle x,y\right\rangle =0\)</span> לכל <span class="math">\(x\)</span> זה גורר ש-<span class="math">\(y=0\)</span>? תרגיל טוב).</p>
<p><a href="http://www.gadial.net/2011/11/02/linear_functionals/">בפוסט שלי</a> על פונקציונלים לינאריים הערתי שיש איזומורפיזם בין <span class="math">\(V\)</span> ובין <span class="math">\(V^{*}\)</span>- מרחב הפונקציונלים הלינאריים מעל <span class="math">\(V\)</span>, אך הוא אינו "קנוני" - כלומר, עבור בחירות בסיס שונות עבור <span class="math">\(V\)</span> נקבל איזומורפיזמים שונים ואין דרך להכריע מי מביניהם יותר "נכון". במקרה שבו <span class="math">\(V\)</span> הוא מרחב מכפלה פנימית, קיבלנו איזומורפיזם קנוני לעילא ולעילא - <span class="math">\(y\mapsto f_{y}\)</span>, שאינו תלוי בבחירת בסיס זה או אחר למרחב. כמובן שאני קצת משקר כאן - האיזומורפיזם הזה עדיין תלוי בבחירת <strong>מכפלה פנימית</strong> למרחב, והיא שקולה לבחירת בסיס, אבל נעזוב את זה.</p>
<p>בואו נעבור לדבר עכשיו על משהו אחר - אופרטורים לינאריים, כלומר טרנספורמציות לינאריות <span class="math">\(T:V\to V\)</span> מ-<span class="math">\(V\)</span> לעצמו. השאלה הראשונה שאני שואל היא שאלה של סימטריה: נניח שיש לי וקטורים <span class="math">\(x,y\)</span>, ואני מפעיל את <span class="math">\(T\)</span> על <span class="math">\(x\)</span> ואז כופל את התוצאה עם <span class="math">\(y\)</span> - האם אקבל את אותו הדבר כאילו הפעלתי את <span class="math">\(T\)</span> על <span class="math">\(y\)</span> וכפלתי את <span class="math">\(x\)</span> בזה? כלומר, האם <span class="math">\(\left\langle Tx,y\right\rangle =\left\langle x,Ty\right\rangle \)</span>? התשובה היא שלא תמיד, ושאופרטורים שמקיימים את התכונה הזו הם מעניינים למדי - הם נקראים <strong>אופרטורים הרמיטיים</strong> (ומעל <span class="math">\(\mathbb{R}\)</span>- <strong>סימטריים</strong>). קחו רגע ונסו להסביר לעצמכם למה השוויון <span class="math">\(\left\langle Tx,y\right\rangle =\left\langle x,Ty\right\rangle \)</span> כלל לא מובן מאליו.</p>
<p>אוקיי, אז לא תמיד מתקיים <span class="math">\(\left\langle Tx,y\right\rangle =\left\langle x,Ty\right\rangle \)</span>. עדיין, התחושה האינטואיטיבית היא שמידת מה של סימטריה צריכה להיות כאן, והתחושה הזו מדוייקת - לכל אופרטור <span class="math">\(T\)</span> מותאם אופרטור <span class="math">\(T^{*}\)</span> - <strong>הצמוד ההרמיטי</strong> של <span class="math">\(T\)</span> - כך ש-<span class="math">\(\left\langle Tx,y\right\rangle =\left\langle x,T^{*}y\right\rangle \)</span>. זה המשפט העיקרי שאני רוצה להוכיח בפוסט. כעת אפשר לתאר אופרטור הרמיטי בצורה קצת יותר פשוטה: זה אופרטור שמקיים <span class="math">\(T=T^{*}\)</span>, כלומר הוא שווה לצמוד ההרמיטי שלו; כלומר הוא <strong>צמוד לעצמו</strong>. זה עוד שם לאופרטורים הרמיטיים.</p>
<p>הוכחת הקיום של <span class="math">\(T^{*}\)</span> היא מחוכמת ואלגנטית. הבה ונקבע את <span class="math">\(y\)</span> לרגע, אז אפשר להגדיר פונקציונל לינארי <span class="math">\(f\left(x\right)=\left\langle Tx,y\right\rangle \)</span>. במילים אחרות, בהינתן <span class="math">\(x\)</span> נתעלל בו על ידי הפעלת <span class="math">\(T\)</span> עליו ואז מכפלה פנימית של כל זה עם <span class="math">\(y\)</span>. זה אכן פונקציונל כי <span class="math">\(T\)</span> היא טרנספורמציה לינארית ומכפלה פנימית היא לינארית. אם <span class="math">\(f\)</span> הזו היא פונקציונל, אז יש איזה שהוא <span class="math">\(z\)</span> שמגדיר אותה: <span class="math">\(f\left(x\right)=\left\langle x,z\right\rangle \)</span>. במילים אחרות, <span class="math">\(\left\langle x,z\right\rangle =\left\langle Tx,y\right\rangle \)</span>, ולכן אם קיים בכלל <span class="math">\(T^{*}\)</span> שהוא צמוד הרמיטי של <span class="math">\(T\)</span>, אז הוא מקיים <span class="math">\(\left\langle x,z\right\rangle =\left\langle x,T^{*}y\right\rangle \)</span>. במילים אחרות, אנחנו נדחפים להגדרה <span class="math">\(T^{*}\left(y\right)=z\)</span>.</p>
<p>באופן הזה אפשר להגדיר את <span class="math">\(T^{*}\)</span> לכל איבר <span class="math">\(y\in V\)</span>. צריך לוודא שאכן קיבלנו אופרטור לינארי; שום דבר לא מבטיח לנו שהתנאי ההכרחי שמצאנו עבור <span class="math">\(T^{*}\)</span> (שקבע באופן יחיד איך הוא חייב להיראות) הוא גם מספיק כדי שהוא אכן יהיה אופרטור לינארי; זה ה"קסם" שיש כאן. אם כן, יהיו <span class="math">\(y_{1},y_{2}\)</span> כך ש-<span class="math">\(T^{*}\left(y_{1}\right)=z_{1}\)</span> ו-<span class="math">\(T^{*}\left(y_{2}\right)=z_{2}\)</span>; נרצה להראות ראשית ש-<span class="math">\(T^{*}\left(y_{1}+y_{2}\right)=z_{1}+z_{2}\)</span>. נסמן <span class="math">\(T^{*}\left(y_{1}+y_{2}\right)=z\)</span>; אנחנו יודעים ש-</p>
<p><span class="math">\(\left\langle x,z\right\rangle =\left\langle Tx,y_{1}+y_{2}\right\rangle =\left\langle Tx,y_{1}\right\rangle +\left\langle Tx,y_{2}\right\rangle =\left\langle x,z_{1}\right\rangle +\left\langle x,z_{2}\right\rangle =\left\langle x,z_{1}+z_{2}\right\rangle \)</span></p>
<p>השוויון <span class="math">\(\left\langle x,z\right\rangle =\left\langle x,z_{1}+z_{2}\right\rangle \)</span> עבור ערך ספציפי של <span class="math">\(x\)</span> לא מספיק כדי להסיק ש-<span class="math">\(z=z_{1}+z_{2}\)</span>, אבל מכיוון שזה נכון עבור כל <span class="math">\(x\)</span> זה מספיק (שוב - למה?). באופן דומה גם מראים ש-<span class="math">\(T^{*}\left(\lambda y\right)=\lambda T^{*}\left(y\right)\)</span> ולכן <span class="math">\(T^{*}\)</span> אכן לינארית.</p>
<p>עכשיו, אנחנו יודעים שבמרחב סוף-ממדי כל טרנספורמציה לינארית ניתנת לייצוג באמצעות מטריצות; נניח שקבענו איזה בסיס <strong>אורתונורמלי </strong>של המרחב, <span class="math">\(B=\left\{ u_{1},\dots,u_{n}\right\} \)</span>, ואנחנו מסתכלים על <span class="math">\(\left[T\right]_{B}\)</span> - המטריצה המייצגת של <span class="math">\(T\)</span> ביחס לבסיס הזה. מה הקשר בינה ובין המטריצה המייצגת של <span class="math">\(\left[T^{*}\right]_{B}\)</span>? האם יש לנו תיאור קונקרטי וקל לחישוב של האופן שבו הייצוג הנוח של <span class="math">\(T\)</span> הופך לייצוג נוח של <span class="math">\(T^{*}\)</span>? התשובה חיובית, במקרה שבו <span class="math">\(B\)</span> אורתונורמלי. זכרו שהעמודה ה-<span class="math">\(i\)</span>-ית של המטריצה <span class="math">\(\left[T^{*}\right]_{B}\)</span> היא בדיוק וקטור הקואורדינטות לפי <span class="math">\(B\)</span> של <span class="math">\(T^{*}\left(u_{i}\right)\)</span> (הפעלת <span class="math">\(T^{*}\)</span> על איבר הבסיס ה-<span class="math">\(i\)</span> ב-<span class="math">\(B\)</span>), או במילים אחרות - הכניסה ה-<span class="math">\(j,i\)</span> של <span class="math">\(\left[T^{*}\right]_{B}\)</span> היא בדיוק <span class="math">\(\left\langle T^{*}\left(u_{i}\right),u_{j}\right\rangle \)</span>. בואו נעשה תעלול אלגברי זריז:</p>
<p><span class="math">\(\left\langle T^{*}\left(u_{i}\right),u_{j}\right\rangle =\overline{\left\langle u_{j},T^{*}\left(u_{i}\right)\right\rangle }=\overline{\left\langle T\left(u_{j}\right).u_{i}\right\rangle }\)</span></p>
<p>אבל מה זה <span class="math">\(\left\langle T\left(u_{j}\right).u_{i}\right\rangle \)</span>? זה בדיוק המקדם של <span class="math">\(u_{i}\)</span> בצירוף הלינארי שמגדיר את <span class="math">\(T\left(u_{j}\right)\)</span>. במילים אחרות, זו הכניסה ה-<span class="math">\(i,j\)</span> של המטריצה <span class="math">\(\left[T\right]_{B}\)</span>!</p>
<p>זה מוביל אותנו להגדרה הבאה: אם <span class="math">\(A\)</span> היא מטריצה ריבועית כלשהי מעל המרוכבים, אז <strong>המטריצה הצמודה</strong> שלה מוגדרת בתור <span class="math">\(A^{*}=\overline{A^{t}}\)</span>, כלומר ביצוע שחלוף והצמדה, כלומר <span class="math">\(A_{ij}^{*}=\overline{A_{ji}}\)</span>. כשמדובר במטריצות קל למדי לראות שמתקיימות התכונות הבאות של הצמדה (שאני מנסח בלשון טרנספורמציות כי הן תקפות באותה מידה גם לטרנספורמציות):</p>
<ol>
    <li><span class="math">\(\left(T+S\right)^{*}=T^{*}+S^{*}\)</span></li>
    <li><span class="math">\(\left(\lambda T\right)^{*}=\overline{\lambda}T^{*}\)</span></li>
    <li><span class="math">\(\left(TS\right)^{*}=S^{*}T^{*}\)</span></li>
    <li><span class="math">\(\left(T^{*}\right)^{*}=T\)</span></li>
</ol>
<p>ארבע התכונות הללו מראות לנו שיש מבנה אלגברי כלשהו לפעולה של "קח טרנספורמציה והחזר את הצמודה שלה" - בלשון פונקציות, <span class="math">\(f\left(T\right)=T^{*}\)</span>. תכונות 1 ו-2 אומרות שהפונקציה הזו היא "כמעט לינארית", עד כדי כך שהוצאת סקלר כרוכה בהצמדה שלו - פונקציה כזו נקראת <strong>אנטי-לינארית</strong>, או <strong>לינארית-צמודה</strong>. התכונה הבאה מראה ש-<span class="math">\(f\)</span> הופכת איברים בכפל: <span class="math">\(f\left(TS\right)=f\left(S\right)f\left(T\right)\)</span>.<br />
לפונקציה שמקיימת <span class="math">\(f\left(ST\right)=f\left(S\right)f\left(T\right)\)</span> קוראים <strong>הומומורפיזם</strong> ולכן ההצמדה שלנו, שעושה מעין היפוך של זה, נקראת <strong>אנטי-הומומורפיזם</strong> (מאוד אנטי כל העסק - אנטי-לינארי, אנטי-הומומורפיזם...). לסיום, תכונה 4 אומרת ש-<span class="math">\(f\left(f\left(T\right)\right)=T\)</span> - לפונקציה שמקיימת את זה קוראים <strong>אינבולוציה</strong>. בקיצור, ההצמדה שלנו היא פעולה שמקיימת כמה תכונות מוכרות וחביבות על המתמטיקאים.</p>
<p>באופן לא מפתיע, מסתבר שאפשר להשתמש בתכונות הללו כבסיס להכללה; זה הבסיס לתחום במתמטיקה של <strong>אלגברות <span class="math">\(C\)</span>-כוכב </strong>(אלגבראות <span class="math">\(C^{*}\)</span>), שהן אלגבראות בנך עם פונקציה שמקיימת את תכונות 1-4 ועוד כמה תכונות שלא אכנס אליהן כעת (כמו שלא אכנס להגדרה של אלגברת בנך; כל הדברים הללו קשורים לאלגברה לינארית במרחב אינסוף ממדי). לא ארחיב לכיוון הזה עכשיו, אלא אדבר דווקא על דוגמה פשוטה ביותר לפונקציה לא טריוויאלית נוספת שמקיימת את תכונות 1-4, שאולי כבר קפצה לחלקכם לראש - הצמדה של מספרים מרוכבים. תכונות 1,2,4 שלה באות באופן טבעי לחלוטין; תכונה 3 נובעת מכך ש-<span class="math">\(\overline{zw}=\overline{z}\cdot\overline{w}\)</span> ומכך שבמספרים מרוכבים הכפל הוא קומוטטיבי, כלומר <span class="math">\(\overline{w}\cdot\overline{z}\)</span>. הדמיון הזה מסביר את השם <strong>צמוד</strong> בהקשר הנוכחי.</p>
<p>הדמיון לא נגמר כאן. במספרים מרוכבים מתקיימת התכונה הנחמדה שאם <span class="math">\(z\)</span> הוא מספר מרוכב כלשהו, אז <span class="math">\(\frac{z+\overline{z}}{2}\)</span> הוא החלק הממשי של <span class="math">\(z\)</span>, ואילו <span class="math">\(\frac{z-\overline{z}}{2}\)</span> הוא החלק המדומה של <span class="math">\(z\)</span> (בדקו בעצמכם אם אינכם זוכרים/יודעים/מאמינים). בואו נעשה דבר דומה עם טרנספורמציות: ניקח <span class="math">\(T\)</span> כלשהי ונגדיר <span class="math">\(T_{R}=\frac{T+T^{*}}{2}\)</span> ו-<span class="math">\(T_{I}=\frac{T-T^{*}}{2}\)</span>.</p>
<p>עכשיו, <span class="math">\(T_{R}^{*}=\frac{1}{2}\left(T+T^{*}\right)^{*}=\frac{T^{*}+\left(T^{*}\right)^{*}}{2}=\frac{T+T^{*}}{2}=T_{R}\)</span>, ולכן <span class="math">\(T_{R}\)</span> צמודה לעצמה; בדומה נקבל ש-<span class="math">\(T_{I}^{*}=-T_{I}\)</span> - לטרנספורמציה שמקיימת את התכונה הזו קוראים <strong>אנטי-הרמיטית</strong>. כפי שאתם ודאי שמים לב, <span class="math">\(T_{R}\)</span> מתנהג ביחס להצמדה כמו שמספר ממשי מתנהג ביחס אליה, ו-<span class="math">\(T_{I}\)</span> מתנהג כמו שמספר מדומה טהור מתנהג ביחס אליה. כעת שימו לב לכך ש-<span class="math">\(T=T_{R}+T_{I}\)</span> , כלומר כל טרנספורמציה לינארית במרחב סוף ממדי ניתן לרשום כסכום של טרנספורמציה הרמיטית וטרנספורמציה אנטי-הרמיטית (למעשה, אפשר גם להגדיר <span class="math">\(T_{I}^{\prime}=\frac{T-T^{*}}{2i}\)</span> ולקבל טרנספורמציה הרמיטית ואז הפירוק הוא <span class="math">\(T=T_{R}+iT_{I}^{\prime}\)</span> - שוב, בדיוק כמו עם מספרים מרוכבים). האנלוגיה הזו הלהיבה אותי מאוד בשעתו; זה תמיד מעניין לראות איך תכונות שקיימות במרוכבים הן ממש לא נחלתם הבלעדית אלא מעידות כנראה על משהו עמוק יותר מתחת לפני השטח.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>