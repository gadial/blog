<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט השלמות לתחשיב הפסוקים - לא מדויק</title>
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <header>
            <h1>משפט השלמות לתחשיב הפסוקים</h1>
            <div class="post-meta">
                <span class="date">2012-04-08</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/תחשיב הפסוקים.html">תחשיב הפסוקים</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסט הקודם הצגתי מערכת הוכחה (חלקית, עוד לא גמרנו) לתחשיב הפסוקים והוכחתי שהיא מקיימת את משפט הדדוקציה: אם <span class="math">\(\Phi\cup\left\{ \alpha\right\} \vdash\beta\)</span> אז <span class="math">\(\Phi\vdash\alpha\to\beta\)</span>. הפעם אני רוצה להמשיך לבנות את מערכת ההוכחה הזו ולהראות שהיא מקיימת את התכונה שלשמה היא קיימת: להוכיח כל מה ש"נכון", דהיינו אם <span class="math">\(\Phi\models\varphi\)</span> אז <span class="math">\(\Phi\vdash\varphi\)</span> (זכרו: <span class="math">\(\Phi\)</span> היא קבוצת פסוקים <strong>כלשהי</strong> של "הנחות"; מערכת ההוכחה שלנו מסתתרת כולה בתוך הסימן <span class="math">\(\vdash\)</span>). ההוכחה עצמה היא מרהיבה וכוללת לפחות שני רעיונות שלטעמי הם מקסימים; אולי הדבר הכי נחמד בה הוא שעיקר העבודה היא בכלל הוכחה של טענה אחרת שנראית לא קשורה ממבט חטוף ראשון אבל היא בעצם לב העניין. כדי להציג אותה, אזדקק להגדרה אחת אחרונה - <strong>עקביות</strong>.</p>
<p>אנחנו אומרים שקבוצת פסוקים <span class="math">\(\Phi\)</span> היא עקבית אם אי אפשר להוכיח ממנה דבר ושלילתו, כלומר לא קיים <span class="math">\(\varphi\)</span> כך שגם <span class="math">\(\Phi\vdash\varphi\)</span> וגם <span class="math">\(\Phi\vdash\neg\varphi\)</span>. אם <span class="math">\(\Phi\)</span> עושה דבר כזה, אז ממשפט הנאותות של מערכת ההוכחה שלנו נובע ש-<span class="math">\(\Phi\models\varphi\)</span> וגם <span class="math">\(\Phi\models\neg\varphi\)</span>, כלומר כל השמה שמספקת את <span class="math">\(\Phi\)</span> בו זמנית מספקת גם את <span class="math">\(\varphi\)</span> וגם את <span class="math">\(\neg\varphi\)</span> וזה בלתי אפשרי עם ההגדרות שלנו ל"מספקת"; המסקנה היא שאם <span class="math">\(\Phi\)</span> היא לא עקבית, אין השמה שמספקת אותה. אם אין השמה שמספקת אותה, אז לכל <span class="math">\(\psi\)</span> שלא יהיה מתקיים <span class="math">\(\Phi\models\psi\)</span> ("באופן ריק") ולכן, אם מערכת ההוכחה שלנו מקיימת את משפט השלמות, אז <span class="math">\(\Phi\vdash\psi\)</span> לכל <span class="math">\(\psi\)</span>. במילים אחרות: במערכת הוכחה "נורמלית" (שמקיימת שלמות ונאותות), קבוצה לא עקבית של פסוקים מוכיחה <strong>הכל</strong>. באנגלית קוראים לזה Principle of Explosion ובעברית אין לי מושג אם יש לזה שם.</p>
<p><img class="alignnone" title="Principle of Explosion" alt="" src="http://imgs.xkcd.com/comics/principle_of_explosion.png" width="740" height="252" /></p>
<p>(<a href="http://xkcd.com/704/">http://xkcd.com/704/</a>)</p>
<p>מעכשיו אני אפסיק לדבר על "השמה מספקת" ואשתמש בביטוי <strong>מודל</strong> שהוא גם קומפקטי יותר וגם מתאים יותר לטרמינולוגיה של תחשיב היחסים (לא להתבלבל - מודל הוא תמיד השמה שהיא גם מספקת, לא סתם כל השמה אפשרית). בנוסף, במקום לומר "קבוצת פסוקים" אני אומר <strong>תורה</strong> (שוב, זה מתאים למושג טיפה יותר כללי בתחשיב היחסים, שבו תורה צריכה לכלול גם אוסף ספציפי של סימנים - מילון - אבל לא ניכנס לזה עכשיו). אם כן, מה שאמרתי עד הוא הוא שלתורה לא עקבית אין מודל, ולכן תורה שיש לה מודל היא עקבית. אבל, האם ל<strong>כל</strong> תורה עקבית יש מודל? או, שאלה מצויינת: כל כך מצויינת, שנגלה שהיא <strong>גוררת</strong> את משפט השלמות (לפחות במערכת ההוכחה שאני בונה).</p>
<p>כדי להבין איך הקסם הזה קורה, אני נזקק לעוד תכונה אחת של מערכת ההוכחה שלי: הוכחה בשלילה. אני רוצה לטעון שאם <span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \)</span> אינה עקבית, אז <span class="math">\(\Phi\vdash\varphi\)</span> (זוהי <strong>בדיוק</strong> הוכחה בשלילה כפי שאנחנו מכירים אותה ממתמטיקה יומיומית; יש לנו הנחות <span class="math">\(\Phi\)</span>; אנחנו מניחים ש-<span class="math">\(\varphi\)</span> אינו נכון, מוכיחים מכך סתירה, ומסיקים ש-<span class="math">\(\varphi\)</span> כן נכון, בהינתן ההנחות <span class="math">\(\Phi\)</span>). לרוע המזל, מערכת ההוכחה שלי עד כה אינה מסוגלת לבצע את הקסם הזה, ולכן אני נזקק לתבנית אקסיומה אחת אחרונה.</p>
<p>ראשית, בואו ננסה להבין מה יש לנו. אם <span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \)</span> אינה עקבית, אז בואו נניח שמערכת ההוכחה שלנו כבר חזקה מספיק כדי שלכל <span class="math">\(\psi\)</span> יתקיים <span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \vdash\psi\)</span>, ואז נוכל להסיק ממשפט הדדוקציה <span class="math">\(\Phi\vdash\neg\varphi\to\psi\)</span>. עכשיו, כלל ידוע במתמטיקה הוא שלהגיד "אם אלף אז בית" שקול ללהגיד "אם לא בית אז לא אלף". זה <strong>בדיוק</strong> מה שעשיתי לכם לפני שניה - אמרתי "אם תורה היא לא עקבית אין לה מודל" שהיה שקול ל"אם לתורה יש מודל היא עקבית". מערכת ההוכחה שלנו עדיין לא יודעת לבטא את העקרון הזה בצורה תחבירית (אין לה את היכולת ליצור מחרוזת שזה מה שהיא אומרת), אז נוסיף לה תבנית אקסיומה שאומרת בדיוק את זה: <span class="math">\(\left(\neg\alpha\to\neg\beta\right)\to\left(\beta\to\alpha\right)\)</span>. זוהי <strong>תבנית אקסיומה מס' </strong><strong>3</strong>. אתם מוזמנים לבדוק שזוהי אכן טאוטולוגיה.</p>
<p>עכשיו הוכחה של "משפט ההוכחה בשלילה" היא קלה. בואו נבחר בתור <span class="math">\(\psi\)</span> טאוטולוגיה כלשהי ש-<span class="math">\(\Phi\)</span> יודעת להוכיח (<span class="math">\(\varphi\to\left(\varphi\to\varphi\right)\)</span> לאלו מכם שרוצים להיות קונקרטיים, אבל זה חסר חשיבות). אז הוכחה של <span class="math">\(\varphi\)</span> תיראה כך:</p>
<ol>
    <li><span class="math">\(\neg\varphi\to\neg\psi\)</span> (ממשפט הדדוקציה).</li>
    <li><span class="math">\(\left(\neg\varphi\to\neg\psi\right)\to\left(\psi\to\varphi\right)\)</span> (תבנית אקסיומה 3).</li>
    <li><span class="math">\(\psi\to\varphi\)</span> (<span class="math">\(\mbox{MP}\)</span> על 1,2).</li>
    <li><span class="math">\(\psi\)</span> (טאוטולוגיה שיכיחה מ-<span class="math">\(\Phi\)</span>).</li>
    <li><span class="math">\(\varphi\)</span> (<span class="math">\(\mbox{MP}\)</span> על 3,4).</li>
</ol>
<p>סיימנו עם משפט ההוכחה בשלילה, אבל רק בהנחה שעקרון הפיצוץ אכן מתרחש במערכת ההוכחה שלנו. בפועל זה קורה בדיוק "בזכות" תבנית אקסיומה 3: נניח ש-<span class="math">\(\Phi\)</span> אינה עקבית, כלומר <span class="math">\(\Phi\vdash\varphi\)</span> וגם <span class="math">\(\Phi\vdash\neg\varphi\)</span> עבור <span class="math">\(\varphi\)</span> כלשהו. בואו נראה הוכחה של <span class="math">\(\psi\)</span> כלשהו:</p>
<ol>
    <li><span class="math">\(\left(\neg\psi\to\neg\varphi\right)\to\left(\varphi\to\psi\right)\)</span> (תבנית אקסיומה 3).</li>
    <li><span class="math">\(\neg\varphi\to\left(\neg\psi\to\neg\varphi\right)\)</span> (תבנית אקסיומה 1).</li>
    <li><span class="math">\(\neg\varphi\)</span> (ניתן להוכחה מ-<span class="math">\(\Phi\)</span>).</li>
    <li><span class="math">\(\neg\psi\to\neg\varphi\)</span> (<span class="math">\(\mbox{MP}\)</span> על 2,3).</li>
    <li><span class="math">\(\varphi\to\psi\)</span> (<span class="math">\(\mbox{MP}\)</span> על 1,4).</li>
    <li><span class="math">\(\varphi\)</span> (ניתן להוכחה מ-<span class="math">\(\Phi\)</span>).</li>
    <li><span class="math">\(\psi\)</span> (<span class="math">\(\mbox{MP}\)</span> על 5,6).</li>
</ol>
<p>בואו נבין עכשיו למה הטענה "אם <span class="math">\(\Phi\)</span> עקבית אז יש לה מודל" גוררת את משפט השלמות. יהא <span class="math">\(\varphi\)</span> כך ש-<span class="math">\(\Phi\models\varphi\)</span>. אם <span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \)</span> אינה עקבית, אז סיימנו; ממשפט ההוכחה בשלילה, <span class="math">\(\Phi\vdash\varphi\)</span>. אחרת, אם <span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \)</span> כן עקבית, אז מההנחה שלנו קיים לה מודל. המודל הזה הוא השמה שמספקת בו זמנית את כל פסוקי <span class="math">\(\Phi\)</span> ואת <span class="math">\(\neg\varphi\)</span>; אבל מכיוון ש-<span class="math">\(\Phi\models\varphi\)</span> כל השמה שמספקת את כל פסוקי <span class="math">\(\Phi\)</span> מספקת גם את <span class="math">\(\varphi\)</span> - סתירה לכך שההשמה מספקת את <span class="math">\(\neg\varphi\)</span>. זה הכל.</p>
<p>שימו לב שההוכחה הזו איננה קונסטרוקטיבית; היא לא מצביעה על האופן שבו אפשר, בהינתן <span class="math">\(\varphi\)</span> שמקיים <span class="math">\(\Phi\models\varphi\)</span>, לבנות הוכחה עבורו. האם אתם מזהים היכן בהוכחה השלב הלא קונסטרוקטיבי? ההוכחה בסך הכל אומרת "לא ייתכן ש-<span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \)</span> עקבית", ומכאן אנחנו מסיקים ש-<span class="math">\(\Phi\vdash\varphi\)</span> ממשפט ההוכחה בשלילה; אבל משפט ההוכחה בשלילה עצמו מניח שבגלל ש-<span class="math">\(\Phi\cup\left\{ \neg\varphi\right\} \)</span> לא עקבית, אז <strong>קיימת</strong> הוכחה במערכת הזו לזוג כלשהו של <span class="math">\(\psi\)</span> ו-<span class="math">\(\neg\psi\)</span>. אחרי שיש לנו ביד את ההוכחה הזו, כל מה שנשאר הוא כמה צעדים פשוטים ומוגדרים היטב. אבל איך ההוכחה של הזוג הזה נראית, אין לנו מושג.</p>
<p>אפשר לחשוב על מה שעשינו גם כך: לפני רגע רצינו להוכיח טענה על ה<strong>תחביר</strong> באמצעות הנחה על ה<strong>סמנטיקה</strong> (הנחנו ש-<span class="math">\(\Phi\models\varphi\)</span> ורצינו להסיק <span class="math">\(\Phi\vdash\varphi\)</span>), ועכשיו הפכנו את היוצרות: אנחנו מניחים משהו על ה<strong>תחביר</strong> - ש-<span class="math">\(\Phi\)</span> עקבית - ורוצים להסיק מזה משהו על הסמנטיקה - שיש ל-<span class="math">\(\Phi\)</span> מודל. כל שארית ההוכחה שלנו תעסוק בנסיון לבנות ל-<span class="math">\(\Phi\)</span> את המודל הזה. הבניה הזו נתקלת בקושי לא צפוי, עם פתרון לא צפוי, שלטעמי הוא החלק המקסים ביותר כאן: מסתבר שקשה למצוא מודל ל-<span class="math">\(\Phi\)</span> דווקא בגלל שיש לנו <strong>יותר מדי</strong> חופש בחירה - יש יותר מדי השמות שיש להן "פוטנציאל להיות מודל ל-<span class="math">\(\Phi\)</span>". הפתרון יהיה להרחיב את <span class="math">\(\Phi\)</span> לתורה עקבית גדולה בהרבה, שהרבה יותר קשה לספק אותה - יהיה לה רק מודל אחד ויחיד. דווקא בגלל אובדן החופש הזה, הרבה יותר קל למצוא את המודל הזה; אין לנו שום בחירה בבניה שלו ולכן הוא ממש "בונה את עצמו".</p>
<p>העניין הזה, של "יש יותר מדי חופש פעולה ורק אחרי שנגביל את עצמנו פתאום ההוכחה תבנה את עצמה" נשמע לי מוכר מאוד כשקראתי (יחסית לא מזמן, אחרי שנים שלא עשיתי זאת) את ההוכחה של משפט הפסוקים; זה הזכיר לי משפט מרכזי מתחום לכאורה שונה לגמרי - את משפט טיכונוף בטופולוגיה קבוצתית. הדמיון הוא כמובן לא מקרי ובדיעבד גם לא מפתיע במיוחד - כבר <a href="http://www.gadial.net/2008/03/03/compactness_theorem_intro/">תיארתי בבלוג בעבר</a> את האופן שבו ניתן להוכיח משפט מלוגיקה של תחשיב הפסוקים - משפט הקומפקטיות, שעוד נגיע אליו - בעזרת טופולוגיה, כשהמשפט ה"כבד" שעשה את העבודה האמיתית ברקע הוא משפט טיכונוף; למשפט הקומפקטיות יש גם הוכחה לוגית למהדרין שבה המשפט ה"כבד" שעושה את העבודה האמיתית ברקע הוא משפט השלמות. לא מפתיע להבין ששני אלו הם בעצם אותו הדבר בתחפושת (עד כדי כך שמשפט טיכונוף הוא כללי וחזק בהרבה ממשפט השלמות לתחשיב הפסוקים). כרגיל במתמטיקה, אם יש דמיון שכזה הוא כנראה אינו מקרי: גם את משפט השלמות וגם את משפט טיכונוף אפשר להוכיח בסיוע מושג כללי ממתמטיקה שנקרא <strong>פילטר</strong>; אני מקווה להציג את כל העניין בפוסט בהמשך. לעת עתה, שכחו ממשפט טיכונוף ומפילטרים, ואוכיח את משפט השלמות בלי שום הנחות וידע מוקדם נוסף.</p>
<p>כאמור, המטרה שלי היא למצוא מודל ל-<span class="math">\(\Phi\)</span>, אבל זה לא קל. מודל ל-<span class="math">\(\Phi\)</span> הוא סדרה של ערכי <span class="math">\(\mbox{T/F}\)</span> שאני מציב למשתנים <span class="math">\(X_{1},X_{2},X_{3},\dots\)</span>. אני יכול להתחיל בלהגיד "טוב, אם הצבת <span class="math">\(\mbox{T}\)</span> ב-<span class="math">\(X_{1}\)</span> לא הופכת אף פסוק ב-<span class="math">\(\Phi\)</span> לבלתי ניתן לסיפוק, נציב בו <span class="math">\(\mbox{T}\)</span>; אחרת, נציב בו <span class="math">\(\mbox{F}\)</span>, ואם גם זה לא יספק אני איכשהו אראה ש-<span class="math">\(\Phi\)</span> לא עקבית". נניח לרגע שאני יכול לעשות את ה"איכשהו" הזה, האם זה פתר את בעיותי? לא, כי הצבתי ערך רק למשתנה <span class="math">\(X_{1}\)</span>. עכשיו צריך להציב גם ל-<span class="math">\(X_{2}\)</span>, בהינתן ההצבה שבחרתי עבור <span class="math">\(X_{1}\)</span>. ואז צריך עבור <span class="math">\(X_{3}\)</span> בהינתן ההצבה שבחרתי עבור <span class="math">\(X_{1},X_{2}\)</span>. ואז ב-<span class="math">\(X_{12414}\)</span> אני אתקע פתאום כי אראה שאין לי דרך לספק את <span class="math">\(\Phi\)</span> לא כשמציבים <span class="math">\(\mbox{T}\)</span> ולא כשמציבים <span class="math">\(\mbox{F}\)</span> ב-<span class="math">\(X_{12414}\)</span>, <strong>אבל</strong>, אם רק הייתי בוחר להציב את הערך ההפוך ב-<span class="math">\(X_{1}\)</span>, אז כתוצאה מכך הייתה מתקבלת סדרת הצבות שונה לגמרי בכל שאר המשתנים, ואז לא הייתי נתקע ב-<span class="math">\(X_{12414}\)</span>. אבל איך אני יכול לוודא את זה? ואיך אני יכול מראש לבחור בהצבה ה"נכונה" עבור כל משתנה? לא ברור. זו הסיבה שהגישה הנאיבית הזו נתקעת.</p>
<p>מה שעושים הוא להגיד "יש לנו פה יותר חופש פעולה מלכתחילה, בואו נגביל אותו!". נגביל אותו בצורה כזו שעבור כל משתנה רק אחת משתי ההצבות האפשריות של ערכים עבורו לא תוביל לסתירה. לשם כך אנחנו צריכים <strong>להרחיב</strong> את <span class="math">\(\Phi\)</span> על ידי הוספת פסוקים, ולקבל <span class="math">\(\Phi\subseteq\Psi\)</span>. כל מודל של <span class="math">\(\Psi\)</span> הוא גם מודל של <span class="math">\(\Phi\)</span> (כי הוא מספק את כל פסוקי <span class="math">\(\Phi\)</span>, ובנוסף לכך עוד פסוקים נוספים) ולכן יהיה די להראות ש-<span class="math">\(\Psi\)</span> הוא בעל מודל. נותר לעשות שלושה דברים: לתאר איך <span class="math">\(\Psi\)</span> הזה אמור להיראות שכל כך יפשט לנו את החיים, להסביר איך מרחיבים את <span class="math">\(\Phi\)</span> לקבלת <span class="math">\(\Psi\)</span>, ולהסביר למה ל-<span class="math">\(\Psi\)</span> יש מודל.</p>
<p>כדי להסביר מה <span class="math">\(\Psi\)</span> יהיה בדיוק אין מנוס מלהכניס למשחק מושג מבלבל: <strong>תורה שלמה</strong>. <span class="math">\(\Psi\)</span> הוא תורה שלמה אם לכל פסוק <span class="math">\(\varphi\)</span> מתקיים <span class="math">\(\Psi\vdash\varphi\)</span> או <span class="math">\(\Psi\vdash\neg\varphi\)</span>. כלומר, <span class="math">\(\Psi\)</span> מוכיחה או מפריכה כל פסוק. המילה <strong>שלמות</strong> כאן והמילה <strong>שלמות</strong> ב"משפט השלמות לתחשיב הפסוקים" מדברות על דברים <strong>שונים לגמרי</strong>; השלמות של <span class="math">\(\Psi\)</span> היא שלמות של <strong>תורה</strong> - קבוצת פסוקים, שממנה "נובע כל דבר או שלילתו"; השלמות של משפט השלמות היא שלמות של <strong>מערכת ההוכחה</strong> - היא אומרת שבהינתן קבוצת פסוקים שממנה נובע לוגית משהו, אז מערכת ההוכחה מאפשרת לנו להוכיח את אותו המשהו מתוך קבוצת הפסוקים. גם אחרי שאוכיח את משפט השלמות, לא תנבע מכך שום תוצאה כמו "כל קבוצת פסוקים <span class="math">\(\Phi\)</span> היא שלמה". בקיצור, זוהי בחירה אומללה של שימוש באותה מילה כדי לתאר שני מושגים שונים (אם כי לא בלתי קשורים לזה לזה, כפי שאפשר להבין מכך שאני מדבר על תורה שלמה כחלק מההוכחה של משפט השלמות). הבלבול זלג גם לתחשיב היחסים: ב"משפט השלמות של גדל" השלמות היא של מערכת ההוכחה (זהו אנלוג מורכב יותר למשפט השלמות שאנחנו מוכיחים כרגע) וב"משפטי אי השלמות של גדל" השלמות היא של תורות מסויימות (אריתמטיות, עקביות ואפקטיביות, אם זה אומר לכם משהו).</p>
<p>הטענה שלי היא שלתורה שלמה ועקבית יש בדיוק מודל יחיד - כלומר, לכל משתנה יש בדיוק ערך אחד שאפשר להציב בו כדי שעדיין נספק את <span class="math">\(\Psi\)</span> - אבל קודם כל בואו נבין כיצד ניתן להרחיב את <span class="math">\(\Phi\)</span> לתורה שלמה <span class="math">\(\Psi\)</span>. התשובה פשוטה: בכוח! נמספר את כל הפסוקים בעולם במספור כלשהו <span class="math">\(\varphi_{1},\varphi_{2},\varphi_{3},\dots\)</span> כך שכל פסוק מופיע מתישהו במספור; ועכשיו נבנה סדרה של תורות <span class="math">\(\Phi_{0},\Phi_{1},\Phi_{2},\dots\)</span> כך ש-<span class="math">\(\Phi_{0}=\Phi\)</span> ולכל <span class="math">\(n&gt;0\)</span>, אחד משניים: אם <span class="math">\(\Phi_{n-1}\cup\left\{ \neg\varphi_{n}\right\} \)</span> עקבית, אז <span class="math">\(\Phi_{n}=\Phi_{n-1}\cup\left\{ \neg\varphi_{n}\right\} \)</span>; אחרת, <span class="math">\(\Phi_{n}=\Phi_{n-1}\)</span>. במילים אחרות, אנחנו עוברים פסוק פסוק ולכל פסוק כזה אנחנו בודקים אם ניתן להוסיף <strong>את שלילתו</strong> לתורה שלנו. אם אפשר (כלומר, העקביות נשמרת) אנחנו מוסיפים. אחרת לא. בצורה הזו די ברור שכל אחת מה-<span class="math">\(\Phi_{n}\)</span> היא עדיין תורה עקבית בפני עצמה. עכשיו בואו ונגדיר <span class="math">\(\Psi=\bigcup\Phi_{n}\)</span>, כלומר <span class="math">\(\Psi\)</span> כוללת את כל הפסוקים שמופיעים ולו באחד מה-<span class="math">\(\Phi_{n}\)</span>-ים, ובגלל שבנינו אותם בצורה כזו ש-<span class="math">\(\Phi_{0}\subseteq\Phi_{1}\subseteq\Phi_{2}\)</span>, בעצם אפשר לומר שאם פסוק כלשהו נמצא ב-<span class="math">\(\Psi\)</span> אז הוא נמצא בכל ה-<span class="math">\(\Phi_{n}\)</span>-ים החל ממקום מסויים.</p>
<p>אנחנו צריכים להשתכנע ש-<span class="math">\(\Psi\)</span> עקבית וש-<span class="math">\(\Psi\)</span> שלמה. הוכחת העקביות מנצלת את העובדה ש<strong>הוכחה</strong> היא תמיד סופית. נניח לרגע ש-<span class="math">\(\Psi\)</span> לא עקבית, כלומר <span class="math">\(\Psi\vdash\varphi\)</span> וגם <span class="math">\(\Psi\vdash\neg\varphi\)</span> עבור איזה שהוא פסוק <span class="math">\(\varphi\)</span>. אז יש לנו שתי הוכחות ששתיהן סופיות; מכיוון שהן סופיות, משתמשים בהן במספר סופי של הנחות מ-<span class="math">\(\Psi\)</span>; בשל בניית <span class="math">\(\Psi\)</span> נובע מכך שכל ההנחות הללו נמצאות בכל ה-<span class="math">\(\Phi_{n}\)</span>-ים החל מ-<span class="math">\(n\)</span> מסויים, ולכן החל מ-<span class="math">\(n\)</span> מסויים גם <span class="math">\(\Phi_{n}\vdash\varphi\)</span> ו-<span class="math">\(\Phi_{n}\vdash\neg\varphi\)</span> בסתירה לכך שכל ה-<span class="math">\(\Phi_{n}\)</span> עקביות.</p>
<p>בכל הנוגע לשלמות, הבה וניקח <span class="math">\(\varphi\)</span> כלשהו ונוכיח כי <span class="math">\(\Psi\vdash\varphi\)</span> או <span class="math">\(\Psi\vdash\neg\varphi\)</span>. השאלה היא מה קרה בבניית <span class="math">\(\Psi\)</span> בשלב שבו שקלנו אם להוסיף את <span class="math">\(\neg\varphi\)</span> לתורה או לא (כלומר, בשלב של <span class="math">\(\varphi_{n}=\varphi\)</span>). מצד אחד, אם <span class="math">\(\Phi_{n-1}\cup\left\{ \neg\varphi_{n}\right\} \)</span> לא הייתה עקבית, אז ממשפט ההוכחה בשלילה <span class="math">\(\Phi_{n-1}\vdash\varphi_{n}=\varphi\)</span> ולכן גם <span class="math">\(\Psi\vdash\varphi\)</span> (על ידי אותה הוכחה פורמלית בדיוק); מצד שני, אם <span class="math">\(\Phi_{n-1}\cup\left\{ \neg\varphi_{n}\right\} \)</span> כן הייתה עקבית אז <span class="math">\(\neg\varphi\in\Phi_{n}\)</span> ולכן <span class="math">\(\neg\varphi\in\Psi\)</span> ולכן <span class="math">\(\Psi\vdash\neg\varphi\)</span> על ידי הוכחה פשוטה במיוחד: <span class="math">\(\neg\varphi\)</span> עצמה ותו לא.</p>
<p>סיימנו את השלב הזה: הראינו שכל תורה עקבית <span class="math">\(\Phi\)</span> ניתנת להרחבה לתורה עקבית ושלמה <span class="math">\(\Psi\)</span>. נותר להוכיח רק שלתורה עקבית ושלמה יש מודל. בניגוד למקרה של <span class="math">\(\Phi\)</span> כללית, עבור <span class="math">\(\Psi\)</span> השלמה אין בעיה להגיד במפורש מה המודל הזה, פשוט כי אין לנו ממש ברירה: לכל משתנה <span class="math">\(X_{i}\)</span>, מתקיים <strong>בדיוק </strong>אחד משניים: <span class="math">\(\Psi\vdash X_{i}\)</span> או <span class="math">\(\Psi\vdash\neg X_{i}\)</span>, וזאת כי <span class="math">\(\Psi\)</span> שלמה. אז אם <span class="math">\(\Psi\vdash X_{i}\)</span> נגדיר ש-<span class="math">\(X_{i}\)</span> מקבל <span class="math">\(\mbox{T}\)</span> בהשמה שלנו, ואם <span class="math">\(\Psi\vdash\neg X_{i}\)</span> נגדיר ש-<span class="math">\(X_{i}\)</span> מקבל <span class="math">\(\mbox{F}\)</span>. עד כדי כך פשוט. רק צריך להשתכנע שההשמה הזו באמת מספקת כל פסוק ב-<span class="math">\(\Psi\)</span>. ליתר דיוק, נוכיח את הטענה החזקה יותר "לכל פסוק <span class="math">\(\varphi\)</span>, <span class="math">\(\Psi\vdash\varphi\)</span> אם ורק אם ההשמה מספקת את <span class="math">\(\varphi\)</span>" (חזקה יותר, כי אם <span class="math">\(\varphi\in\Psi\)</span> אז בפרט <span class="math">\(\Psi\vdash\varphi\)</span>).</p>
<p>את ההוכחה הזו אפשר לעשות באינדוקציה על המבנה של פסוקים <span class="math">\(\mbox{WFF}\)</span>. כזכור, פסוק כזה הוא או <span class="math">\(\varphi=X_{i}\)</span> עבור משתנה כלשהו, או שהוא מהצורה <span class="math">\(\varphi=\neg\alpha\)</span>, או שהוא מהצורה <span class="math">\(\varphi=\alpha\to\beta\)</span>.</p>
<p>במקרה הראשון, אם <span class="math">\(\Psi\vdash X_{i}\)</span> אז על פי ההגדרה של ההשמה, <span class="math">\(X_{i}\)</span> מקבל <span class="math">\(\mbox{T}\)</span>; ואם <span class="math">\(X_{i}\)</span> קיבל <span class="math">\(\mbox{T}\)</span> אז בהכרח <span class="math">\(\Psi\vdash X_{i}\)</span> (כי אחרת היה מתקיים <span class="math">\(\Psi\vdash\neg X_{i}\)</span> ואז <span class="math">\(X_{i}\)</span> היה מקבל <span class="math">\(\mbox{F}\)</span> בהשמה).</p>
<p>בשני המקרים הבאים נוכל להניח ש-<span class="math">\(\alpha,\beta\)</span> כבר מקיימים את התכונה שהם יכיחים מ-<span class="math">\(\Psi\)</span> אם ורק אם ההשמה מספקת אותם; זוהי בדיוק הנחת האינדוקציה.</p>
<p>במקרה השני, <span class="math">\(\Psi\vdash\neg\alpha\)</span> אם ורק אם <span class="math">\(\Psi\not\vdash\alpha\)</span> (כי <span class="math">\(\Psi\)</span> עקבית ושלמה), כלומר אם ורק אם ההשמה נותנת ל-<span class="math">\(\alpha\)</span> ערך <span class="math">\(\mbox{F}\)</span>, כלומר אם ורק אם ההשמה נותנת ל-<span class="math">\(\neg\alpha\)</span> ערך <span class="math">\(\mbox{T}\)</span>. זה היה קל; המקרה השלישי טיפה יותר קשה.</p>
<p>במקרה השלישי, נניח קודם כל כי <span class="math">\(\Psi\vdash\alpha\to\beta\)</span>. אם <span class="math">\(\alpha\)</span> מקבלת ערך <span class="math">\(\mbox{F}\)</span> בהשמה, סיימנו כי <span class="math">\(\alpha\to\beta\)</span> תמיד יקבל ערך <span class="math">\(\mbox{T}\)</span>; אז נניח ש-<span class="math">\(\alpha\)</span> מקבלת <span class="math">\(\mbox{T}\)</span> ולכן, מהנחת האינדוקציה, <span class="math">\(\Psi\vdash\alpha\)</span>, ומכאן ש-<span class="math">\(\Psi\vdash\beta\)</span> (כי ההוכחה פשוט מייצרת את <span class="math">\(\alpha\)</span> ואת <span class="math">\(\alpha\to\beta\)</span> ואז מבצעת <span class="math">\(\mbox{MP}\)</span>) ומהנחת האינדוקציה, <span class="math">\(\beta\)</span> מסתפקת על ידי ההשמה. זה מסיים כיוון אחד של ההוכחה; בכיוון השני, נניח כי <span class="math">\(\alpha\to\beta\)</span> הסתפקה בהשמה ונוכיח כי <span class="math">\(\Psi\vdash\alpha\to\beta\)</span>. יש שתי דרכים שבהן <span class="math">\(\alpha\to\beta\)</span> יכלה להסתפק; או ש-<span class="math">\(\beta\)</span> קיבלה <span class="math">\(\mbox{T}\)</span>, או ש-<span class="math">\(\alpha\)</span> קיבלה <span class="math">\(\mbox{F}\)</span>. אם <span class="math">\(\beta\)</span> קיבלה <span class="math">\(\mbox{T}\)</span> אז מהנחת האינדוקציה, <span class="math">\(\Psi\vdash\beta\)</span> ולכן בוודאי ש-<span class="math">\(\Psi\cup\left\{ \alpha\right\} \vdash\beta\)</span> וממשפט הדדוקציה, <span class="math">\(\Psi\vdash\alpha\to\beta\)</span>. במקרה השני, אם <span class="math">\(\alpha\)</span> קיבלה <span class="math">\(\mbox{F}\)</span>, אז <span class="math">\(\Psi\vdash\neg\alpha\)</span> ולכן <span class="math">\(\Psi\cup\left\{ \alpha\right\} \)</span> לא עקבית. אם היא לא עקבית, אז היא מוכיחה הכל, כולל <span class="math">\(\beta\)</span>; שוב קיבלנו ש-<span class="math">\(\Psi\cup\left\{ \alpha\right\} \vdash\beta\)</span> וממשפט הדדוקציה, <span class="math">\(\Psi\vdash\alpha\to\beta\)</span>. זה מסיים את הוכחת משפט השלמות.</p>
<p>אני אעצור כאן ולא ארוץ להציג מסקנות מהמשפט או כל דבר אחר; למרות שהוכחת המשפט היא קלה למדי, לוקח זמן לעכל אותה אחרי קריאה ראשונה, ואני ממליץ לכל מי שהמשפט עניין אותו ולא הבין עד הסוף את ההוכחה פשוט לנסות ולחזור עליה בעצמו, בלי לקרוא בפוסט. ההנאה מובטחת.</p>
        </article>
        
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2012/04/21/math_against_traffic_reports/" class="nav-link nav-next">
                <span class="nav-label">→ פוסט חדש יותר</span>
                <span class="nav-title">כיצד תעזור לכם המתמטיקה לחמוק מדו&#34;חות תנועה</span>
            </a>
            
            
            
            <a href="/2012/04/04/propositional_caclulus_proofs/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר ←</span>
                <span class="nav-title">תחשיב הפסוקים - על נביעה לוגית והוכחות</span>
            </a>
            
        </nav>
        
        
        <footer>
            <p>בלוג מתמטיקה בעברית</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>