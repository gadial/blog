<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>עיון בהיר במיון מהיר - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2012/07/20/quick_quicksort/">
    <meta property="og:title" content="עיון בהיר במיון מהיר">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2012/07/20/quick_quicksort/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="עיון בהיר במיון מהיר">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2012/07/13/heap_sort/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">איך להערים על מיון ערימה</span>
            </a>
            

            
            <a href="/2012/07/22/counting_sort_and_sort_lower_bound/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">למה יש מיון מהיר יותר ממיון מהיר אבל בעצם אין</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>עיון בהיר במיון מהיר</h1>
            <div class="post-meta">
                <span class="date">2012-07-20</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/מבני נתונים ואלגוריתמים.html">מבני נתונים ואלגוריתמים</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אלגוריתמים.html">אלגוריתמים</a>
                    
                    <a href="/tags/הטור ההרמוני.html">הטור ההרמוני</a>
                    
                    <a href="/tags/מיון מהיר.html">מיון מהיר</a>
                    
                    <a href="/tags/מיונים.html">מיונים</a>
                    
                    <a href="/tags/משתנים מקריים.html">משתנים מקריים</a>
                    
                    <a href="/tags/תוחלת.html">תוחלת</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>מבין כל אלגוריתמי המיון המפורסמים, מיון מהיר הוא החביב עלי, בגלל שהוא כל כך מוזר. ראשית, זה אלגוריתם מיון שזמן הריצה שלו במקרה הגרוע שלו הוא <span class="math">\(\Theta\left(n^{2}\right)\)</span>, ובפועל הביצועים שלו גרועים במקרה הזה יותר מאשר אלו של מיון בחירה ומיון הכנסה, ולמרות זאת במקרה ה"ממוצע" (מה זה? נסביר בהמשך) הביצועים שלו דווקא מצויינים; שנית, המקרה הגרוע ביותר עבור המימוש הנאיבי שלו הוא זה שבו <strong>המערך כבר ממוין</strong>, וזה משעשע. לבסוף, הוא כל כך פשוט מבחינה רעיונית שאפשר לתאר אותו, בשפת התכנות המתאימה, בעזרת קוד פשוט ביותר:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="nf">quicksort</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">quicksort</span><span class="w"> </span><span class="kt">[]</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">quicksort</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">quicksort</span><span class="w"> </span><span class="n">smaller</span><span class="p">)</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">(</span><span class="n">quicksort</span><span class="w"> </span><span class="n">larger</span><span class="p">)</span>
<span class="w">    </span><span class="kr">where</span>
<span class="w">        </span><span class="n">smaller</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="p">]</span>
<span class="w">        </span><span class="n">larger</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">]</span>
</code></pre></div>


</div>

<p>קטע הקוד הזה, בשפת Haskell, הוא דוגמה פופולרית בספרים/מאמרים על השפה (היפהפיה) הזו, שממחיש יפה את האופי ה"מתמטי" של ההגדרה של המיון. השורה הראשונה עשויה להיראות מפחיד למי שלא בקיאים בסינטקס של הסקל אבל היא בסך הכל אומרת ש-quicksort היא פונקציה שלוקחת רשימה של איברים מטיפוס a (כש-a הוא Ord - משהו שניתן להשוואה) ומחזירה רשימה של איברים מטיפוס a. כלומר, זו פשוט הגדרה מתמטית של פונקציה. השורה הבאה בסך הכל אומרת שעל רשימה ריקה, quicksort מחזיר רשימה ריקה. לאחר מכן מגיעה ההגדרה של מה ש-quicksort עושה בפועל: הוא מקבל קלט שעליו הוא חושב בתור איבר <span class="math">\(x\)</span> ("איקס") ועוד רשימה של איברים <span class="math">\(xs\)</span> ("איקסים"). כלומר, אנחנו אוטומטית מפרקים את הרשימה שקיבלנו ל"איבר ראשון ועוד רשימה של כל יתר האיברים". והפלט שאנחנו מחזירים הוא שרשור של שלוש רשימות: רשימה בשם smaller שאותה אנחנו ממיינים רקורסיבית עם quicksort; רשימה שהאיבר היחיד בה הוא <span class="math">\(x\)</span>, ורשימה בשם larger שגם אותה אנחנו ממיינים עם quicksort. ואיך מוגדרות הרשימות הללו? זה מה שכתוב אחרי ה-where: הרשימה smaller כוללת את כל האיברים של <span class="math">\(xs\)</span> שקטנים או שווים ל-<span class="math">\(x\)</span>, ואילו larger כוללת את כל האיברים של <span class="math">\(xs\)</span> שגדולים מ-<span class="math">\(x\)</span>.</p>
<p>זה הכל.</p>
<p>בואו ננסה שוב, הפעם במילים: מיון מהיר של רשימה פועל כך: הוא בוחר מהרשימה איבר שישמש בתור ציר - pivot בלעז. עכשיו הוא מסדר את הרשימה כך שכל האיברים בה שקטנים מאיבר הציר יהיו משמאלו, וכל האיברים בה שגדולים מאיבר הציר יהיו מימינו; ולסיום הוא ממיין את שתי תתי-הרשימות הללו באופן רקורסיבי על ידי קריאה לעצמו. זה הכל.</p>
<p>ראינו כבר את מיון מיזוג, שהיה דוגמה קלאסית לאלגוריתם "הפרד ומשול" למיון: הוא חילק את הרשימה שלו לשני חלקים, מיין כל חלק בנפרד ואז מיזג אותן. במיון מיזוג פעולת ה"הפרד" הייתה טריוויאלית - פשוט בחרנו את נקודת האמצע וחילקנו בה, והעבודה האמיתית הייתה ב"ומשול" - שלב המיזוג של האלגוריתם. מיון מהיר נוקט את הגישה ההפוכה. שלב ה"ומשול" שלו טריוויאלי - אחרי ששתי תתי-הרשימות כבר מוינו, אין שום דבר נוסף לעשות ואפשר לסיים; החוכמה היא בשלב ה"הפרד" שגורמת לכך שהרשימה תופרד לשתי תתי-רשימות בעלות התכונה שכל איבר בראשונה קטן יותר מכל איבר בשניה. אחרי שהבנו את הרעיון הזה, האלגוריתם פשוט בונה את עצמו מאליו.</p>
<p>כמובן שבקוד עבור שפה שהיא פחות מתמטית באופיה יהיה צורך לעשות את העניינים הללו קצת יותר במפורש. אז הנה הקוד בשפת רובי שמבצע את המיון עצמו:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">quicksort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">finish</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="n">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">finish</span>
<span class="w">  </span><span class="n">middle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">finish</span><span class="p">)</span>
<span class="w">  </span><span class="n">quicksort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">middle</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="n">quicksort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">middle</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">finish</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">list</span>
<span class="k">end</span>
</code></pre></div>


</div>

<p>הקוד מקבל רשימה, וגם שני משתנים נוספים start, finish שאומרים לו איזה חלק של הרשימה צריך למיין כרגע (צריך למיין את כל האיברים החל מ-start ועד ל-finish). אם המשתנים הללו לא מועברים במפורש הערכים שהם מקבלים הם 0 ואורך הרשימה פחות 1 (כלומר, האינדקסים של האיבר הראשון והאחרון ברשימה). האלגוריתם חוזר מייד אם אין לו מה לעשות - כלומר, אם start לא קטן מ-finish (זה אומר שגודל הרשימה שמבקשים מאיתנו למיין הוא לא יותר מ-1).</p>
<p>אחרת, האלגוריתם קורא לפונקציה partition, שעושה שני דברים: היא בוחרת איבר ציר, ולאחר מכן גם מסדרת מחדש את list (רק באיזור שבין start ו-finish, כמובן) כך שכל האיברים ברשימה שקטנים מהציר יהיו משמאלו וכל מי שגדולים מהציר יהיו מימינו; לסיום היא מחזירה את האינדקס של איבר הציר ברשימה המסודרת. כעת כל שנותר לעשות הוא לקרוא למיון מהיר מחדש על שתי תתי-הרשימות של "מי שקטנים מהציר" ו"מי שגדולים מהציר". שימו לב שהציר עצמו אינו נכלל באף אחת מהרשימות, כך שבהכרח שתיהן קטנות יותר מהרשימה המקורית ולכן אין סיכוי שנקלע ללולאה אינסופית.</p>
<p>צריך להשתכנע שהאלגוריתם באמת ממיין את הרשימות, אבל זה די ברור. אחרי שתי הקריאות הרקורסיביות למיון מהיר, אנחנו מקבלים ש-list מורכבת משלושה חלקים: כל מי שהיו קטנים מהציר, כשהם ממויינים; כל מי שגדולים מהציר, כשהם ממויינים; והציר באמצע בין שתי הרשימות הללו. אם הרשימה הכוללת לא הייתה ממויינת זה היה אומר שיש <span class="math">\(a,b\)</span> כך ש-<span class="math">\(a>b\)</span> אבל <span class="math">\(a\)</span> דווקא נמצא משמאל ל-<span class="math">\(b\)</span> ברשימה. לא ייתכן ש-<span class="math">\(a,b\)</span> שונים מהציר ושניהם משמאל או מימין לו כי זה היה מראה שאחת משתי תת-הרשימות לא ממויינת; ולכן <span class="math">\(a\)</span> בהכרח נמצא מימין לאיבר הציר (או שווה לו) ו-<span class="math">\(b\)</span> נמצא משמאל לאיבר הציר (או שווה לו). זהו זה.</p>
<p>נשאר להבין איך מממשים את partition. קוד:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">partition</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">finish</span><span class="p">)</span>
<span class="w">  </span><span class="n">pivot_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">choose_pivot</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">finish</span><span class="p">)</span>
<span class="w">  </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">pivot_index</span><span class="o">]</span>
<span class="w">  </span><span class="n">list</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">pivot_index</span><span class="p">,</span><span class="w"> </span><span class="n">finish</span><span class="p">)</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">start</span><span class="o">...</span><span class="n">finish</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pivot</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="n">list</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="n">list</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="mi">1</span>
<span class="k">end</span>
</code></pre></div>


</div>

<p>גם כאן הקוד עדיין לא שלם כי הוא תלוי במימוש של choose_pivot. בקוד ההסקל פשוט בחרנו את האיבר הראשון, אבל כאן אני מאפשר קצת יותר חופש בחירה (מסיבות שיובהרו בהמשך). אז קוראים ל-choose_pivot שמחזיר את האינדקס של איבר הציר, ואז pivot עצמו מקבל את הערך של איבר הציר, ואז אנחנו מעיפים את איבר הציר מהדרך - שמים אותו בסוף הרשימה. כעת אנחנו מתחזקים משתנה a שאומר "מה הקצה הימני של רשימת כל האיברים שקטנים מאיבר הציר". בהתחלה זו רשימה ריקה, אז הקצה הימני הוא <strong>לפני</strong> תחילת הרשימה שאנחנו מטפלים בה (מיון מהיר מבלבל למדי מבחינת אינדקסים בקטע הזה, והתיאור המילולי שנתתי עוזר לזכור מה צריך לעשות, לדעתי).</p>
<p>מכאן ואילך הפעולה שלנו פשוטה: אנחנו עוברים סדרתית על כל האינדקסים של איברים בחלק הרלוונטי ברשימה (החל מ-start ועד ל-finish לא כולל). אם נתקלנו באיבר שקטן מאיבר הציר, אנחנו מקדמים את a ב-1 ואז מחליפים את מי שכרגע נמצא במקום a עם האיבר במקום i (שימו לב שבהחלט עשוי לקרות בהתחלה שאיבר יוחלף <strong>עם עצמו</strong>). בסופו של דבר, אחרי שסיימנו לעבור על הרשימה, אנחנו שמים את איבר הציר במקום a+1 ומחזירים את האינדקס שלו.</p>
<p>כדי לראות שזה עובד, שימו לב ש<strong>כל</strong> איבר ברשימה שקטן מהציר יוחלף מתישהו; כשזה יקרה, אנחנו שמים אותו במקום שהוא הערך שיש ל-a כרגע, וכל החלפה שתתבצע בהמשך תתבצע עבור מקום שגדול מ-a הזה. כלומר, ברגע שבו איבר שקטן מאיבר הציר הוחלף, מובטח לנו שהוא לא יוחלף שוב. מכאן שכל האיברים שקטנים מאבר הציר אכן יהיו משמאלו כשנסיים.</p>
<p>האם איבר שגדול מאיבר הציר עשוי גם כן להיות משמאלו כשנסיים? הדרך הפשוטה ביותר, לדעתי, לראות שזה לא יכול לקרות היא על ידי כך שנשים לב שערכו של a+1 בסיום, פחות הערך של start, שווה בדיוק למספר האיברים הקטנים מאיבר הציר ברשימה; זאת כי אנחנו מאתחלים את a להיות start-1 ומגדילים אותו ב-1 בכל פעם שמצאנו איבר שקטן מאיבר הציר. כעת, בסוף הריצה יש בדיוק a+1-start איברים משמאל לאיבר הציר, וכבר ראינו שכל מי שקטן מאיבר הציר אכן יהיה משמאלו, ולכן פשוט "אין מקום" לאיברים גדולים מאיבר הציר שם.</p>
<p>זה משלים את ההוכחה שמיון מהיר עובד. זה עדיין לא מטפל במה שהוא העיקר כאן - <strong>כמה מהר</strong> מיון מהיר עובד? התשובה המתבקשת "מהר, הרי הוא מיון מהיר" לא עובדת. למעשה, באופן מפתיע למדי, מיון מהיר במקרה הגרוע עובד <strong>לאט</strong>.</p>
<p>בואו נזכר איך טיפלנו במיון מיזוג: שם אמרנו שזמן הריצה מקיים את הנוסחה הרקורסיבית <span class="math">\(T\left(n\right)=2T\left(\frac{n}{2}\right)+O\left(n\right)\)</span>, כאשר ה-<span class="math">\(O\left(n\right)\)</span> היה הזמן שנדרש למיזוג וה-<span class="math">\(T\left(\frac{n}{2}\right)\)</span> היה הזמן שנדרש למיון שני תת-הרשימות. מתקבל על הדעת שלמיון מהיר תהיה נוסחה דומה, אבל יש כאן בעיה קטנה: בעוד מיון מיזוג מפצל את הרשימה <strong>תמיד</strong> לשני חלקים שווים בגודלם, מיון מהיר מפצל את הרשימה לשני תת-רשימות של "כל האיברים שגדולים יותר מאיבר הציר" ו"כל האיברים שקטנים יותר מאיבר הציר". אין שום סיבה בעולם להניח ששתי הרשימות הללו יהיו מאותו אורך. יש רק מקרה אחד שבו הן מאותו אורך - אם איבר הציר הוא ה<strong>חציון</strong> של הרשימה (חציון של רשימה מוגדר כאיבר שגדול מחצי מהאיברים בה וקטן מחצי מהאיברים בה - לרשימה באורך זוגי יש שני חציונים). אלא שאצלנו לא בוחרים את איבר הציר להיות החציון בהכרח. בקוד ההסקל שלי בחרנו אותו להיות האיבר הראשון ברשימה. לפעמים בוחרים אותו בתור האיבר האחרון ברשימה. בכל מקרה עושים את זה בלי שיהיה לנו מושג מה הגודל שלו ביחס לשאר אברי הרשימה. התוצאות עשויות להיות הרסניות.</p>
<p>בואו נסתכל על המקרה ההרסני הבא: הרשימה <strong>ממוינת</strong>, ואנחנו בוחרים בתור איבר הציר תמיד את האיבר הראשון ברשימה (אותה בעיה תהיה גם אם נבחר אותו להיות האיבר האחרון ברשימה). במקרה הזה, נבזבז <span class="math">\(O\left(n\right)\)</span> זמן על הרצת partition מיותרת, שבסופה נקבל שתי תת-רשימות: אחת שכוללת את כל האיברים שקטנים מאיבר הציר, אבל זו רשימה ריקה כי איבר הציר הוא האיבר <strong>הקטן ביותר</strong> ברשימה המקורית. תת-הרשימה השניה כוללת את <strong>כל</strong> אברי הרשימה פרט לאיבר הציר. כלומר, עכשיו נריץ רקורסיבית את מיון מהיר על רשימה מגודל 0 ועל רשימה מגודל <span class="math">\(n-1\)</span>, וכך זה יימשך. קיבלנו את נוסחת הנסיגה <span class="math">\(T\left(n\right)=T\left(n-1\right)+\Theta\left(n\right)\)</span> שלא קשה לראות שפתרונה הוא <span class="math">\(T\left(n\right)=\Theta\left(n^{2}\right)\)</span>. בבירור יש כאן בעיה שצריך לפתור איכשהו. פתרונות נאיביים כמו "בדוק אם המערך ממויין לפני שתתחיל" לא ממש יעזרו כי גם במערך שהוא "כמעט" ממוין עדיין תהיה לנו בעיה דומה ואי אפשר להותיר אותו לא ממויין.</p>
<p>דרך אחת לפתור את הבעיה היא לממש את choose_pivot כך שתבחר תמיד את החציון של הרשימה. יש אלגוריתם מחוכם ויפה שמוצא חציון ברשימה מאורך <span class="math">\(n\)</span> בזמן <span class="math">\(O\left(n\right)\)</span> וניתן להשתמש בו כאן, ולקבל שזמן הריצה של מיון מהיר הוא <span class="math">\(\Theta\left(n\log n\right)\)</span>. אבל לשיטה הזו יש גם חסרון ברור - היא איטית. אלגוריתם מציאת החציון הוא רקורסיבי וידרוש לא מעט תקורה משל עצמו, והתוצאה תהיה שמיון מהיר יהיה איטי בהרבה מהמתחרים שלו - מיון מיזוג ומיון ערימה. אז זו לא דרך הפעולה שבה ננקוט.</p>
<p>דרך אחרת לפתור את הבעיה, שנשמעת מטופשת אבל אין לזלזל בה, היא לטעון שבכלל אין בעיה. שאמנם, זמן הריצה של האלגוריתם עבור המקרה הגרוע ביותר הוא <span class="math">\(\Theta\left(n^{2}\right)\)</span>, אבל עבור המקרה <strong>הממוצע</strong> זמן הריצה הוא מצוין. כאן נשאלת השאלה מהו המקרה ה"ממוצע", וזה כמובן תלוי בשאלה מהו הקלט. אם, למשל, יש לנו רשימת שירים בנגנן מוזיקה שממויינת כרגע לפי אלבום ואנחנו עוברים למיין אותה לפי שם השיר, סביר להניח שתיראה "אקראית" ביחס לפרמטר הזה. לעומת זאת, ביחס לפרמטר "שם היוצר/להקה" הרשימה בוודאי לא תיראה אקראית (כי שירים ששייכים לאותו אלבום ישתייכו גם לאותה להקה, כנראה). בקיצור, זה עניין סבוך למדי להעריך מה סוג הקלטים שהולכים לטפל בו (עם זאת, בעולם האמיתי זה דבר שכדאי להתחשב בו כשבאים לבחור באיזה מיון להשתמש). אנחנו נבחר בגישה הפשוטה ונניח ש"המקרה הממוצע" הוא פשוט רשימה אקראית.</p>
<p>זה מעביר אותנו לפתרון השלישי, שבמובן מסוים מכליל את השני והוא מה שאני רוצה להשתמש בו: נהפוך את מיון מהיר לאלגוריתם <strong>הסתברותי</strong>:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">choose_pivot</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">finish</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">rand</span><span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>


</div>

<p>מה שקורה כאן הוא פשוט: במקום לבחור איבר ציר, אני מגריל אינדקס כלשהו בתוך הרשימה כדי שישמש כאיבר הציר. מה המשמעות של "הגרלה" שכזו - <a href="http://www.gadial.net/2009/04/08/random_numbers/">כתבתי על זה פוסט בשעתו</a> ואני לא ארחיב על כך כרגע. השאלה המעניינת כרגע היא איך לנתח סיבוכיות של אלגוריתם שכזה.</p>
<p>ראשית, נשים לב לכך שמיו מהיר הוא דוגמה לאלגוריתם הסתברותי ש<strong>תמיד</strong> מחזיר את התוצאה הנכונה, וה"סכנה" היא שלא תמיד הוא יעשה זאת מהר. לאלגוריתם כזה קוראים <strong>אלגוריתם לאס-וגאס</strong>. סוג אחר של אלגוריתמים הסתברותיים, שנקרא <strong>אלגוריתמי מונטה-קרלו</strong>, פועל תמיד במהירות טובה אך תחת הסיכון שתהיה טעות כלשהי (<a href="http://www.gadial.net/2009/08/09/miller_rabin/">אלגוריתם מילר-רבין</a> לבדיקת ראשוניות שתיארתי בעבר בבלוג הוא דוגמה נאה לאלגוריתם מונטה-קרלו). שימו לב שאלגוריתם "הסתברותי" שאינו טועה אף פעם ותמיד רץ במהירות טובה אינו צריך להיות הסתברותי בכלל; אם כל הגרלה אפשרית נותנת תוצאות טובות, אפשר להמנע לחלוטין מביצוע ההגרלה ופשוט להשתמש תמיד בפלט אפשרי אחד של ההגרלה. לכן מלכתחילה דיונים על אלגוריתמים הסתברותיים הם מעניינים רק אם יש לנו "מה להפסיד" במקרה של הגרלה לא מוצלחת.</p>
<p>אפשר לבצע ניתוח הסתברותי שיאמר משהו בסגנון "בהסתברות <span class="math">\(\frac{2}{3}\)</span> האלגוריתם ירוץ בסיבוכיות זמן <span class="math">\(O\left(n\log n\right)\)</span>", אבל אנחנו נעשה משהו חזק יותר - נדבר על <strong>תוחלת</strong> זמן הריצה של האלגוריתם. התוחלת היא ממוצע משוקלל; בהינתן קלט נתון כלשהו, אנחנו סוכמים את <strong>כל</strong> זמני הריצה האפשריים של האלגוריתם על הקלט, כאשר כל זמן ריצה מוכפל בהסתברות שהוא יתקבל. באופן הזה, אם האלגוריתם לפעמים מציג ביצועים שהם <strong>ממש</strong> איומים, אנחנו מתחשבים ב<strong>כמה</strong> איומים הביצועים.</p>
<p>החסרון של מעבר לדיון הסתברותי הוא, כמובן, שצריך לדעת הסתברות כלשהי בשבילו. לא יותר מדי; אבל משהו תצטרכו לדעת. עבור מי שלא יחזיק מעמד עד הסוף רק נגלה את הסיום המפתיע: זמן הריצה של מיון מהיר ההסתברותי, בתוחלת, הוא <span class="math">\(\Theta\left(n\log n\right)\)</span>!</p>
<p>שוק, מה?</p>
<p>בואו נעבור לניתוח המתמטי, שהוא מקסים למדי לטעמי.</p>
<p>ראשית, מה שנרצה לספור הוא את מספר ה<strong>השוואות</strong> שהאלגוריתם מבצע. מספר ההחלפות (הפעולה ה"בסיסית" האחרת) בכל הפעלה של partition חסום על ידי מספר ההשוואות ועוד 2, כך שזה לא באמת מגביל את כלליות הניתוח שלנו (אם מספר ההשוואות הוא <span class="math">\(\Theta\left(n\log n\right)\)</span> כך יהיה גם מספר ההחלפות). לא קשה לראות שכל שאר העבודה שהאלגוריתם מבצע (פרט להחלפות/השוואות) היא <span class="math">\(O\left(n\right)\)</span> כי partition ייקרא לכל היותר <span class="math">\(n\)</span> פעמים, שהרי אחרי כל קריאה ל-partition אחד מהאיברים ברשימה (זה שנבחר בתור איבר הציר) יוצא מהמשחק.</p>
<p>טוב, אז מסתפקים בלספור השוואות. האבחנה הבאה היא שאם אנחנו משווים שני איברים, זה קורה בדיוק פעם אחת. למה? כי השוואה תמיד מתרחשת בתוך partition, כאשר משווים את איבר הציר לאיברים אחרים. באותה קריאה ל-partition משווים את איבר הציר בדיוק פעם אחת עם כל שאר האיברים בחלק של הרשימה שעליו partition עובדת; ולא ייתכן שאיבר הציר יושווה בעתיד עם איברים נוספים, כי אחרי הקריאה הזו ל-partition הוא יוצא מהמשחק ולכן לא יושווה שוב עם אף אחד. מכאן שאין שום סיכוי שנשווה שני איברים יותר מפעם אחת. נותרנו עם השאלה: מה ההסתברות ששני איברים ספציפיים ברשימה יושוו <strong>בכלל</strong>.</p>
<p>תשובה לשאלה הזו מסיימת את הניתוח, כי מה שנשעשה הוא להגדיר <strong>משתנה מקרי</strong> שייקרא <span class="math">\(X_{ij}\)</span> שמקבל 1 אם <span class="math">\(i,j\)</span> הושוו ו-0 אם לא, ואז המשתנה המקרי שסופר את מספר ההשוואות הכולל שביצע האלגוריתם בריצה אקראית מסויימת שלו הוא <span class="math">\(X=\sum_{i<j}X_{ij}\)</span>, ולכן, מלינאריות התוחלת, תוחלת מספר ההשוואות שיבצע האלגוריתם היא <span class="math">\(\text{E}\left[X\right]=\text{E}\left[\sum_{i<j}X_{ij}\right]=\sum_{i<j}\text{E}\left[X_{ij}\right]=\sum_{i<j}\text{Pr}\left[X_{ij}=1\right]\)</span>. אם כל זה נשמע לכם כמו ג'יבריש - יש לי <a href="http://www.gadial.net/2010/08/14/random_variables/">פוסט</a> על העניינים הללו אבל עדיף ללמוד אותם בצורה מסודרת.</p>
<p>אבל רגע, מה זה בכלל <span class="math">\(i,j\)</span>? אני מניח שחשבתם באופן מובלע שאלו ה<strong>אינדקסים</strong> של האיברים ברשימה, ובהחלט אפשר לנקוט בשיטת הסימון הזו; אבל עוד מעט נראה שהרבה יותר אפקטיבי למספר את האיברים <strong>על פי גודלם</strong>. כלומר, איבר מס' <span class="math">\(i\)</span> יהיה האיבר מספר <span class="math">\(i\)</span> בגודלו ברשימה. אם הרשימה היא <span class="math">\(\left[3,1,5,4,2\right]\)</span> אז עבור <span class="math">\(i=2\)</span> נקבל את האיבר <span class="math">\(2\)</span> ועבור <span class="math">\(i=3\)</span> נקבל את האיבר <span class="math">\(3\)</span>, למרות שהאינדקסים שלהם ברשימה הם שונים. יש כאן הגיון לא מועט כי בכל מקרה הסדר המקורי בתוך הרשימה עשוי להיעלם לגמרי אחרי בחירת איבר הציר הראשון וסידור אברי הרשימה על פיו; מה שמעניין הוא הסדר האמיתי של האיברים, כי שני איברים שבאים אחד אחרי השני בסדר הרבה יותר קשה להפריד על ידי איבר ציר מאשר שני איברים "רחוקים".</p>
<p>ההסתברות שנשווה את <span class="math">\(i,j\)</span> היא ההסתברות שיקרה הדבר הבא: או ש-<span class="math">\(i\)</span> ייבחר כאיבר ציר, או ש-<span class="math">\(j\)</span> ייבחר כאיבר ציר, וזה בזמן שבו <span class="math">\(i,j\)</span> עדיין נמצאים באותה תת-רשימה. כלומר, לפני שנבחר איבר ציר כלשהו <strong>ביניהם</strong>. לצורך כך, הבה ונחשוב על הקטע של כל האיברים שבין <span class="math">\(i\)</span> ו-<span class="math">\(j\)</span>, כולל שניהם; אסמנו <span class="math">\(\left[i,j\right]\)</span>. הקטע הזה <strong>מוכל בשלמותו</strong> בכל תת-רשימה שעשויה לצוץ במהלך האלגוריתם, וזאת עד הפעם הראשונה שבה נבחר איבר ציר <strong>מתוך <span class="math">\(\left[i,j\right]\)</span>.</strong> בנוסף, הפעם הראשונה הזו תבוא בהכרח, אחרת האלגוריתם לא היה מסתיים. מכאן שהשאלה היא רק - איזה איבר מתוך <span class="math">\(\left[i,j\right]\)</span> ייבחר לראשונה?</p>
<p>התשובה היא שלכל האיברים ב-<span class="math">\(\left[i,j\right]\)</span> יש אותו סיכוי להיבחר, בכל פעם שיש בחירה שכזו, וזאת תחת ההנחה שאיבר הציר אכן נבחר באופן אחיד בכל איטרציה. אם לכל האיברים ב-<span class="math">\(\left[i,j\right]\)</span> יש אותו סיכוי להיבחר בכל פעם שבה מתבצעת בחירה, אז לכל אחד מהם יש אותו סיכוי להיבחר ראשון. כמה איברים יש בסך הכל ב-<span class="math">\(\left[i,j\right]\)</span>? ובכן, <span class="math">\(j-i+1\)</span> (תמיד קשה לזכור האם צריך לעשות פלוס 1 או לא; אני תמיד פשוט מציב <span class="math">\(i=1,j=3\)</span> ובודק מה המספר יוצא כדי להיזכר). כלומר, לכל איבר ב-<span class="math">\(\left[i,j\right]\)</span> יש סיכוי של <span class="math">\(\frac{1}{j-i+1}\)</span> להיות הראשון שנבחר מתוך <span class="math">\(\left[i,j\right]\)</span>. אנחנו רוצים לדעת מה הסיכוי שהאיבר הראשון הזה יהיה <span class="math">\(i\)</span> או שיהיה <span class="math">\(j\)</span>, ולכן ההסתברות היא <span class="math">\(\text{Pr}\left[X_{ij}=1\right]=\frac{2}{j-i+1}\)</span>.</p>
<p>עכשיו יתר הניתוח הופך לפשוט. תוחלת מספר ההשוואות של האלגוריתם היא <span class="math">\(\sum_{i<j}\frac{2}{j-i+1}\)</span> ולכן כל מה שנותר לנו לעשות הוא חישוב סכום. כדי לפשט את החישוב נוח לפצל את הסכום הזה לשני סכומים, אחד על <span class="math">\(i\)</span> והשני על <span class="math">\(j\)</span>:</p>
<p><span class="math">\(\sum_{i<j}\frac{2}{j-i+1}=2\sum_{i=1}^{n}\sum_{j=i+1}^{n}\frac{1}{j-i+1}=2\sum_{i=1}^{n}\sum_{k=1}^{n-i}\frac{1}{k+1}\)</span></p>
<p>המעבר האחרון הוא החלפת משתנה רגילה: <span class="math">\(k=j-i\)</span>. עכשיו, חישוב מדויק של ערכו של הטור שקיבלנו הוא לא פשוט, ולכן נשתמש בחסמים עליונים:</p>
<p><span class="math">\(2\sum_{i=1}^{n}\sum_{k=1}^{n-i}\frac{1}{k+1}\le2\sum_{i=1}^{n}\sum_{k=1}^{n}\frac{1}{k}\le2n\cdot H_{n}\)</span></p>
<p>כאשר <span class="math">\(H_{n}=\sum_{k=1}^{n}\frac{1}{k}\)</span> הוא מה שנקרא <strong>מספר הרמוני</strong>, כי הוא סכום חלק של הטור ההרמוני <span class="math">\(\sum_{k=1}^{\infty}\frac{1}{k}\)</span> ש<a href="http://www.gadial.net/2010/07/25/harmonic_series_converges_to_137/">כבר הוזכר בבלוג</a>.</p>
<p>אפשר לסיים כאן על ידי זה שנציין ש-<span class="math">\(H_{n}\le\lg n+1\)</span>, אבל ייתכן שזה לא מספיק לכם ואתם רוצים גם לראות <strong>איך</strong> מוכיחים את זה. מצוין! זה עוד תעלול קטן ונחמד שכדאי להכיר. הרעיון הוא לחלק את הסכום <span class="math">\(\sum_{k=1}^{n}\frac{1}{k}\)</span> להרבה תת-סכומים קטנים שכל אחד מהם אפשר לחסום מלמעלה בצורה פשוטה כך שהתוצאה הסופית היא עדיין קטנה יחסית. החסם הנאיבי ביותר הוא זה שבו חוסמים את כל הסכום על ידי האיבר הראשון בו (שהוא האיבר הגדול ביותר), מה שנותן לנו את הסכום <span class="math">\(\sum_{k=1}^{n}1=n\)</span> שהוא בוודאי גדול מדי, ולכן צריך לבצע את החלוקה לתת-סכומים.</p>
<p>בדרך כלל מחלקים את הסכום לתתי-סכומים שווים בגודלם (למשל, חוצים אותו באמצע), אבל כאן משתלם הרבה יותר לבצע חלוקה שונה: <span class="math">\(1|2,3|4,5,6,7|8,9,10,11,12,13,14,15,\dots\)</span> כשהקווים מייצגים סוף של תת-סכום אחד והתחלה של תת-סכום אחר. פורמלית, כל תת-סכום כולל את כל האיברים <span class="math">\(\frac{1}{k}\)</span> כאשר <span class="math">\(k\)</span> הוא איבר בתחום שבין <span class="math">\(2^{i}\)</span> ועד <span class="math">\(2^{i+1}-1\)</span>. כמה סכומים כאלו יש? ובכן, עד אשר <span class="math">\(2^{i}>n\)</span>, כלומר <span class="math">\(i>\lg n\)</span>. לכן נקבל:</p>
<p><span class="math">\(\sum_{k=1}^{n}\frac{1}{k}\le\sum_{i=1}^{\left\lceil \lg n\right\rceil }\sum_{k=2^{i}}^{2^{i+1}-1}\frac{1}{k}\)</span></p>
<p>אם נראה שהסכום הפנימי, <span class="math">\(\sum_{k=2^{i}}^{2^{i+1}-1}\frac{1}{k}\)</span>, הוא תמיד קטן מ-1, הרי שסיימנו; זה יוכיח שהסכום כולו קטן או שווה ל-<span class="math">\(\left\lceil \lg n\right\rceil \le\lg n+1\)</span>. אבל איך נראה את זה? ובכן, כמה איברים יש בסכום הפנימי?</p>
<p><span class="math">\(\left(2^{i+1}-1\right)-2^{i}+1=2^{i+1}-2^{i}=2^{i}\left(2-1\right)=2^{i}\)</span></p>
<p>ומה האיבר הגדול ביותר בסכום הפנימי? <span class="math">\(\frac{1}{2^{i}}\)</span>. ולכן, מה החסם העליון המיידי על הסכום הפנימי? <span class="math">\(\frac{2^{i}}{2^{i}}=1\)</span>, וסיימנו.</p>
<p>כמו במקרה של מיון ערימה, גם כאן מאוד נחמד לדעתי איך פתאום צצות בעיות מתמטיות "טהורות" באמצע ניתוח של אלגוריתם פרקטי שכזה, וגם הניתוח ההסתברותי שלו נחמד. וזו הסיבה שמבין כל אלגוריתמי המיון המפורסמים, מיון מהיר הוא החביב עלי.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>