<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מיון מהיר של מיונים איטיים - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2012/07/10/all_sorts_of_slow_sorts/">
    <meta property="og:title" content="מיון מהיר של מיונים איטיים">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2012/07/10/all_sorts_of_slow_sorts/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="מיון מהיר של מיונים איטיים">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2012/07/06/asymptotic_notation/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">הסבר בזמן (O(n על סימונים אסימפטוטיים</span>
            </a>
            

            
            <a href="/2012/07/11/help_me_latex_people/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">בקשת עזרה מקהילת הקוד הפתוח בכלל ומכל מי שמבין משהו ב-LaTeX בפרט</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מיון מהיר של מיונים איטיים</h1>
            <div class="post-meta">
                <span class="date">2012-07-10</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/מבני נתונים ואלגוריתמים.html">מבני נתונים ואלגוריתמים</a>
                    
                    <a href="/categories/תכנות.html">תכנות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אלגוריתם.html">אלגוריתם</a>
                    
                    <a href="/tags/מיון בועות.html">מיון בועות</a>
                    
                    <a href="/tags/מיון בחירה.html">מיון בחירה</a>
                    
                    <a href="/tags/מיון הכנסה.html">מיון הכנסה</a>
                    
                    <a href="/tags/מיון מיזוג.html">מיון מיזוג</a>
                    
                    <a href="/tags/מיונים.html">מיונים</a>
                    
                    <a href="/tags/סיבוכיות זמן.html">סיבוכיות זמן</a>
                    
                    <a href="/tags/רקורסיה.html">רקורסיה</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>היום נדבר על אלגוריתמים למיון, אבל לפני שנתחיל להציג אלגוריתמים קונקרטיים, בואו נענה על השאלה האקוטית שחלקכם בוודאי תוהים לגביה - מה זה בכלל <strong>אלגוריתם</strong>?</p>
<p>המילה אלגוריתם מגיעה משיבוש שמו של המתמטיקאי הפרסי מוחמד אבן מוסא אל-ח'ואריזמי, אחד מגדולי המתמטיקאים של ימי הביניים (בימי הביניים, בזמן שאירופה הייתה בחור שחור מאין כמותו, המתמטיקה פרחה במקומות אחרים ובעולם המוסלמי בעיקר). אל-ח'ואריזמי כתב את אחד מהספרים החשובים במתמטיקה - "חיסאב אל-ג'אבר ואל-מוקאבלה", שעסק בפתרון משוואות ממעלה שניה (המילה "אלגברה" מגיעה מה"אל-ג'אבר" שבשם הספר). ספר אחר שלו עסק בחישובים בעזרת ספרות הודיות - ליתר דיוק, בעזרת שיטת כתיבת המספרים ההודית, השונה מאוד מזו הרומאית. בשיטה זו אנו משתמשים עד היום. אחד מהיתרונות בשיטה הזו היא הקלות הרבה שבה ניתן לבצע פעולות חשבון; זה כל כך קל עד שילדים לומדים את זה כבר בבית הספר היסודי. למשל, איך מחברים שני מספרים? כותבים האחד מעל השני, ספרה-ספרה, כאשר הספרות הימניות ביותר של המספרים נמצאות זו מעל זו, ואז עוברים ספרה-ספרה מימין לשמאל, מחברים את הספרות, כותבים את הספרה הראשונה של התוצאה וזוכרים את היתר (מה שמקבלים אחרי ש"חותכים" את הספרה הימנית ביותר ממנו), ומחברים אותו לשתי הספרות הבאות, וכן הלאה. זו דוגמה לאלגוריתם.</p>
<p>אלגוריתם באופן כללי הוא תיאור <strong>פשוט</strong> של <strong>תהליך</strong> שמטרתו לפתור בעיה. הפשטות היא קריטית - האלגוריתם תמיד צריך לכלול סדרה של צעדים פשוטים שכל אחד מהם הוא קל מספיק כדי שלקורא יהיה ברור איך אפשר לבצע אותו. כמו כן צריך שהאלגוריתם תמיד יסיים את עבודתו תוך פרק זמן <strong>סופי</strong> ושתוצאות האלגוריתם תהיה <strong>נכונה</strong>. כל תוכנית מחשב היא דוגמה לאלגוריתם, אם כי לרוב מעדיפים לכתוב אלגוריתמים בשפה שהיא חופשית קצת יותר מאשר תוכנית מחשב. אני אנקוט בדרך ביניים שמשלבת את הרע מבין שני העולמות - אתאר אלגוריתמים באופן לא פורמלי, שבו אני לא מסביר כל צעד עד הסוף; ואציג קוד מחשב "אמיתי" שפותר את הבעיה, בשפה שאף אחד לא מכיר (Ruby).</p>
<p>עכשיו משסיימנו עם המבוא, בואו נעבור לאקשן.</p>
<p>בעיית ה<strong>מיון</strong> היא הבעיה המושלמת להתחיל איתה דיון על אלגוריתמים. זו בעיה פשוטה מאוד לתיאור, אך לא טריוויאלית לפתרון; זו בעיה מאוד, מאוד, מאוד חשובה; יש לה פתרונות שונים ומגוונים מבחינת אופיים ואיכותם, ואין פתרון אחד "נכון"; והפתרונות הם פשוטים דיו כדי שאפשר יהיה להציג ניתוחים מפורטים שלהם, ועם זאת הם מסובכים מספיק כדי שיהיה עניין בניתוחים הללו. בפוסט הזה אסתפק לבינתיים בהצגת הבעיה והצגת פתרונות נאיביים עבורה.</p>
<p>"מיון", בעברית, משמש באופן אומלל למדי לתיאור שני דברים שונים. האחד הוא Classification - בהינתן קבוצת אובייקטים, לחלק אותם לתת-קבוצות על פי תכונה שלהם ("יונקים", "זוחלים", "חרקים"). זו לא הבעיה שאני מדבר עליה, אלא Sorting - בהינתן רשימה של אובייקטים שמוגדר עליהם סדר כלשהו, לסדר אותה.</p>
<p>לרשימה אני אקרא <span class="math">\(A\)</span>, ואת האיבר במקום ה-<span class="math">\(i\)</span> ברשימה אסמן בתור <span class="math">\(A\left[i\right]\)</span>. ההנחה היא שיש <strong>סדר</strong> על הרשימה, כלומר שלכל <span class="math">\(i\ne j\)</span> מתקיים <span class="math">\(A\left[i\right]<A\left[j\right]\)</span> או <span class="math">\(A\left[j\right] < A\left[i\right]\)</span>. המטרה היא לסדר מחדש את הרשימה כך שיתקיים <span class="math">\(A\left[0\right] < A\left[1\right] < A\left[2\right]<\dots<A\left[n\right]\)</span> (שימו לב שאני מתחיל את האינדקס מאפס, כפי שנהוג במדעי המחשב; יש לשיטה הזו יתרונות וחסרונות ואני בוחר בה כדי להתאים לקוד שאני אכתוב כאן).</p>
<p>מהם אברי הרשימה <span class="math">\(A\)</span>? אניח שהם מספרים שלמים, רק לצורך פשטות. באופן כללי הם יכולים להיות אובייקטים מורכבים מאוד, וההשוואה בין שניהם יכולה להיעשות בצורה מחוכמת מאוד. רוב האלגוריתמים שאציג פה לא יתעניינו בכך - כל מה שהם יצטרכו לדעת לצורך תהליך המיון זה המידע הבא: בהינתן שני איברים <span class="math">\(a,b\)</span> האם <span class="math">\(a<b\)</span> או <span class="math">\(b < a\)</span> (או שהם שווים). יש גם אלגוריתמים שיכולים להיעזר בכך שהם יודעים משהו על סוג האיברים שממיינים, אבל דיה לצרה בשעתה.</p>
<p>אז הנה דוגמה פשוטה. נניח ש-<span class="math">\(A=\left[1,4,2,3\right]\)</span>. אחרי מיון נרצה לקבל <span class="math">\(A=\left[1,2,3,4\right]\)</span>. איך אפשר לעשות זאת? השיטה הראשונה שאני מעלה על דעתי היא זו: נעבור על <span class="math">\(A\)</span> ונמצא את האינדקס שבו נמצא האיבר הגדול ביותר. מצאנו? נחליף את האיבר הזה עם האיבר שנמצא כרגע בסוף הרשימה. עכשיו אנחנו יודעים שהאיבר בסוף הרשימה נמצא במקומו הנכון ולכן אפשר לחשוב על הסיטואציה כאילו הרשימה קטנה ב-1. נעבור מחדש על הרשימה הקטנה יותר ונמצא את האיבר המקסימלי <strong>בה</strong>, נחליף אותו עם האיבר שנמצא כרגע בסוף הרשימה (הרשימה הקטנה ב-1), וכן הלאה וכן הלאה. הנה קוד שעושה את זה:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">def selection_sort(list)
  list.length.downto(1) do |k|
    max_index = 0
    for i in 1...k do
      max_index = i if list[max_index] &lt; list[i]
    end
    list.swap(max_index,k-1)
  end
  return list
end
</code></pre>


</div>

<p>קצת על רובי, כדי שהקוד יהיה קריא בכל זאת גם למי שלא מכיר שפות תכנות בכלל:</p>
<p>ברובי, def מתאר הכרזה על שם של פונקציה, כלומר קטע קוד שמקבל קלט (במקרה שלנו הקלט הוא ה-list שמופיע בסוגיים, שהוא על תפקיד ה-<span class="math">\(A\)</span> שלנו), ובסופו של דבר מחזיר פלט (אבל יותר מעניין אותנו כאן דווקא המניפולציות שעושים על הקלט - ממיינים את list ישירות, אם כי בסוף גם מחזירים אותה). הפונקציה מסתיימת ב-end שלמטה.</p>
<p>בתוך הפונקציה יש <strong>לולאות</strong>. לולאה היא קטע קוד שחוזר על עצמו שוב ושוב; לפעמים יש משתנה מיוחד כלשהו (ה<strong>מונה</strong>) שהערך שלו משתנה בין כל הרצה של הלולאה (הרצה כזו נקראת <strong>איטרציה</strong>). כך גם אצלנו:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">list.length.dowto(1) do |k|
</code></pre>


</div>

<p>זו דרך לרשום "עכשיו תעשה לולאה שהמונה שלה, שנקרא לו k מתחיל מהערך list.length (אורך הרשימה) ובכל איטרציה המונה קטן ב-1 עד שהוא מגיע ל-1 (וכשהוא מגיע ל-1 תריץ את הלולאה פעם אחת אחרונה וצא ממנה)".</p>
<p>אחרי השורה הזו מגיע הגוף של הלולאה - מה שמתבצע בכל איטרציה - ומסתיים ב-end שלפני ה-return list (זו, באופן מפתיע, השורה שבה מחזירים את המערך הממויין).</p>
<p>המשמעות של k היא "האורך של הרשימה שכרגע אנחנו ממיינים" - זכרו שבכל איטרציה, האורך הזה באמת אמור לקטון ב-1.</p>
<p>קטע הקוד הבא מוקדש למציאת האיבר המקסימלי ברשימה הנוכחית. אז קודם כל יוצאים מתוך ברירת מחדל שהאיבר המקסימלי נמצא במקום 0, וזה פשוט max_index = 0, וכעת מבצעים לולאה נוספתת שמחפשת ברשימה את האינדקס של האיבר המקסימלי.</p>
<p>הלולאה נפתחת ב-for i in 1...k do, שגם אותו צריך להסביר. כאן משתנה הלולאה הוא ה-i שבא מייד אחרי ה-for; ואילו 1...k מייצג את "כל המספרים השלמים מ-1 ועד k, לא כולל k''. אצלנו i יתחיל מ-1 ויגדל ב-1 כל פעם עד שיגיע ל-k, ואז נצא מהלולאה (בלי להריץ אותה עבור i=k). הסיבה שאנחנו לא מגיעים עד k היא פשוטה: ברובי, כמו ברוב שפות התכנות, האיבר הראשון ברשימה הוא איבר מספר 0, ולכן אם אורך הרשימה הוא <span class="math">\(n\)</span> אז האיבר האחרון בה הוא איבר מספר <span class="math">\(n-1\)</span>. זה משהו מבלבל ואיום ונורא למי שכרגע נתקל בו לראשונה, אבל מתרגלים אליו ורואים שהוא חשוב מאוד לפעמים. במילים אחרות - הרבה אלגוריתמים הם פשוטים יותר בגלל זה, אבל גם הרבה אלגוריתמים הם מסובכים יותר בגלל זה. אני אישית דבק בקונבנציה הזו כי זה מה שקורה בשפות תכנות. בפועל. בעולם האמיתי. כשתרצו ללכת ולכתוב קוד, זה מה שתצטרכו לעשות. מקומות אחרים (למשל <a href="http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844">הספר של CLRS</a> שהוא התנ"ך של מבוא לאלגוריתמים) מתחילים דווקא מ-1. אין תשובה טובה לשאלה "מה נכון" פרט ל"זה הבלוג שלי. אל תריבו!"</p>
<p>השורה הבאה מציבה ב-max_index את האינדקס של המספר הנוכחי שבודקים, i, אם האיבר במקום i גדול מהאיבר במקום max_index. שימו לב לסגנון הכתיבה - קודם כל ההשמה, ורק אחר כך הבדיקה. לטעמי זה משפר את הקריאות של הקוד, שמרגיש כמו שפה טבעית ויותר ברור מה הולך בו; אנשים אחרים <strong>מתעבים לחלוטין</strong> את סגנון הכתיבה הזה. לגיטימי.</p>
<p>בסיום הלולאה הפנימית (ה-end שאחרי השורה של הבדיקה-והשמה) אנחנו מחליפים בין האיבר האחרון במערך כרגע (זה האיבר במקום <span class="math">\(k-1\)</span>) ובין האיבר במקום המקסימלי, וזאת על ידי הפקודה (list.swap(max_index, k-1. לא הסברתי איך אני מבצע החלפה בין שני איברים במערך. ברובי אפשר לעשות את זה בשורה אחת:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">list[i], list[j] = list[j], list[i]
</code></pre>


</div>
<p>קטע הקוד הזה מחליף את האיברים במקומות <span class="math">\(i,j\)</span> ברשימה. אני משתמש ב-list.swap במקום זה רק כדי לשפר את הקריאות. בפועל, בשפה ברמה יותר בסיסית מאשר רובי, צריך להשתמש במשתנה עזר כלשהו כדי לזכור את הערך שהיה באחד המקומות ברשימה לצורך ההחלפה (תרגיל נחמד: כאשר הרשימה כוללת מספרים, אפשר להחליף שני תאים בלי שום משתני עזר - איך?)</p>
<p>האם האלגוריתם שלמעלה (שאני קורא לו "מיון-בחירה", כי בוחרים בכל פעם את האיבר שצריך להיכנס לסוף הרשימה) הוא טוב או רע? ובכן, הוא פשוט מאוד להבנה, וזה טוב. אבל הוא עושה הרבה עבודה: מספר האיטרציות שלו הוא כגודל המערך, ובכל איטרציה יש לולאה פנימית, שעושה הרבה השוואות. באיטרציה הראשונה יש <span class="math">\(n-1\)</span> השוואות (כש-<span class="math">\(n\)</span> הוא אורך הרשימה); בשניה יש <span class="math">\(n-2\)</span> השוואות; בשלישית יש <span class="math">\(n-3\)</span> וכן הלאה. סך הכל <span class="math">\(\left(n-1\right)+\left(n-2\right)+\cdots+1=\frac{\left(n-1\right)\left(n-2\right)}{2}=\Theta\left(n^{2}\right)\)</span> השוואות. בנוסף יש גם <span class="math">\(\Theta\left(n\right)\)</span> החלפות, אבל זה פחות נורא. בסך הכל האלגוריתם הוא לא אסון אבל יש טובים ממנו שעוד נראה.</p>
<p>המשמעות של סיבוכיות ריבועית שכזו היא שעבור רשימה של 1,000 פריטים צריך סדר גודל של מיליון השוואות; עבור רשימה של מיליון פרטים (וזו סיטואציה אפשרית בהחלט) צריך סדר גודל של <span class="math">\(10^{12}\)</span> השוואות - זה לא משהו בכלל. כבר על רשימות קטנות יחסית האלגוריתם דורש זמן ריצה מורגש, גם במחשבים מודרניים (אערוך השוואות כלשהן בהמשך, אחרי שאציג את כל אלגוריתמי המיון).</p>
<p>בואו ננסה לחשוב על שיטת מיון אחרת, שהיא טבעית מאוד עבור בני אדם (ונוחה מאוד למימוש אצל בני אדם, כל עוד הקלט קטן מספיק - למשל, קלפי משחק) - מיון הכנסה. במיון הכנסה, חושבים על הרשימה הקיימת <span class="math">\(A\)</span> בתור משהו מבולגן לחלוטין, ובונים לאט לאט רשימה ממוינת באופן הבא: שולפים איבר כלשהו מ-<span class="math">\(A\)</span>, בודקים איפה ברשימה החדשה הוא צריך להיות, ומכניסים אותו שם, אולי בין שני איברים קיימים.</p>
<p>השיטה הזו <strong>דואלית</strong> למיון בחירה במובן מסויים. במיון בחירה ידענו מראש בתחילת כל איטרציה <strong>לאן</strong> אנחנו רוצים להכניס את האיבר שאנחנו הולכים לבחור (המקסימלי) והעבודה שלנו הייתה למצוא אותו; במיון הכנסה אנחנו יודעים מראש מי האיברי שאנחנו רוצים להכניס, ונותר רק למצוא את המקום שבו נרצה להכניס אותו.</p>
<p>בפועל המימוש של מיון הכנסה קצת יותר מסובך, בגלל שכדי להכניס איבר <strong>לתוך</strong> רשימה צריך "להזיז הצידה" את האיברים שבאים אחריו ברשימה. הנה הקוד:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">def insertion_sort(list)
  for k in 1...list.length
    new_element = list[k]
    i = k-1
    while i &gt;= 0 and list[i] &gt; new_element
      list[i+1] = list[i]
      i = i - 1
    end
    list[i+1] = new_element
  end
  return list
end
</code></pre>


</div>

<p>בתחילת ריצת האלגוריתם מתייחסים לתא 0 לבדו בתור "רשימה ממוינת" (לא חוכמה, זו רשימה של איבר אחד) ואילו כל היתר הוא מערב פרוע. לאט לאט מגדילים את האיזור הממויין על ידי כך שלוקחים את האיבר הראשון שהוא מחוץ לאיזור הממויין (האיבר במקום ה-k) ועוברים על האיזור הממויין מהסוף להתחלה תוך שאנו דוחפים קדימה את האיברים שאנו חולפים על פניהם, עד שאנו מוצאים את המקום הנכון להכניס אליו את האיבר החדש (בדיוק המקום שבו כל האיברים שחלפנו על פניהם היו גדולים מ-k והאיבר הראשון שטרם חלפנו על פניו קטן מ-k).</p>
<p>ניתוח הסיבוכיות כאן יותר מסובך. ללולאה החיצונית יש n-1 איטרציות, אבל הלולאה הפנימית היא לולאה מסוג חדש - לולאת while, שממשיכה לרוץ כל עוד תנאי מסויים לא התקיים. התנאי הוא שטרם מצאנו את המקום שאליו צריך להכניס את האיבר החדש. לכל היותר זה ייקח לנו k צעדים, אבל ייתכן שזה יקח לנו גם הרבה פחות. אז מה עושים?</p>
<p>לרוב הניתוח מתבסס על <strong>המקרה הגרוע ביותר</strong>. מה יהיה המקרה הגרוע ביותר כאן? אם תמיד האיבר החדש יהיה קטן מכל האיברים שכרגע נמצאים ברשימה הממויינת. זה יכול לקרות אם list כבר ממוין, אבל בדיוק בסדר הפוך (מהגדול ביותר לקטן ביותר). במקרה הזה בכל איטרציה יהיו לנו <span class="math">\(O\left(k\right)\)</span> השוואות ו-<span class="math">\(O\left(k\right)\)</span> החלפות, ולכן בסך הכל נקבל שהאלגוריתם מבצע <span class="math">\(\Theta\left(n^{2}\right)\)</span> החלפות ו-<span class="math">\(\Theta\left(n^{2}\right)\)</span> השוואות. זה עוד פחות טוב ממיון-בחירה. מצד שני, שימו לב שהאלגוריתם לא בדיוק מבצע "החלפה" - הוא מבצע חצי החלפה בלבד בכל פעם (לא השתמשתי ב-swap), אז הנזק פחות גדול משנראה במבט ראשון.</p>
<p>מצד שני, הביצועים במקרה הגרוע ביותר הם ממש לא המדד היחיד שצריך לחשוב עליו. למיון-בחירה יש חסרון לפיו הוא <strong>תמיד</strong> ידרוש ביצוע של <span class="math">\(\Theta\left(n^{2}\right)\)</span> השוואות; לעומת זאת מיון הכנסה עשוי לדרוש הרבה, הרבה פחות פעולות אם הקלט יהיה "נחמד" (למשל, אם הרשימה ממויינת ברובה כבר כך - סיטואציה מציאותית יחסית).</p>
<p>בואו נעבור למיון פשוט נוסף - מיון בועות. השם של המיון הזה מגיע מכך שבשיטה שלו, בכל איטרציה האיבר הגדול ביותר שטרם טופל "מפעפע למעלה" למקומו במערך. השיטה פשוטה: מתחילים מהשוואה בין <span class="math">\(A\left[0\right]\)</span> ו-<span class="math">\(A\left[1\right]\)</span>. אם <span class="math">\(A\left[0\right]<A\left[1\right]\)</span> הכל בסדר, אבל אם <span class="math">\(A\left[1\right]<A\left[0\right]\)</span> אז מחליפים ביניהם. כעת אנו יודעים שב-<span class="math">\(A\left[1\right]\)</span> יש את האיבר הגדול מבין שני הראשונים; משווים אותו עם <span class="math">\(A\left[2\right]\)</span>. אם <span class="math">\(A\left[2\right]<A\left[1\right]\)</span>, מחליפים, וכעת ב-<span class="math">\(A\left[2\right]\)</span> יש את האיבר הגדול מבין שלושת הראשונים. ממשיכים... ובסוף התהליך ב-<span class="math">\(A\left[n\right]\)</span> יהיה את האיבר הגדול ביותר ברשימה. עכשיו אפשר להתחיל את כל הסיפור מחדש אבל לעצור ב-<span class="math">\(A\left[n-1\right]\)</span>, וכן הלאה.</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">def bubble_sort(list)
  list.length.downto(1) do |n|
    for i in 0...(n-1) do
      list.swap(i,i+1) if list[i] &gt; list[i+1]
    end
  end
  return list
end
</code></pre>


</div>
<p>האלגוריתם הזה הוא <strong>איום ונורא</strong>. הוא גם לא טריוויאלי לחלוטין להבנה מבחינה רעיונית (למרות שאחרי שמבינים, הקוד עצמו הוא פשוט מאוד), והוא גם משיג בפועל תוצאות שהן משמעותית גרועות יותר מאשר אלו של מיון הכנסה ומיון-בחירה. הסיבה לכך היא שהוא מבצע גם המון השוואות (<span class="math">\(\Theta\left(n^{2}\right)\)</span> תמיד - למה?) וגם המון החלפות, במקרים גרועים. במקרה טוב, למשל אם המערך כבר ממוין, הוא ישיג ביצועים טובים יותר מאשר מיון-בחירה, אבל בדרך כלל הביצועים שלו יהיו גרועים משמעותית יותר מאלו של מיון-בחירה ומיון הכנסה. אל תשתמשו בו. פשוט אל.</p>
<p>עד כה כל האלגוריתמים פעלו בזמן שהוא <span class="math">\(\Theta\left(n^{2}\right)\)</span> במקרה הגרוע. הגיע הזמן לראות אלגוריתם מיון טוב, כזה שפועל בזמן <span class="math">\(\Theta\left(n\log n\right)\)</span> ולכן משיג ביצועים טובים יותר משמעותית מכל האלגוריתמים שהצגתי. נתחיל ממיון שהוא פשוט יחסית להצגה, אבל הוא חזק מאוד (יש ספריות שמשתמשות בו בתור אלגוריתם המיון שלהן) - מיון מיזוג, שהומצא על ידי המתמטיקאי ג'ון פון-נוימן בשנת 1945 (ראשית ימי מדעי המחשב).</p>
<p>הרעיון של האלגוריתם פשוט, ומתמצה בביטוי <strong>הפרד ומשול</strong>. אלגוריתמי הפרד ומשול הם אלגוריתמים שלוקחים את הקלט, מחלקים אותו לכמה חלקים (הפרד), פותרים כל חלק בנפרד ואז איכשהו משלבים את הפתרונות של כל חלק בנפרד לפתרון כללי. הרעיון שבלב השיטה הזו הוא שלפעמים השלם הוא יותר מסך כל חלקיו; כלומר, שהעבודה שנדרשת כדי למיין רשימה שלמה בצורה פשוטה היא גדולה משמעותית יותר מאשר העבודה שנדרשת כדי למיין שתי רשימות קטנות יותר, כל אחת בנפרד.</p>
<p>האבחנה הזו די ברורה אם מסתכלים על האלגוריתמים שכבר התעסקנו בהם. מיון נאיבי של רשימה לוקח <span class="math">\(n^{2}\)</span> צעדים, נאמר? אז מיון נאיבי של רשימה שגודלה <span class="math">\(\frac{n}{2}\)</span> יקח <span class="math">\(\left(\frac{n}{2}\right)^{2}=\frac{n^{2}}{4}\)</span> צעדים, ולכן מיון של <strong>שתי</strong> רשימות שגודלן <span class="math">\(\frac{n}{2}\)</span> יקח רק <span class="math">\(\frac{n^{2}}{2}\)</span> צעדים - חצי מספר הצעדים מאשר מיון של הרשימה הגדולה. כמובן, זה בפני עצמו עדיין לא מהווה שיפור גדול במיוחד, אבל אחרי שמפצלים את הרשימה הגדולה לשתי רשימות קטנות, אפשר כדי למיין אותן לפצל אותן <strong>שוב</strong> לשתי רשימות כל אחת, ושוב ושוב ושוב. זו דוגמה לאלגוריתם <strong>רקורסיבי</strong>; אלגוריתם שמפעיל את עצמו על מקרים קטנים ופשוטים יותר של הבעיה. המקרה הכי פשוט הוא רשימה מגודל 0 או 1; רשימה כזו היא ממויינת בהכרח מעצמה, בלי שנעשה שום דבר נוסף איתה.</p>
<p>בינתיים לא אמרנו כלום, בעצם. אוקיי, אז מפצלים את הרשימה לשניים, באמצע, ממיינים כל תת-רשימה באופן רקורסיבי, ואז מה? נשארנו עם רשימה שהחצי הראשון שלה ממויין והחצי השני שלה ממויין אבל היא עצמה לא ממויינת. אז מה עושים עכשיו? <strong>ממזגים</strong> את שני החצאים לרשימה אחת גדולה.</p>
<p>איך עושים את זה? פשוט. מכינים בצד מקום לרשימה חדשה, בגודלה של הרשימה המקורית; ומתחילים לעבור בו זמנית על שתי תתי-הרשימות הממוינות. בכל צעד משווים את שני האיברים בתתי-הרשימות הממויינות שאנחנו רואים כרגע. את הקטן מבין השניים נכניס לרשימה שאנחנו בונים ונקדם את האינדקס של האיבר שאנחנו מסתכלים עליו ברשימה הזו ב-1. אם מתישהו סיימנו לעבור על אחת מהרשימות, נעתיק את כל יתר האיברים הרשימה השניה אל הרשימה שאנחנו בונים כמות שהם. הנכונות של המיזוג הזה נובעת מכך ששתי תתי-הרשימות כבר ממויינות.</p>
<p>הנה הקוד של המיון:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">def merge_sort(list)
  return list if list.length &lt;= 1
  k = list.length / 2
  list_a = merge_sort(list[0...k])
  list_b = merge_sort(list[k...list.length])
  return merge(list_a, list_b)
end
</code></pre>


</div>

<p>כמו שאנחנו רואים, הוא פשוט מאוד - אפילו טריוויאלי. פשוט מחלקים את הרשימות לשני חלקים באמצע (אלא אם הרשימה שלנו מכילה לכל היותר איבר אחד ואז לא עושים כלום), ממיינים כל אחת משתי הרשימות בנפרד ובסוף ממזגים. כדי להשלים את התמונה צריך להציג את האלגוריתם שממזג. כאן, למרבה הצער, הקוד יוצא טיפה מסורבל, אם כי לא נורא:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">def merge(list_a, list_b)
  i, j = 0, 0
  result = []
  while i &lt; list_a.length and j &lt; list_b.length
    if (list_a[i] &lt; list_b[j])
      result.push(list_a[i])
      i = i + 1
    else
      result.push(list_b[j])
      j = j + 1
    end
  end

  while i &lt; list_a.length
        result.push(list_a[i])
        i = i + 1
  end

  while j &lt; list_b.length
        result.push(list_b[j])
        j = j + 1
  end
  return result
end
</code></pre>


</div>
<p>נשאר רק להבין מה סיבוכיות זמן הריצה של האלגוריתם הזה. ראשית כל, שימו לב שאם merge מופעל על שתי רשימות שהארוכה מביניהן היא באורך <span class="math">\(n\)</span>, אז זמן הריצה שלו הוא <span class="math">\(\Theta\left(n\right)\)</span> (עוברים על לכל היותר <span class="math">\(2n\)</span> איברים). במילים - מיזוג ניתן לבצע <strong>בזמן לינארי</strong>.</p>
<p>כדי להבין כמה זמן נדרש מ-merge_sort לרוץ צריך להתאמץ טיפה יותר. הקושי כאן הוא שמדובר על אלגוריתם רקורסיבי - כזה שקורא לעצמו - ולכן צריך להתחכם קצת בניתוח. בואו נסמן את זמן הריצה של האלגוריתם ב-<span class="math">\(T\left(n\right)\)</span>. אז ברור ש-<span class="math">\(T\left(1\right)=O\left(1\right)\)</span> (כי על רשימה מגודל 1 האלגוריתם רק מבזבז זמן על בדיקה האם הרשימה מגודל 1 או פחות וזהו).</p>
<p>אם לעומת זאת <span class="math">\(n\)</span> גדול יותר, אנחנו מקבלים את המשוואה הבאה שמתארת את זמן הריצה של האלגוריתם:</p>
<p><span class="math">\(T\left(n\right)=2T\left(\frac{n}{2}\right)+\Theta\left(n\right)\)</span></p>
<p>מה המשוואה בעצם אומרת? שהזמן שלוקח להריץ את המיון על רשימה בגודל <span class="math">\(n\)</span> שווה לזמן שלוקח להריץ את המיון על שתי רשימות בגודל <span class="math">\(\frac{n}{2}\)</span> (<span class="math">\(2T\left(\frac{n}{2}\right)\)</span> - זה שלב ה"הפרד") ועוד הזמן שלוקח למזג אותן אחר כך (<span class="math">\(\Theta\left(n\right)\)</span> - זה ה"ומשול"). יופי, איך מתקדמים מכאן? - פשוט משתמשים באותה נוסחה <strong>שוב</strong>, ומקבלים:</p>
<p><span class="math">\(2T\left(\frac{n}{2}\right)+\Theta\left(n\right)=2\left(2T\left(\frac{n}{4}\right)+\Theta\left(\frac{n}{2}\right)\right)+\Theta\left(n\right)=4T\left(\frac{n}{4}\right)+\Theta\left(n\right)\)</span></p>
<p>מפתה לעבור עכשיו לטענה כללית: שלכל <span class="math">\(k\)</span> טבעי, מתקיים:</p>
<p><span class="math">\(T\left(n\right)=2^{k}T\left(\frac{n}{2^{k}}\right)+\Theta\left(n\right)\)</span></p>
<p>ואז לומר "בואו נבחר <span class="math">\(k\)</span> כך ש-<span class="math">\(2^{k}=n\)</span> ואז נקבל <span class="math">\(T\left(n\right)=n+\Theta\left(n\right)=\Theta\left(n\right)\)</span> וקיבלנו זמן ריצה לינארי של האלגוריתם". רק שזה <strong>לא נכון</strong>. זו נקודה עדינה ומבלבלת שחשוב להתייחס אליה, אז בואו נעשה את זה.</p>
<p>מה <span class="math">\(T\left(n\right)=\Theta\left(n\right)\)</span> אומר? שקיים קבוע <span class="math">\(c\)</span> וקיים <span class="math">\(N\)</span> כך ש-<span class="math">\(T\left(n\right)<c\cdot n\)</span> לכל <span class="math">\(n>N\)</span> (יש גם חסם מלמטה אבל הוא לא חשוב כרגע).</p>
<p>מה <span class="math">\(T\left(n\right)=2^{k}T\left(\frac{n}{2^{k}}\right)+\Theta\left(n\right)\)</span> אומר? שלכל <span class="math">\(k\)</span>, קיים קבוע <span class="math">\(c_{k}\)</span> וקבוע <span class="math">\(N_{k}\)</span> כך ש-<span class="math">\(T\left(n\right)<2^{k}T\left(\frac{n}{2^{k}}\right)+c_{k}n\)</span> לכל <span class="math">\(n>N_{k}\)</span>.</p>
<p>האם אפשר לעבור מהטענה השניה לראשונה על ידי הצבת <span class="math">\(k=n\)</span>? לא! כי <span class="math">\(n\)</span> אינו קבוע. זכרו - אנחנו מנסים לחסום פה פונקציה של <span class="math">\(n\)</span>. בקיצור, האינטואיציה פכמהה מסוכנת ובעייתית. משחקי <span class="math">\(\Theta\)</span> עלולים להוביל לבעיות מסוג זה.</p>
<p>הדרך להתגבר על הבעיה היא ניתוח קצת יותר זהיר. אנחנו יודעים ש-<span class="math">\(T\left(n\right)=2T\left(\frac{n}{2}\right)+\Theta\left(n\right)\)</span>. זה אומר ש<span class="math">\(T\left(n\right)<2T\left(\frac{n}{2}\right)+c\cdot n\)</span> לכל <span class="math">\(n>N\)</span> עבור <span class="math">\(N,c\)</span> מסויימים. יפה. עכשיו ניטרלנו (לעת עתה) את הסימונים האסימפטוטיים מהמשוואה. כדי לסיים עם זה, נשים לב לכך שעבור <span class="math">\(n<N\)</span> מתקיים <span class="math">\(T\left(n\right)<d\)</span> עבור קבוע <span class="math">\(d\)</span> כלשהו. אם נבחר את <span class="math">\(c\)</span> להיות גדול מספיק, ובפרט גדול יותר מ-<span class="math">\(d\)</span>, נקבל ש-<span class="math">\(T\left(n\right) < 2T\left(\frac{n}{2}\right)+c\cdot n\)</span> היא משוואה שתקפה תמיד, לכל <span class="math">\(n\)</span>.</p>
<p>עכשיו אפשר לעשות את התעלול הבא:</p>
<p><span class="math">\(T\left(n\right)<2T\left(\frac{n}{2}\right)+c\cdot n<2\left(2T\left(\frac{n}{4}\right)+c\cdot\frac{n}{2}\right)+c\cdot n=4T\left(\frac{n}{4}\right)+2cn\)</span></p>
<p>שימו לב: ה-<span class="math">\(2cn\)</span> שבאגף ימין נבנה מה-<span class="math">\(cn\)</span> שהיה בהתחלה, ועוד פעמיים <span class="math">\(c\frac{n}{2}\)</span> (המחיר של הפעלת מיזוג על שני תתי-הרשימות).</p>
<p>נחזור על הקסם שוב:</p>
<p><span class="math">\(4T\left(\frac{n}{4}\right)+2cn<4\left(2T\left(\frac{n}{8}\right)+c\frac{n}{4}\right)+2cn=8T\left(\frac{n}{8}\right)+3cn\)</span></p>
<p>הבנתם את הרעיון. הנה המשוואה הכללית, שנכונה לכל <span class="math">\(k\)</span> טבעי:</p>
<p><span class="math">\(T\left(n\right)<2^{k}T\left(\frac{n}{2^{k}}\right)+k\cdot cn\)</span></p>
<p>ולכן עבור <span class="math">\(k\)</span> שמקיים <span class="math">\(2^{k}\ge n\)</span> יתקיים ש- <span class="math">\(T\left(\frac{n}{2^{k}}\right)<d\)</span> עבור איזה שהוא קבוע <span class="math">\(d\)</span>. נשאלת רק השאלה איזה <span class="math">\(k\)</span> לבחור.</p>
<p>אם <span class="math">\(2^{k}=n\)</span>, יש סימון מיוחד ל-<span class="math">\(k\)</span> שמקיים את השוויון: <span class="math">\(k=\lg n\)</span> (זה מה שנקרא לוגריתם על בסיס 2). לא תמיד <span class="math">\(n\)</span> הוא בדיוק חזקה של 2, ולכן לא תמיד <span class="math">\(\lg n\)</span> יוצא מספר שלם. תמיד אפשר לעגל למעלה: <span class="math">\(k=\left\lceil \lg n\right\rceil \)</span>, והמספר שנקבל יקיים <span class="math">\(n\le2^{k}\le2n\)</span>. לכן אנחנו מקבלים בסופו של דבר את אי השוויון הבא:</p>
<p><span class="math">\(T\left(n\right)<2n\cdot d+\left\lceil \lg n\right\rceil \cdot cn=O\left(n\log n\right)\)</span></p>
<p>(הסיבה שעברתי מ-<span class="math">\(\lg\)</span> ל-<span class="math">\(\log\)</span> היא שכדי לעבור בין שני בסיסים שונים של לוגריתם כופלים בקבוע: <span class="math">\(\log_{a}n=\left(\log_{a}b\right)^{-1}\cdot\log_{b}n\)</span>, ולכן <span class="math">\(\log_{a}n=\Theta\left(\log_{b}n\right)\)</span>).</p>
<p>קיבלנו חסם עליון על הזמן שבו רץ האלגוריתם, ולא קשה במיוחד להראות חסם תחתון דומה. המסקנה: מיון מיזוג רץ בזמן <span class="math">\(\Theta\left(n\log n\right)\)</span>, שהוא טוב משמעותית יותר מאשר <span class="math">\(\Theta\left(n^{2}\right)\)</span>, שכן <span class="math">\(\log n\)</span> הוא קטן משמעותית ביחס ל-<span class="math">\(n\)</span>. ההבדל שבין <span class="math">\(n\)</span> ו-<span class="math">\(\log n\)</span> הוא ההבדל שבין <strong>גודל</strong> של מספר ובין <strong>מספר הספרות</strong> של אותו מספר (בבסיס עשרוני, או בינארי, לא באמת חשוב). כך למשל הגודל של 10 הוא עשר, ואילו מספר הספרות שלו הוא 2; ואילו מספר הספרות של <span class="math">\(10^{100}\)</span> הוא בסך הכל 101, בעוד הגודל של המספר הזה (<strong>גוגול</strong>) הוא גדול ממספר האטומים ביקום. התוצאה היא הבדל משמעותי ביותר בביצועים.</p>
<p>מיון מיזוג הוא האלגוריתם ה"טוב" הראשון למיון שהראיתי. בהמשך אראה עוד שני אלגוריתמים מפורסמים טובים למיון, כל אחד עם יתרונות וחסרונות משל עצמו: מיון ערימה, ומיון מהיר. בנוסף לכך שהם יפים ומועילים לכשעצמם, הניתוח של זמן הריצה שלהם הוא מורכב ומחוכם יותר מתמטית ממה שראינו עד כה ויתן תחושה כלשהי של אופי הטיפול באלגוריתמים מחוכמים. יהיה כיף.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>