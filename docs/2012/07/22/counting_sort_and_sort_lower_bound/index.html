<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>למה יש מיון מהיר יותר ממיון מהיר אבל בעצם אין - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2012/07/22/counting_sort_and_sort_lower_bound/">
    <meta property="og:title" content="למה יש מיון מהיר יותר ממיון מהיר אבל בעצם אין">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2012/07/22/counting_sort_and_sort_lower_bound/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="למה יש מיון מהיר יותר ממיון מהיר אבל בעצם אין">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <a href="/lecture_notes.html">סיכומי הרצאות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2012/07/20/quick_quicksort/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">עיון בהיר במיון מהיר</span>
            </a>
            

            
            <a href="/2012/07/23/stirling_and_flying_spaghetti_monster/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">מהי נוסחת סטירלינג ואיך היא מוכיחה את קיום מפלצת הספגטי המעופפת</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>למה יש מיון מהיר יותר ממיון מהיר אבל בעצם אין</h1>
            <div class="post-meta">
                <span class="date">2012-07-22</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/מבני נתונים ואלגוריתמים.html">מבני נתונים ואלגוריתמים</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/חסמים תחתונים.html">חסמים תחתונים</a>
                    
                    <a href="/tags/מיון מניה.html">מיון מניה</a>
                    
                    <a href="/tags/מיונים.html">מיונים</a>
                    
                    <a href="/tags/עצי החלטה.html">עצי החלטה</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>עד כה כל אלגוריתמי המיון שראינו פעלו בזמן של <span class="math">\(\Omega\left(n\log n\right)\)</span>, כלומר דרשו לפחות זמן ריצה אסימפטוטי של לפחות <span class="math">\(n\log n\)</span> (כאשר <span class="math">\(n\)</span> הוא גודל רשימת האיברים שאותה ממיינים). השאלה הראשונה שמתעוררת היא - האם אפשר טוב יותר מזה, או ש<strong>כל</strong> אלגוריתם מיון ידרוש זמן ריצה של לפחות <span class="math">\(n\log n\)</span> צעדים?</p>
<p>התשובה, כמו כל תשובה מעניינת במתמטיקה, היא "כן ולא".</p>
<p>נתחיל מה"לא" - קיים אלגוריתם מיון פשוט ביותר שאציג עוד מעט שזמן הריצה שלו הוא <span class="math">\(\Theta\left(n\right)\)</span>. רק מה, האלגוריתם הזה הוא <strong>לא כללי</strong>; הוא חייב להניח הנחות מסויימות על אופי הקלט שלו. בפרט, הוא מניח שהוא ממיין רשימה של <strong>מספרים טבעיים</strong>. כמו כן, לומר שזמן הריצה שלו הוא <span class="math">\(\Theta\left(n\right)\)</span> זו קצת רמאות כי יש עוד פרמטר שצריך לקחת בחשבון. למרות ההסתייגויות הללו, האלגוריתם הזה עובד מצוין בפועל, וכדאי לעתים קרובות להשתמש בו יותר מאשר כדאי להשתמש במיון מיזוג, או מיון מהיר, או מיון ערימה.</p>
<p>נעבור אל ה"כן" - קיימת הוכחה מתמטית לא מסובכת יותר מדי לפיה <strong>כל</strong> אלגוריתם מיון כללי ידרוש לפחות <span class="math">\(\Omega\left(n\log n\right)\)</span> צעדי ריצה. מה זה אומר, "אלגוריתם כללי"? הכוונה כאן לאלגוריתם שהמידע <strong>היחיד</strong> שהוא יכול להפיק על אברי הרשימה שלו הוא מתוך השוואות של זוגות איברים. זה אומר שהאלגוריתם לא יכול להתבסס על ידע כלשהו לגבי ההתפלגויות האפשריות של האיברים ברשימה; ושהוא לא יכול לדעת שהם מספרים טבעיים או שלמים או כל דבר דומה. זו סיטואציה שאכן מתרחשת במקרים רבים בפועל, כך שהחסם התחתון הזה הוא ממשי מאוד.</p>
<p>נתחיל מהמיון, שנקרא "מיון ספירה" (Counting Sort). הרעיון הוא אידיוטי לגמרי: יש לכם רשימה של מספרים טבעיים ואתם רוצים למיין אותה? תעברו עליה איבר-איבר ותספרו כמה פעמים 0 מופיע, כמה פעמים 1 מופיע, וכן הלאה. אחרי שסיימתם, תבדקו כמה פעמים 0 הופיע ותכתבו כמספר הזה פעמים 0 לפלט; אחר כך תבדקו כמה פעמים 1 הופיע ותכתבו כמספר הזה פעמים 1 לפלט, וכן הלאה. הנה כל העסק בקוד:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">counting_sort</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
<span class="w">  </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="n">max</span>
<span class="w">  </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">list</span>
<span class="w">    </span><span class="n">values</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">...</span><span class="n">values</span><span class="o">.</span><span class="n">length</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">...</span><span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
<span class="w">      </span><span class="n">list</span><span class="o">[</span><span class="n">pos</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">      </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">list</span>
<span class="k">end</span>
</code></pre></div>


</div>

<p>מה זמן הריצה שלנו? הלולאה הראשונית, זו שבה סופרים כמה פעמים מופיע כל מספר ברשימה, דורשת <span class="math">\(O\left(n\right)\)</span> זמן (וכך גם מציאת המקסימום שאני מבצע בשורה הראשונה). הלולאה השניה מעניינת קצת יותר, כי היא תלויה בערך של <strong>האיבר המקסימלי</strong> ברשימה. בואו נסמן בתור <span class="math">\(m\)</span> את הערך הזה, אז הלולאה השניה מתבצעת בזמן של <span class="math">\(O\left(m+n\right)\)</span> (למי שלא רואה את זה, שימו לב לכך ש-<span class="math">\(i\)</span> רץ מאפס עד <span class="math">\(m\)</span> ואילו <span class="math">\(pos\)</span> רץ מאפס עד <span class="math">\(n\)</span>). לכן זמן הריצה הכולל של האלגוריתם הוא <span class="math">\(O\left(n+m\right)\)</span>.</p>
<p>זה דבר חדש: זמן ריצה של אלגוריתם שתלוי בשני פרמטרים ולא באחד. כמובן, ייתכן שהערך של <span class="math">\(m\)</span> הוא קבוע בכל הריצות של האלגוריתם, בלי תלות בגודל הרשימה (למשל, אם הרשימה היא תמיד של מספרי זהות); במקרים כאלו נכון לומר שזמן הריצה של האלגוריתם הוא פשוט <span class="math">\(O\left(n\right)\)</span> ו"לשכוח" מהפרמטר <span class="math">\(m\)</span> (למרות שהוא יבוא לידי ביטוי בקבוע גדול בפונקציה שמתארת את זמן הריצה בפועל).</p>
<p>שימו לב לכך שהאלגוריתם לא מבצע מיון במקום אלא דורש הקצאת זכרון נוסף - רשימה מאורך <span class="math">\(m\)</span>. זה לא חסרון מהותי עבור ערכים קטנים של <span class="math">\(m\)</span>, אבל אם הערכים האפשריים של <span class="math">\(m\)</span> הם גדולים מדי זה הופך את האלגוריתם לבלתי ישים לחלוטין. למשל, עבור <span class="math">\(m=10^{12}\)</span> האלגוריתם הוא כבר מאוד, מאוד בעייתי. לכן המיון הזה מבהיר יותר מכל מיון אחר עד כמה אין "מיון אחד נכון" שאפשר להשתמש בו להכל, ושהסיטואציה שבה אנחנו נמצאים חשובה. ארחיב על כך יותר בפוסט הבא בעניין.</p>
<p>נעבור לעניין השני שלנו - החסם התחתון של <span class="math">\(\Omega\left(n\log n\right)\)</span> על מיון כללי. איך מוכיחים כזה דבר? באופן כללי, הוכחת חסמים <strong>תחתונים</strong> במדעי המחשב היא עניין קשה בהרבה מהוכחת חסמים עליונים. כדי להוכיח חסם עליון על זמן הריצה הנדרש לפתרון בעיה, כל מה שיש להציג הוא אלגוריתם <strong>אחד</strong> שפותר את הבעיה בזמן הריצה הזה; לעומת זאת, כדי להראות חסם תחתון על זמן הריצה יש להראות כי <strong>כל</strong> אלגוריתם שינסה לפתור את הבעיה יעשה זאת בזמן ריצה שהוא לפחות <span class="math">\(n\log n\)</span>. ההבדל הזה, של "קיים" אל מול "כל", חוזר שוב ושוב במתמטיקה (ובחיים באופן כללי).</p>
<p>הדרך להתמודד עם הקושי הזה כאן היא למעט ככל הניתן בכניסה לפרטים הטכניים של "מה האלגוריתם בעצם עושה", ולהתמקד בשאלה יותר פשוטה - כמה <strong>אינפורמציה</strong> האלגוריתם חייב להשיג על מנת להחזיר את הפלט הנכון ללא טעות? כדי להבין את הטענה הזו, בואו נעבור רגע לבעיה אחרת, פשוטה יותר - הבעיה של מציאת מקסימום ברשימה. אנחנו יודעים שאפשר למצוא מקסימום על ידי קריאת כל תא ברשימה בדיוק פעם אחת; האם אפשר פחות מזה?</p>
<p>התשובה האינטואיטיבית כאן היא "לא". למה? כי נניח שקראנו את כל התאים ברשימה חוץ מאחד, ומבין כל התאים שקראנו, הערך המקסימלי שהיה בתוך תא הוא 13. אז מה? עדיין <strong>ייתכן</strong> שבתא היחיד שלא קראנו הערך יהיה 42, או 15, או כל דבר דומה שגדול מ-13, ולכן כל עוד לא קראנו את התא הזה פשוט אין לנו מספיק אינפורמציה כדי להחזיר את התשובה הנכונה.</p>
<p>קצת יותר פורמלית, אם יש לנו אלגוריתם שמחזיר את המקסימום מבלי לקרוא את כל התאים, אז אפשר לבנות קלט ש<strong>יטעה</strong> את האלגוריתם. הטיעון הולך כך: נניח שיש לנו אלגוריתם למציאת מקסימום ברשימה כך ש<strong>קיימת</strong> רשימה <span class="math">\(A\)</span> שהאלגוריתם מחזיר עליה את התשובה הנכונה מבלי שיקרא את כל התאים. יהא <span class="math">\(k\)</span> מספרו של תא שאותו האלגוריתם לא קורא, ויהא <span class="math">\(m\)</span> הפלט של האלגוריתם על <span class="math">\(A\)</span>. נגדיר כעת רשימה חדשה <span class="math">\(B\)</span> באופן הבא:</p>
<p><span class="math">\(B\left[i\right]=\begin{cases}A\left[i\right] & i\ne k\\m+1 & i=k\end{cases}\)</span></p>
<p>כעת, על הקלט <span class="math">\(B\)</span> האלגוריתם יחזיר <strong>בודאות</strong> את הפלט <span class="math">\(m\)</span>, שכן ההבדל היחיד בין <span class="math">\(A\)</span> ובין <span class="math">\(B\)</span> הוא בתוכן התא <span class="math">\(k\)</span> שאותו האלגוריתם <strong>לא קורא</strong>. לכן האלגוריתם יתנהג על <span class="math">\(B\)</span> בדיוק כפי שהיה מתנהג על <span class="math">\(A\)</span> ויחזיר את הפלט <span class="math">\(m\)</span> וזו כמובן טעות כי הערך המקסימלי ב-<span class="math">\(B\)</span> הוא <span class="math">\(m+1\)</span>.</p>
<p>בואו נעבור לטפל במיון באמצעות אותו רעיון, ולצורך כך נכניס לתמונה מושג מתמטי חדש: <strong>עץ החלטה</strong>. עץ החלטה (Decision Tree) הוא בעצם מודל מאוד פשטני של חישוב (כשהחישוב הוא על קלט כלשהו מאורך <span class="math">\(n\)</span> - האורך של הקלט הוא חלק מהגדרת עץ ההחלטה הספציפי). זהו עץ בינארי שבו לכל צומת שאינו עלה יש שני בנים (הזכרתי עצים בינאריים בפוסט שדיבר על מיון ערימה). כל צומת פנימי מסומן על ידי פריט אחד של מידע מתוך הקלט שיכול להיות "כן" או "לא" (למשל, <span class="math">\(A\left[i\right]<A\left[j\right]\)</span> עבור <span class="math">\(i,j\)</span> מסוימים), ואילו העלים מסומנים על ידי פלטים אפשריים כלשהם. "חישוב" בעץ החלטה על קלט מסויים פועל כך: הוא מתחיל מהשורש, בודק את פריט המידע שמסומן בשורש, אם התשובה היא "כן" הוא הולך אל הבן הימני, ואם התשובה היא "לא" הוא הולך אל הבן השמאלי. כעת, אם הבן הוא עלה האלגוריתם פולט את הערך שכתוב בו; אחרת, האלגוריתם מבצע עוד בדיקה על בסיס הערך שכתוב בתוך הבן, ובוחר בן על פי התוצאה, וכן הלאה עד אשר מגיעים לעלים. כפי שאתם רואים, הרעיון פשוט עד אימה (או לחילופין, סתם מטיל אימה). הנקודה היא ש<strong>כל</strong> אלגוריתם מיון כללי אכן ניתן לתאר באמצעות עץ החלטה שכזה, שבו פריטי המידע שבצמתים הם בדיוק השוואות בין זוג איברים ברשימה (כלומר, כל צומת מתאים לשאלה האם <span class="math">\(A\left[i\right]<A\left[j\right]\)</span> עבור <span class="math">\(i,j\)</span> מסויימים).</p>
<p>עכשיו, זמן הריצה של האלגוריתם חסום מלמטה על ידי עומק עץ ההחלטה (כי עומק עץ ההחלטה הוא בעצם "מספר ההשוואות המקסימלי שהאלגוריתם יבצע על קלט כלשהו"). נשאלת השאלה, אם כן, מה העומק המינימלי שיכול להיות בכלל לעץ החלטה שמתאים למיון קלט מגודל <span class="math">\(n\)</span>? כדי לענות על זה צריך להבין כמה <strong>פלטים</strong> אפשריים צריכים להיות לעץ. פלט של אלגוריתם מיון הוא בעצם פרמוטציה של הקלט; לכל אינדקס ברשימה המקורית מותאם האינדקס של המקום החדש שאליו האיבר מועבר ברשימה החדשה. אם הרשימה היא מגודל <span class="math">\(n\)</span>, יש <span class="math">\(n!\)</span> פרמוטציות (<span class="math">\(n!\)</span> הוא סימון מקוצר ל-<span class="math">\(1\cdot2\cdot3\cdots n\)</span>; הסיבה שיש <span class="math">\(n!\)</span> פרמוטציות מוסברת <a href="http://www.gadial.net/2010/06/20/combinatorics_intro/">בפוסט שלי</a> על קומבינטוריקה בסיסית).</p>
<p>לא קשה להוכיח שהעץ הבינארי בעל העומק הקטן ביותר יחסית למספר הצמתים הוא עץ בינארי מלא - עץ שבו לכל צומת יש שני בנים עד לשכבה כלשהי שבה נמצאים כל העלים. אם עומק העץ הזה הוא <span class="math">\(k\)</span>, אז יש לו (חשבו!) בדיוק <span class="math">\(2^{k}\)</span> עלים. מכיוון שבעץ ההחלטה עבור מיון צריכים להיות <span class="math">\(n!\)</span> עלים לפחות, אז צריך להתקיים <span class="math">\(2^{k}\ge n!\)</span>, כלומר <span class="math">\(k\ge\lg n!\)</span>. זה מסיים את זה, בתנאי שאתם מאמינים לי ש-<span class="math">\(\lg n!=\Omega\left(n\log n\right)\)</span>.</p>
<p>אם אתם לא מאמינים, בואו נראה את זה. כמו תמיד, זה הופך להיות תרגיל נחמד בסכומים, שהוא כבר מתמטי טהור ולא קשור למדעי המחשב. ראשית כל, ללוגריתם יש את התכונה הנפלאה שהוא הופך מכפלה לחיבור, כלומר <span class="math">\(\log\left(a\cdot b\right)=\log a+\log b\)</span>. זה היה הרעיון הבסיסי שמאחורי <strong>סרגלי החישוב</strong> - עזרי חישוב מכניים נפלאים ויפהפיים שהפכו למיותרים לחלוטין עם המצאת המחשב, אבל זה לא גורע ממגניבותם. אני מקווה לכתוב על כך פוסט ביום מן הימים.</p>
<p>חזרה לענייננו. אם נשתמש בתכונה שלעיל, נהפוך את המכפלה לסכום: <span class="math">\(\lg\left(n!\right)=\lg\left(\prod_{k=1}^{n}k\right)=\sum_{k=1}^{n}\lg k\)</span> (הסימן <span class="math">\(\Pi\)</span> פשוט בא לתאר מכפלה בצורה מקוצרת, כשם ש-<span class="math">\(\Sigma\)</span> בא לתאר סכום מקוצר). עכשיו, מפתה לומר ש-<span class="math">\(\lg k<\lg n\)</span> לכל <span class="math">\(1\le k\le n\)</span> ולכן <span class="math">\(\sum_{k=1}^{n}\lg k\le\sum_{k=1}^{n}\lg n=n\lg n\)</span> ולכן סיימנו, אבל רגע! זה בכלל לא מה שאנחנו רוצים לעשות! אנחנו רוצים חסם <strong>תחתון</strong> על הסכום, לא חסם עליון! הבלבול הקטן והמטופש הזה נפוץ בצורה יוצאת מן הכלל (וגם אני לוקה בו לעתים קרובות). אם כן, צריך משהו מחוכם קצת יותר; מה הוא יהיה? תעלול די סטנדרטי: לחלק את הסכום לשני חלקים.</p>
<p>אם כן, <span class="math">\(\sum_{k=1}^{n}\lg k\ge\sum_{k=\left\lceil \frac{n}{2}\right\rceil }^{n}\lg k\)</span> - כאן זרקתי את כל החצי הראשון של האיברים בסכום, כי הם לא גדולים במיוחד אז למי אכפת מהם. כעת אני יודע שהאיבר הקטן ביותר בסכום הוא <span class="math">\(\lg\left\lceil \frac{n}{2}\right\rceil \)</span>, ויש בסכום <span class="math">\(\left\lfloor \frac{n}{2}\right\rfloor \)</span> איברים, ולכן <span class="math">\(\sum_{k=1}^{n}\lg k\ge\left\lfloor \frac{n}{2}\right\rfloor \lg\left\lceil \frac{n}{2}\right\rceil \ge\left\lfloor \frac{n}{2}\right\rfloor \lg n-2\left\lfloor \frac{n}{2}\right\rfloor =\Omega\left(n\log n\right)\)</span>. זה מסיים את העניין סופית.</p>
<p>אם לסכם, הטיעון הוא "אם לא ביצעת סדר גודל של <span class="math">\(n\log n\)</span> השוואות, לא קיבלת מספיק אינפורמציה על הקלט כדי להיות מסוגל להכריע בודאות איך למיין אותו. שימו לב שאף פעם לא צריך את <strong>כל</strong> האינפורמציה, כלומר את כל <span class="math">\({n \choose 2}\)</span> ההשוואות של איברים, מה שהיה מסדר גודל של <span class="math">\(\Theta\left(n^{2}\right)\)</span>; הרי אפשר להסיק אינפורמציה נוספת מתוך מה שקראנו ישירות מהקלט. כך למשל אם גילינו ש-<span class="math">\(A\left[i\right]<A\left[j\right]\)</span> ו-<span class="math">\(A\left[j\right]<A\left[k\right]\)</span> אז אפשר להסיק ש-<span class="math">\(A\left[i\right]<A\left[k\right]\)</span> (זוהי ה<strong>טרנזיטיביות</strong> של יחס הסדר). מיון מהיר משתמש בתכונה הזו בצורה מאוד מפורשת - כל ההשוואות הן תמיד ל"איבר ציר" מתוך הנחה שאם יש לנו שני איברים כך שהראשון קטן מאיבר הציר והשני גדול ממנו, אז האיבר הראשון קטן מהשני. מיון מיזוג ומיון ערימה משתמשים בהנחה הזו באופן קצת יותר מעודכן, וזה תרגיל נחמד לבדוק איפה היא בדיוק צצה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>