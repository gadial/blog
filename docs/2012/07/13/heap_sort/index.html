<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>איך להערים על מיון ערימה - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2012/07/13/heap_sort/">
    <meta property="og:title" content="איך להערים על מיון ערימה">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2012/07/13/heap_sort/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="איך להערים על מיון ערימה">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <a href="/lecture_notes.html">סיכומי הרצאות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2012/07/11/help_me_latex_people/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">בקשת עזרה מקהילת הקוד הפתוח בכלל ומכל מי שמבין משהו ב-LaTeX בפרט</span>
            </a>
            

            
            <a href="/2012/07/20/quick_quicksort/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">עיון בהיר במיון מהיר</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>איך להערים על מיון ערימה</h1>
            <div class="post-meta">
                <span class="date">2012-07-13</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/מבני נתונים ואלגוריתמים.html">מבני נתונים ואלגוריתמים</a>
                    
                    <a href="/categories/תכנות.html">תכנות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/טור חזקות.html">טור חזקות</a>
                    
                    <a href="/tags/מיון ערימה.html">מיון ערימה</a>
                    
                    <a href="/tags/מיונים.html">מיונים</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסט הקודם, שאני מניח שקראתם ואם לא מומלץ שתעשו זאת לפני הפוסט הנוכחי, דיברתי על אלגוריתמי מיון בסיסיים. שלושת הבסיסיים - מיון בחירה, מיון הכנסה ומיון בועות - היו איטיים למדי; זמן ריצתם היה <span class="math">\(\Theta\left(n^{2}\right)\)</span> כאשר <span class="math">\(n\)</span> הוא אורך הרשימה שאותה רוצים למיין. מבין השלושה זה שמשיג את הביצועים הטובים ביותר הוא מיון הכנסה, שלא <strong>חייב</strong> לרוץ זמן של בערך <span class="math">\(n^{2}\)</span> תמיד; זה תלוי עד כמה הרשימה שהוא פועל עליה כבר ממויינת (לעומת זאת, עבור מיון בחירה ומיון בועות בכלל הרבה פחות משנה איך הרשימה נראית - הם עדיין יבצעו המון פעולות בהכרח).</p>
<p>ראינו גם את מיון מיזוג, שכבר הציע שיפור משמעותי בזמן הריצה - <span class="math">\(\Theta\left(n\log n\right)\)</span>. ה"בעיה" במיון מיזוג הייתה שהוא לא ביצע מיון <strong>במקום</strong>, כלומר ללא שימוש בזכרון נוסף; במימוש שלנו של פעולת ה"מיזוג" השתמשנו ברשימת עזר שגודלה כגודל הרשימה שאותה מיזגנו. אמנם, אפשר להסתדר גם בלי זה, אבל במחיר מיזוג מסובך יותר ותובעני יותר מבחינת כמות הפעולות שהוא דורש. אני רוצה להציג עכשיו אלגוריתם מיון שמבצע את המיון במקום, וזמן הריצה שלו הוא <span class="math">\(\Theta\left(n\log n\right)\)</span>. למיון הזה קוראים <strong>מיון ערימה</strong>.</p>
<p>מיון ערימה הוא מעין הכללה של מיון בחירה ומיון בועות. בואו נתחיל מלהבין את הבעיות של המיונים הללו ואיך אפשר להתגבר עליהן. מיון בחירה, כזכור, היה אלגוריתם פשוט ביותר מבחינה רעיונית: "מצא את המקסימום ברשימה, העבר אותו לסוף הרשימה; עכשיו שכח מהאיבר האחרון ברשימה ופעל באותו האופן על תת-הרשימה שכוללת את כל האיברים פרט לאחרון, וכו' וכו'". הבזבזנות של האלגוריתם מתבטאת בכך שבכל איטרציה אנחנו מחפשים את המקסימום ברשימה, וקרוב לודאי שחוזרים על השוואות שכבר ביצענו בעבר. השאלה היא אם אין דרך כלשהי לחסוך את הזמן שמציאת המקסימום דורשת.</p>
<p>באופן כללי, התשובה היא "לא". אם יש לנו רשימה מאורך <span class="math">\(n\)</span>, אז כדי למצוא את המקסימום בה אנחנו חייבים לעבור על כל <span class="math">\(n\)</span> האיברים. אבל כאן מדובר על סיטואציה מורכבת יותר: מדובר על רשימה שאנחנו עומדים לקרוא שוב ושוב, כשבין כל שתי קריאות אנחנו מבצעים בה שינוי קטן - סילוק של איבר אחד מתוכה. האם ניתן לבצע עיבוד כלשהו לרשימה שיאפשר לפעולת "מציאת מקסימום" להתבצע במהירות גדולה יותר?</p>
<p>הרי לנו דוגמה קלאסית לבעיה שמצריכה <strong>מבנה נתונים</strong>. מבנה נתונים הוא דרך ייצוג כלשהי של מידע שמאפשרת לפעולות מסוימות להתבצע באופן יעיל. בדרך כלל עלינו <strong>ליצור</strong> את מבנה הנתונים בצורה כלשהי, אולי על בסיס נתונים קיימים, וזה דורש זמן כלשהו של <strong>עיבוד מקדים</strong>; אולם מרגע שמבנה הנתונים כבר קיים, התקווה היא שביצוע פעולות עליו ידרוש זמן קצר יחסית.</p>
<p>במקרה שלנו, מבנה הנתונים צריך לתמוך בשתי פעולות שאותן הוא יבצע במהירות: הוא צריך לאפשר <strong>מציאת מקסימום</strong> יעילה, והוא צריך לאפשר <strong>הוצאת מקסימום</strong> יעילה (דהיינו, הוצאה של איבר מתוך המבנה; אבל אנחנו מסתפקים במקרה הפרטי שבו האיבר הזה הוא במקרה גם המקסימום, ולכן אולי יהיה יותר פשוט להוציא אותו מאשר להוציא איבר כללי). יש מבנה נתונים פשוט מאוד שתומך בפעולות הללו - <strong>ערימה</strong> (ובאנגלית Heap; אין קשר ל-Heap שאליו מתייחסים בתכנות בתור מקום שזכרון מוקצה מתוכו).</p>
<p>מה שאנו עומדים לראות הוא שניתן לבנות ערימה מתוך רשימה של <span class="math">\(n\)</span> איברים בזמן <span class="math">\(\Theta\left(n\right)\)</span>(ליתר דיוק, אנחנו הופכים את הרשימה לערימה), ולאחר מכן ניתן לבצע פעולה של מציאת מקסימום בזמן <span class="math">\(\Theta\left(1\right)\)</span> ושל הוצאת מקסימום בזמן <span class="math">\(\Theta\left(\log n\right)\)</span>. מכאן בבירור זמן הריצה של האלגוריתם יהיה <span class="math">\(\Theta\left(n\log n\right)\)</span>, שכן הוא יכלול קודם כל את בניית הערימה, ולאחר מכן <span class="math">\(n\)</span> איטרציות שבכל אחת מהן נמצא ונוציא את המקסימום.</p>
<p>ובכן, איך נממש ערימה? ברור שאם יש לנו רשימה שהיא <strong>כבר ממויינת</strong>, אז היא יכולה לתפקד בתור ערימה מצוינת: כדי למצוא את המקסימום פשוט נחזיר את האיבר האחרון, וכדי להוציא את המקסימום פשוט נוציא את האיבר האחרון (ונסמן שאורך הרשימה קטן ב-1 אם יש בכך צורך). טוב ויפה, אבל אם הרשימה כבר ממויינת אז כל הדיון מיותר, וגם לא ברור איך אפשר (אם בכלל) לבנות מתוך רשימה כללית של <span class="math">\(n\)</span> איברים רשימה ממויינת בזמן <span class="math">\(\Theta\left(n\right)\)</span>. אז כדאי להקל קצת את הדרישות.</p>
<p>הדרישה מרשימה ממויינת היא זו: האיבר הגדול ביותר הוא בסוף. לפניו נמצא האיבר השני בגודלו, ולפניו האיבר השלישי בגודלו וכן הלאה. ערימה מקלה את הדרישה הזו קצת. במקום לחשוב על הרשימה בתור "קו ישר" של איברים, אנחנו חושבים עליה בתור <strong>עץ בינארי</strong>. עץ בינארי נראה כמו עץ משפחה - יש לו "צמתים" שמייצגים איברים ברשימה, ולכל צומת יכולים להיות עד שני בנים (זה פירוש ה"בינארי" שבשם - עד שני בנים) , שהם בעצמם צמתים, כך שלכל צומת יש לכל היותר אב יחיד. אם אנחנו נמצאים בצומת כלשהו אנחנו יכולים "לטייל" אל אחד מהבנים שלו, ומשם אל אחד מהבנים של הבן, וכן הלאה; נקבל כך מסלול בתוך העץ. הדרישה מערימה היא שכל מסלול כזה יהיה ממוין לפי הגודל (מהגדול ביותר לקטן ביותר). לא קשה לראות שזה שקול לדרישה "כל צומת גדול מכל בניו", שתיקרא <strong>תכונת הערימה</strong>.</p>
<p>תמונה אחת שווה אלף מילים. הנה ערימה, הן בייצוג שלה בתור רשימה, והן בייצוג שלה בתור עץ בינארי:</p>
<p><a href="/img/2012/07/heap2.png"><img class="alignnone size-full wp-image-2101" title="heap" src="/img/2012/07/heap2.png" alt="" width="603" height="513" /></a></p>
<p>&nbsp;</p>
<p>כפי שאתם רואים, אין צורך לתחזק מבנה של עץ בתוך המחשב עצמו; אפשר להסתפק לצורך כך ברשימה, עם המוסכמה לפיה הבנים של התא מספר <span class="math">\(k\)</span> הם בדיוק התאים מספר <span class="math">\(2k+1\)</span> ו-<span class="math">\(2k+2\)</span>, ושהצומת בראש העץ (ה<strong>שורש</strong> של העץ) הוא תא מספר 0 (ולכן הבנים שלו הם תאים 1 ו-2; והבנים של תא 1 הם תאים 3 ו-4 בעוד שהבנים של תא 2 הם תאים 5 ו-6, וכן הלאה). כאן אנחנו קצת מגבילים את עצמנו בכך שאנחנו דורשים שהעץ יהיה בנוי מ"שכבות" שבהן יש את כל הצמתים האפשריים למעט בשכבה האחרונה, של הצמתים שאין להם בנים כלל (צמתים כאלו נקראים <strong>עלים</strong>) ובשכבה הזו נמצאים כל הצמתים עד למקום מסויים ושם הם מפסיקים. לעץ כזה קוראים "עץ בינארי כמעט מלא" (עץ מלא הוא עץ שבו כל השכבות מלאות). המבנה הפשוט הזה של העץ הוא שמאפשר לאחסן אותו כל כך בקלות בתוך רשימה; ייצוג עצים כלליים הוא מטלה קשה בהרבה.</p>
<p>טוב, אז מה זו ערימה - הבנו. איך היא מיוצגת על ידי רשימה - הבנו. מה הלאה?</p>
<p>מציאת האיבר המקסימלי בערימה היא טריוויאלית - זה חייב להיות האיבר שבשורש. שהרי אם המקסימום אינו בשורש, יש לו אבא; ומכיוון שהאבא חייב להיות גדול לפחות כמו הבן, והבן הוא המקסימלי, אז או שהגענו לסתירה (מה שיקרה בהכרח אם אין שני איברים ברשימה שהם מאותו הגודל), או שהאבא שווה בגודלו לבן ואז אפשר לחזור על אותו שיקול לגבי האבא, עד שנגיע לכך שגם השורש עצמו חייב להיות שווה לאיבר המקסימלי.</p>
<p>אם כן, למצוא את המקסימום זה קל. אבל איך אפשר, אחרי שהוצאנו את המקסימום מהערימה, "לתקן" אותה כך שהיא עדיין תהיה ערימה תקנית?</p>
<p>ראשית, מכיוון שערימה חייבת להיות עץ בינארי כמעט מלא, אנחנו לא יכולים סתם להעלים את הצומת של האבא; מה שנעשה יהיה <strong>להחליף</strong> אותו עם הבן הימני ביותר בשכבה התחתונה, ואז להקטין את הגודל של הערימה ב-1 (מה שגורם לנו "לא לראות יותר" את הצומת של המקסימום, בדיוק כמו שעושים במיון בחירה).</p>
<p>אחרי החלפה שכזו, העץ עשוי לאבד את תכונת הערימה, כי הצומת שבשורש עשוי להיות קטן מאחד מבניו. אז מה עושים? כמו במיון בועות, "מפעפעים" אותו למטה. משווים אותו לבנים שלו, ואם אחד מהם גדול ממנו, מחליפים ביניהם (אם שניהם גדולים ממנו אז מחליפים בינו לבין הגדול מביניהם), ואז חוזרים על הפעולה עבור תת-העץ שבו היה הבן קודם. באופן הזה מובטח לנו שכאשר התהליך הסתיים, העץ יקיים שוב את תכונת הערימה (ולכן בפרט השורש יכיל את המקסימום החדש). לפעולה הזו - ה"פעפוע" למטה של הצומת שמפר את תכונת הערימה - אקרא heapify (אל תהיו רעים אלי, זה מה ש-CLRS משתמשים בו).</p>
<p>הנה הקוד:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">heapify</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">heapsize</span><span class="p">)</span>
<span class="w">  </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span>
<span class="w">  </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="c1">#left son</span>
<span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="w"> </span><span class="c1">#right son</span>
<span class="w">  </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">heapsize</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">max</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">r</span><span class="o">]</span>
<span class="w">  </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">heapsize</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">max</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">l</span><span class="o">]</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span>
<span class="w">  </span><span class="n">list</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">max</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="n">heapify</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">,</span><span class="w"> </span><span class="n">heapsize</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>


</div>

<p>הקוד די מסביר את עצמו (אני מקוה). רק שימו לב לבדיקות אם r &lt; heapsize ו-l &lt; heapsize שמטרתן למנוע מאיתנו לגלוש אל מעבר לקצה הערימה (מה שעשוי להיות מסוכן כי האיזור הזה לא בהכרח ריק או מכיל ג'יבריש; הוא יהיה עשוי להכיל איברים שכבר מיינו) ולקריאה הרקורסיבית בסוף של heapify.</p>
<p>היתרון האדיר שנותן לנו מעבר לחשיבה על הקלט בתור עץ במקום הישארות עם רשימה הוא שתהליך הפעפוע הזה לא יכול לקחת הרבה זמן; הוא בהכרח ידרוש לכל היותר <span class="math">\(\log n\)</span> צעדים. למה? כי עומק של עץ בינארי כמעט מלא עם <span class="math">\(n\)</span> צמתים הוא <span class="math">\(\log n\)</span>. אסביר זאת בפירוט בהמשך. לעת עתה, בואו נטפל בשאלה האחרונה שנותרה פתוחה: איך בכלל בונים ערימה מתוך רשימה לא מסודרת?</p>
<p>התשובה פשוטה. ראשית כל, אפשר לחשוב גם על רשימה מבולגנת בתור עץ בינארי כמעט מלא, פשוט כזה שלא מקיים בהכרח את תכונת הערימה. אז בואו פשוט נתחיל לתקן אותו. מה שכבר ראינו הוא ש-heapify מקבלת צומת n, ועושה הוקוס-פוקוס שמקיים את התנאי הבא: אם תת-העץ ששורשו n הוא ערימה תקנית פרט אולי לכך ש-n מפר את תכונת הערימה, אז אחרי הפעלת heapify תת-העץ כולו יקיים את תכונת הערימה.</p>
<p>אם כן, אם יש לנו כרגע עץ שהוא בלאגן אחד גדול, להפעיל את heapify על השורש שלו לא הולך ליצור לנו ערימה מתוך העץ (כי העץ עשוי להפר את תכונת הערימה במקומות רבים ולא רק בשורש). לכן נטפל בעץ "מלמטה למעלה". אנחנו יודעים שתת-העץ של כל עלה הוא מן הסתם רשימה חוקית (כי הוא מכיל רק צומת בודד), אז בואו נעבור על כל הצמתים מהרמה הלפני-אחרונה והלאה, ולכל אחד מהם נריץ את heapify על תת-העץ שלו:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_heap</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">list</span><span class="o">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">downto</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">heapify</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>


</div>

<p>אני מציג כאן סגנון כתיבה סטנדרטי ברובי שהוא קצת חריג למי שלא מכיר את השפה. הנה דרך אחרת לכתוב את אותו הדבר בדיוק:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_heap</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="n">length</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">heapify</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


</div>

<p>כלומר, תפקיד הסוגריים המסולסלות כאן הוא בסך הכל להכניס את הכל לאותה השורה, מה שאפקטיבי כאשר מריצים פקודות בנות שורה אחת.</p>
<p>שימו לב שהקוד שלי טיפה בזבזני כי אני עובר על <strong>כל</strong> הצמתים ברשימה, כולל העלים. אפשר היה להתחיל גם מהחצי.</p>
<p>מה זמן הריצה של make_heap? בבירור הוא <span class="math">\(O\left(n\log n\right)\)</span>: אני עובר על כל הצמתים ברשימה, כלומר <span class="math">\(n\)</span>, ולכל אחד אני מריץ את heapify שזמן הריצה שלו הוא <span class="math">\(O\left(\log n\right)\)</span>. עם זאת, ניתוח קצת יותר זהיר של מה שהולך כאן שאציג בהמשך מראה שזמן הריצה הוא בעצם <span class="math">\(\Theta\left(n\right)\)</span>. הסיבה לכך היא ש-heapify דורש פחות זמן ריצה כשהוא מורץ על צמתים נמוכים יותר, ואין כל כך הרבה צמתים גבוהים בעץ. נחזור לכך אחר כך.</p>
<p>כעת אפשר סוף סוף להציג את הקוד של מיון ערימה. כצפוי, אין הבדל מהותי בינו לבין הקוד של מיון בחירה:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">heapsort</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
<span class="w">  </span><span class="n">make_heap</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="n">list</span><span class="o">.</span><span class="n">length</span>
<span class="w">    </span><span class="n">list</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">list</span><span class="o">.</span><span class="n">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="n">heapify</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="n">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="k">end</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">list</span>
<span class="k">end</span>
</code></pre></div>


</div>

<p>בהתחלה יוצרים ערימה. בכל איטרציה מעבירים את האיבר שב-0 (המקסימלי) לסוף, מקטינים ב-1 את גודל הערימה, ומתקנים את מה שקלקלנו עם heapify. לטעמי זה אלגוריתם פשוט, אלגנטי ונחמד.</p>
<p>עכשיו בואו נעבור לניתוחים המתמטיים. ראשית כל אנחנו צריכים להבין עובדות בסיסיות על עצים בינאריים. נפתח בהגדרה: ה<strong>גובה</strong> של עץ בינארי הוא אורך המסלול הארוך ביותר בו, כאשר "מסלול" הוא פשוט סדרה של צמתים כך שכל אחד מהם הוא אביו של זה שבא אחריו. אפשר למדוד אורך של מסלול או על ידי מספר הצמתים הכולל בו, או על ידי מספר <strong>הצעדים</strong> שאנו מבצעים בו, כלומר מספר הצמתים במסלול פחות 1 (ולכן מסלול שמכיל רק צומת אחד - כלומר, כזה שבו אנו "נשארים במקום", הוא מאורך 0). אני מעדיף את ההגדרה השניה ולכן בה אשתמש.</p>
<p>כעת, עץ בינארי כמעט מלא שגובהו <span class="math">\(h\)</span> מכיל בדיוק <span class="math">\(h+1\)</span> שכבות, שכולן מלאות למעט אולי האחרונה. כמה צמתים יש בכל שכבה?</p>
<p>בשכבה מס' 0 יש רק צומת יחיד - השורש. בשכבה מס' 1 יש שני צמתים - הבנים של השורש. בשכבה מס' 2 יש 4 צמתים - הבנים של הבנים של השורש, וכן הלאה. בכל שכבה יש לכל היותר פי 2 צמתים מאשר בשכבה הקודמת, שכן לכל צומת בשכבה הקודמת יש לכל היותר 2 בנים. מכאן שקל מאוד לקבל חסם עליון על מספר הצמתים בעץ בינארי כמעט מלא מעומק <span class="math">\(h\)</span>:</p>
<p><span class="math">\(1+2+4+\dots+2^{h}=2^{h+1}-1\)</span></p>
<p>השוויון הזה הוא פשוט הנוסחה הרגילה לטור הנדסי מתכנס (ומי שלא מאמין - שיכפול את אגף שמאל ב-<span class="math">\(\left(2-1\right)\)</span> ויראה מה קורה).</p>
<p>מצד שני, אם העץ הוא מעומק <span class="math">\(h\)</span>, אז כל השכבות עד לשכבה ה-<span class="math">\(h\)</span> ולא כולל חייבות להיות מלאות, ולכן יש בעץ לפחות <span class="math">\(1+2+\dots+2^{h-1}=2^{h}-1\)</span> צמתים.</p>
<p>קיבלנו שמתקיים, עבור עץ בינארי כמעט מלא עם <span class="math">\(n\)</span> צמתים, הקשר הבא: <span class="math">\(2^{h}-1\le n\le2^{h+1}-1\)</span>, כלומר <span class="math">\(\lg\left(2^{h}\right)\le\lg\left(n+1\right)\le\lg\left(2^{h+1}\right)\)</span>, כלומר <span class="math">\(h\le\lg\left(n+1\right)\le h+1\)</span>. מכאן ש-<span class="math">\(h=\Theta\left(\log n\right)\)</span>. עכשיו רק נותר לשים לב לכך ש-heapify קורא לעצמו רקורסיבית לכל היותר <span class="math">\(h\)</span> פעמים (כי בכל קריאה רקורסיבית הוא יורד רמה אחת בעץ) וקיבלנו שזמן הריצה של heapify הוא <span class="math">\(O\left(\log n\right)\)</span> (זה לא <span class="math">\(\Theta\)</span> כי הוא עשוי לעצור מייד, תלוי בנסיבות). מכאן נובע מייד שזמן הריצה של make_heap הוא <span class="math">\(O\left(n\log n\right)\)</span> ושזמן הריצה של heapsort הוא גם כן <span class="math">\(O\left(n\log n\right)\)</span>. לכן ההוכחה האחרונה, שזמן הריצה של make_heap הוא <span class="math">\(O\left(n\right)\)</span>, עשויה להיראות טיפה מיותרת. היא לא, משתי סיבות: ראשית, כי משתמשים בערימות לעוד דברים חוץ מאשר מיון (למשל, תור עדיפויות). שנית, כי זו הוכחה מגניבה.</p>
<p>אז ההוכחה הולכת כך: זמן הריצה של make_heap הוא סכום זמני הריצה של heapify על כל הצמתים בגרף. זמן הריצה של heapify על צומת שגובהו <span class="math">\(t\)</span> הוא <span class="math">\(O\left(t\right)\)</span>. אם כן, כמה צמתים יש בגרף שגובהם <span class="math">\(t\)</span>?</p>
<p>יש צומת אחת בגובה <span class="math">\(h\)</span> - השורש. שני צמתים בגובה <span class="math">\(h-1\)</span> (הבנים). ארבעה בגובה <span class="math">\(h-2\)</span> וכן הלאה. אם כן, באופן כללי, ישנם <span class="math">\(2^{k}\)</span> צמתים בגובה <span class="math">\(h-k\)</span>, וזאת עד <span class="math">\(k=h\)</span> שבו יש לנו לכל היותר <span class="math">\(2^{h}\)</span> צמתים (נניח שיש בדיוק, זה רק מגדיל את זמן הריצה). קיבלנו שזמן הריצה הכולל של make_heap על עץ בינארי כמעט מלא מגובה <span class="math">\(h\)</span>, שנסמן <span class="math">\(T\left(h\right)\)</span>, הוא:</p>
<p><span class="math">\(T\left(h\right)=\sum_{k=0}^{h}2^{k}\cdot O\left(h-k\right)\)</span></p>
<p>כלומר, אם לכתוב במפורש, קיים <span class="math">\(c\)</span> כך ש-<span class="math">\(T\left(h\right)\le c\cdot\sum_{k=0}^{h}2^{k}\left(h-k\right)\)</span>, לכל <span class="math">\(h\)</span> גדול דיו. זה מזמין החלפת משתנה: <span class="math">\(t=h-k\)</span>. נקבל:</p>
<p><span class="math">\(T\left(h\right)\le c\cdot\sum_{t=0}^{h}2^{h-t}t=c\cdot2^{h}\cdot\sum_{t=0}^{h}\frac{t}{2^{t}}\le c\cdot2^{h}\cdot\sum_{t=0}^{\infty}\frac{t}{2^{t}}\)</span></p>
<p>למה עברתי ל-<span class="math">\(\sum_{t=0}^{\infty}\frac{t}{2^{t}}\)</span> בסוף? כי זה טור מוכר מאוד, יחסית. הוא נראה <strong>כמעט</strong> כמו טור הנדסי, למעט זה שהוא גם מוכפל ב-<span class="math">\(t\)</span>. הנה הדרך הסטנדרטית לטפל בו, למי שצריך להתחיל מאפס ולא זוכר כלום על טורים מהצורה הזו, אבל <strong>כן</strong> בעל ידע בסיסי בחשבון אינפיניטסימלי (ברמה של טורי פונקציות): ראשית, נחשוב על הטור כעל פונקציה במשתנה <span class="math">\(x\)</span> שנראית כך: <span class="math">\(f\left(x\right)=\sum_{t=0}^{\infty}t\cdot x^{t}\)</span> (והטור מתקבל על ידי הצבת <span class="math">\(x=2^{-1}\)</span>). זו דוגמה נאה לפונקציה שמוגדרת על ידי <strong>טור חזקות</strong>, מה שאומר שאפשר לעשות לה כל מני דברים נחמדים - למשל, אינטגרציה איבר-איבר. לרוע המזל, זה לא עובד כמו שצריך, כי <span class="math">\(\int x^{t}=\frac{x^{t+1}}{t+1}\)</span> והיינו רוצים שיהיה <span class="math">\(t\)</span> במכנה, אז מה שנעשה יהיה להוציא <span class="math">\(x\)</span> משני האגפים: <span class="math">\(\frac{f\left(x\right)}{x}=\sum_{t=0}^{\infty}tx^{t-1}\)</span>. אינטגרציה לאגף שמאל נותנת לנו כעת <span class="math">\(\sum_{t=0}^{\infty}x^{t}=\frac{1}{1-x}\)</span> (הנוסחה האחרונה היא הנוסחה לטור הנדסי; אם אתם לא מאמינים, כפלו את אגף שמאל ב-<span class="math">\(1-x\)</span> ותראו מה אתם מקבלים).</p>
<p>אם כן, קיבלנו ש-<span class="math">\(f\left(x\right)=x\cdot\left(\frac{1}{1-x}\right)^{\prime}=\frac{x}{\left(1-x\right)^{2}}\)</span>. סכום הטור, כזכור, הוא <span class="math">\(f\left(\frac{1}{2}\right)\)</span> ולכן קיבלנו <span class="math">\(\sum_{t=0}^{\infty}\frac{t}{2^{t}}=\frac{1/2}{\left(1-1/2\right)^{2}}=\frac{1/2}{1/4}=2\)</span>. המסקנה: <span class="math">\(T\left(h\right)\le2^{h}\cdot2=O\left(n\right)\)</span>, כנדרש.</p>
<p>אני אוהב את ההוכחה הזו משתי סיבות. ראשית, העובדה שניתוח קצת יותר זהיר מהניתוח הפשטני של make_heap נותן לנו חסם עדיף אסימפטוטית מעידה יפה, כבר בשלב מוקדם זה של דיונים על אלגוריתמים, עד כמה העניינים הללו עשויים להיות עדינים לפעמים. שנית, אנחנו רואים כאן היטב איך ידע בסיסי במתמטיקה הוא הכרחי כדי לטפל בצורה נכונה בניתוחי הסיבוכיות של אלגוריתמים שכאלו. בפוסט הבא, שבו נדבר על מיון מהיר, העניינים הללו יודגשו אף יותר.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>