<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט Valiant-Vazirani, או: איך להרוג השמות מספקות עם פונקציות תמצות אקראיות - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2012/05/11/valiant-vazirani/">
    <meta property="og:title" content="משפט Valiant-Vazirani, או: איך להרוג השמות מספקות עם פונקציות תמצות אקראיות">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2012/05/11/valiant-vazirani/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="משפט Valiant-Vazirani, או: איך להרוג השמות מספקות עם פונקציות תמצות אקראיות">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2012/04/29/inner_product_space_adjoint/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">מרחבי מכפלה פנימית - לפעמים הצמדה היא באמת הצמדה</span>
            </a>
            

            
            <a href="/2012/05/14/bible_jump_1/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">אז מה הקטע עם דילוגי אותיות בתורה? (חלק א&#39;)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט Valiant-Vazirani, או: איך להרוג השמות מספקות עם פונקציות תמצות אקראיות</h1>
            <div class="post-meta">
                <span class="date">2012-05-11</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/SAT.html">SAT</a>
                    
                    <a href="/tags/הסתברות.html">הסתברות</a>
                    
                    <a href="/tags/עקרון ההכלה וההפרדה.html">עקרון ההכלה וההפרדה</a>
                    
                    <a href="/tags/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>מזמן לא היה פה פוסט על סיבוכיות ומתחשק לי. מה שאני רוצה לדבר עליו הפעם הוא תוצאה מפתיעה יחסית (אם כי לא מפתיעה מספיק כדי להכנס לפנתאון של <a href="http://www.gadial.net/?tag=%D7%A4%D7%A8%D7%95%D7%99%D7%99%D7%A7%D7%98-%D7%AA%D7%95%D7%A6%D7%90%D7%95%D7%AA-%D7%9E%D7%A4%D7%AA%D7%99%D7%A2%D7%95%D7%AA-%D7%91%D7%A1%D7%99%D7%91%D7%95%D7%9B%D7%99%D7%95%D7%AA">"תוצאות מפתיעות בסיבוכיות"</a>) של Valiant ו-Vazirani שיש בה את כל מה שטוב בסיבוכיות - גם תוצאה מפתיעה, גם הוכחה אלגנטית ויפה, וגם רעיון שאחר כך אפשר להרחיב אותו עוד יותר לתוצאה שהיא <strong>ממש </strong>מפתיעה (משפט Toda, שאני מקווה להגיע גם אליו מתישהו). אבל לפני שנגיע לאקשן, רקע.</p>
<p>אולי הבעיה הקונקרטית המפורסמת ביותר בתורת הסיבוכיות היא SAT. בבעיה הזו נתון לנו פסוק לוגי בצורת CNF, כלומר הוא נראה כך: <span class="math">\(C_{1}\wedge C_{2}\wedge\dots\wedge C_{k}\)</span>, כך שכל <span class="math">\(C_{i}\)</span> נראה כך: <span class="math">\(\left(l_{1}\vee l_{2}\vee\dots\vee l_{r}\right)\)</span>, כך שכל <span class="math">\(l_{j}\)</span> הוא או משתנה <span class="math">\(x\)</span> או שלילה של משתנה, <span class="math">\(\neg x\)</span>. ל-<span class="math">\(l\)</span> כזה קוראים "ליטרל", ל-<span class="math">\(C\)</span> כזה קוראים "פסוקית CNF'', והשאלה היא זו: האם יש השמה למשתנים של הפסוק <span class="math">\(\varphi\)</span> שמספקת אותו? השמה נותנת לכל משתנה ערך <span class="math">\(\text{T}\)</span> או <span class="math">\(\text{F}\)</span> (אמת או שקר). אם הליטרל <span class="math">\(l\)</span> הוא מהצורה <span class="math">\(x\)</span> הוא מקבל את הערך של <span class="math">\(x\)</span> ואם הוא מהצורה <span class="math">\(\neg x\)</span> הוא מקבל את הערך ההפוך לערך של <span class="math">\(x\)</span>; הפסוקית <span class="math">\(C_{i}\)</span> מקבלת את הערך <span class="math">\(\text{T}\)</span> אם לפחות אחד מהליטרלים שלה קיבל <span class="math">\(\text{T}\)</span> ואחרת היא מקבלת <span class="math">\(\text{F}\)</span>; והפסוק כולו מקבל <span class="math">\(\text{T}\)</span> רק אם כל הפסוקיות שבו קיבלו <span class="math">\(\text{T}\)</span>. תחשבו על פסוק <span class="math">\(\varphi\)</span> בתור "רשימה של אילוצים", כך שכל אילוץ הוא פסוקית, חייבים שכל האילוצים<br />
יתקיימו בו זמנית, וכל אילוץ קל יחסית לקיים - רק צריך שאחד מהליטרלים בתוכו יתקיים.</p>
<p>דוגמה: <span class="math">\(\varphi=\left(x\vee\neg y\right)\wedge\left(\neg x\vee z\right)\)</span>. זה פסוק שדי קל לספק, למשל על ידי ההשמה <span class="math">\(x=\text{\ensuremath{\text{T}},y=\ensuremath{\text{F}},z=\ensuremath{\text{T}}}\)</span>. יש גם השמות שלא מספקות אותו, למשל <span class="math">\(x=\text{F},y=\text{T},z=\text{F}\)</span>. אפשר, אם באמת רוצים, לספור כמה השמות מספקות יש ל-<span class="math">\(\varphi\)</span>- די ברור שיש יותר מאחת.</p>
<p>אוקיי, תגידו, אז הבנו/נזכרנו מה הבעיה הזו. אבל למה בעיה ספציפית כזו מתחום הלוגיקה מעניינת בכלל? ובכן, בגלל שהיא האמא של הבעיות ה-NP-שלמות. יש לי <a href="http://www.gadial.net/2010/08/15/p_vs_np_overview/">פוסט שמסביר</a> את הנושאים הללו ולכן רק תזכורת קצרה: בעיה NP-שלמה היא בעיה שאם היא נפתרת בצורה יעילה, אז עוד אלפי בעיות שכיום נחשבות קשות ולא ידוע פתרון יעיל עבורן ייפתרו גם הן. במילים אחרות, פתרון יעיל ל-SAT יהיה הסנסציה הגדולה ביותר במדעי המחשב מאז ומעולם (גם הוכחה לכך שאין פתרון יעיל ל-SAT תהיה סנסציה אדירה, אם כי צפויה קצת יותר ולכן גם מרגשת פחות). בינתיים המעמד של SAT הוא של "בעיה קשה, קשה, קשה לפתרון" (שקר גס, בפועל פותרים בעיות כאלו בעזרת היוריסטיקות ומסתדרים לא רע יחסית).</p>
<p>מה מתמטיקאים עושים עם בעיות קשות שאין לאף אחד מושג איך לפתור? חושבים עליהן יותר חזק? לא. מנסים לפתח תורה מתמטית חדשה שתתמודד עם הבעיה? לא. מתכנסים בליל ירח מלא בתוך <a href="http://www.gadial.net/2010/11/08/hilberts_hotel/">המלון של הילברט</a>, מקריבים את <a href="http://www.gadial.net/2008/06/17/infinite_series/">הצב של זנון</a> על מזבח הריגורוזיות ומתפללים ל<a href="http://www.gadial.net/2010/04/06/euler_formula_and_harmonic_oscillator/">נוסחת אוילר</a>? לא. מנסים לפתור מקרה פרטי של הבעיה הקשה שהוא אולי יותר קל? או, עכשיו אנחנו בכיוון.</p>
<p>אז בואו נאמר שאנחנו רוצים להיות מסוגלים להבדיל רק בין שני מקרים - המקרה שבו ל-<span class="math">\(\varphi\)</span> אין בכלל השמות מספקות, והמקרה שבו יש ל-<span class="math">\(\varphi\)</span> השמה מספקת אחת. ויותר מזה - אנחנו מרשים לאלגוריתם שלנו להיות הסתברותי עם טעות חד-צדדית. כלומר, <strong>אם</strong> <span class="math">\(\varphi\)</span> אינו ספיק, אנחנו דורשים שהאלגוריתם יעצור ובודאות יגיד "לא", אבל אם <span class="math">\(\varphi\)</span> ספיק על ידי השמה מספקת אחת <strong>בדיוק</strong> כל מה שאנחנו דורשים הוא שהוא יעצור ויגיד "כן" בהסתברות נמוכה כלשהי (כמה נמוכה? נדון בכך אחר כך). אם <span class="math">\(\varphi\)</span> ספיק על ידי יותר מהשמה מספקת אחת ממש לא אכפת לנו מה האלגוריתם יעשה. האינטואיציה היא זו: אם המקרה הזה קל יותר מהבעיה הכללית, אולי הבנה של הפתרון שלו תעזור לנו להבין איך לפתור את הבעיה הכללית או היכן טמון הקושי בבעיה הכללית; ואילו אם הוא קשה מספיק לכשעצמו אז אולי נקבל אינטואיציה טובה יותר לגבי הקושי הזה. ובכן, משפט VV מראה לנו, באופן די מפתיע, שגם המקרה הזה הוא קשה למדי; ספציפית, אם יש אלגוריתם שפותר אותו נובע מכך ש<strong>לכל</strong> בעיה ב-NP יש אלגוריתם הסתברותי עם טעות חד צדדית שפותר<br />
אותה, בפרט ל-SAT עצמה (בלשון סיבוכיותית, <span class="math">\(\text{RP=NP}\)</span>). משפט VV מראה זאת על ידי תיאור של דרך לפתור את <span class="math">\(\text{SAT}\)</span> בעזרת פתרון לבעיה הפשוטה יותר - הוא עושה זאת באמצעות <strong>רדוקציה אקראית</strong>, ואסביר עכשיו מה זה בדיוק אומר.</p>
<p>באופן פורמלי, המשפט אומר שאם נתון לנו פסוק CNF <span class="math">\(\varphi\)</span> אז אפשר להמיר אותו (באופן הסתברותי) לפסוק <span class="math">\(\text{CNF}\)</span> <span class="math">\(\varphi^{\prime}\)</span> כך ש:</p>
<ol>
    <li> ההמרה מתבצעת בזמן יעיל (פולינומי באורך של <span class="math">\(\varphi\)</span>).</li>
    <li> אם <span class="math">\(\varphi\)</span> לא ספיק אז גם <span class="math">\(\varphi^{\prime}\)</span> לא ספיק.</li>
    <li> אם <span class="math">\(\varphi\)</span> ספיק אז בהסתברות לא רעה ל-<span class="math">\(\varphi^{\prime}\)</span> יש בדיוק השמה מספקת אחת ("הסתברות לא רעה" כאן היא <span class="math">\(\frac{1}{8n}\)</span> כש-<span class="math">\(n\)</span> הוא מספר המשתנים של <span class="math">\(\varphi\)</span>).</li>
</ol>
<p>יפה, אז הבנו מה המשפט אומר. עכשיו אפשר לגשת לאקשן האמיתי - ההוכחה.</p>
<p>הבניה עצמה היא פשוטה באופן מפתיע. מה שנעשה יהיה להוסיף ל-<span class="math">\(\varphi\)</span> עוד אילוצים; פורמלית, <span class="math">\(\varphi^{\prime}\left(x\right)=\varphi\left(x\right)\wedge\left(h\left(x\right)=0\right)\)</span>, כאשר <span class="math">\(h\left(x\right)=0\)</span> כאן הוא קידוד של פסוק CNF שבודק ש-<span class="math">\(h\left(x\right)=0\)</span> עבור פונקציה <span class="math">\(h\)</span> שמוגרלת באופן מסויים שאסביר בקרוב. מייד נשאלת השאלה איך מקודדים את <span class="math">\(h\left(x\right)=0\)</span> בתור פסוק CNF; נדחה את השאלה הזו להמשך.</p>
<p>לב הרעיון, שמשתמשים בו במקומות נוספים בסיבוכיות, הוא לבחור את <span class="math">\(h\)</span> מתוך אוסף של <strong>פונקציות תמצות בלתי תלויות בזוגות</strong>. עזבו אתכם ממה זה אומר באופן כללי ובואו נדבר קונקרטית. אנחנו חושבים על <span class="math">\(x\)</span> (שהוא וקטור של <span class="math">\(\text{T}\)</span> ו-<span class="math">\(\text{F}\)</span>) בתור איבר של <span class="math">\(\mathbb{Z}_{2}^{n}\)</span> - סדרה מאורך <span class="math">\(n\)</span> של אפסים ואחדים - ואנחנו מגרילים מטריצה <span class="math">\(A\in\mathbb{Z}_{2}^{k\times n}\)</span> עם <span class="math">\(k\)</span> שורות ו-<span class="math">\(n\)</span> עמודות, כך ש-<span class="math">\(k\)</span> עצמו נבחר באקראי מתוך <span class="math">\(\left\{ 2,3,\dots,n+1\right\} \)</span> (למה התחום המוזר הזה? יהיה הסבר, סבלנות) ובנוסף אנחנו מגרילים וקטור <span class="math">\(b\in\mathbb{Z}_{2}^{k}\)</span>, וכעת מגדירים <span class="math">\(h\left(x\right)=Ax+b\)</span>. כלומר, <span class="math">\(h\)</span> תלויה בביטים של <span class="math">\(A\)</span> ושל <span class="math">\(b\)</span>.</p>
<p>כדאי לחשוב על העניין כך: כל שורה <span class="math">\(a^{i}\in\mathbb{Z}_{2}^{n}\)</span> של <span class="math">\(A\)</span> מגדירה אילוץ מהצורה <span class="math">\(a^{i}\cdot x=b_{i}\)</span> (העברתי את ה-<span class="math">\(b\)</span> אגף, ומכיוון שאנחנו מעל <span class="math">\(\mathbb{Z}_{2}\)</span> אין צורך לשנות סימן). עכשיו, די בבירור אם אני מגריל את <span class="math">\(a\)</span> ואת <span class="math">\(b_{i}\)</span> בהתפלגות אחידה אז יש ל-<span class="math">\(x\)</span> נתון הסתברות של <span class="math">\(\frac{1}{2}\)</span> לקיים את האילוץ, כי אם "נקפיא" את <span class="math">\(a\)</span> אז עבור אחד מהערכים האפשריים של <span class="math">\(b_{i}\)</span> האילוץ יתקיים ועבור הערך השני של <span class="math">\(b_{i}\)</span> האילוץ לא יתקיים, ולכן הוא מתקיים בדיוק עבור חצי מהזוגות <span class="math">\(\left(a,b_{i}\right)\)</span>. במילים אחרות, לכל <span class="math">\(x\)</span> יש הסתברות של <span class="math">\(\frac{1}{2}\)</span> לשרוד כל אחד מהאילוצים, ומכיוון שכל <span class="math">\(k\)</span> האילוצים נבחרים באופן בלתי תלוי זה בזה, יש ל-<span class="math">\(x\)</span> סיכוי של <span class="math">\(2^{-k}\)</span> לשרוד את כל האילוצים. אם כן, <span class="math">\(h\)</span> מדללת באופן <strong>אקספוננציאלי</strong> את כמות ה-<span class="math">\(x\)</span>-ים שמספקים את <span class="math">\(\varphi\)</span>, ובגלל שיש לנו שליטה על <span class="math">\(k\)</span> נוכל לבחור את רמת הדילול המדוייקת שאנחנו צריכים, בהסתברות לא רעה. פורמלית: <span class="math">\(\text{Pr}_{h}\left[h\left(x\right)=0\right]=2^{-k}\)</span>. אסמן <span class="math">\(p=2^{-k}\)</span> לצורך פשטות.</p>
<p>בינתיים כל מה שעשיתי נראה מטופש להפליא. למה בכלל הגרלתי <span class="math">\(A\)</span>? הרי היא לא סייעה לי בטיעון. הייתי יכול להגריל רק את <span class="math">\(b\)</span> ולהשוות אותו בכל פעם ל-<span class="math">\(x_{1}+x_{2}+\dots+x_{n}\)</span> וחסל. אלא שאני זקוק לעוד תכונה של ה-<span class="math">\(h\)</span> שאני מגריל - בדיוק תכונת ה<strong>בלתי תלויות בזוגות</strong> שהוזכרה קודם; בלעדיה אני באמת לא אוכל לעשות הרבה. מה שאני רוצה לומר הוא שלא רק ש-<span class="math">\(h\)</span> מדללת "הרבה", אלא גם שהיא מדללת באופן ש<strong>יוצר פער</strong> בין, נאמר, דילול שמשאיר רק השמה מספקת אחת בחיים ודילול שמשאיר שתיים כאלו בחיים. בשביל להראות את זה אני צריך להראות שההסתברות לכך ששתי השמות נתונות שונות זו מזו יישארו בחיים קטן משמעותית מההסתברות של השמה אחת להישאר בחיים. ספציפית, אני רוצה לחשב את <span class="math">\(\text{Pr}\left[h\left(x\right)=0\wedge h\left(y\right)=0\right]\)</span> עבור <span class="math">\(x\ne y\)</span>. כאן מגיע תעלול רעיוני שהוא לב ההוכחה ולטעמי הוא רעיון מקסים ביותר, למרות שהוא גם מאוד פשוט.</p>
<p>הרעיון הוא כזה: מכיוון ש-<span class="math">\(x\ne y\)</span> יש ביט, נאמר <span class="math">\(i\)</span>, כך ש-<span class="math">\(x_{i}=0\)</span> ו-<span class="math">\(y_{i}=1\)</span> (או הפוך). נסתכל על אילוץ <span class="math">\(\left(a^{k},b_{k}\right)\)</span> כלשהו ש-<span class="math">\(x\)</span> <strong>מספק</strong>, כלומר <span class="math">\(a^{k}\cdot x=b_{k}\)</span>. אז מכיוון ש-<span class="math">\(x_{i}=0\)</span>, זה אומר שהביט במקום ה-<span class="math">\(i\)</span> בוקטור <span class="math">\(a^{k}\)</span> <strong>לא משנה</strong> את הערך של <span class="math">\(a^{k}\cdot x\)</span>; בפרט, אם אגדיר <span class="math">\(c^{k}\)</span> כך ש-<span class="math">\(a^{k}=c^{k}\)</span> בכל ביט פרט לביט ה-<span class="math">\(i\)</span> ושם הם הפוכים, אז יתקיים גם <span class="math">\(c^{k}\cdot x=b_{k}\)</span>.</p>
<p>לעומת זאת, <strong>לא ייתכן</strong> ש-<span class="math">\(a^{k}\cdot y=c^{k}\cdot y\)</span>, כי הערכים של <span class="math">\(a^{k}\cdot y,c^{k}\cdot y\)</span> נבדלים ב-1 בדיוק (הסבירו את זה לעצמכם!) ולכן <span class="math">\(y\)</span> מקיים <strong>בדיוק אחד משני האילוצים</strong> <span class="math">\(a^{k}\cdot y=b_{k}\)</span> ו-<span class="math">\(c^{k}\cdot y=b_{k}\)</span>, כלומר <span class="math">\(y\)</span> מקיים בדיוק <strong>חצי</strong> מהאילוצים ש-<span class="math">\(x\)</span> מקיים, כלומר ההסתברות לכך ש-<span class="math">\(y\)</span> יקיים אילוץ בהינתן ש-<span class="math">\(x\)</span> מקיים אותו היא <span class="math">\(\frac{1}{2}\)</span>, כלומר ההסתברות ש-<span class="math">\(x,y\)</span> יקיימו אילוץ מסויים בו זמנית היא <span class="math">\(\frac{1}{4}\)</span>, ולכן ההסתברות ששניהם יקיימו זמנית את כל האילוצים היא <span class="math">\(4^{-k}\)</span>, כלומר <span class="math">\(\text{Pr}\left[h\left(x\right)=0\wedge h\left(y\right)=0\right]=p^{2}\)</span>. אם הבנתם את זה - הבנתם את העיקר בהוכחה (שימו לב שהעיקר הזה הוא תכונה כללית של פונקציות תמצות בלתי תלויות בזוגות; זה לא משהו שייחודי למשפט הנוכחי).</p>
<p>עכשיו בואו נבין איך זה עוזר לנו. נסמן ב-<span class="math">\(S\)</span> את קבוצת ההשמות שמספקות את <span class="math">\(\varphi\)</span>. בבירור אם <span class="math">\(S\)</span> ריקה אז אין השמה שמספקת את <span class="math">\(\varphi^{\prime}\)</span> (כי כל השמה שמספקת את <span class="math">\(\varphi^{\prime}\)</span> בפרט צריכה לספק את <span class="math">\(\varphi\)</span>). לכן נניח ש-<span class="math">\(\left|S\right|\ge1\)</span>. נסמן ב-<span class="math">\(N\)</span> את מספר ההשמות ב-<span class="math">\(S\)</span> שמקיימות <span class="math">\(h\left(x\right)=0\)</span>; זה משתנה מקרי שתלוי בבחירת <span class="math">\(h\)</span>. אנחנו רוצים למצוא מהו <span class="math">\(\text{Pr}_{h}\left[N=1\right]\)</span>. דרך אחת לעשות זאת היא כך: <span class="math">\(\text{Pr}_{h}\left[N=1\right]=\text{Pr}_{h}\left[N\ge1\right]-\text{Pr}_{h}\left[N\ge2\right]\)</span> (הסבירו לעצמכם למה!) ולכן, אם אנחנו רוצים למצוא חסם מלמטה עבור <span class="math">\(\text{Pr}_{h}\left[N=1\right]\)</span> (אין צורך לחשב את ההסתברות במדויק) מספיק למצוא חסם מלמטה עבור <span class="math">\(\text{Pr}_{h}\left[N\ge1\right]\)</span> וחסם מלמעלה עבור <span class="math">\(\text{Pr}_{h}\left[N\ge2\right]\)</span>.</p>
<p>כדי להקל על הסימונים, בואו נסמן בתור <span class="math">\(A_{x}\)</span> את המאורע "<span class="math">\(h\left(x\right)=0\)</span>" (כלומר, <span class="math">\(A_{x}\)</span> היא קבוצת ה-<span class="math">\(h\)</span>-ים שמקיימים <span class="math">\(h\left(x\right)=0\)</span>) ובדומה נסמן ב-<span class="math">\(A_{x,y}\)</span> את המאורע "<span class="math">\(h\left(x\right)=0\wedge h\left(y\right)=0\)</span>". כעת:</p>
<p><span class="math">\(\text{Pr}_{h}\left[N\ge2\right]=\text{Pr}\left[\bigcup_{x&lt;y\in S}A_{x,y}\right]\le\sum_{x&lt;y\in S}\text{Pr}\left[A_{x,y}\right]=\sum_{x&lt;y\in S}p^{2}={\left|S\right| \choose 2}p^{2}\)</span></p>
<p>השתמשתי כאן במה שנקרא Union-bound - ההסתברות של איחוד מאורעות חסומה מלעיל על ידי סכום ההסתברויות של כולם. זה לרוב חסם גס מאוד, אבל כאן הוא מספיק טוב לנו.</p>
<p>לחסום את <span class="math">\(\text{Pr}\left[N\ge1\right]\)</span> מלמטה זה קצת יותר מחוכם. התעלול הוא להשתמש ב<strong><a href="http://www.gadial.net/2011/12/31/inclusion_exclusion_principle/">עקרון הההכלה וההפרדה</a></strong>. כשמפעילים אותו על המקרה הנוכחי, מקבלים:</p>
<p><span class="math">\(\text{Pr}\left[N\ge1\right]=\text{Pr}\left[\bigcup A_{x}\right]-\text{Pr}\left[\bigcup A_{x,y}\right]+\text{Pr}\left[\bigcup A_{x,y,z}\right]-\dots\)</span></p>
<p>(למה? ובכן, אם נכפול את שני אגפי המשוואה במספר ה-<span class="math">\(h\)</span>-ים הכולל האפשרי, נוכל להפסיק לדבר על הסתברות ולעבור לדבר על קומבינטוריקה סופית טהורה ואז יהיה יותר ברור שעקרון ההכלה וההפרדה תקף כאן). הנקודה הקריטית כאן היא שה"זנב" <span class="math">\(\text{Pr}\left[\bigcup A_{x,y,z}\right]-\text{Pr}\left[\bigcup A_{x,y,z,w}\right]+\dots\)</span> הוא חיובי, כי אפשר לפרק אותו לזוגות של "משהו חיובי פחות משהו קטן ממנו". לכן אפשר להיפטר מהזנב לגמרי:</p>
<p><span class="math">\(\text{Pr}\left[N\ge1\right]\ge\text{Pr}\left[\bigcup A_{x}\right]-\text{Pr}\left[\bigcup A_{x,y}\right]=\left|S\right|p-{\left|S\right| \choose 2}p^{2}\)</span></p>
<p>ועכשיו מחיבור שני האי שוויונות שמצאנו, נקבל:</p>
<p><span class="math">\(\text{Pr}\left[N=1\right]=\text{Pr}_{h}\left[N\ge1\right]-\text{Pr}_{h}\left[N\ge2\right]\ge\left|S\right|p-2{\left|S\right| \choose 2}p^{2}\ge\left|S\right|p-\left(\left|S\right|p\right)^{2}\)</span></p>
<p>עכשיו, את הפונקציה <span class="math">\(f\left(t\right)=t-t^{2}\)</span> קל לחקור אם יודעים טיפה אינפי; מהר מאוד רואים שבקטע <span class="math">\(\left[\frac{1}{4},\frac{1}{2}\right]\)</span> היא פונקציה עולה, לכן המינימום שלה מתקבל ב-<span class="math">\(t=\frac{1}{4}\)</span> והוא <span class="math">\(\frac{1}{4}-\frac{1}{16}=\frac{3}{16}&gt;\frac{1}{8}\)</span>. לכן הגענו למסקנה הבאה: אם <span class="math">\(\frac{1}{4}\le\left|S\right|p\le\frac{1}{2}\)</span>, אז <span class="math">\(\text{Pr}\left[N=1\right]\ge\frac{1}{8}\)</span>. לא רע בכלל!</p>
<p>עכשיו, מהו <span class="math">\(p\)</span>? כזכור, <span class="math">\(p=2^{-k}\)</span>. ומי זה <span class="math">\(k\)</span>? את <span class="math">\(k\)</span> בחרנו באקראי בתחום <span class="math">\(\left\{ 2,\dots,n+1\right\} \)</span>. אז כדי שיתקיים <span class="math">\(\frac{1}{4}\le\left|S\right|p\le\frac{1}{2}\)</span> צריך שיתקיים <span class="math">\(2^{k-2}\le\left|S\right|\le2^{k-1}\)</span>. אבל, מכיוון ש-<span class="math">\(1\le\left|S\right|\le2^{n}\)</span>, זה <strong>בהכרח</strong> קורה לאחד מה-<span class="math">\(k\)</span>-ים בדיוק בתחום <span class="math">\(\left\{ 2,\dots,n+1\right\} \)</span>, שאני מקווה שעכשיו נראה קצת יותר ברור. לכן ההסתברות שלנו לבחור <span class="math">\(k\)</span> "נכון" היא <span class="math">\(\frac{1}{n}\)</span> (גודל התחום), ולכן ההסתברות של הרדוקציה כולה לעבור היא לפחות <span class="math">\(\frac{1}{8n}\)</span> - בדיוק מה שהבטחתי שאוכיח. סיימנו!</p>
<p>ובכן, לא, עוד לא סיימנו כי עוד לא הסברתי איך לקודד את <span class="math">\(h\left(x\right)=0\)</span>. זה לא מובן מאליו; צריך להיזהר ולא לקודד את הביטוי הזה על ידי נוסחת CNF גדולה <strong>מדי</strong>. כדי לעשות את זה אהיה חייב להשתמש במשתני עזר; קיימת הוכחה לכך שאפילו מקרה פרטי - הנוסחה <span class="math">\(x_{1}\oplus\dots\oplus x_{n}=0\)</span>, הידועה גם בתור הפונקציה PARITY - לא ניתן לקודד כפסוק CNF קצר (פולינומי) באופן כזה שכל השמה למשתנים תחזיר את הערך הנכון של הפרדיקט <span class="math">\(x_{1}\oplus\dots\oplus x_{n}=0\)</span>. אז מה שאעשה יהיה שונה: אני אקודד את <span class="math">\(h\left(x\right)=0\)</span> על ידי פסוק <span class="math">\(\psi\left(x,z\right)\)</span> כך ש-<span class="math">\(z\)</span> הם משתני עזר, כך ש<strong>אם</strong> <span class="math">\(h\left(x\right)=0\)</span> אז קיימת השמה <strong>יחידה</strong> למשתני העזר כך ש-<span class="math">\(\psi\left(x,z\right)=\text{T}\)</span>; ואחרת אף השמה לא תספק את <span class="math">\(\psi\)</span>. לבקיאים רק אציין שאפשר לעצור כבר כאן באמירה "ניקח מכונת טיורינג דטרמיניסטית שבודקת אם <span class="math">\(h\left(x\right)=0\)</span> ומקבלת אם כן, ו-<span class="math">\(\psi\)</span> יהיה קידוד קוק-לוין של הריצה שלה" אבל לטובת אלו מכם שאין להם מושג מה אמרתי, או לא זוכרים<br />
את הפרטים של קוק-לוין, אתן כאן בניה ישירה. ולמען הסר ספק: אני עצמי לא ממש זוכר את הפרטים של קוק-לוין ומעדיף הרבה יותר לראות בניה ישירה מאשר את נפנוף הידיים המתועב הזה.</p>
<p>בואו נתחיל ממשהו פשוט: איך אני מקודד ב-CNF את <span class="math">\(x\oplus y\)</span>? פשוט מאוד: <span class="math">\(\left(x\vee y\right)\wedge\left(\neg x\vee\neg y\right)\)</span>. מה קורה פה? אם <span class="math">\(x=y\)</span> אז או ש-<span class="math">\(x\vee y\)</span> לא יסתפק (אם <span class="math">\(x=y=\text{F}\)</span>) או ש-<span class="math">\(\neg x\vee\neg y\)</span> לא יסתפק (אם <span class="math">\(x=y=\text{T}\)</span>). ההכללה של זה לשלושה משתנים לא מסובכת: את <span class="math">\(x\oplus y\oplus w\)</span> נקודד בתור <span class="math">\(\left(x\vee\neg y\vee\neg w\right)\wedge\left(\neg x\vee\neg y\vee w\right)\wedge\left(\neg x\vee y\vee\neg w\right)\wedge\left(x\vee y\vee w\right)\)</span>. האם אתם רואים את העקרון? בכל זוג סוגריים צריכים להיות מספר זוגי של שלילות. כך, אם יש לנו השמה כלשהי למשתנים שבה מספר זוגי של משתנים קיבל <span class="math">\(\text{T}\)</span>, יהיה זוג סוגריים שיחזיר <span class="math">\(\text{F}\)</span> (בדיוק זה שבו אותם המשתנים מופיעים עם <span class="math">\(\neg\)</span>) ולעומת זאת כל השמה שבה מספר אי זוגי של משתנים קיבל <span class="math">\(\text{T}\)</span> בהכרח תספק את כל זוגות הסוגריים (כי אז אז או שאחד מהמשתנים שקיבלו <span class="math">\(\text{T}\)</span> מופיע בלי <span class="math">\(\neg\)</span>, או שאחד מהמשתנים שקיבל <span class="math">\(\text{F}\)</span> מופיע עם <span class="math">\(\neg\)</span>). אלא<br />
שאם יש לנו <span class="math">\(n\)</span> משתנים, זה אומר שנצטרך ליצור פסוק עם המון פסוקיות - <span class="math">\(2^{n-1}\)</span> (פורמלית, <span class="math">\({n \choose 0}+{n \choose 2}+\dots\)</span> ויש תעלולים שמראים שהסכום אכן יוצא <span class="math">\(2^{n-1}\)</span>). בקיצור, אקספוננציאלי. אז השיטה הישירה לא תעבוד כאן ואנחנו חייבים משהו מתוחכם יותר.</p>
<p>הנה תעלול אפשרי אחד: אם אנחנו רוצים לקודד את <span class="math">\(x_{1}\oplus x_{2}\oplus\dots\oplus x_{n}\)</span>, אפשר תחת זאת לקודד את <span class="math">\(\left(z_{1}=x_{1}\oplus x_{2}\right)\wedge\left(z_{2}=z_{1}\oplus x_{3}\right)\wedge\dots\wedge\left(z_{n-1}=z_{n-2}\oplus x_{n}\right)\wedge\left(z_{n-1}\right)\)</span>. זה יפתור לנו את הבעיה, בהינתן שאפשר לקודד משהו כמו <span class="math">\(z=x\oplus y\)</span> בעזרת פסוק CNF מאורך פולינומי. ובכן, איך מוצאים דבר כזה באופן שיטתי, בלי ניסוי וטעיה? ראשית כותבים את <span class="math">\(z\ne x\oplus y\)</span> בתור DNF דווקא; לכתוב DNF זה קל כי פשוט מבצעים <span class="math">\(\vee\)</span> על כל ארבע ההשמות האפשריות שיספקו את <span class="math">\(z\ne x\oplus y\)</span>: <span class="math">\(\left(x\wedge y\wedge z\right)\vee\left(\neg x\wedge\neg y\wedge z\right)\vee\left(\neg x\wedge y\wedge\neg z\right)\vee\left(x\wedge\neg y\wedge\neg z\right)\)</span>. עכשיו מפעילים שלילה על הפסוק כולו ומשתמשים בכללי דה-מורגן, ומקבלים <span class="math">\(\left(\neg x\vee\neg y\vee\neg z\right)\wedge\left(x\vee y\vee\neg z\right)\wedge\left(x\vee\neg y\vee z\right)\wedge\left(\neg x\vee y\vee z\right)\)</span>. זה מסיים את ההוכחה כולה.</p>
<p>ההוכחה עצמה יפה מספיק כדי להצדיק פוסט, לטעמי, אבל הסיפור לא נגמר כאן. המשכים אפשריים הם ההוכחה של משפט Toda שמשתמשת ב-VV בתור כלי בסיסי, והוכחה של תוצאות מרהיבות אחרות בסיבוכיות שעושות שימוש באותו תעלול של פונקציות תמצות בלתי תלויות בזוגות. אני מקווה להציג את כל הדברים הללו בעתיד.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>