<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>טומוגרפיה קוונטית: איך מגלים מה כבר יש לנו? - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2022/10/12/quantum_state_tomography/">
    <meta property="og:title" content="טומוגרפיה קוונטית: איך מגלים מה כבר יש לנו?">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="https://gadial.net2022/qst.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary_large_image">


    <meta name="twitter:url" content="https://gadial.net/2022/10/12/quantum_state_tomography/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="טומוגרפיה קוונטית: איך מגלים מה כבר יש לנו?">
    

<meta property="twitter:image" content="https://gadial.net2022/qst.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2022/10/09/density_matrices/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">חישוב קוונטי: פורמליזם מטריצות הצפיפות</span>
            </a>
            

            
            <a href="/2023/01/07/well_ordered_sets/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">תורת הקבוצות - קבוצות סדורות היטב</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>טומוגרפיה קוונטית: איך מגלים מה כבר יש לנו?</h1>
            <div class="post-meta">
                <span class="date">2022-10-12</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/חישוב קוונטי.html">חישוב קוונטי</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/טומוגרפיה קוונטית.html">טומוגרפיה קוונטית</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p><a href="https://gadial.net/2022/10/09/density_matrices/">בפוסט הקודם שלי</a> הצגתי את מה שקראתי לו "פורמליזם מטריצת הצפיפות" ולפני שאני ממשיך לדבר עליו - ספציפית, על השינויים שהוא יכול לעבור - אני רוצה לעצור ולהציג נושא שישתמש באופן ישיר בפורמליזם הזה והוא די מגניב בזכות עצמו: טומוגרפיית מצבים קוונטית (Quantum State Tomography).</p>
<p>דבר אחד שאני מקווה שהדגשתי בסדרת הפוסטים עד כה הוא שמדידה של מצב קוונטי <strong>הורסת</strong> את המצב הקוונטי. משמידה אותו. חורבן. הרס. אם הייתי במצב <span class="math">\(\left|+\right\rangle \)</span> ומדדתי מדידה "רגילה", בבסיס <span class="math">\(Z\)</span> (כלומר, מדידה שמתאימה לאיברים <span class="math">\(\left\{ \left|0\right\rangle ,\left|1\right\rangle \right\} \)</span>), אז זהו, אני כבר לא ב-<span class="math">\(\left|+\right\rangle \)</span>. אני או ב-<span class="math">\(\left|0\right\rangle \)</span> או ב-<span class="math">\(\left|1\right\rangle \)</span>. אם הייתי במצב כללי <span class="math">\(\alpha\left|0\right\rangle +\beta\left|1\right\rangle \)</span> ומדדתי בבסיס <span class="math">\(Z\)</span> , אז זהו. אני או ב-<span class="math">\(\left|0\right\rangle \)</span> או ב-<span class="math">\(\left|1\right\rangle \)</span> וזהו. המקדמים <span class="math">\(\alpha,\beta\)</span> נעלמו ואינם עוד.</p>
<p>גרוע מכך - מדידה אחת פשוט <strong>לא יכולה</strong> ללמד אותי מהם <span class="math">\(\alpha,\beta\)</span>. אם קיבלתי <span class="math">\(\left|0\right\rangle \)</span> אני יכול לדעת ש-<span class="math">\(\alpha\ne0\)</span> אבל לא יותר מכך. באלגוריתמים הקוונטיים שהצגתי עד כה, כולל האלגוריתם של שור, לא התעניינו בערכים של האמפליטודות; רק ניסינו לבצע עליהם מניפולציות כדי להבטיח שבהסתברות גבוהה התוצאה הסופית תהיה כזו שעוזרת לנו.</p>
<p>אבל העניין הוא... שקצת שיקרתי. בהחלט <strong>אפשר</strong> לחשב את ה-<span class="math">\(\alpha,\beta\)</span> הללו מתוך המצב הקוונטי, וזאת בתנאי שיש לנו <strong>מספר עותקים שלו</strong>. כמה עותקים בדיוק - את זה נראה בקרוב. עכשיו, אפשר לטעון ובצדק שאי אפשר לשכפל מצב קוונטי (יש משפט כזה! No Cloning Theorem!) ולכן אני לא יכול סתם לקחת מצב קוונטי, לשכפל אותו ואז להשתמש בשיטה הקסומה שאני הולך להציג פה. זה נכון לגמרי; אבל אם המצב הקוונטי נוצר כתוצאה של תהליך מסוים, אני יכול לחזור על התהליך הזה שוב ושוב ולקבל את אותו מצב שוב ושוב. זה מה שהרצה פרקטית של אלגוריתם במחשב קוונטי עושה גם ככה: מריצה את אותו אלגוריתם מספר פעמים גדול (נאמר, 1,000?) על המחשב ויוצרת סטטיסטיקה של תוצאות.</p>
<p>כמובן, אפשר לשאול ובצדק - אם אנחנו אלו שמייצרים את המצב, האם זה לא אומר שאנחנו יודעים לאיזה מצב הגענו? ובכן, <strong>לא!</strong> משתי סיבות. ראשית, כי אני לא מניח שאנחנו יודעים לחשב מה המצב גם אם יש לנו מעגל קונקרטי שמייצר אותו - אולי החישוב המלא של מה שהמעגל עושה הוא מסובך? אולי יש בתוך המעגל אלמנטים שאנחנו יכולים לשלוט עליהם אבל אנחנו לא יודעים מה הם בדיוק עושים? ושנית, באופן די דומה למה שכבר אמרתי, במעגלים קוונטיים יש בעיה של <strong>רעשים</strong> והתנהגויות לא צפויות. ייתכן שאנחנו <strong>חושבים</strong>~שאנחנו מייצרים את <span class="math">\(\left|+\right\rangle \)</span> אבל עקב שגיאות במימוש של המחשב הקוונטי אנחנו תמיד מקבלים את <span class="math">\(\left|-\right\rangle \)</span> - זה <strong>בהחלט</strong> משהו שהיינו רוצים להיות מסוגלים לזהות. בפועל, זה אכן שימוש מרכזי של טומוגרפיה קוונטית - בדיקה שהמחשב אכן מתנהג כפי שאנו מצפים שיתנהג, והערכה של רמת הרעש שיש בו.</p>
<p>אם כן, הבה ונאמר שיש לנו מצב קוונטי ואנחנו מסוגלים לשחזר שוב ושוב במדויק את התהליך שיוצר אותו. ואנחנו מודדים אותו 1,000 פעם בבסיס <span class="math">\(Z\)</span> ומקבלים 483 פעם "0" ו-517 פעם "1". מה זה אומר על המצב שבו אני נמצא? אם אני ב-<span class="math">\(\left|+\right\rangle =\frac{\left|0\right\rangle +\left|1\right\rangle }{\sqrt{2}}\)</span> ומודד 1,000 פעמים בהחלט ייתכן שאקבל את התפלגות התוצאות הזו, אבל גם אם אני במצב <span class="math">\(\sqrt{\frac{483}{1000}}\left|0\right\rangle +\sqrt{\frac{517}{1000}}\left|1\right\rangle \)</span> זה ייתכן. כלומר, יש לנו בעיה כבר עם עצם זה שלחזור שוב ושוב על אותו ניסוי ולספור תוצאות לא נותן לנו את ההסתברויות שהובילו אליהן. אבל זו אפילו לא הבעיה המרכזית לבינתיים! </p>
<p>אז בואו נניח לצורך הדיון שאיכשהו המדידות שלי מושלמות ואני מצליח לגלות בצורה מדויקת את ההסתברויות לכל התוצאות, כלומר אם המצב שלי הוא <span class="math">\(\left|+\right\rangle \)</span> אני מקבל את וקטור ההסתברויות <span class="math">\(\overline{p}=\left(\begin{array}{c} 0.5\\ 0.5 \end{array}\right)\)</span>. מה הבעיה כאן? שגם אם המצב שלי הוא <span class="math">\(\left|-\right\rangle \)</span> אני אקבל את <strong>אותו וקטור הסתברויות בדיוק</strong>. מדידה בבסיס <span class="math">\(Z\)</span> פשוט <strong>לא מסוגלת</strong> להבדיל בין שני המצבים הללו. אני אקבל את אותה סטטיסטיקה בדיוק. אז מה עושים?</p>
<p>למרבה המזל, יש עוד מדידות בעולם חוץ ממדידה בבסיס <span class="math">\(Z\)</span>. למשל, מדידה בבסיס <span class="math">\(X\)</span>, שאבריה הם <span class="math">\(\left\{ \left|+\right\rangle ,\left|-\right\rangle \right\} \)</span>. מדידה כזו בוודאי יכולה להפריד בין <span class="math">\(\left|+\right\rangle \)</span> (שיחזיר וקטור הסתברויות <span class="math">\(\left(\begin{array}{c} 1\\ 0 \end{array}\right)\)</span>) ובין <span class="math">\(\left|-\right\rangle \)</span> (שיחזיר וקטור הסתברויות <span class="math">\(\left(\begin{array}{c} 0\\ 1 \end{array}\right)\)</span>). אלא מה? מדידה בבסיס <span class="math">\(X\)</span> לא מסוגלת להבדיל בין <span class="math">\(\left|0\right\rangle ,\left|1\right\rangle \)</span> ששניהם מחזירים <span class="math">\(\overline{p}=\left(\begin{array}{c} 0.5\\ 0.5 \end{array}\right)\)</span> - אותה בעיה כמו קודם.</p>
<p>האם צריך להתייאש? בוודאי שלא! המסקנה צריכה להיות חיובית - אולי בסיס מדידה אחד הוא לא הפתרון, אבל שילוב של מידע מכמה מדידות שונות יאפשר לשחזר את המצב בודאות. מכאן מגיע השם של השיטה שאציג - <strong>טומוגרפיה קוונטית</strong>. בעולם האמיתי, "טומוגרפיה" הוא שם של טכניקה בתחומים רבים ושונים שמאפשרת לשחזר מידע על אובייקט מורכב (חומרים, איברים בגוף וכו') על ידי מדידה של "חתכים" שלו. כאן צריך לחשוב על מדידה בבסיס ספציפי (שנותנת הסתברויות) בתור "חתך" שכזה. אבל כמה חתכים צריך? כמה מידע צריך לשחזר?</p>
<p>בואו נסבך קצת יותר את הסיטואציה. מה אם התהליך שמייצר את המצב הקוונטי שלנו איננו דטרמיניסטי, למרות שהוא בעל חוקיות ברורה? למשל: התהליך קודם מייצר את המצב <span class="math">\(\left|+\right\rangle \)</span>, ואז התהליך עצמו מודד אותו בבסיס <span class="math">\(Z\)</span> וכמובן שלא מספר לנו מה התוצאה. זה אומר שהמצב הקוונטי שאנחנו מנסים לבצע לו טומוגרפיה הוא <span class="math">\(\left|0\right\rangle \)</span> בהסתברות <span class="math">\(\frac{1}{2}\)</span> ו-<span class="math">\(\left|1\right\rangle \)</span> בהסתברות <span class="math">\(\frac{1}{2}\)</span>. מדידה בבסיס <span class="math">\(Z\)</span> תיתן לנו את וקטור ההסתברויות <span class="math">\(\left(\begin{array}{c} 0.5\\ 0.5 \end{array}\right)\)</span> וגם מדידה בבסיס <span class="math">\(X\)</span> תיתן לנו את אותו וקטור הסתברויות - סיטואציה שונה מאלו שראינו קודם, שממחישה שכשאנחנו משחזרים מצב, אנחנו לא רוצים לשחזר <strong>וקטור</strong> אלא <strong>מטריצה</strong> - את מטריצת הצפיפות שמתארת את המצב. כלומר, אם אנחנו מתעסקים עם מצב של קיוביט יחיד, אנחנו רוצים לשחזר מטריצה <span class="math">\(\rho=\left(\begin{array}{cc} \alpha & \beta\\ \gamma & \delta \end{array}\right)\)</span>.</p>
<p>עכשיו, כשדיברנו על מטריצות צפיפות ראינו ש-<span class="math">\(\text{tr}\rho=1\)</span>, כלומר <span class="math">\(\alpha+\delta=1\)</span>, מה שאומר שאפשר להסיק את <span class="math">\(\delta\)</span> מתוך <span class="math">\(\alpha\)</span>. נשארו לנו שלושה פרמטרים שצריך להסיק - שלוש "דרגות חופש" של המטריצה. האינטואיציה שלנו מאלגברה לינארית אולי אומרת לנו שצריך, אם כן, מערכת של שלוש משוואות לינאריות שמערבת את <span class="math">\(\rho\)</span> איכשהו, וזה במקרה הממוזל שבכלל אפשר להסיק את <span class="math">\(\rho\)</span> ממערכת משוואות לינארית שכזו. זה מה שיפה כאן - בתנאים האידאליים שלנו (שבהם וקטורי ההסתברויות נתונים לנו במדויק) זה אכן כל מה שצריך, פתרון של מערכת משוואות לינארית. אבל איזו?</p>
<p>כזכור מהפוסט הקודם על מטריצות צפיפות, אם אני במצב <span class="math">\(\rho\)</span> ואני מודד אותו עם קבוצת אופרטורי מדידה כלשהי, אז ההסתברות ש-<span class="math">\(M_{i}\)</span> יעלה בגורל היא <span class="math">\(p\left(i\right)=\text{tr}\left(M_{i}^{\dagger}M_{i}\rho\right)\)</span>. זו אחלה משוואה בזכות עצמה, אבל אם רוצים לפשט אותה קצת, אפשר לעבור שוב ללשון של וקטורים. על מטריצה <span class="math">\(A\)</span> מסדר <span class="math">\(n\times m\)</span> קל מאוד לחשוב בתור וקטור מאורך <span class="math">\(n\cdot m\)</span>: נאמר, וקטור שמכיל קודם כל את אברי <strong>השורה הראשונה</strong> של <span class="math">\(A\)</span>, ואז השורה השניה וכן הלאה; או <strong>העמודה הראשונה</strong> של <span class="math">\(A\)</span> ואז העמודה השניה וכן הלאה. אני אלך לפי הקונבנציה שלוקחים את <strong>השורות</strong> בזו אחר זו, אבל שתי הגישות נפוצות ואין עדיפות עקרונית לאחת מהן.</p>
<p>אם כן, אם אם <span class="math">\(A\)</span> היא מטריצה מסדר <span class="math">\(n\times m\)</span>, אני אסמן ב-<span class="math">\(\left|\left.A\right\rangle \right\rangle \)</span> את וקטור <strong>העמודה</strong> מאורך <span class="math">\(n\cdot m\)</span> שאבריו לפי הסדר הם <span class="math">\(a_{11},\ldots,a_{1m},a_{21},\ldots,a_{nm}\)</span>. הנה דוגמא קונקרטית עבור מטריצת <span class="math">\(2\times3\)</span>:</p>
<p><span class="math">\(A=\left(\begin{array}{ccc} a_{11} & a_{12} & a_{13}\\ a_{21} & a_{22} & a_{23} \end{array}\right)\)</span></p>
<p>במקרה הזה נקבל</p>
<p><span class="math">\(\left|\left.A\right\rangle \right\rangle =\left(\begin{array}{cccccc} a_{11} & a_{12} & a_{13} & a_{21} & a_{22} & a_{23}\end{array}\right)^{T}\)</span></p>
<p>עכשיו, כמו שהגדרתי בשעתו <span class="math">\(\left\langle \psi\right|=\left(\left|\psi\right\rangle \right)^{\dagger}\)</span> אני יכול להגדיר גם <span class="math">\(\left\langle \left\langle A\right.\right|=\left(\left|\left.A\right\rangle \right\rangle \right)^{\dagger}\)</span>, ואז אני מקבל את השוויון היפה</p>
<p><span class="math">\(\left\langle \left\langle A\right.\right|\left|\left.B\right\rangle \right\rangle =\text{tr}\left(A^{\dagger}B\right)\)</span></p>
<p>קל לבדוק שזה אכן מתקיים:</p>
<p><span class="math">\(\text{tr}\left(A^{\dagger}B\right)=\sum_{k=1}^{m}\left[A^{\dagger}B\right]_{kk}=\sum_{k=1}^{m}\sum_{i=1}^{n}\left[A^{\dagger}\right]_{ki}\left[B\right]_{ik}=\)</span></p>
<p><span class="math">\(=\sum_{k=1}^{m}\sum_{i=1}^{n}\overline{\left[A\right]_{ik}}\left[B\right]_{ik}=\left\langle \left\langle A\right.\right|\left|\left.B\right\rangle \right\rangle \)</span></p>
<p>שימו לב שהמעבר האחרון לא כל כך מתעניין בשאלה אם האופן שבו <span class="math">\(A,B\)</span> הפכו לוקטור היה לפי שורות, עמודות, או כל סדר אחר; לכן הבחירה שלי ללכת על פי שורות היא קונבנציה ולא משהו קריטי.</p>
<p>אגב, לא נכנסתי לפרטים הללו כאן, אבל <span class="math">\(\text{tr}\left(A^{\dagger}B\right)\)</span> מגדיר לנו <strong>מכפלה פנימית</strong> על המרחב הוקטורי של המטריצות מהסדר המתאים; זו לא פעולה אקראית שצצה משום מקום. בהקשר שלנו, <span class="math">\(\text{tr}\left(M_{i}^{\dagger}M_{i}\rho\right)\)</span> זה הערך שמעניין אותנו, ואנחנו יכולים לנצל את זה ש-<span class="math">\(\left(M_{i}^{\dagger}M_{i}\right)^{\dagger}=M_{i}^{\dagger}M_{i}\)</span> כדי לכתוב</p>
<p><span class="math">\(p\left(i\right)=\left\langle \left\langle M_{i}^{\dagger}M_{i}\right.\right|\left|\left.\rho\right\rangle \right\rangle \)</span></p>
<p>למעשה, כדי לפשט עניינים, נוח לסמן <span class="math">\(E_{i}=M_{i}^{\dagger}M_{i}\)</span> ולעבור לתאר מדידות עם ה-<span class="math">\(E_{i}\)</span>-ים הללו, שמקיימים <span class="math">\(\sum E_{i}=I\)</span> וכל <span class="math">\(E_{i}\)</span> הוא מטריצה חיובית (במובן שתיארתי בפוסט הקודם: <span class="math">\(\left\langle \psi\right|E_{i}\left|\psi\right\rangle >0\)</span> לכל <span class="math">\(\left|\psi\right\rangle \ne0\)</span>). אפשר לעשות את ההפך, <strong>להתחיל</strong> מסט של אופרטורים שמקיימים את שתי התכונות הללו ולהסיק ממנו <span class="math">\(M_{i}\)</span>-ים שנותנים לנו מדידה; הפורמליזם שבו עובדים עם ה-<span class="math">\(E_{i}\)</span>-ים נקרא פורמליזם ה-POVM (ראשי תיבות של Positive Operator Valued Measurements), אבל אני לא נכנס לעובי הקורה הזה.</p>
<p>סיכום ביניים: אם יש לי מדידה עם אופרטור מתאים <span class="math">\(E_{i}\)</span>, אני מקבל</p>
<p><span class="math">\(p\left(i\right)=\left\langle \left\langle E_{i}\right.\right|\left|\left.\rho\right\rangle \right\rangle \)</span></p>
<p>את הפעולה הזו אפשר לתאר בתור כפל של השורה <span class="math">\(\left\langle \left\langle E_{i}\right.\right|\)</span> בעמודה <span class="math">\(\left|\left.\rho\right\rangle \right\rangle \)</span>, והיא מתאימה לתוצאה אפשרית <strong>אחת </strong>של מדידה אפשרית <strong>אחת</strong> של <span class="math">\(\rho\)</span>. אני יכול לאסוף בצורה הזו הרבה שורות, שמתאימות למדידות שונות, ולקבל מטריצה <span class="math">\(M\)</span>, ואז יש לי את מערכת המשוואות</p>
<p><span class="math">\(M\left|\left.\rho\right\rangle \right\rangle =\vec{p}\)</span></p>
<p>כאשר <span class="math">\(\vec{p}\)</span> הוא וקטור ההסתברויות: וקטור של סקלרים, שבו הכניסה ה-<span class="math">\(i\)</span> מתאימה למדידה על פי האופרטור שרשום בשורה ה-<span class="math">\(i\)</span> של <span class="math">\(M\)</span>.</p>
<p>כל זה מתוסבך נורא, אז בואו נראה דוגמא קונקרטית עבור המקרה של קיוביט בודד. כבר דיברתי על מדידה של קיוביט בבסיסים <span class="math">\(Z,X\)</span> שנגזרים מאופרטורי פאולי <span class="math">\(X,Z\)</span>; אני אזכיר איך בדיוק הם נגזרים, ואעשה את אותו דבר בדיוק גם עבור <span class="math">\(Y\)</span>.</p>
<p>נתחיל עם <span class="math">\(X=\left(\begin{array}{cc} 0 & 1\\ 1 & 0 \end{array}\right)\)</span>. הרעיון הוא שבגלל שזה אופרטור הרמיטי, קיים לו <strong>פירוק ספקטרלי</strong>, כלומר שאפשר לכתוב <span class="math">\(X=\sum\lambda P_{\lambda}^{X}\)</span>: צירוף לינארי שהמקדמים <span class="math">\(\lambda\)</span> שלו הם הערכים העצמיים השונים של <span class="math">\(X\)</span> ו-<span class="math">\(P_{\lambda}^{X}\)</span> הוא אופרטור ההטלה למרחב העצמי שמתאים ל-<span class="math">\(\lambda\)</span>. עבור <span class="math">\(X\)</span> (וגם עבור <span class="math">\(Y,Z\)</span>) הערכים העצמיים הם <span class="math">\(\pm1\)</span> ולכן מקבלים</p>
<p><span class="math">\(X=1\cdot P_{1}^{X}+\left(-1\right)\cdot P_{-1}^{X}\)</span></p>
<p>בדיקה זריזה מעלה ש-</p>
<p><span class="math">\(P_{1}^{X}=\frac{1}{2}\left(\begin{array}{cc} 1 & 1\\ 1 & 1 \end{array}\right),P_{-1}^{X}=\frac{1}{2}\left(\begin{array}{cc} 1 & -1\\ -1 & 1 \end{array}\right)\)</span></p>
<p>עבור <span class="math">\(Y=\left(\begin{array}{cc} 0 & -i\\ i & 0 \end{array}\right)\)</span> נקבל</p>
<p><span class="math">\(P_{1}^{Y}=\frac{1}{2}\left(\begin{array}{cc} 1 & -i\\ i & 1 \end{array}\right),P_{-1}^{Y}=\frac{1}{2}\left(\begin{array}{cc} 1 & i\\ -i & 1 \end{array}\right)\)</span></p>
<p>ועבור <span class="math">\(Z=\left(\begin{array}{cc} 1 & 0\\ 0 & -1 \end{array}\right)\)</span> נקבל</p>
<p><span class="math">\(P_{1}^{Z}=\left(\begin{array}{cc} 1 & 0\\ 0 & 0 \end{array}\right),P_{-1}^{Z}=\left(\begin{array}{cc} 0 & 0\\ 0 & 1 \end{array}\right)\)</span></p>
<p>ה-<span class="math">\(P\)</span>-ים הללו הם ה-<span class="math">\(M_{i}\)</span>-ים בשיטת הכתיב הקודמת שלי, כך שאנחנו רוצים לקבל מהם את <span class="math">\(E_{i}=M_{i}^{\dagger}M_{i}\)</span>, אבל מכיוון שאלו אופרטורים הרמיטיים (כלומר <span class="math">\(M_{i}^{\dagger}=M_{i}\)</span>) והטלות (כלומר <span class="math">\(M_{i}^{2}=M_{i}\)</span>) נקבל בדיוק את אותם אופרטורים. אז כדי לבנות את המטריצה <span class="math">\(M\)</span> שדיברתי עליה צריך לעשות שני דברים: לפרוש אותם לשורה אחת ארוכה כל אחד, ולהצמיד את האיברים (כי כזכור, <span class="math">\(\left\langle \left\langle E_{i}\right.\right|\)</span> מסמל את <span class="math">\(\left(\left|\left.E_{i}\right\rangle \right\rangle \right)^{\dagger}\)</span>). לכן <span class="math">\(P_{1}^{Y}\)</span> יהפוך אל <span class="math">\(\left(\begin{array}{cccc} \frac{1}{2} & -\frac{i}{2} & \frac{i}{2} & \frac{1}{2}\end{array}\right)\)</span> אחרי השיטוח ואל <span class="math">\(\left(\begin{array}{cccc} \frac{1}{2} & \frac{i}{2} & -\frac{i}{2} & \frac{1}{2}\end{array}\right)\)</span> אחרי ההצמדה. בסך הכל נקבל את המטריצה</p>
<p><span class="math">\(M=\left(\begin{array}{cccc} \frac{1}{2} & \frac{1}{2} & \frac{1}{2} & \frac{1}{2}\\ \frac{1}{2} & -\frac{1}{2} & -\frac{1}{2} & \frac{1}{2}\\ \frac{1}{2} & \frac{i}{2} & -\frac{i}{2} & \frac{1}{2}\\ \frac{1}{2} & -\frac{i}{2} & \frac{i}{2} & \frac{1}{2}\\ 1 & 0 & 0 & 0\\ 0 & 0 & 0 & 1 \end{array}\right)\)</span></p>
<p>עכשיו, הרעיון הוא כזה: יש לנו מצב קוונטי <span class="math">\(\rho\)</span> שאנחנו לא יודעים מהו. אנחנו מודדים אותו בבסיסים <span class="math">\(X,Y,Z\)</span> ומקבלים התפלגות של תוצאות. לכל בסיס אנחנו מקבלים שתי תוצאות, אחת לכל אחד מהערכים העצמיים (שתי התוצאות הללו מסתכמות ל-1, אז הן לא בלתי תלויות זו בזו). את התוצאות הללו אנחנו מכניסים לוקטור <span class="math">\(\vec{p}\)</span>, ואז אנחנו מקבלים<strong> מערכת משוואות לינארית:</strong></p>
<p><span class="math">\(M\left|\left.\rho\right\rangle \right\rangle =\vec{p}\)</span></p>
<p>כאן <span class="math">\(M,\vec{p}\)</span> ידועים ו-<span class="math">\(\left|\left.\rho\right\rangle \right\rangle \)</span> הוא הנעלם שאנחנו רוצים לשחזר. איך פותרים מערכת משוואות לינארית? בדרך כלל מחשבים את <span class="math">\(M^{-1}\)</span> וכופלים בה את שני האגפים ומקבלים <span class="math">\(\left|\left.\rho\right\rangle \right\rangle =M^{-1}\vec{p}\)</span>, אלא שזה פשוט לא יכול לעבוד כאן, כי <span class="math">\(M\)</span> <strong>גדולה מדי</strong> - היא לא מטריצה ריבועית. יש לה רק ארבע עמודות, אבל שש שורות. אפשר, כמובן, להסיר חלק מהשורות הללו, אבל אפשר גם לעשות משהו אחר.</p>
<p>כאמור, <span class="math">\(M\)</span> היא לא מטריצה ריבועית, אבל <span class="math">\(M^{\dagger}M\)</span> היא כן מטריצה ריבועית, ובתקווה היא גם הפיכה (במקרה שלנו היא אכן יוצאת הפיכה; אם היא לא יוצאת הפיכה זה אומר שבחרנו למדוד את <span class="math">\(\rho\)</span> בשילוב בסיסים שהוא לא <strong>מלא טומוגרפית</strong> - אי אפשר להשתמש בו בשביל טומוגרפיה). ועכשיו תראו איזה קסם אני עושה. אני מתחיל עם <span class="math">\(M\left|\left.\rho\right\rangle \right\rangle =\vec{p}\)</span>, כופל את שני האגפים ב-<span class="math">\(M^{\dagger}\)</span> ומקבל <span class="math">\(M^{\dagger}M\left|\left.\rho\right\rangle \right\rangle =M^{\dagger}\vec{p}\)</span>, ואז אני כופל בהופכית של <span class="math">\(M^{\dagger}M\)</span> ומקבל:</p>
<p><span class="math">\(\left|\left.\rho\right\rangle \right\rangle =\left(M^{\dagger}M\right)^{-1}M^{\dagger}\vec{p}\)</span></p>
<p>וכך אני מצליח לשחזר את <span class="math">\(\rho\)</span> המקורית!</p>
<p>בואו נראה איך זה עובד בפועל. אם תחשבו, תקבלו ש-</p>
<p><span class="math">\(M^{\dagger}M=\left(\begin{array}{cccc} 2 & 0 & 0 & 1\\ 0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0\\ 1 & 0 & 0 & 2 \end{array}\right)\)</span></p>
<p>ההופכית שלה היא</p>
<p><span class="math">\(\left(M^{\dagger}M\right)^{-1}=\left(\begin{array}{cccc} \frac{2}{3} & 0 & 0 & -\frac{1}{3}\\ 0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0\\ -\frac{1}{3} & 0 & 0 & \frac{2}{3} \end{array}\right)\)</span></p>
<p>ולכן מקבלים בסוף</p>
<p><span class="math">\(\left(M^{\dagger}M\right)^{-1}M^{\dagger}=\left(\begin{array}{cccccc} \frac{1}{6} & \frac{1}{6} & \frac{1}{6} & \frac{1}{6} & \frac{2}{3} & -\frac{1}{3}\\ \frac{1}{2} & -\frac{1}{2} & -\frac{i}{2} & \frac{i}{2} & 0 & 0\\ \frac{1}{2} & -\frac{1}{2} & \frac{i}{2} & -\frac{i}{2} & 0 & 0\\ \frac{1}{6} & \frac{1}{6} & \frac{1}{6} & \frac{1}{6} & -\frac{1}{3} & \frac{2}{3} \end{array}\right)\)</span></p>
<p>זו המטריצה הקסומה שכשכופלים אותה בוקטור ההסתברויות <span class="math">\(\vec{p}\)</span> שקיבלנו מהניסוי, משחזרים את המצב <span class="math">\(\rho\)</span> המקורי. בואו ננסה למשל לשחזר את <span class="math">\(\rho\)</span> שמתאר את הסיטואציה שבה אנחנו ב-<span class="math">\(\left|0\right\rangle ,\left|1\right\rangle \)</span> בהסתברות חצי-חצי. אנחנו כבר יודעים שתוצאות המדידה בבסיס <span class="math">\(X\)</span> הולכות להיות <span class="math">\(\left(\frac{1}{2},\frac{1}{2}\right)\)</span> בגלל שלא משנה אם אנחנו ב-<span class="math">\(\left|0\right\rangle \)</span> או ב-<span class="math">\(\left|1\right\rangle \)</span>, מדידה בבסיס <span class="math">\(X\)</span> מתפלגת חצי-חצי עבור שני המצבים הללו. בנוסף אנחנו יודעים שגם המדידה בבסיס <span class="math">\(Z\)</span> הולכת להיות <span class="math">\(\left(\frac{1}{2},\frac{1}{2}\right)\)</span> מסיבה שונה: אם אנחנו ב-<span class="math">\(\left|0\right\rangle \)</span> אז המדידה תחזיר בודאות <span class="math">\(\left|0\right\rangle \)</span> אבל אנחנו ב-<span class="math">\(\left|0\right\rangle \)</span> רק בהסתברות <span class="math">\(\frac{1}{2}\)</span> מראש. מה שעוד לא דיברתי עליו הוא מה קורה במדידה בבסיס <span class="math">\(Y\)</span>, אבל חישוב עם הנוסחה <span class="math">\(p\left(i\right)=\left\langle \psi\right|E_{i}\left|\psi\right\rangle \)</span> מראה שגם במקרה זה, לא משנה אם אנחנו ב-<span class="math">\(\left|0\right\rangle \)</span> או ב-<span class="math">\(\left|1\right\rangle \)</span>, ההסתברות לכל תוצאה היא <span class="math">\(\frac{1}{2}\)</span>. לכן בסך הכל </p>
<p><span class="math">\(\vec{p}=\left(\begin{array}{c} \frac{1}{2}\\ \frac{1}{2}\\ \frac{1}{2}\\ \frac{1}{2}\\ \frac{1}{2}\\ \frac{1}{2} \end{array}\right)\)</span></p>
<p>עכשיו נחשב ונקבל</p>
<p><span class="math">\(\left(M^{\dagger}M\right)^{-1}M^{\dagger}\vec{p}=\left(\begin{array}{c} \frac{1}{2}\\ 0\\ 0\\ \frac{1}{2} \end{array}\right)\)</span></p>
<p>וכשמשחזרים מזה את המטריצה המקורית מקבלים <span class="math">\(\left(\begin{array}{cc} \frac{1}{2} & 0\\ 0 & \frac{1}{2} \end{array}\right)\)</span>, כפי שציפינו.</p>
<p>מה אם במקום זה היינו במצב <span class="math">\(\left|+\right\rangle \)</span> בהתחלה? כזכור, זה משפיע על המדידות בבסיס <span class="math">\(X\)</span> שיוצאות <span class="math">\(\left(\begin{array}{c} 1\\ 0 \end{array}\right)\)</span>, אבל אם עושים את החישובים עבור בסיסים <span class="math">\(Y,Z\)</span> עדיין מקבלים חצי חצי, כלומר וקטור ההסתברויות במקרה זה הוא</p>
<p><span class="math">\(\left(\begin{array}{c} 1\\ 0\\ \frac{1}{2}\\ \frac{1}{2}\\ \frac{1}{2}\\ \frac{1}{2} \end{array}\right)\)</span></p>
<p>ועכשיו מקבלים:</p>
<p><span class="math">\(\left(M^{\dagger}M\right)^{-1}M^{\dagger}\vec{p}=\left(\begin{array}{c} \frac{1}{2}\\ \frac{1}{2}\\ \frac{1}{2}\\ \frac{1}{2} \end{array}\right)\)</span></p>
<p>כלומר <span class="math">\(\rho=\left(\begin{array}{cc} \frac{1}{2} & \frac{1}{2}\\ \frac{1}{2} & \frac{1}{2} \end{array}\right)\)</span> כמו שציפינו לקבל.</p>
<p>יפה, אז אנחנו רואים שאפשר לבצע את הקסם של שיחזור <span class="math">\(\rho\)</span> מתוך מדידות, אבל <strong>איך</strong> מבצעים את המדידות הללו? כמובן, אם אנחנו אלו שמתעסקים במחשב הקוונטי ברמת המימוש (או בניסוי הקוונטי שעושים; טומוגרפיה קוונטית לא חייבת להיות של מצב במחשב קוונטי) אנחנו אולי יכולים לממש סוגים שונים של מדידות. אבל נאמר שאנחנו עובדים עם מחשב קוונטי שיודע למדוד רק בבסיס <span class="math">\(Z\)</span>, האם יש דרך לבצע מדידות גם בבסיסים אחרים?</p>
<p>ובכן, יש. בואו ניזכר במשהו שכבר הראיתי פעם-פעמיים, עבור המטריצה <span class="math">\(H=\frac{1}{\sqrt{2}}\left(\begin{array}{cc} 1 & 1\\ 1 & -1 \end{array}\right)\)</span>:</p>
<p><span class="math">\(H^{\dagger}ZH=X\)</span></p>
<p>אפשר לראות את זה על ידי חישוב מפורש. זה כמובן עובר לרמת ההטלות:</p>
<p><span class="math">\(X=H^{\dagger}ZH=H^{\dagger}\left(P_{1}^{Z}-P_{-1}^{Z}\right)H=H^{\dagger}P_{1}^{Z}H-H^{\dagger}P_{-1}^{Z}H\)</span></p>
<p>ומכאן אפשר להסיק שלכל מצב <span class="math">\(\left|\psi\right\rangle \)</span> מתקיים</p>
<p><span class="math">\(\left\langle \psi\right|P_{\lambda}^{X}\left|\psi\right\rangle =\left\langle \psi\right|H^{\dagger}P_{1}^{Z}H\left|\psi\right\rangle =\left\langle H\psi\right|P_{1}^{Z}\left|H\psi\right\rangle \)</span></p>
<p>כלומר, אפשר להמיר מדידה בבסיס <span class="math">\(X\)</span> של <span class="math">\(\left|\psi\right\rangle \)</span> במדידה בבסיס <span class="math">\(Z\)</span> של <span class="math">\(H\left|\psi\right\rangle \)</span> - התפלגות התוצאות שנקבל תהיה זהה. זה באמת מה שעושים במחשב קוונטי - מעגל אחד שפשוט מייצר את המצב הקוונטי עבור מדידה בבסיס <span class="math">\(Z\)</span>, מעגל אחר שמייצר את המצב הקוונטי ואז מפעיל עליו <span class="math">\(H\)</span> עבור מדידה בבסיס <span class="math">\(X\)</span>. ומה עם בסיס <span class="math">\(Y\)</span>? ובכן, <span class="math">\(SXS^{\dagger}=Y\)</span> עבור <span class="math">\(S=\left(\begin{array}{cc} 1 & 0\\ 0 & i \end{array}\right)\)</span>, ולכן <span class="math">\(\left(HS^{\dagger}\right)^{\dagger}Z\left(HS^{\dagger}\right)=Y\)</span>, ומכאן שכדי למדוד בבסיס <span class="math">\(Y\)</span> קודם מפעילים על המצב <span class="math">\(S^{\dagger}\)</span>, אחר כך מפעילים עליו <span class="math">\(H\)</span> ואז מודדים בבסיס <span class="math">\(Z\)</span> כרגיל.</p>
<p>כל הדיון עד כה התעסק בסיטואציה של קיוביט בודד. אבל מה אם <span class="math">\(\rho\)</span> הוא מצב של מערכת על <span class="math">\(n\)</span> קיוביטים? נתחיל מ-<span class="math">\(n=2\)</span>. במקרה הזה, אנחנו מסתכלים על כל הזוגות <span class="math">\(\left(P_{1},P_{2}\right)\)</span> כאשר <span class="math">\(P_{i}\in\left\{ X,Y,Z\right\} \)</span> - בסך הכל תשעה זוגות כאלו. כל זוג מגדיר לנו מעגל אחר עם מדידות אחרות. למשל, <span class="math">\(\left(X,Y\right)\)</span> פירושו "למדוד את הקיוביט הראשון בבסיס <span class="math">\(X\)</span> ואת השני בבסיס <span class="math">\(Y\)</span>", כששתי המדידות הללו מבוצעות בצורה שתיארתי זה עתה. מה שמתקבל הוא 4 תוצאות מדידה אפשריות: <span class="math">\(00,01,10,11\)</span>, שכל אחת נותנת לנו הסתברות אחרת ותקבל שורה משלה בוקטור <span class="math">\(\vec{p}\)</span> - כלומר, זה יהיה וקטור עם 36 כניסות. עבור <span class="math">\(n\)</span> כללי, אנחנו מסתכלים על כל ה-<span class="math">\(n\)</span>-יות <span class="math">\(\left(P_{1},\ldots,P_{n}\right)\)</span> כאשר <span class="math">\(P_{i}\in\left\{ X,Y,Z\right\} \)</span>. יש בסך הכל <span class="math">\(3^{n}\)</span> <span class="math">\(n\)</span>-יות כאלו וכל <span class="math">\(n\)</span>-יה כזו מגדירה <span class="math">\(2^{n}\)</span> תוצאות מדידה אפשריות... כפי שאפשר לראות, זה גדל אקספוננציאלית. זה אומר שבפועל, טומוגרפיה הופכת למשהו <strong>בלתי יישים בעליל</strong> עבור יותר ממספר זעיר של קיוביטים; מה שעושים בפועל הוא טומוגרפיה רק לחלק מהקיוביטים במערכת במקום לכולם.</p>
<p>הנה למשל מעגל טומוגרפיה על שני קיוביטים שקודם כל מייצר את המצב השזור <span class="math">\(\frac{\left|00\right\rangle +\left|11\right\rangle }{\sqrt{2}}\)</span> (או, אם לחדד את הפואנטה מאחורי טומוגרפיה קוונטית, קודם <strong>מנסה </strong>ליצור<strong> </strong>את המצב הזה, ומטרת הטומוגרפיה היא לראות כמה הוא הצליח בזה) ולאחר מכן מודד את הקיוביט הראשון בבסיס <span class="math">\(X\)</span> ואת השני בבסיס <span class="math">\(Y\)</span>:</p>
<p><img src="/img/2022/qst.png" alt=""/></p>
<p>לסיום, אי אפשר לוותר על רגע ה"כל מה שאמרתי לכם עד כה היה שקר גמור" הבלתי נמנע. כלומר, לא שיקרתי בשום צורה, אבל כן הזנחתי את העניין המרכזי. אי שם בתחילת הפוסט אמרתי שבואו נניח לצורך פשטות שיש לי את הערכים המדויקים של <span class="math">\(\vec{p}\)</span>, שזה נחמד אבל זה <strong>לא משהו שהולך להתקבל בניסוי</strong>. בניסוי אני לא אקבל <span class="math">\(\frac{1}{2}\)</span> אלא זוועה כמו <span class="math">\(\frac{483}{1000}\)</span>. בסיטואציה כזו, הוקטור <span class="math">\(\vec{p}\)</span> שקיבלתי הוא לא מדויק; שיטת היפוך המטריצה שהצגתי לא רק שלא תחזיר את <span class="math">\(\rho\)</span> הנכונה אלא רק קירוב שלה (את זה אפשר לסבול, בכל מקרה אנחנו לא מצפים לדיוק מוחלט), אבל גרוע מזה - סביר להניח שהיא תחזיר <span class="math">\(\rho\)</span> <strong>שאינה מטריצת צפיפות</strong>, כלומר אינה בעלת עקבה 1 או שאינה חיובית. זו כבר בעיה משמעותית יותר - בדרך כלל אנחנו רוצים שטומוגרפיה תחזיר לנו מצב קוונטי שהוא קירוב של המצב האמיתי, לא שתחזיר לנו קירוב שאיננו אמיתי.</p>
<p>זה אומר שנוקטים בשיטת פתרון אחרת, שנעזרת בכלים סטנדרטיים של אופטימיזציה: מה שאנחנו רוצים הוא להביא למינימום את הביטוי</p>
<p><span class="math">\(\|M\left|\left.\rho\right\rangle \right\rangle -\vec{p}\|\)</span></p>
<p>כאשר אברי <span class="math">\(\left|\left.\rho\right\rangle \right\rangle \)</span> הם המשתנים של בעיית האופטימיזציה, והם כפופים לאילוצים נוספים שמבטיחים ש-<span class="math">\(\rho\)</span> תהיה מטריצת צפיפות תקינה. חשבתי להיכנס כאן לעובי הקורה של איך עושים את זה, ואולי אעשה את זה בהמשך, אבל נראה לי שעדיף לשמור על הפוסט הזה ממוקד יחסית.</p>
<p>עוד בעיה שצריך להביא בחשבון היא שחישוב קוונטי הוא תהליך <strong>רועש</strong>. זה אומר שבביצוע תהליך המדידה עצמה עשויות להצטבר בעיות; וגרוע לא פחות - גם בשערי ה-<span class="math">\(H\)</span> וה-<span class="math">\(S^{\dagger}\)</span> שאנחנו משתמשים בהם כדי למדוד בבסיסים שונים גם כן עשויות להצטבר בעיות. מה שהיינו רוצים הוא שיטת טומוגרפיה שאיכשהו מביאה את זה בחשבון, ואמנם יש כזו (במחיר של סיבוכיות הרבה יותר גדולה של מה שהיא עושה) שנקראת Gate Set Tomography, אבל לפני שאדבר עליה צריך לחזור אל השאלה שבה סיימתי את הפוסט הקודם - איך בעצם ממדלים שינויים שיכולים להתבצע על מערכת קוונטית, וספציפית איך ממדלים רעשים?</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>