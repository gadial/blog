<!DOCTYPE html>
<html lang="he" dir="rtl"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>חישוב קוונטי: האלגוריתם של שור | לא מדויק</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="חישוב קוונטי: האלגוריתם של שור" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="האלגוריתם של שור הוא הקלף המנצח של חישוב קוונטי: גם פותר בעיה פרקטית מעניינת, וגם עושה את זה עם המון מתמטיקה מגניבה מסוגים שונים ומשונים" />
<meta property="og:description" content="האלגוריתם של שור הוא הקלף המנצח של חישוב קוונטי: גם פותר בעיה פרקטית מעניינת, וגם עושה את זה עם המון מתמטיקה מגניבה מסוגים שונים ומשונים" />
<link rel="canonical" href="http://gadial.net/2022/09/30/shor_algorithm_revisit/" />
<meta property="og:url" content="http://gadial.net/2022/09/30/shor_algorithm_revisit/" />
<meta property="og:site_name" content="לא מדויק" />
<meta property="og:image" content="http://gadial.net/2022/shor_algorithm.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-30T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="http://gadial.net/2022/shor_algorithm.png" />
<meta property="twitter:title" content="חישוב קוונטי: האלגוריתם של שור" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://gadial.net/2022/09/30/shor_algorithm_revisit/","image":"http://gadial.net/2022/shor_algorithm.png","headline":"חישוב קוונטי: האלגוריתם של שור","dateModified":"2022-09-30T00:00:00+00:00","datePublished":"2022-09-30T00:00:00+00:00","description":"האלגוריתם של שור הוא הקלף המנצח של חישוב קוונטי: גם פותר בעיה פרקטית מעניינת, וגם עושה את זה עם המון מתמטיקה מגניבה מסוגים שונים ומשונים","mainEntityOfPage":{"@type":"WebPage","@id":"http://gadial.net/2022/09/30/shor_algorithm_revisit/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/favicon.ico" type="image/x-icon"><link type="application/atom+xml" rel="alternate" href="http://gadial.net/feed.xml" title="לא מדויק" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-3924539-2', 'auto');
  ga('send', 'pageview');
}
</script>
  
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        processEscapes: true
      },
      TeX: {extensions: ["AMSmath.js","AMSsymbols.js"]},
      "HTML-CSS": { 
        linebreaks: { automatic: true }
      },
      SVG: { 
        linebreaks: { automatic: true } 
      }
    });
  </script>
  <!-- "https://www.gadial.net/wp-includes/js/xypic.js" -->

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

</head>
<body><header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <a class="navbar-brand" href="/">לא מדויק</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarCollapse">
      <ul class="navbar-nav mr-auto">
        
            
            <li class="nav-item">
                <a class="nav-link" href="/lecture_notes">סיכומי הרצאות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/">דף הבית</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/categories">קטגוריות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/random">דף אקראי</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">אודות</a>
            </li>
            
        
      </ul>
      <form class="form-inline mt-2 mt-md-0" action="/post_list/" method="get">
        <input class="form-control mr-sm-2" type="text" placeholder="חיפוש" aria-label="חיפוש" name="s">
        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">חיפוש</button>
      </form>
    </div>
  </nav>
</header><main class="page-content" aria-label="Content" role="main">
      <div class="wrapper text-right">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><div class="PageNavigation">
    
      <a class="prev" href="/2022/09/06/phase_estimation_algorithm/">&laquo; חישוב קוונטי: אלגוריתם הערכת פאזה</a>
    
    
      <a class="next" href="/2022/10/09/density_matrices/">חישוב קוונטי: פורמליזם מטריצות הצפיפות &raquo;</a>
    
  </div><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">חישוב קוונטי: האלגוריתם של שור</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-09-30T00:00:00+00:00" itemprop="datePublished">Sep 30, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2>מבוא</h2>

<p>סדרת הפוסטים הקודמת שלי על חישוב קוונטי הסתיימה <a href="https://gadial.net/2014/08/24/shor_algorithm/">בפוסט גדול על האלגוריתם של שור</a>. אני חושב שהגיע הזמן לתת עוד סיבוב, עם פוסט שייתן מבט רחב יותר על מה הרעיון הכללי של האלגוריתם ואיך הוא עובד, ויוותר על חלק מהפרטים הקטנים שכבר הוכחתי בפוסט המקורי ההוא. היתרון הגדול שלי עכשיו על פני הסיבוב הקודם הוא שכבר היו לי פוסטים נפרדים על <a href="https://gadial.net/2022/09/01/quantum_fourier_transform/">התמרת פורייה הקוונטית</a> ועל <a href="https://gadial.net/2022/09/06/phase_estimation_algorithm/">אלגוריתם הערכת פאזה</a>, שהם הרכיבים הקוונטיים המרכזיים של האלגוריתם, והיכרות איתם מאפשרת להסתכל עליו “ממעוף הציפור”, מה שבלתי אפשרי בלעדיהם.</p>

<p>אז בואו נתחיל עם מעוף הציפור הזה. ראשית, הבעיה שאלגוריתם שור בא לפתור היא בעיית <strong>הפירוק לגורמים</strong>: נתון לנו מספר טבעי <span>\( N \)</span>, ואנחנו מחפשים מספר טבעי <span>\( 1&lt;d&lt;N \)</span> כך ש-<span>\( d \)</span> מחלק את <span>\( N \)</span>. למשל עבור <span>\( N=15 \)</span> אנחנו נשמח לקבל את <span>\( d=3 \)</span> או <span>\( d=5 \)</span>. זו נראית בעיה לא גדולה כל כך במספרים קטנים, אבל כש-<span>\( N \)</span> הוא מספר בן מאות ספרות, אפילו האלגוריתמים המחוכמים ביותר שיש לנו כיום שאינם משתמשים במחשב קוונטי (ואלו אלגוריתמים <strong>מאוד</strong> מחוכמים, עם מתמטיקה <strong>מאוד</strong> מתקדמת) לא מסוגלים להתמודד עם הבעיה, וזה למרות שקל לנו לעשות חשבונות עם מספרים בני מאות ספרות; זו לא סתם בעיה של “המספר גדול מכדי שנעשה איתו כל דבר שהוא” - זו בעיה של <strong>סיבוכיות זמן ריצה אקספוננציאלית</strong>. מה שהאלגוריתם של שור מציע הוא פתרון <strong>מהיר</strong> של הבעיה, בזמן ריצה <strong>פולינומי</strong> (לא חייבים באמת להבין מה המילים הללו אומרות, מעבר לזה שכאן “אקספוננציאלי” זו מילה נרדפת לא מדוייקת ל”איטי” ו”פולינומי” זו מילה נרדפת לא מדוייקת ל”מהיר”). בשביל המהירות הגדולה הזו, האלגוריתם של שור משתמש במחשב קוונטי (אם כי טרם נבנה מחשב קוונטי שמסוגל להריץ את שור עבור מספרים בני מאות ספרות, וזו שאלה טובה מתי יהיה כזה).</p>

<p>אחרי שאמרנו את זה, צריך להבהיר שהאלגוריתם של שור, למעשה, <strong>איננו</strong> אלגוריתם לפירוק לגורמים! הוא אלגוריתם שבא לפתור בעיה אחרת, שנקראת “בעיית מציאת הסדר”, כי היכולת שלנו לפתור את בעיית מציאת הסדר נותנת לנו גם שיטה לפירוק לגורמים, אבל החלק שנעזר במציאת הסדר כדי לפרק לגורמים הוא חלק “קלאסי”, שלא מעורב בו חישוב קוונטי.</p>

<p>עוד נקודה שצריך להבהיר היא שהאלגוריתם של שור הוא <strong>הסתברותי</strong> - ייתכן בהחלט שנריץ אותו, לא נקבל שום דבר שיעזור לנו לפרק את <span>\( N \)</span> לגורמים, ונאלץ להריץ אותו שוב. ההסתברות שהוא יצליח היא טובה למדי, אבל הניתוח שנדרש כדי להראות את זה הוא לא פשוט.</p>

<p>ולבסוף, החלק הקוונטי של האלגוריתם של שור הוא פשוט מקרה ספציפי של אלגוריתם הערכת הפאזה, עבור <span>\( U \)</span> קונקרטי כלשהו שאציג בהמשך. זה מקרה מעניין יותר ממה שדיברנו עליו בפוסט הקודם, כי שם היה נתון לנו <span>\( \left|u\right\rangle  \)</span> שהוא וקטור עצמי של <span>\( U \)</span>, אבל באלגוריתם של שור אין לנו מושג מי הוקטורים העצמיים של <span>\( U \)</span>; אבל באמצעות תעלול מחוכם ויפה, אנחנו הולכים להריץ את אלגוריתם הערכת הפאזה על <strong>סופרפוזיציה</strong> של הערכים העצמיים של <span>\( U \)</span> ואיכשהו זה יסתדר לנו.</p>

<p>גם אחרי שאלגוריתם הערכת הפאזה הסתיים, הפלט שלו הוא לא התוצאה הסופית של שום דבר - הוא בוודאי לא מספר שמחלק את <span>\( N \)</span>, אבל הוא אפילו לא אותו “סדר” מסתורי שאנחנו צריכים למצוא; מה שאלגוריתם הערכת הפאזה נותן לנו הוא מספר רציונלי בין 0 ל-1 שבפני עצמו אין בו כלום; מה שאנחנו עושים (וגם זה חישוב קלאסי לגמרי) הוא ליצור בדרך מסויימת סדרה של <strong>קירובים</strong> לתוצאה הזו של הערכת הפאזה שקיבלנו. כל קירוב כזה יהיה מספר רציונלי <span>\( \frac{s}{r} \)</span>, כשהמכנה <span>\( r \)</span> <strong>עשוי להיות</strong> ה”סדר” שחיפשנו. זה אומר שבהינתן התוצאה של שור, אנחנו מקבלים קבוצה של כמה וכמה מועמדים להיות ה”סדר”, ועבור כל אחד מהם צריך לבדוק אם הוא איכשהו נותן לנו פירוק לגורמים של <span>\( N \)</span>.</p>

<p>זה נשמע ממש מסורבל - איפה זה ואיפה הגרסה האוטופית המדומיינת של האלגוריתם של שור, שבה אנחנו עושים איזה מעגל קוונטי חמוד, מודדים ומקבלים גורם של <span>\( N \)</span>. אבל ככה זה בחישוב קוונטי - זה אף פעם לא פשוט כמו שעושים מזה, אבל כשמבינים את הפרטים המשוגעים זה נהיה עוד יותר יפה משזה נשמע במבט ראשון.</p>

<h2>איך "מציאת סדר" עוזרת לפרק מספר לגורמים?</h2>

<p>בואו ניכנס קצת יותר לפרטים של מה עושים כשרוצים למצוא גורם של <span>\( N \)</span>. המתמטיקה שצריך להכיר פה היא זו של <strong>חשבון מודולרי</strong>, כלומר של ביצוע פעולות חיבור וכפל כשבסוף מחלקים במשהו ולוקחים את השארית. החישובים שלנו יהיו מודולו <span>\( N \)</span>. למשל, אם <span>\( N=15 \)</span> ו-<span>\( a=7 \)</span> אז <span>\( 7^{2} \)</span> מודולו <span>\( N \)</span> הוא שארית החלוקה של 49 ב-15, כלומר 4. כותבים את זה <span>\( 7^{2}\equiv_{N}4 \)</span>. הדבר השני שצריך להכיר הוא את הקיום של אלגוריתם יעיל שבהינתן שני מספרים <span>\( a,b \)</span> מחשב את ה-<span>\( \text{gcd}\left(a,b\right) \)</span> - המספר הגדול ביותר שמחלק את <span>\( a \)</span> וגם את <span>\( b \)</span>. לא חשוב כרגע איך אלגוריתם עושה את זה (<a href="https://gadial.net/2011/09/12/euclidean_algorithm_and_rings/">יש לי פוסט</a>) אלא רק שאפשר לבדוק את זה ביעילות.</p>

<p>מה זה ה”סדר” המסתורי שהאלגוריתם של שור מחשב? זה המושג הסטנדרטי מתורת החבורות: הסדר של <span>\( a \)</span> מודולו <span>\( N \)</span> הוא המספר <span>\( r&gt;0 \)</span> המינימלי שעבורו <span>\( a^{r}\equiv_{N}1 \)</span>. מספר כזה קיים בהכרח רק <span>\( \text{gcd}\left(a,N\right)=1 \)</span>; אבל אם <span>\( \text{gcd}\left(a,N\right)&gt;1 \)</span> אז המספר <span>\( \text{gcd}\left(a,N\right) \)</span> (שאפשר לחשב ביעילות, כאמור) הוא מחלק לא טריוויאלי של <span>\( N \)</span> וסיימנו.</p>

<p>אז איך עובד כל התהליך? ראשית, בודקים ש-<span>\( N \)</span> הוא לא זוגי, כלומר פשוט מנסים לחלק אותו ב-2. אם כן - סיימנו. אחרת, בודקים ש-<span>\( N \)</span> הוא לא חזקה של ראשוני, כלומר <span>\( N=p^{n} \)</span> עבור <span>\( n \)</span> כלשהו. זה כבר עניין טריקי יותר, אבל יש אלגוריתם יעיל שעושה את זה ואני לא מציג אותו כי זה לא באמת קשור לאלגוריתם של שור.</p>

<p>בהינתן ש-<span>\( N \)</span> הוא לא מהצורה הזו, אנחנו עושים את הדבר הבא: מגרילים מספר <span>\( 1&lt;a&lt;N \)</span>. בודקים ש-<span>\( \text{gcd}\left(a,N\right)=1 \)</span>, כי אם הוא גדול יותר אז מצאנו מחלק של <span>\( N \)</span>.</p>

<p>אחר כך אנחנו מפעילים את החלק הקוונטי של האלגוריתם של שור ומקבלים כל מני מספרים שכל אחד מהם הוא בעל פוטנציאל להיות הסדר של <span>\( a \)</span>. לכל מספר <span>\( r \)</span> כזה, אם <span>\( r \)</span> אי זוגי מתעלמים ממנו, ואם <span>\( r \)</span> זוגי, אנו בודקים האם <span>\( \text{gcd}\left(a^{\frac{r}{2}}-1,N\right)&gt;1 \)</span> או ש-<span>\( \text{gcd}\left(a^{\frac{r}{2}}+1,N\right)&gt;1 \)</span>. אם קיבלנו מספר כזה, סיימנו; מצאנו מחלק לא טריוויאלי של <span>\( N \)</span>. אם לכל ה-<span>\( r \)</span>-ים שעשינו הניסוי לא הצליח, אנחנו מגרילים <span>\( a \)</span> אחר ומנסים שוב. זהו, זה כל האלגוריתם… למעט החלק של מציאת הסדר, שהוא כאמור העיקר.</p>

<p>למה כל זה עובד? כאן מגיעה הוכחה קצת מייגעת מתורת המספרים, שאני ארשה לעצמי לדלג עליה לגמרי כי כבר יש לי אותה <a href="https://gadial.net/2014/08/24/shor_algorithm/">בפוסט הקודם</a> על האלגוריתם של שור. זה עובד, תסמכו עלי. אנחנו פה בשביל החלק הקוונטי.</p>

<h2>איך בגדול עובד אלגוריתם מציאת הסדר?</h2>

<p>בואו ניזכר מה עושה אלגוריתם הערכת הפאזה: הוא מניח שאנחנו יודעים לבנות מעגל עבור אופרטור <span>\( U:\mathbb{C}^{2^{m}}\to\mathbb{C}^{2^{m}} \)</span>, ובהינתן שני רגיסטרים קוונטיים (שזה שם יפה ל”הרבה קיוביטים שאנחנו מחלקים אותם קונספטואלית לשתי קבוצות”) <span>\( \left|0^{n}\right\rangle \left|u\right\rangle  \)</span> כך ש-<span>\( \left|u\right\rangle  \)</span> הוא וקטור עצמי של <span>\( U \)</span>, אנחנו מסוגלים לבצע חישוב שבסוף שלו מדידה של הרגיסטר הראשון תניב קירוב ל-<span>\( \varphi \)</span>, שהוא מספר <span>\( 0\le\varphi\le1 \)</span> שמקיים <span>\( U\left|u\right\rangle =e^{2\pi i\varphi} \)</span>.</p>

<p>לכן, כשאנחנו באים להשתמש באלגוריתם הזה בפועל, השאלה הראשונה שאנחנו צריכים לענות עליה היא מהו <span>\( U \)</span> שלנו, והשניה היא מהו <span>\( \left|u\right\rangle  \)</span>. בואו נראה איך זה יהיה אצלנו.</p>

<p>ראשית, בואו ניזכר איך אני משתמש בכתיב <span>\( \left|a\right\rangle  \)</span> כאשר <span>\( a \)</span> הוא מספר טבעי. למשל, אם <span>\( a=5 \)</span> אז הייצוג הבינארי של <span>\( a \)</span> הוא <span>\( 101 \)</span>, ואז הסימון <span>\( \left|a\right\rangle  \)</span> מסמן את <span>\( \left|101\right\rangle =\left|1\right\rangle \otimes\left|0\right\rangle \otimes\left|1\right\rangle  \)</span>. צריך קצת להיזהר - אם מלכתחילה ברגיסטר שלנו משתתפים יותר קיוביטים מאשר צריך ספרות כדי לייצג את המספר, אז כל הקיוביטים ה”מיותרים” יהיו אפס. למשל, אם יש חמישה קיוביטים ואני מתבונן על המספר <span>\( 13 \)</span>, אז <span>\( \left|13\right\rangle =\left|01101\right\rangle  \)</span>. מעכשיו בכל מה שהולך לקרות באלגוריתם של שור, אני אשתמש רק בסימון <span>\( \left|a\right\rangle  \)</span> כש-<span>\( a \)</span> הוא מספר טבעי; אני לא אכתוב דברים בינאריים שם.</p>

<p>עכשיו אפשר לתאר את <span>\( U \)</span>. כזכור, אלגוריתם מציאת הסדר מקבל כקלט מספר <span>\( N \)</span> ומספר <span>\( a&lt;N \)</span> והשאלה היא מהו הסדר של <span>\( a \)</span> מודולו <span>\( N \)</span>. אז האופרטור <span>\( U \)</span> שבו משתמשים נבנה בהתבסס על שני המספרים הללו:</p>

<p><span>\( U\left|b\right\rangle =\left|ab\text{ mod }N\right\rangle  \)</span></p>

<p>כלומר, הוא בסך הכל כפל ב-<span>\( a \)</span> מודולו <span>\( N \)</span>. בגלל שמעצבן לכתוב כל הזמן <span>\( \text{mod }N \)</span> אני הולך להשמיט אותו מעכשיו והלאה, אבל בכל פעם שבה מופיע משהו כמו <span>\( \left|a^{2}\right\rangle  \)</span>, תזכרו שאני מתכוון אל הערך של <span>\( a^{2} \)</span> מודולו <span>\( N \)</span>.</p>

<p>עכשיו, אם אנחנו זוכרים, בהערכת פאזה צריך להיות מסוגלים לחשב לא רק את <span>\( U \)</span> אלא גם את <span>\( U^{2^{t}} \)</span> עבור ערכים הולכים וגדלים של <span>\( t \)</span>, כלומר לחשב</p>

<p><span>\( U^{2^{t}}\left|b\right\rangle =\left|a^{2^{t}}b\text{ mod }N\right\rangle  \)</span></p>

<p>אני <strong>לא הולך להסביר</strong> בפוסט הזה איך עושים את זה, כדי להישאר ממוקד. יש איזו פרדוקסליות בשאלה איך עושים את זה. מצד אחד, באופן כללי אנחנו מסוגלים לבצע חישובים “רגילים” במחשב קוונטי, מה שמזמין פוסט שעומד בפני עצמו שמסביר איך בדיוק עושים את זה. מצד שני, השאלה איך מחשבים את <span>\( U^{2^{t}} \)</span> בצורה אופטימלית, עם מינימום שערים, היא לא שאלה סגורה גם כיום. לכל זוג של <span>\( a,N \)</span> בעצם בונים מעגל אחר שמבצע את החישוב המתאים, וזו בעיה קלאסית בתחום של <strong>סינתזה</strong> של מעגלים קוונטיים - הבניה של מעגל אופטימלי מתוך התיאור האבסטרקטי יותר שלו. אז אני לא נכנס לזה בפוסט הזה כי זה מזמין סדרת פוסטים בפני עצמה. אבל אפשר לעשות את זה.</p>

<p>יפה, אז יש לנו את האופרטור <span>\( U\left|b\right\rangle =\left|ab\text{ mod }N\right\rangle  \)</span>. איך בדיוק הוא קשור לסדר <span>\( r \)</span> של <span>\( a \)</span> מודולו <span>\( N \)</span>? איך כל זה קשור ל”פאזה”? מה הולך כאן? בואו נפיל את האסימון הזה - לטעמי זה הולך להיות הרגע היפה ביותר מבין כל מה שראינו עד כה בסדרת הפוסטים הזו על חישוב קוונטי. כל כך יפה, שאני ארשה לעצמי להיות לא מדויק בניסוחים שלי - בהמשך גם זה יגיע.</p>

<p>בואו נסתכל לרגע על מה <span>\( U \)</span> עושה לכמה איברים קונקרטיים:</p>

<p><span>\( U\left|1\right\rangle =\left|a\cdot1\text{ mod }N\right\rangle =\left|a\right\rangle  \)</span></p>

<p><span>\( U\left|a\right\rangle =\left|a\cdot a\text{ mod }N\right\rangle =\left|a^{2}\right\rangle  \)</span></p>

<p><span>\( U\left|a^{2}\right\rangle =\left|a\cdot a^{2}\text{ mod }N\right\rangle =\left|a^{3}\right\rangle  \)</span></p>

<p>אוקיי, אנחנו מבינים, על סדרת הערכים <span>\( 1,a,a^{2},\ldots \)</span> מה ש-<span>\( U \)</span> עושה הוא לקדם את האיבר הנוכחי אל האיבר הבא בסדרה. אבל מתי זה נגמר? ובכן, זה נגמר בדיוק כשמגיעים לסדר של <span>\( a \)</span> - לאיבר <span>\( a^{2}\equiv_{N}1 \)</span>. במילים אחרות:</p>

<p><span>\( U\left|a^{r-1}\right\rangle =\left|a\cdot a^{r-1}\text{ mod }N\right\rangle =\left|1\right\rangle  \)</span></p>

<p>ואז אנחנו חוזרים אל <strong>התחלת</strong> הסדרה (במתמטית אומרים על זה ש-<span>\( U \)</span> מבצע לסדרה <span>\( 1,a,a^{2},\ldots,a^{r-1} \)</span> <strong>הזזה ציקלית</strong>).</p>

<p>סבבה, איך זה נותן לנו וקטור עצמי של <span>\( U \)</span>? פשוט מאוד: בואו ניקח <strong>סופרפוזיציה אחידה</strong> של כל אברי הסדרה הזו, כלומר נסתכל על המצב</p>

<p><span>\( \left|u_{0}\right\rangle =\frac{\left|1\right\rangle +\left|a\right\rangle +\left|a^{2}\right\rangle +\ldots+\left|a^{r-1}\right\rangle }{\sqrt{r}}=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\left|a^{k}\right\rangle  \)</span></p>

<p>המצב הזה הוא בבירור מצב עצמי של <span>\( U \)</span>, כלומר <span>\( U\left|u_{0}\right\rangle =\left|u_{0}\right\rangle  \)</span>; הוא מתאים לערך העצמי 1, וזה… לא עוזר לנו… בשום צורה? אלגוריתם הערכת הפאזה, אם יופעל על המצב הזה, יחזיר לנו 0. זה לא נותן לנו את <span>\( r \)</span>; זה לא נותן לנו שום כלום. אז בשביל מה אני משגע אתכם?</p>

<p>אה-הא! העניין הוא שיש <strong>עוד</strong> וקטורים עצמיים! <span>\( \left|u_{0}\right\rangle  \)</span> הוא רק האבטיפוס; הדוגמא הראשונה והפשוטה שנותנת לנו את האינטואיציה כדי להמשיך הלאה. בואו נחשוב לרגע על אותו וקטור, אבל עם <strong>מקדמים</strong> עבור האיברים:</p>

<p><span>\( \frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\alpha_{k}\left|a^{k}\right\rangle  \)</span></p>

<p>אם אנחנו רוצים שאחרי הפעלת <span>\( U \)</span> נחזור לאותו מצב בדיוק כפול סקלר כלשהו, צריך להתקיים</p>

<p><span>\( U\left(\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\alpha_{k}\left|a^{k}\right\rangle \right)=\lambda\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\alpha_{k}\left|a^{k}\right\rangle  \)</span></p>

<p>אבל</p>

<p><span>\( U\left(\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\alpha_{k}\left|a^{k}\right\rangle \right)=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\alpha_{k}U\left(\left|a^{k}\right\rangle \right)=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\alpha_{k}\left|a^{k+1\text{ mod }r}\right\rangle  \)</span></p>

<p>אם אנחנו משווים את זה אל <span>\( \lambda\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\alpha_{k}\left|a^{k}\right\rangle  \)</span> אנחנו מקבלים</p>

<p><span>\( \lambda\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\alpha_{k}\left|a^{k}\right\rangle =\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\alpha_{k}\left|a^{k+1\text{ mod }r}\right\rangle  \)</span></p>

<p>ואחרי חילוץ המקדמים, אנחנו מקבלים את המשוואות</p>

<p><span>\( \lambda\alpha_{0}=\alpha_{r-1} \)</span></p>

<p><span>\( \lambda\alpha_{1}=\alpha_{0} \)</span></p>

<p><span>\( \lambda\alpha_{2}=\alpha_{1} \)</span></p>

<p>וכן הלאה, עד שמגיעים לבסוף אל</p>

<p><span>\( \lambda\alpha_{r-1}=\alpha_{r-2} \)</span></p>

<p>אם נכפול את אגפי ימין ושמאל של כל המשוואות, נקבל</p>

<p><span>\( \lambda^{r}\prod_{k=0}^{r-1}\alpha_{k}=\prod_{k=0}^{r-1}\alpha_{k} \)</span></p>

<p>כלומר, <span>\( \lambda^{r}=1 \)</span>. או במילים אחרות, אנחנו מסוגלים לקבל וקטור עצמי עבור כל <strong>שורש יחידה </strong>מסדר<strong> </strong><span>\( r \)</span>.</p>

<p>הצורה הכללית של שורש יחידה מסדר <span>\( r \)</span> היא</p>

<p><span>\( e^{\frac{2\pi i}{r}\cdot s} \)</span></p>

<p>כאשר <span>\( 0\le s&lt;r \)</span>.</p>

<p>עכשיו, עבור שורש יחידה <span>\( e^{\frac{2\pi i}{r}\cdot s} \)</span> קונקרטי, איך נקבל את הוקטורים העצמיים המתאימים? אפשר לקבוע שרירותית שתמיד יתקיים <span>\( \alpha_{0}=1 \)</span> כי ככה דברים ייצאו לנו נחמד, ואז נובע ש-</p>

<p><span>\( \alpha_{1}=\lambda^{-1}\alpha_{0}=e^{-\frac{2\pi i}{r}\cdot s} \)</span></p>

<p>ובדומה נקבל</p>

<p><span>\( \alpha_{2}=e^{-2\cdot\frac{2\pi i}{r}\cdot s} \)</span></p>

<p>ובאופן כללי, נקבל את הוקטור העצמי</p>

<p><span>\( \left|u_{s}\right\rangle =\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}e^{-k\cdot\frac{2\pi i}{r}s}\left|a^{k}\right\rangle  \)</span></p>

<p>והוקטור <span>\( \left|u_{0}\right\rangle  \)</span> שראינו קודם אכן מתקבל כאן כמקרה פרטי, כאשר <span>\( s=0 \)</span>.</p>

<p>האם אלו באמת וקטורים עצמיים? אפשר לעשות שוב את החישוב, אבל כבר עשינו אותו קודם והוא יעבוד באותה צורה כל פעם. עבור <span>\( \left|u_{s}\right\rangle  \)</span>, הערך העצמי הוא שורש היחידה ה-<span>\( r \)</span>-י שהתאים ל-<span>\( s \)</span>, כלומר</p>

<p><span>\( U\left|u_{s}\right\rangle =e^{\frac{2\pi i}{r}s}\left|u_{s}\right\rangle  \)</span></p>

<p>ואם לחזור ללשון של אלגוריתם הערכת הפאזה, אז הפאזה <span>\( \varphi_{s} \)</span> של <span>\( \left|u_{s}\right\rangle  \)</span> היא <span>\( \varphi_{s}=\frac{s}{r} \)</span>. בפרט, <strong>אם</strong> הייתה לנו דרך להפעיל את אלגוריתם הערכת הפאזה על <span>\( \left|u_{1}\right\rangle  \)</span> ולקבל תוצאה מדויקת, אז היינו מקבלים ליד את המספר הרציונלי <span>\( \frac{1}{r} \)</span>. היינו מקבלים אותו בייצוג בינארי, אבל מתוך הייצוג הזה קל לחשב את <span>\( r \)</span> עצמו, מה שמסיים לנו את כל העבודה!</p>

<p>זהו, זו “נפילת האסימון” המדוברת. זה האופן שבו הסדר <span>\( r \)</span> עשוי לצוץ מתוך אלגוריתם הערכת פאזה. כשאני רוצה לסכם לעצמי את הפאנץ’ של האלגוריתם, אני חושב על הסדרה <span>\( 1,a,a^{2},\ldots,a^{r-1} \)</span> ואומר לעצמי “הזזה ציקלית. הזזה ציקלית”.</p>

<p>העניין הוא שזה לא מספיק. מה שתיארתי עד כה הוא אמנם נכון מבחינה רעיונית, אבל אנחנו לא באמת מסוגלים לממש את זה בפועל. נזדקק לעוד תעלול אחד אחרון. והתעלול הזה הוא כנראה הדבר הכי מגניב פה.</p>

<p>מה בעצם הבעיה? אם הייתי מסוגל להפעיל את אלגוריתם הערכת הפאזה על <span>\( \left|u_{1}\right\rangle  \)</span> אכן הייתי מקבל את <span>\( \frac{1}{r} \)</span> (או לפחות קירוב טוב של <span>\( \frac{1}{r} \)</span> ועוד נחזור לחישוב המדויק). אבל <strong>אני לא יודע</strong> את <span>\( \left|u_{1}\right\rangle  \)</span>. אין לי מושג איך לבנות אותו. המקדמים שלו מקודדים איכשהו את <span>\( e^{\frac{2\pi i}{r}} \)</span>; בשביל ליצור אותם אני כנראה אצטרך לדעת מה הוא <span>\( r \)</span>, שהוא המספר שאותו אנחנו מחפשים! לכאורה אני במעגל ולא התקדמתי אף צעד; זה הכי כיף כשנראה שאנחנו בסיטואציה כזו כשלמעשה אנחנו במרחק צעד אחד מהפתרון.</p>

<p>הפתרון הוא לקחת את <strong>כל</strong> הוקטורים העצמיים <span>\( \left|u_{s}\right\rangle  \)</span>, עבור <strong>כל</strong> <span>\( 0\le s&lt;r \)</span>, ולהסתכל על הסופרפוזיציה של כולם ביחד, כלומר על</p>

<p><span>\( \frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\left|u_{s}\right\rangle  \)</span></p>

<p>לכאורה לא התקדמנו בכלל - קודם היה מצב אחד שלא היה לנו מושג מהו, ועכשיו יש לנו סופרפוזיציה של הרבה מצבים כאלו; איך אנחנו אמורים לבנות אותה? התשובה היא שהיא מצב שאנחנו מכירים היטב וקל לנו מאוד לבנות - רק צריך לעשות את החישוב:</p>

<p><span>\( \frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\left|u_{s}\right\rangle =\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\left(\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}e^{-k\cdot\frac{2\pi i}{r}s}\left|a^{k}\right\rangle \right)= \)</span></p>

<p><span>\( =\frac{1}{r}\sum_{k=1}^{r-1}\left(\sum_{s=0}^{r-1}e^{-k\cdot\frac{2\pi i}{r}s}\right)\left|a^{k}\right\rangle  \)</span></p>

<p>עכשיו נחלץ לעזרתנו תעלול ידוע ומוכר - אם <span>\( \omega \)</span> הוא שורש יחידה <strong>כלשהו</strong> מסדר <span>\( r \)</span>, אז <span>\( 1+\omega+\omega^{2}+\ldots+\omega^{r-1}=\begin{cases} 0 &amp; \omega\ne1\\ r &amp; \omega=1 \end{cases} \)</span>. למה? כי אם <span>\( \omega\ne1 \)</span> אז הסכום משמאל הוא טור הנדסי שיוצא <span>\( \frac{\omega^{r}-1}{\omega-1}=\frac{1-1}{\omega-1}=0 \)</span>.</p>

<p>במקרה שלנו, <span>\( \omega=-k\frac{2\pi i}{r} \)</span> - זה בהחלט שורש יחידה מסדר <span>\( r \)</span>, והוא שווה ל-1 רק כאשר <span>\( k=0 \)</span>. כלומר מכל הסכום הגדול נשאר רק</p>

<p><span>\( \frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\left|u_{s}\right\rangle =\frac{1}{r}\cdot r\left|a^{0}\right\rangle =\left|1\right\rangle  \)</span></p>

<p>שימו לב: <span>\( \left|1\right\rangle  \)</span> במקרה הזה הוא לא קיוביט בודד שערכו <span>\( \left|1\right\rangle  \)</span>, אלא כזכור, הסימון המקוצר שלי ל-<span>\( \left|000\ldots01\right\rangle  \)</span>. אבל זה בוודאי ובוודאי מצב שאנחנו יודעים לבנות - כלומר, אנחנו בהחלט יודעים לקבל את הסופרפוזיציה של כל ה-<span>\( \left|u_{s}\right\rangle  \)</span> גם אם אנחנו לא יודעים לקבל אף אחד מהם אישית; זו גם הסיבה שבגללה כל כך עניין אותי להבין את כל ה-<span>\( \left|u_{s}\right\rangle  \)</span> כולל <span>\( \left|u_{0}\right\rangle  \)</span> ולא סתם התמקדתי ב-<span>\( \left|u_{1}\right\rangle  \)</span>.</p>

<p>בסופו של דבר, מה עושה המעגל של אלגוריתם הערכת פאזה? נקרא לו <span>\( \text{PE} \)</span> (קיצור של Phase Estimation). אם מריצים אותו עד השלב שלפני המדידה שבסוף, הוא מחשב את האופרטור האוניטרי</p>

<p><span>\( \text{PE}\left(\left|0^{n}\right\rangle \left|u_{s}\right\rangle \right)=\left|\tilde{\varphi}_{s}\right\rangle \left|u_{s}\right\rangle  \)</span></p>

<p>כאשר <span>\( \left|\tilde{\varphi}_{s}\right\rangle  \)</span> הוא מצב קוונטי שהמדידה שלו נותנת בהסתברות טובה קירוב טוב של <span>\( \varphi_{s} \)</span> - הפאזה שמתאימה ל-<span>\( u_{s} \)</span>, כלומר <span>\( \frac{s}{r} \)</span>. עכשיו, אם במקום לרוץ על מצב בודד, נרוץ על סופרפוזיציה שלהם, העובדה ש-<span>\( \text{PE} \)</span> הוא אופרטור <strong>לינארי</strong> נותנת לנו</p>

<p><span>\( \text{PE}\left(\left|0^{n}\right\rangle \left(\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\left|u_{s}\right\rangle \right)\right)=\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\text{PE}\left(\left|0^{n}\right\rangle \left|u_{s}\right\rangle \right)=\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\left|\tilde{\varphi}_{s}\right\rangle \left|u_{s}\right\rangle  \)</span></p>

<p>במילים אחרות, אנחנו מקבלים ברגיסטר הראשון סופרפוזיציה אחידה של כל ה-<span>\( \left|\tilde{\varphi}_{s}\right\rangle  \)</span>-ים, ולכן אפשר לחשוב על מדידה של הרגיסטר הראשון כאילו היא עושה שני דברים בזה אחר זה:</p>

<ul> <li>מגרילה <span>\( 0\le s&lt;r \)</span> באקראי ובהתפלגות אחידה.</li>


<li>מודדת את <span>\( \left|\tilde{\varphi}_{s}\right\rangle  \)</span>, כלומר מקבלת ערך שבהסתברות טובה הוא קירוב טוב של <span>\( \frac{s}{r} \)</span>.</li>

</ul>

<p>האם כל ה-<span>\( s \)</span>-ים טובים עבורנו? ובכן, לא. ראינו כבר קודם שעבור <span>\( s=0 \)</span> אין לנו כלום - לא נוכל לחלץ את <span>\( r \)</span> מהערך שנקבל. ובמקרים אחרים, אם <span>\( \text{gcd}\left(s,r\right)&gt;1 \)</span> אז הסיכוי שנצליח לעשות משהו טוב נפגע מאוד - <span>\( \frac{s}{r} \)</span> לא יהיה שבר מצומצם ולכן אם ננסה “לשחזר” את <span>\( \frac{s}{r} \)</span> לא נקבל את <span>\( r \)</span>. הנה דוגמא פשוטה: נניח ש-<span>\( r=15 \)</span> ו-<span>\( s=3 \)</span>. אז <span>\( \frac{s}{r}=\frac{3}{15}=\frac{1}{5}=0.2 \)</span>; אז אפילו אם נקבל את התוצאה המדויקת <span>\( 0.2 \)</span> לא נוכל לשחזר מזה את <span>\( r=15 \)</span>; המכנה שנשחזר הוא 5. בגלל הבעיה הזו, לפעמים באלגוריתם של שור כשמקבלים “מועמד ל-<span>\( r \)</span>” משתלם לפעול לא רק מתוך הנחה שהמועמד הזה טוב, אלא גם לנסות כמה כפולות שלו - להכפיל ב-2,3,4 וכו’ ולנסות גם עבורן. זה חישוב מהיר מאוד שלא מאט אותנו, ואם במקרה הוא מצליח ומצאנו גורם של <span>\( N \)</span> נדע בודאות שהצלחנו, כך שאין חיסרון של ממש להרחבה הזו.</p>

<p>זה סוף אלגוריתם הערכת הפאזה, כלומר סוף החלק הקוונטי של האלגוריתם; הנה איך הכל נראה בסופו של דבר.</p>

<p><img src="/assets/img/2022/shor_algorithm.png" alt="" /></p>

<h2>איך משחזרים את הסדר מתוך הקירוב שהערכת הפאזה נותנת לנו?</h2>

<p>ברגע שבו אלגוריתם הערכת הפאזה מסתיים, נגמר החלק הקוונטי של האלגוריתם, אבל עדיין נשאר חלק לא טריוויאלי בעליל שצריך לבצע - השלב שבו אנחנו עוברים מה<strong>קירוב</strong> שקיבלנו לפאזה, עד שיש לנו ביד מועמד פוטנציאלי להיות הסדר, <span>\( r \)</span>. כאן נכנס לתמונה מה שנקרא <strong>אלגוריתם השברים המשולבים</strong>, שזו פשוט דרך מפחידה להגיד “שיטה למציאת קירובים רציונלים טובים למספר שקיבלנו”.</p>

<p>מה זה שבר משולב? <a href="https://gadial.net/2010/05/29/continued_fractions_1/">יש לי פוסט על זה</a> אבל הוא נכנס לעומק שאני לא זקוק לו פה, ומצד שני תמיד נחמד להציג שוב נושא כל כך מגניב, בטח כשיש לו שימוש פרקטי. אז הנה מבוא על רגל אחת. נתחיל עם דוגמא קונקרטית - המספר <span>\( \pi \)</span> - היחס בין היקף מעגל לקוטרו - הוא אחד מהקבועים המתמטיים המפורסמים ביותר. אם ננסה לכתוב אותו בבסיס עשרוני הוא ייראה משהו כמו <span>\( \pi=3.14159\ldots \)</span>, כשהנקודות אומרות שיש עוד ספרות בהמשך. אם נוותר על הנקודות ונסתכל על המספר <span>\( 3.14159 \)</span>, מה שיש לנו ביד הוא <strong>קירוב רציונלי</strong> של <span>\( \pi \)</span> - קירוב שאפשר לכתוב אותו בתור מנה של שני מספרים שלמים, <span>\( \frac{314159}{10000} \)</span> (זאת להבדיל מ-<span>\( \pi \)</span> עצמו שיש הוכחה שאי אפשר להציג בתור מנה של שני מספרים שלמים). אני יכול גם להסתכל על קירובים שמתקבלים מלקחת <strong>פחות</strong> ספרות של <span>\( \pi \)</span>: אני מקבל את סדרת הקירובים</p>

<p><span>\( 3,\frac{31}{10},\frac{314}{100},\frac{3141}{1000},\frac{31415}{10000} \)</span></p>

<p>האם זו סדרת קירובים <strong>טובה</strong>? הקירוב <span>\( \frac{314}{100}=3.14 \)</span>, למשל, הוא מפורסם במיוחד: צורת הכתיב שלו, בשילוב עם שיטת כתיב התאריכים האמריקאית ויום ההולדת של אלברט איינשטיין, הולידו את <strong>יום פאי</strong>. אבל האמת היא, בינינו, שזה קירוב <strong>די גרוע</strong> לעומת קירוב אחר, <span>\( \frac{22}{7} \)</span>, שזכה ליום פחות מפורסם משל עצמו (“יום קירוב פאי”, למרות שכאמור הוא דווקא הקירוב הטוב יותר). אם נחשב את ההפרש של כל אחד מהקירובים מפאי נקבל<span>\( \left|\pi-3.14\right|=0.001592\dots \)</span> ו-<span>\( \left|\pi-\frac{22}{7}\right|=0.001264\ldots \)</span>, כלומר יש יתרון ברור ל-<span>\( \frac{22}{7} \)</span>, למרות שלכאורה נקודת המוצא של <span>\( \frac{314}{100} \)</span> היא טובה <strong>הרבה </strong>יותר, כי המכנה שלו הוא מספר גדול יותר, ולכן לכאורה מאפשר למצוא מספר שקרוב לפאי ברזולוציה טובה יותר (תחשבו על סרגל שיש בו סימוני סנטימטרים לעומת סרגל שיש בו רק שבעה סימנים ברווחים אחידים בין כל מטר - מה נראה לנו כמו כלי מדויק יותר?)</p>

<p>אם נסתכל על הקירוב ה”טוב”, <span>\( \frac{22}{7} \)</span>, מה מבדיל אותו מהסדרה שהראיתי קודם? בסדרה הזו, <strong>המכנה</strong> של כל השברים היה חזקה של 10: 1, 10, 100, 1000 וכו’. לעומת בקירוב <span>\( \frac{22}{7} \)</span> נדחף לנו ה-7 הלא קשור הזה. העניין הוא שמבחינת המתמטיקה, האהבה שלנו למספר 10 היא <strong>שרירותית</strong>; זה בגלל שהביולוגיה חננה אותנו בעשר אצבעות, לא בגלל שעשר הוא מספר מופלא לקירובים. לכן, שיטת הקירובים שאנחנו רגילים אליה מהבסיס העשרוני שלנו היא לאו דווקא אופטימלית; שברים משולבים הם אלו שנותנים לנו את הקירובים האופטימליים, במובן מאוד מדויק שאתאר עוד מעט - ובגלל שמקבלים קירובים כל כך טובים, זה מתקשר ישירות לאלגוריתם שלנו.</p>

<p>איך זה קשור? ובכן, עוד מעט אראה איך בעזרת שברים משולבים אפשר לקבל סדרת קירובים למספר כלשהו <span>\( x \)</span>. הקסם המופלא בשיטה הזו הוא שאם למספר <span>\( x \)</span> כלשהו יש קירוב <strong>טוב</strong> (עבור משמעות של “טוב” שאתן במדויק בהמשך), אז <strong>בודאות מוחלטת</strong> הקירוב הטוב הזה יופיע בסדרת הקירובים שמקבלים מהפיתוח של <span>\( x \)</span> לשבר משולב.</p>

<p>איך זה קשור אלינו? כי בואו נחשוב רגע מה עושה שלב הערכת הפאזה: הוא מחזיר מספר <span>\( x \)</span> שהוא <strong>קירוב טוב</strong> של <span>\( \frac{s}{r} \)</span> כאשר <span>\( r \)</span> הוא הסדר שאנחנו מחפשים - מטרת האלגוריתם - ו-<span>\( 0\le s&lt;r \)</span> הוא מספר אקראי. אבל אם <span>\( x \)</span> הוא <strong>קירוב טוב</strong> של <span>\( \frac{s}{r} \)</span> ההפך נכון באותה מידה: <span>\( \frac{s}{r} \)</span> הוא <strong>קירוב טוב </strong>של <span>\( x \)</span>, ולכן הולך להופיע בפיתוח לשברים משולבים של <span>\( x \)</span>. כזכור, בפוסט על אלגוריתם הערכת פאזה ראינו בדיוק כיצד ניתן להגדיל את ההסתברות לקבלת קירוב טוב (עוד קיוביטים), אז מה שנצטרך לעשות הוא להבין כמה טוב צריך להיות <strong>הקירוב הטוב</strong> הזה.</p>

<p>עוד עניין שאין לנו דרך להתמודד איתו הוא ש-<span>\( \frac{s}{r} \)</span> צריך להיות <strong>שבר מצומצם</strong>. אם למשל <span>\( s=7 \)</span> ו-<span>\( r=63 \)</span>, אז <span>\( \frac{s}{r}=\frac{7}{63}=\frac{1}{9} \)</span>, ואז מה שהפיתוח לשברים משולבים ייתן לנו הוא את <span>\( \frac{1}{9} \)</span>. זה כמובן אותו מספר בדיוק כמו <span>\( \frac{7}{63} \)</span>, אבל אנחנו מעוניינים במספר 63 שנמצא במכנה, לא ב-9. אז כדי שהאלגוריתם יצליח, ה-<span>\( 0\le s&lt;r \)</span> שנבחר באקראי צריך להיות זר ל-<span>\( r \)</span>. למרבה המזל, רוב ה-<span>\( s \)</span>-ים הללו אכן כאלו, אז זו לא בעיה אמיתית - אבל מי שרוצים להיות ממש זהירים יכולים, בהינתן המספר שהתקבל במכנה, לנסות גם כפולות שלו - אם היינו מנסים לקחת את ה-9 שקיבלנו במכנה, לכפול אותו ב-7 ולנסות לפרק לגורמים את <span>\( N \)</span> עם ה-<span>\( 63 \)</span> שקיבלנו, היינו מצליחים; הנסיונות הללו לא מפריעים לשום דבר ומגדילים עוד קצת את הסיכוי שנצליח, אבל כנראה שאפשר גם בלעדיהם.</p>

<p>אוקיי, בואו נעבור לשברים משולבים! ספציפית אל המספר <span>\( \frac{314159}{100000} \)</span> שהבטחתי למצוא לו סדרת קירובים טובה יותר מאשר <span>\( 3,3.1,3.14 \)</span> וכן הלאה. הטכניקה שבה אשתמש תיראה מוזרה במבט ראשון, אבל סמכו עלי - היא עובדת. כזכור, אי שם בבית הספר לימדו אותנו שיש משהו שנקרא “שבר מדומה” שהוא שבר שבו המונה גדול מהמכנה. שבר כזה אפשר להפריד לסכום שנקרא “מספר מעורב” של החלק השלם ועוד החלק השברי שהוא בין 0 ל-1. במקרה שלנו:</p>

<p><span>\( \frac{314159}{100000}=3+\frac{14159}{100000} \)</span></p>

<p>עכשיו אני עושה את הטריק המרכזי שלי: אני משתמש בכך שבאופן כללי, <span>\( \frac{a}{b}=\frac{1}{\frac{b}{a}} \)</span> כדי לכתוב</p>

<p><span>\( \frac{14159}{100000}=\frac{1}{\frac{100000}{14159}} \)</span></p>

<p>מה הולך פה? קודם היה לנו שבר “אמיתי”, שבו המונה <strong>קטן</strong> מהמכנה; עכשיו המונה והמכנה התהפכו, אז שוב קיבלנו שבר מדומה שאנחנו יכולים להפריד למספר שלם ועוד שבר. בשביל לעשות את זה, צריך לחלק את 100,000 ב-14,159; המנה שנקבל היא החלק השלם, והשארית שנקבל היא מה שנשאר על השבר: <span>\( \frac{100000}{14159}=7+\frac{887}{14159} \)</span>.</p>

<p>אם שותלים את הביטוי הזה בחישוב שכבר עשינו, מקבלים</p>

<p><span>\( 3+\frac{14159}{100000}=3+\frac{1}{7+\frac{887}{14159}} \)</span></p>

<p>אפשר להמשיך עם זה ולהתעלל גם ב–<span>\( \frac{887}{14159} \)</span>, אבל אפשר גם לקחת הפסקה לרגע ולהגיד “אוקיי, בואו נתעלם לגמרי מה-<span>\( \frac{887}{14159} \)</span>, מה קיבלנו עכשיו?” ואז יש לנו את השבר</p>

<p><span>\( 3+\frac{1}{7}=\frac{22}{7} \)</span></p>

<p>הופה! הנה צץ לנו הקירוב המצוין לפאי שדיברתי עליו קודם! כאילו במטה קסם. ובכן, כן, זה <strong>באמת</strong> קסם, עד כמה שדברים שקורים במתמטיקה הם קסם; זה הקסם שמאפשר לנו לסיים את האלגוריתם של שור. <strong>למה</strong> זה קורה? סבלנות! עוד אוכיח את זה באופן מלא בפוסט הזה.</p>

<p>נחזור אל ה-<span>\( \frac{887}{14159} \)</span>. בשלב הזה אנחנו כבר יודעים מה לעשות - לחלק את 14159 ב-887 ולראות מה המנה ומה השארית, ואז לכתוב</p>

<p><span>\( \frac{887}{14159}=\frac{1}{15+\frac{854}{887}} \)</span></p>

<p>אם נשתול את זה בביטוי המקורי נקבל משהו שהוא כבר בלתי קריא בעליל:</p>

<p><span>\( 3+\frac{1}{7+\frac{1}{15+\frac{854}{887}}} \)</span></p>

<p>בגלל שזה בלתי קריא, משתמשים לפעמים בשיטת סימון אחרת, שבה לא צריך לרדת למטה עוד ועוד:</p>

<p><span>\( 3+\frac{1}{7+}\frac{1}{15+}\frac{1}{887/854} \)</span></p>

<p>אבל אני אשתמש בשיטת סימון עוד יותר קומפקטית: הרי לא באמת צריך את כל הפלוסים וה-1 חלקי הללו, אנחנו מתעניינים רק במספרים שליד הפלוסים. אז אפשר לכתוב</p>

<p><span>\( \left[3,7,15,\frac{887}{854}\right] \)</span></p>

<p>זו צורת הכתיב הנפוצה והמקובלת. הנה הגדרה פורמלית של מה היא אומרת:</p>

<p><span>\( \left[a_{0},a_{1},\ldots a_{n}\right]=a_{0}+\frac{1}{a_{1}+\frac{1}{a_{2}+\frac{1}{\cdots+\frac{1}{a_{n}}}}} \)</span></p>

<p>ועכשיו אפשר להמשיך יותר בנוחות. נחלק את 887 ב-854 ונקבל מנה 1 ושארית 33, כלומר השלב הבא הוא</p>

<p><span>\( \left[3,7,15,1,\frac{854}{33}\right] \)</span></p>

<p>בשלב הבא נחלק 854 ב-33 ונקבל מנה 25 ושארית 29, ובואו נמשיך גם לשלב הבא כי הבנו את הקטע:</p>

<p><span>\( \left[3,7,15,1,25,\frac{33}{29}\right]=\left[3,7,15,1,25,1,\frac{29}{4}\right]= \)</span></p>

<p><span>\( =\left[3,7,15,1,25,1,7,\frac{4}{1}\right] \)</span></p>

<p>וזה השלב האחרון, כי 4 מתחלק ב-1 ללא שארית! זו הצורה ה”סופית” של השבר המשולב:</p>

<p><span>\( \left[3,7,15,1,25,1,7,4\right] \)</span></p>

<p>כלומר, אנחנו מרגישים רגועים לומר שסיימנו כשהאיבר האחרון, הימני ביותר, הוא עצמו מספר שלם ולא שבר.</p>

<p>ואיך כל זה עוזר לנו בכלל? כפי שראינו קודם, כבר כש”עצרנו” את החישוב אחרי שקיבלנו את ה-7 הראשון והתעלמנו מהשארית, קיבלנו את הקירוב <span>\( \frac{22}{7} \)</span> המצוין. באותו אופן אפשר לעצור את הקירוב גם בשלבים מתקדמים יותר ולקבל קירובים מצויינים אחרים. למשל:</p>

<p><span>\( \left[3,7,15\right]=3+\frac{1}{7+\frac{1}{15}}=3+\frac{1}{\frac{106}{15}}=\frac{333}{106} \)</span></p>

<p>גם זה קירוב מפורסם של פאי, וכן הלאה - הבנו את הרעיון. שימו לב, אגב, שלא עבדנו עם <span>\( \pi \)</span> בכלל; התחלנו עם המספר <span>\( 3.14159 \)</span> ומצאנו סדרת קירובים <strong>אליו</strong>; בגלל שהוא קירוב לא רע של פאי, קיבלנו שסדרת הקירובים החלקיים עד כה נותנת גם את הקירובים המצויינים של <span>\( \pi \)</span>. אם היינו מלכתחילה רוצים לחשב שבר משולב עבור <span>\( \pi \)</span> היינו נתקלים בשתי בעיות - החישוב קצת יותר מסובך, והשבר המשולב המתקבל צריך להיות <strong>אינסופי</strong>; כדי להתחמק מהסיבוך הזה שלא דרוש לי הסתפקתי בלתאר איך מחשבים שבר משולב עבור מספר שהוא מלכתחילה שבר - ומה שראינו הוא שהשבר המשולב שאנחנו בונים אכן נותן סדרה מצויינת של קירובים לאותו השבר. זה המקרה הרלוונטי לנו כי כזכור, אנחנו מקבלים מאלגוריתם הערכת הפאזה מספר <strong>רציונלי </strong><span>\( x \)</span> שבתקווה <span>\( \frac{s}{r} \)</span> הוא קירוב מצויין אליו. אם <span>\( x \)</span> הוא מספר רציונלי, אנחנו יודעים איך לחשב לו שבר משולב ואז לקבל ממנו את סדרת הקירובים האופטימלית שהוא נותן - זה חישוב מאוד פשוט שכולל בסך הכל פעולות של חילוק עם שארית וחישובים אריתמטיים פשוטים יותר. קל לתכנת את זה והריצה של החלק הזה לוקחת שברירי שניה.</p>

<h2>בונוס: איך מוכיחים את כל הקטע הזה של השברים המשולבים?</h2>

<p>יופי, סיימנו עם האלגוריתם של שור ואפשר לעבור לתורת המספרים נטו! בואו נעבור לתיאור פורמלי של עניין ה<strong>קירוב טוב</strong> הזה. נתחיל עם סימון: אם <span>\( x \)</span> הוא מספר רציונלי עם פיתוח לשבר משולב <span>\( \left[a_{0},a_{1},\ldots,a_{n}\right] \)</span>, אני אסמן את סדרת הקירובים שמתקבלת מהפיתוח הזה בתור <span>\( \frac{p_{0}}{q_{0}},\frac{p_{1}}{q_{1}},\frac{p_{2}}{q_{2}},\ldots,\frac{p_{n}}{q_{n}} \)</span>. כלומר, <span>\( \frac{p_{k}}{q_{k}}=\left[a_{0},a_{1},\ldots,a_{k}\right] \)</span>.</p>

<p>הנה דברים שאפשר להראות אבל לא אראה הפעם: <span>\( q_{0}&lt;q_{1}&lt;q_{2}&lt;\ldots&lt;q_{n} \)</span>, כלומר המכנה הולך וגדל ככל שמתקדמים בסדרה; <span>\( p_{k},q_{k} \)</span> זרים זה לזה לכל אינדקס <span>\( k \)</span>; והקירוב <span>\( \frac{p_{k}}{q_{k}} \)</span> הוא טוב במובן הבא:</p>

<p><span>\( \left|x-\frac{p_{k}}{q_{k}}\right|&lt;\frac{1}{q_{k}q_{k+1}}&lt;\frac{1}{q_{k}^{2}} \)</span></p>

<p>כשהמעבר השני נובע מכך ש-<span>\( q_{k}&lt;q_{k+1} \)</span> (עבור <span>\( k=n \)</span> הנוסחה לא עובדת כי אין <span>\( q_{k+1} \)</span> אבל ממילא בשלב הזה ההפרש הוא 0).</p>

<p><span>\( \frac{p_{k}}{q_{k}} \)</span> הוא <strong>הקירוב הטוב ביותר</strong> במובן זה שלכל <span>\( 1\le d\le q_{k} \)</span> ולכל <span>\( c \)</span> מתקיים</p>

<p><span>\( \left|x-\frac{p_{k}}{q_{k}}\right|\le\left|x-\frac{c}{d}\right| \)</span></p>

<p>כלומר, אם מסתכלים על כל המספרים הרציונליים עם מכנה שהוא לכל היותר <span>\( q_{k} \)</span>, לא נמצא אף אחד שהוא קירוב יותר טוב ל-<span>\( x \)</span> מאשר <span>\( \frac{p_{k}}{q_{k}} \)</span>.</p>

<p>יפה, כל אלו הם משפטים מעניינים, אבל המשפט שמעניין אותי באמת הוא זה שמבטיח לנו שקירוב טוב בהכרח יופיע בפיתוח לשבר משולב, וסוף סוף אפשר לנסח אותו פורמלית: אם <span>\( c,d \)</span> זרים זה לזה, עם <span>\( 1\le d \)</span>, ומתקיים</p>

<p><span>\( \left|x-\frac{c}{d}\right|&lt;\frac{1}{2d^{2}} \)</span></p>

<p>אז <strong>בודאות</strong> קיים <span>\( k \)</span> כך ש-<span>\( \frac{c}{d}=\frac{a_{k}}{b_{k}} \)</span> עבור איבר <span>\( \frac{a_{k}}{b_{k}} \)</span> בסדרת הקירובים שמתקבלת מהפיתוח של <span>\( x \)</span> לשבר משולב.</p>

<p>איך מוכיחים את זה?</p>

<p>טוב, אני אצטרך שנכיר עוד כמה דברים על שברים משולבים כדי להתקדם. הדבר הראשון הוא נוסחה די משוגעת שעבור שבר משולב <span>\( \left[a_{0},a_{1},\ldots,a_{n},a_{n+1}\right] \)</span> נותנת לנו את <span>\( \frac{p_{n+1}}{q_{n+1}} \)</span> - האיבר הבא בסדרת הקירובים - אם נתונים לנו <span>\( \frac{p_{n}}{q_{n}},\frac{p_{n-1}}{q_{n-1}} \)</span> ו-<span>\( a_{n+1} \)</span>. הנה הנוסחה:</p>

<p><span>\( \frac{p_{n+1}}{q_{n+1}}=\frac{a_{n+1}p_{n}+p_{n-1}}{a_{n+1}q_{n}+q_{n-1}} \)</span></p>

<p>בואו נראה את זה בפעולה עבור <span>\( \left[3,7,15,1,25,1,7,4\right] \)</span>, השבר המשולב שכבר מצאנו עבור הקירוב לפאי. כזכור, שני הקירובים הראשונים שקיבלנו היו <span>\( \frac{3}{1} \)</span> ו-<span>\( \frac{22}{7} \)</span>, והקירוב השלישי היה <span>\( \frac{333}{106} \)</span>. לכאורה כדי לקבל את הקירוב השלישי אנחנו לא יכולים להיעזר בשני הראשונים; אנחנו חייבים לבצע את כל החישוב <span>\( 3+\frac{1}{7+\frac{1}{15}} \)</span>; אי אפשר לקחת את <span>\( \frac{22}{7}=3+\frac{1}{7} \)</span> ופשוט “לשתול” את <span>\( 15 \)</span> בתוכו בצורה פשוטה. אבל בואו נראה מה קורה עם הנוסחה:</p>

<p><span>\( \frac{a_{2}p_{1}+p_{0}}{a_{2}q_{1}+q_{0}}=\frac{15\cdot22+3}{15\cdot7+1}=\frac{333}{106} \)</span></p>

<p>קסם! תקשיבו לי, זה פשוט קסם! אין לי שמץ של מושג איך זה קורה למרות שלדעתי כבר ראיתי כמה פעמים את ההוכחה. בואו נראה אותה שוב ביחד.</p>

<p>כפי שניתן לנחש, מוכיחים את הטענה באינדוקציה. המקרה הפשוט ביותר שהוא היא רלוונטית הוא <span>\( n=1 \)</span>. במקרה הזה, השבר המשולב שלנו הוא <span>\( \left[a_{0},a_{1},a_{2}\right] \)</span> והפיתוחים החלקיים שלו הם</p>

<p><span>\( \frac{p_{0}}{q_{0}}=\frac{a_{0}}{1} \)</span></p>

<p><span>\( \frac{p_{1}}{q_{1}}=a_{0}+\frac{1}{a_{1}}=\frac{a_{0}a_{1}+1}{a_{1}} \)</span></p>

<p>מאלו אנחנו יכולים להסיק:</p>

<p><span>\( p_{0}=a_{0},q_{0}=1 \)</span></p>

<p><span>\( p_{1}=a_{0}a_{1}+1,q_{1}=a_{1} \)</span></p>

<p>עבור האיבר הבא החישוב קצת יותר מסובך אבל נעשה אותו במפורש:</p>

<p><span>\( \frac{p_{2}}{q_{2}}=a_{0}+\frac{1}{a_{1}+\frac{1}{a_{2}}}=a_{0}+\frac{a_{2}}{a_{2}a_{1}+1}=\frac{a_{2}a_{0}a_{1}+a_{0}+a_{2}}{a_{2}a_{1}+1}= \)</span></p>

<p><span>\( =\frac{a_{2}\left(a_{0}a_{1}+1\right)+a_{0}}{a_{2}a_{1}+1}=\frac{a_{2}p_{1}+p_{0}}{a_{2}q_{1}+q_{0}} \)</span></p>

<p>קיבלנו את הנוסחה במקרה הזה, ועכשיו רק נשאר לסיים באינדוקציה את המקרה הכללי. כאן פשוט <strong>חייב</strong> לבוא איזה טיעון מתוחכם, כי הנוסחה הזו מפשטת לנו מאוד משהו שנראה מבעית בהתחלה. הנה ההתחכמות: במקרה הכללי, השבר המשולב שמתקבל מהאיברים הראשונים עד <span>\( a_{n} \)</span> הוא</p>

<p><span>\( \left[a_{0},a_{1},\ldots,a_{n}\right] \)</span></p>

<p>ועבורו יש לנו את נוסחת הנסיגה</p>

<p><span>\( \left[a_{0},a_{1},\ldots,a_{n}\right]=\frac{a_{n}p_{n-1}+p_{n-2}}{a_{n}q_{n-1}+q_{n-2}} \)</span></p>

<p>עכשיו הטיעון המתוחכם: <span>\( p_{n-1},q_{n-1},p_{n-2},q_{n-2} \)</span> מתקבלים מ-<span>\( \left[a_{0},a_{1},\ldots,a_{n-1}\right] \)</span> ומ-<span>\( \left[a_{0},a_{1},\ldots,a_{n-2}\right] \)</span>; השברים המשולבים הללו לא תלויים באיבר האחרון, ולכן המספרים הללו יישארו זהים גם אם נשתול בתור האיבר האחרון משהו אחר, למשל את <span>\( a_{n}+\frac{1}{a_{n+1}} \)</span>. אבל מה זה <span>\( \left[a_{0},a_{1},\ldots,a_{n-1},a_{n}+\frac{1}{a_{n+1}}\right] \)</span>? אם נפתח את ההגדרה, נראה שזה</p>

<p><span>\( a_{0}+\frac{1}{a_{1}+\frac{1}{a_{2}+\frac{1}{\cdots+\frac{1}{a_{n}+\frac{1}{a_{n+1}}}}}} \)</span></p>

<p>כלומר, זה פשוט המספר <span>\( \left[a_{0},a_{1},\ldots,a_{n-1},a_{n},a_{n+1}\right]=\frac{p_{n+1}}{q_{n+1}} \)</span>, רק שעבור הצורה הקודמת אפשר להשתמש בנוסחת הנסיגה:</p>

<p><span>\( \left[a_{0},a_{1},\ldots,a_{n-1},a_{n}+\frac{1}{a_{n+1}}\right]=\frac{\left(a_{n}+\frac{1}{a_{n+1}}\right)p_{n-1}+p_{n-2}}{\left(a_{n}+\frac{1}{a_{n+1}}\right)q_{n-1}+q_{n-2}} \)</span></p>

<p>זה קצת מזוויע אבל נכפול מונה ומכנה ב-<span>\( a_{n+1} \)</span> ונקבל</p>

<p><span>\( \frac{\left(a_{n+1}a_{n}+1\right)p_{n-1}+a_{n+1}p_{n-2}}{\left(a_{n+1}a_{n}+1\right)q_{n-1}+a_{n+1}q_{n-2}}=\frac{a_{n+1}\left(a_{n}p_{n-1}+p_{n-2}\right)+p_{n-1}}{a_{n+1}\left(a_{n}q_{n-1}+q_{n-2}\right)+q_{n-1}}=\frac{a_{n+1}p_{n}+p_{n-1}}{a_{n+1}q_{n}+q_{n-1}} \)</span></p>

<p>וזה בדיוק הביטוי שקיווינו לקבל! זה מסיים את ההוכחה הזו.</p>

<p>בעזרת הנוסחה הזו אפשר לקבל נוסחה מקסימה נוספת, שמקשרת בין <span>\( \frac{p_{n}}{q_{n}} \)</span> ובין האיבר הקודם לו, <span>\( \frac{p_{n-1}}{q_{n-1}} \)</span>:</p>

<p><span>\( q_{n}p_{n-1}-p_{n}q_{n-1}=\left(-1\right)^{n} \)</span></p>

<p>ההוכחה של זה היא באינדוקציה פשוטה למדי: במקרה הבסיס <span>\( n=1 \)</span> אנו מתבססים על כך שבפיתוח של <span>\( \left[a_{0},a_{1},\ldots,a_{k}\right] \)</span> מקבלים, כמו שכבר ראינו, <span>\( \frac{p_{0}}{q_{0}}=\frac{a_{0}}{1} \)</span> ולכן <span>\( p_{0}=a_{0},q_{0}=1 \)</span> וש-<span>\( \frac{p_{1}}{q_{1}}=a_{0}+\frac{1}{a_{1}}=\frac{a_{0}a_{1}+1}{a_{1}} \)</span>, כלומר <span>\( p_{1}=a_{0}a_{1}+1 \)</span> ו-<span>\( q_{1}=a_{1} \)</span>. אנו מציבים את זה בנוסחה ומקבלים</p>

<p><span>\( q_{1}p_{0}-p_{1}q_{0}=a_{1}a_{0}-\left(a_{0}a_{1}+1\right)=1 \)</span></p>

<p>זה מסיים את המקרה הזה. ובאופן כללי? אם נניח שהקשר מתקיים עבור <span>\( n,n-1 \)</span>, בואו נוכיח אותו עבור <span>\( n+1,n \)</span> תוך ניצול נוסחת הנסיגה שכבר מצאנו, שהיא כזכור</p>

<p><span>\( p_{n+1}=a_{n+1}p_{n}+p_{n-1} \)</span></p>

<p><span>\( q_{n+1}=a_{n+1}q_{n}+q_{n-1} \)</span></p>

<p>נציב את אלו בנוסחה שאנחנו רוצים להוכיח עבורה את הטענה:</p>

<p><span>\( q_{n+1}p_{n}-p_{n+1}q_{n}=\left(a_{n+1}q_{n}+q_{n-1}\right)p_{n}-\left(a_{n+1}p_{n}+p_{n-1}\right)q_{n}= \)</span></p>

<p><span>\( =\left(a_{n+1}q_{n}p_{n}-a_{n+1}p_{n}q_{n}\right)+\left(q_{n-1}p_{n}-p_{n-1}q_{n}\right)= \)</span></p>

<p><span>\( =-\left(p_{n-1}q_{n}-q_{n-1}p_{n}\right)=-\left(-1\right)^{n}=\left(-1\right)^{n+1} \)</span></p>

<p>מה שמסיים גם את זה! עכשיו סוף סוף יש לנו את הכלים שאנחנו צריכים כדי להוכיח את הטענה המקורית שלנו: שעבור <span>\( x \)</span> רציונלי, אם ניקח <span>\( \frac{c}{d} \)</span> חיובי שמקיים</p>

<p><span>\( \left|x-\frac{c}{d}\right|&lt;\frac{1}{2d^{2}} \)</span></p>

<p>אז <span>\( \frac{c}{d} \)</span> יופיע בפיתוח לשבר משולב של <span>\( x \)</span>. נקודה אחת שצריך לשים לב אליה ולא אוכיח פורמלית היא שהפיתוח לשבר משולב שבו כל האיברים הם שלמים הוא <strong>יחיד</strong> למעט אפשרות להתחכם קצת בשלב האחרון: אפשר להחליף את <span>\( \left[a_{0},a_{1},\ldots,a_{n}\right] \)</span> ב-<span>\( \left[a_{0},a_{1},\ldots,a_{n}-1,1\right] \)</span>, כי <span>\( a_{n}-1+\frac{1}{1}=a_{n} \)</span>. אם כן, אם אני אראה שיש ל-<span>\( x \)</span> פיתוח <strong>כלשהו </strong>לשבר משולב שבו <span>\( \frac{c}{d} \)</span> מופיע לפני הסוף, סיימנו. מצד שני, בזכות ההתחכמות שהראיתי, אפשר תמיד להניח שכשאנחנו לוקחים פיתוח של משהו לשבר משולב, אנחנו יכולים לשלוט על האם הפיתוח הוא מאורך <strong>זוגי</strong> או <strong>אי זוגי</strong>, כלומר האם <span>\( q_{n}p_{n-1}-p_{n}q_{n-1} \)</span> הוא 1 או דווקא <span>\( -1 \)</span>; אני הולך להשתמש בזה בקרוב.</p>

<p>עכשיו אפשר לגשת סוף סוף לעניינים. מכיוון ש-<span>\( \frac{c}{d} \)</span> הוא עצמו מספר רציונלי, קיים לו פיתוח לשבר משולב שהאיבר האחרון שלו יסומן ב-<span>\( \frac{p_{n}}{q_{n}} \)</span>:</p>

<p><span>\( \frac{c}{d}=\frac{p_{n}}{q_{n}}=\left[a_{0},a_{1},\ldots,a_{n}\right] \)</span></p>

<p>כאשר כאמור בהמשך אני אגיד אם <span>\( n \)</span> זוגי או לא, בהתאם למה שיתאים לי. הרעיון עכשיו הוא למצוא <span>\( \lambda \)</span> רציונלי כלשהו כך שמתקיים</p>

<p><span>\( x=\left[a_{0},a_{1},\ldots,a_{n},\lambda\right] \)</span></p>

<p>שימו לב: זה לא הפיתוח המלא של <span>\( x \)</span> לשברים משולבים! אבל אם <span>\( \lambda\ge1 \)</span> אפשר להמשיך את הפיתוח - לפתח גם את <span>\( \lambda \)</span> לשבר משולב ולהוסיף את זה להמשך הפיתוח. זה נשמע מבלבל, אבל זה בדיוק מה שעשינו בדוגמה של פאי שכל כך התעקשתי עליה משום מה. הגעתי לביטוי כמו</p>

<p><span>\( \left[3,7,15,1,\frac{854}{33}\right] \)</span></p>

<p>ואז פשוט המשכתי עם <span>\( \frac{854}{33} \)</span>, בעזרת אותה טכניקה שבה מצאתי את האיברים הקודמים בסדרה. אם כן, ה-<span>\( \lambda \)</span> הוא ה-<span>\( \frac{854}{33} \)</span> שלנו כאן - אבל קודם צריך להשתכנע בכך שהוא קיים ושהוא גדול או שווה ל-1.</p>

<p>החלק היפה הוא שאם <span>\( \lambda \)</span> קיים, אנחנו יודעים בדיוק איזו נוסחה שמערבת את <span>\( x \)</span> הוא אמור לקיים, כי זה מה שטרחתי להוכיח קודם:</p>

<p><span>\( x=\left[a_{0},a_{1},\ldots,a_{n},\lambda\right]=\frac{\lambda p_{n}+p_{n-1}}{\lambda q_{n}+q_{n-1}} \)</span></p>

<p>אנחנו רוצים לחלץ את <span>\( \lambda \)</span> מפה, אז נכפול את שני האגפים ב-<span>\( \lambda q_{n}+q_{n-1} \)</span> ונקבל</p>

<p><span>\( \lambda q_{n}x+q_{n-1}x=\lambda p_{n}+p_{n-1} \)</span></p>

<p>נעביר אגפים ונוציא את <span>\( \lambda \)</span> החוצה:</p>

<p><span>\( \lambda\left(q_{n}x-p_{n}\right)=p_{n-1}-q_{n-1}x \)</span></p>

<p>ולסיום נחלק ב-<span>\( q_{n}x-p_{n} \)</span> ונקבל</p>

<p><span>\( \lambda=\frac{p_{n-1}-q_{n-1}x}{q_{n}x-p_{n}} \)</span></p>

<p>הביטוי הזה מוגדר תמיד, למעט במקרה שבו <span>\( x=\frac{p_{n}}{q_{n}} \)</span> ואז נקבל במכנה 0; אבל המקרה הזה הוא טריוויאלי, כי <span>\( \frac{p_{n}}{q_{n}} \)</span> הוא כזכור מה שרצינו לטעון שמופיע בפיתוח של <span>\( x \)</span>, ולכן אם הוא עצמו <span>\( x \)</span> בוודאי שהוא מופיע!</p>

<p>אז נניח ש-<span>\( x\ne\frac{p_{n}}{q_{n}} \)</span>. אנחנו יודעים (זו הייתה ההנחה שלנו) ש-<span>\( \left|x-\frac{p_{n}}{q_{n}}\right|&lt;\frac{1}{2q_{n}^{2}} \)</span> ולכן אפשר לסמן את זה</p>

<p><span>\( x-\frac{p_{n}}{q_{n}}=\frac{\delta}{2q_{n}^{2}} \)</span></p>

<p>כאשר <span>\( 0&lt;\left|\delta\right|&lt;1 \)</span>. נעביר אגף ונקבל</p>

<p><span>\( x=\frac{p_{n}}{q_{n}}+\frac{\delta}{2q_{n}^{2}} \)</span></p>

<p>עכשיו אני רוצה לקחת את זה ולהציב בתוך <span>\( \lambda=\frac{p_{n-1}-q_{n-1}x}{q_{n}x-p_{n}} \)</span>. מכיוון שנקבל ביטוי פשוט אבל עם שלב ביניים מסובך, בואו נטפל במונה ובמכנה בנפרד. קודם כל המכנה:</p>

<p><span>\( q_{n}x-p_{n}=q_{n}\left(\frac{p_{n}}{q_{n}}+\frac{\delta}{2q_{n}^{2}}\right)-p_{n}=p_{n}+\frac{\delta}{2q_{n}}-p_{n}=\frac{\delta}{2q_{n}} \)</span></p>

<p>אוקיי, זה לא היה כל כך נורא! עכשיו המונה:</p>

<p><span>\( p_{n-1}-q_{n-1}x=p_{n-1}-\frac{p_{n}q_{n-1}}{q_{n}}-\frac{q_{n-1}\delta}{2q_{n}^{2}} \)</span></p>

<p>זה נראה מזוויע, אבל זוכרים את הנוסחה <span>\( q_{n}p_{n-1}-p_{n}q_{n-1}=1 \)</span>? היא מתחבאת כאן, רק צריך להעלות את ה-<span>\( p_{n-1} \)</span> הזה למעלה:</p>

<p><span>\( p_{n-1}-\frac{p_{n}q_{n-1}}{q_{n}}-\frac{q_{n-1}\delta}{2q_{n}^{2}}=\frac{p_{n-1}q_{n}-p_{n}q_{n-1}}{q_{n}}-\frac{q_{n-1}\delta}{2q_{n}^{2}}=\frac{\left(-1\right)^{n}}{q_{n}}-\frac{q_{n-1}\delta}{2q_{n}^{2}} \)</span></p>

<p>עכשיו, לחלק את זה ב-<span>\( \frac{\delta}{2q_{n}} \)</span> זה כמו לכפול את זה ב-<span>\( \frac{2q_{n}}{\delta} \)</span> (מותר לנו כי <span>\( \delta\ne0 \)</span> כי <span>\( x\ne\frac{p_{n}}{q_{n}} \)</span>). נקבל:</p>

<p><span>\( \lambda=\frac{2q_{n}}{\delta}\left(\frac{\left(-1\right)^{n}}{q_{n}}-\frac{q_{n-1}\delta}{2q_{n}^{2}}\right)=\left(-1\right)^{n}\frac{2}{\delta}-\frac{q_{n-1}}{q_{n}} \)</span></p>

<p>וזה יצא… ממש פשוט! עכשיו, כזכור אנחנו רוצים לקבל <span>\( \lambda&gt;1 \)</span>; בשביל זה אנחנו חייבים להבטיח שהביטוי <span>\( \left(-1\right)^{n}\frac{2}{\delta} \)</span> ייצא חיובי ולא שלילי, זה מחזיר אותנו לבחירה של <span>\( n \)</span> בהתחלה; אם <span>\( \delta&gt;0 \)</span> אז בוחרים את <span>\( n \)</span> להיות זוגי ומקבלים <span>\( \left(-1\right)^{n}=1 \)</span>, ואם <span>\( \delta&lt;0 \)</span> בוחרים <span>\( n \)</span> אי זוגי ומקבלים <span>\( \left(-1\right)^{n}=-1 \)</span>. בכל מקרה אנחנו לבסוף מקבלים</p>

<p><span>\( \lambda=\frac{2}{\left|\delta\right|}-\frac{q_{n-1}}{q_{n}} \)</span></p>

<p>יותר מזה, בגלל שסדרת המכנים בפיתוח לשבר משולב היא עולה, <span>\( q_{n-1}&lt;q_{n} \)</span> ולכן <span>\( \frac{q_{n-1}}{q_{n}}&lt;1 \)</span> ומצד שני בגלל ש-<span>\( \left|\delta\right|&lt;1 \)</span> אז <span>\( \frac{2}{\left|\delta\right|}&gt;2 \)</span>, ואנחנו מקבלים <span>\( \lambda&gt;1 \)</span>, כפי שרצינו. אנחנו מפתחים אותו לשבר משולב, מקבלים <span>\( \lambda=\left[b_{1},\ldots,b_{m}\right] \)</span> ולבסוף מקבלים <span>\( x=\left[a_{1},\ldots,a_{n},b_{1},\ldots,b_{m}\right] \)</span> - פיתוח מלא של <span>\( x \)</span> לשבר משולב שבמהלכו מופיע <span>\( \frac{a}{b}=\frac{p_{n}}{q_{n}} \)</span>, כפי שרצינו. זה מסיים את ההוכחה!</p>

<h2>דברי סיכום ופרידה</h2>

<p>ובכן, מה היה לנו הפעם? איך זה היה שונה מהפוסט הקודם שלי על האלגוריתם של שור? האלגוריתם מחולק קונספטואלית לשלושה חלקים; החלק הראשון, של הרדוקציה מבעיית הפירוק לגורמים אל בעיית הפרת הסדר, הוא חלק שהרחבתי עליו מאוד בפוסט ההוא והפעם לא נגעתי בו כי אין לי משהו נוסף לומר, אבל בשני החלקים האחרים הרחבתי לא מעט. ראשית, הצגתי באופן מפורש את שור בתור מקרה פרטי של אלגוריתם הערכת פאזה, שזה משהו שבכלל לא ניסיתי לעשות בפוסט הקודם (בואו לא נדבר על השאלה המביכה עד כמה הבנתי את זה בעצמי). שנית, הפעם התעמקתי קצת יותר במשפט הספציפי שקשור לשברים משולבים שמבטיח לנו שעם קצת מזל, ה-<span>\( \frac{s}{r} \)</span> שאנחנו מחפשים יצוץ מתוך תוצאת אלגוריתם הערכת הפאזה. זה דרש גלישה נוספת לתורת המספרים במקום לחישוב קוונטי, אבל הנושא של שברים משולבים הוא כל כך כיפי שלא יכלתי להתאפק.</p>

<p>לאן הולכים מכאן? בסדרת הפוסטים הקודמת שלי, שור היה המטרה הסופית; אבל בסדרה הנוכחית, אני מקווה שעכשיו משהוצאנו את זה מהדרך, אפשר להראות כל מני דברים לא קשורים בעליל אבל מגניבים לא פחות.</p>

  </div>

  <hr />
  <p>
    נהניתם? התעניינתם? אם תרצו, אתם מוזמנים לתת טיפ:
  </p>
  <a href='https://ko-fi.com/H2H5XFBQ' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://az743702.vo.msecnd.net/cdn/kofi2.png?v=2' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a><div class="PageNavigation">
    
      <a class="prev" href="/2022/09/06/phase_estimation_algorithm/">&laquo; חישוב קוונטי: אלגוריתם הערכת פאזה</a>
    
    
      <a class="next" href="/2022/10/09/density_matrices/">חישוב קוונטי: פורמליזם מטריצות הצפיפות &raquo;</a>
    
  </div><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://gadial.net/2022/09/30/shor_algorithm_revisit/';
      this.page.identifier = 'http://gadial.net/2022/09/30/shor_algorithm_revisit/';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://not-precise.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/2022/09/30/shor_algorithm_revisit/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">לא מדויק</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">לא מדויק</li><li><a class="u-email" href="mailto:gadial@gmail.com">gadial@gmail.com</a></li><li>&copy; כל הזכויות שמורות לגדי אלכסנדרוביץ'</li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/%D7%9C%D7%90-%D7%9E%D7%93%D7%95%D7%99%D7%A7-163347110378474"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">לא מדויק</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>RSS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>בלוג על מתמטיקה ומדעי המחשב</p>
      </div>
    </div>

  </div>

</footer><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script>

<!-- Default Statcounter code for New blog
http://www.gadial.net/ -->
<script type="text/javascript">
  var sc_project=5444342; 
  var sc_invisible=1; 
  var sc_security="4a89cbe4"; 
  </script>
  <script type="text/javascript"
  src="https://www.statcounter.com/counter/counter.js"
  async></script>
  <noscript><div class="statcounter"><a title="Web Analytics"
  href="https://statcounter.com/" target="_blank"><img
  class="statcounter"
  src="https://c.statcounter.com/5444342/0/4a89cbe4/1/"
  alt="Web Analytics"></a></div></noscript>
  <!-- End of Statcounter Code --></body>

</html>
