<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מספרי קטלן - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2025/05/31/catalan_numbers/">
    <meta property="og:title" content="מספרי קטלן">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2025/05/31/catalan_numbers/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="מספרי קטלן">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2025/03/15/why_0999_equals_1/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">אז למה 1=...0.999?</span>
            </a>
            

            
            <a href="/2025/06/11/catalan_numbers_and_generating_functions/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">פונקציות יוצרות ומספרי קטלן</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מספרי קטלן</h1>
            <div class="post-meta">
                <span class="date">2025-05-31</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/קומבינטוריקה.html">קומבינטוריקה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/מספרי קטלן.html">מספרי קטלן</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <h2>מבוא</h2>

<p>אם אני אלך ברחוב ואשאל באקראי אנשים איזו סדרה מתמטית הם מכירים, אחרי שנקלף את שכבות האלו שיבהלו ויברחו או יתחכמו ויגידו ש-Numb3rs (אף אחד לא יגיד, העולם כבר שכח שהייתה סדרה כזו וגם לי לא יצא לראות אותה) כנראה אקבל שלל תשובות: "סדרת פיבונאצ'י", "סדרת פיבונאצ'י!", "פיבונאצ'י", "הטבעיים" (חכמולוג, לסנן) ו"פיבונאצ'י". ובכן, סדרת פיבונאצ'י כבודה במקומו מונח, יש עוד סדרות מעניינות בעולם ואני רוצה לדבר בפוסט הזה על אחת אהובה במיוחד - סדרת מספרי קטלן (Catalan, על שם המתמטיקאי הבלגי אז'ן שרל קטלן). זו הסדרה הבאה:</p>
<p><span class="math">\(1,1,2,5,14,42,132,429,1430,4862,\ldots\)</span></p>
<p>מה שמעניין בה הוא שהיא הפתרון של שלל בעיות קומבינטורית שונות ומשונות. המתמטיקאי ריצ'רד סטנלי (שכתב את הספר הפנטסטי Enumerative Combinatorics) התמחה בלאסוף בעיות שונות ומשונות שמספרי קטלן הם הפתרון שלהן, ובסופו של דבר פרסם ספר עם 214 בעיות כאלו. מן הסתם אני לא אכסה כמעט כלום מזה הפעם; אבל אני רוצה בפוסט הזה שנכיר את התכונות הבסיסיות של המספרים הללו (שאנחנו מבינים די טוב) ונראה שלל בעיות שונות ומשונות ולכאורה לא קשורות שהם פותרים.</p>
<p>היסטורית, האדם הראשון שיש לנו אינדיקציה שנתקל במספרי קטלן הוא המתמטיקאי המונגולי Minggatu, בספר על חישוב קירובים שכתב בסביבות 1730 שבו מספרי קטלן הופיעו בתוך חלק מהנוסחאות; זה פחות רלוונטי לנו כאן כי זה לא שימוש במספרי קטלן לפתרון בעיה קומבינטורית. מכאן אנחנו קופצים ל-1751, כשלאונרד אוילר (מהמתמטיקאים הפורים בהיסטוריה שנראה שהתעסק פשוט בכל דבר) תיאר אותם במכתב לשותפו המתמטי כריסטיאן גולדבך, בתור הפתרון של בעיה קומבינטורית ספציפית - אז בואו נתחיל מלדבר על הבעיה הזו למרות שהיא אולי לא הכי פשוטה מבין אלו שאפשר לפתוח בהן.</p>
<h2>שילושים של מצולע</h2>

<p>במקרה הזה תמונה אחת שווה אלף מילים, ואני מתנצל בפני מי שלא יכולים לראות אותה (ואת כל יתר האיורים שהפוסט הזה יהיה עמוס בהם):</p>
<p><img src="/img/2025/catalan_triangulations.svg" alt=""/></p>
<p>מה רואים פה? אני מצייר משושה משוכלל (כלומר מצולע עם שש צלעות שאורכי כל הצלעות שלו שווים וכל הזוויות שלו שוות) ובתוך המשושה אני מותח קווים בין חלק מהקודקודים, בצורה כזו שאין שני קווים שחוצים אחד את השני, ואני מותח מספיק קווים כדי לחלק את המצולע למשולשים. דבר כזה נקרא "שילוש". בימינו אנו שילושים הם דבר מאוד מעניין, למשל בגרפיקה תלת ממדית, אבל כבר בימי אוילר זה היה מספיק מעניין כדי לנסות להבין איך נראים השילושים האפשריים השונים של מצולע - ובפרט, כמה כאלו יש. מה שאנחנו רואים בתמונה הוא את כל 14 השילושים האפשריים של משושה משוכלל. חלק מהשילושים נראים דומים אחד לשני - כאילו אפשר לסובב או לשקף אחד ולקבל את האחר. מה שמעניין אותנו כאן הוא לספור אותם בתור שילושים שונים - כלומר, אפשר לחשוב על זה כאילו מספרנו את הקודקודים של המצולע, ואנחנו מסתכלים על רשימה של שלשות שמציינות קודקודים. הנה דוגמא:</p>
<p><img src="/img/2025/catalan_triangulation_numbered.svg" alt=""/></p>
<p>כאן מספרתי את הקודקודים מ-1 עד 6 בכיוון השעון החל מהקודקוד העליון השמאלי, והמשולשים שלי הם <span class="math">\(\left\{ 1,5,6\right\} ,\left\{ 1,2,5\right\} ,\left\{ 2,4,5\right\} ,\left\{ 2,3,4\right\} \)</span>.</p>
<p>האם יש דרך מסודרת "לייצר" שילושים? למרבה השמחה, כן - דרך <strong>רקורסיבית</strong>. כלומר, אם אנחנו כבר יודעים למצוא שילושים למצולעים פשוטים, אנחנו יכולים לנצל את זה כדי למצוא שילושים למצולעים מורכבים יותר. מה המצולעים הפשוטים ביותר? ובכן, כמובן שמשולש הוא די פשוט - אם יש לנו משולש, ה"שילוש" שלו זה בסך הכל הוא עצמו. שימו לב שזה לא צריך להיות משולש משוכלל ("משולש שווה צלעות") - זה נכון לכל משולש.</p>
<p>אבל חוץ ממשולש, תכף נראה שישתלם לנו לדבר על מצולע אפילו עוד יותר פשוט - מצולע בן <strong>שני קודקודים</strong>. מה זה הדבר הזה? זה בסך הכל קו ישר אחד; אפשר להתלונן ולומר שזה לא <strong>באמת</strong> מצולע, אבל זה לא משנה - כאמור, זה הולך להשתלם לנו לחשוב עליו כמצולע עוד מעט.</p>
<p>בואו ננסה למצוא שילוש למשושה המשוכלל. אני מתחיל עם השאלה - מה קורה עם הצלע 1-2? אני יודע שבסופו של דבר היא תהיה חלק ממשולש שכל הקודקודים שלו שייכים למצולע המקורי, כלומר משולש ששניים מהקודקודים שלו הם 1 ו-2 ואני חופשי לבחור את הקודקוד הנוסף - כל בחירה שונה תניב בסופו של דבר שילושים שונים. בואו נאמר שבחרתי את 5, אז אני מותח קווים אליו מ-1 ו-2, ומקבל:</p>
<p><img src="/img/2025/catalan_triangulation_initial.svg" alt=""/></p>
<p>עכשיו מגיע הצעד הרקורסיבי: קונספטואלית, אפשר לחשוב על זה כאילו אני <strong>מוחק</strong> את הצלע 1-2 מהמשושה ומקבל:</p>
<p><img src="/img/2025/catalan_triangulation_erase.svg" alt=""/></p>
<p>מה שקיבלתי פה הוא שפירקתי את המשושה המקורי לשני מצולעים שונים: המצולע 1-5-6 והמצולע 2-3-4-5. שני המצולעים חולקים קודקוד משותף אחד, את 5 - הקודקוד שבחרתי. בנוסף, יש להם פחות צלעות: לאחד יש 3 ולשני 4 (שימו לב שמספר הצלעות הכולל שלהם הוא כמספר הצלעות במצולע שהתחלנו ממנו, ועוד 1 - זה בגלל שמחקנו את 1-2 אבל הוספנו את 1-5 ואת 2-5). אם יש להם פחות צלעות, אני יכול רקורסיבית לשלש אותם... רגע, שניה, הרי 2-3-4-5 הוא אמנם מצולע, אבל הוא לא מצולע משוכלל, הוא נראה כמו מין טרפז שכזה. למה שאוכל לשלש אותו?</p>
<p>בואו נחשוב שניה - מה אנחנו צריכים כדי שנוכל לשלש צורה? ראינו שכל משולש הוא בר-שילוש, אבל מה קורה בצורה מורכבת יותר? במשושה שלנו הייתה לי הנחה סמויה - שאני באמת יכול להעביר קווים מ-1 ו-2 אל 5. לא הייתה לי בעיה לעשות את זה כי משושה משוכלל הוא צורה <strong>קמורה</strong> - כלומר, צורה שבה כל קו בין שתי נקודות ששייכות לצורה עובר כולו בתוך הצורה. זו ההנחה שאני זקוק לה - כלומר, מה שאני סופר הוא כמה שילושים יש למצולע קמור כלשהו, ויוצא שזה לא באמת תלוי בצורה של המצולע אלא רק במספר הקודקודים שלו.</p>
<p>בואו נכנס סימון לעניין: נסמן ב-<span class="math">\(T_{n}\)</span> את מספר השילושים של מצולע קמור עם <span class="math">\(n\)</span> קודקודים. הספירה שלנו מתחילה מ-2, ואז אמרנו שאני בוחר בצורה שנראית קצת שרירותית להגדיר <span class="math">\(T_{2}=1\)</span>. בנוסף <span class="math">\(T_{3}=1\)</span> כי למשולש יש שילוש יחיד. ומה קורה עבור <span class="math">\(n\)</span> גדולים יותר? אני אעשה את הטריק שכבר ראינו: אסתכל על הקודקודים 1,2 במצולע בן <span class="math">\(n\)</span> הצלעות שלי, ואשאל את עצמי מי הקודקוד הנוסף שמתחבר אליהם. נסמן את הקודקוד הזה ב-<span class="math">\(k\)</span> (<span class="math">\(3\le k\le n\)</span>). אחרי שנחבר את 1,2 אליו ונסיר את הקשת 1-2 נקבל שני מצולעים עם פחות צלעות. כמה צלעות? ובכן, בואו נסתכל על הדוגמא למעלה - שם בחרתי <span class="math">\(k=5\)</span>, מה שאמר שהמצולע הראשון שקיבלנו כלל את הקודקודים <span class="math">\(2,3,4,5\)</span> והמצולע השני את <span class="math">\(5,6,1\)</span>. זה מה שקורה באופן כללי - המצולעים שלנו יהיו בעלי קבוצות הקודקודים</p>
<p><span class="math">\(\left\{ 2,3,\ldots,k\right\} ,\left\{ k,k+1,\ldots,n,1\right\} \)</span></p>
<p>בקבוצה הראשונה יש <span class="math">\(k-1\)</span> קודקודים ובשתיהן יחד יש <span class="math">\(n+1\)</span> קודקודים (כי <span class="math">\(k\)</span> מופיע פעמיים) ולכן בקבוצה השניה יש <span class="math">\(\left(n+1\right)-\left(k-1\right)\)</span> קודקודים. זה אומר שמספר השילושים האפשרי של המצולע הראשון הוא <span class="math">\(T_{k-1}\)</span> ושל השני הוא <span class="math">\(T_{\left(n+1\right)-\left(k-1\right)}\)</span>. עכשיו נשתמש <strong>בקומבינטוריקה</strong>: כל שילוש של המצולע המקורי שלנו מתקבל מבחירה של שילוש אחד של המצולע הראשון ושילוש אחד של המצולע השני, ושתי הבחירות הללו הן בלתי תלויות זו בזו (כלומר, <strong>לכל</strong> שילוש של המצולע הראשון אפשר לבחור <strong>כל</strong> שילוש של המצולע השני ונקבל שילוש שונה של המצולע המקורי) ולכן מספר האפשרויות הכולל הוא <strong>מכפלה</strong> של מספר האפשרויות הראשון ומספר האפשרויות השני - זה מה שנקרא בקומבינטוריקה <strong>עקרון הכפל</strong>. בסך הכל יש <span class="math">\(T_{k-1}\cdot T_{\left(n+1\right)-\left(k-1\right)}\)</span> אפשרויות.</p>
<p>עכשיו, זה היה מספר האפשרויות אם המשולש שאני בונה עם 1,2 כולל גם את <span class="math">\(k\)</span>. עבור בחירות שונות של <span class="math">\(k\)</span> אני אקבל שילושים שונים. האם אותו ניתוח יעבוד בכולן? נראה שכן, אבל כדי לוודא בואו נסתכל על המקרה הקיצוני - נאמר, כשבוחרים את הקודקוד <span class="math">\(k=6\)</span>:<br />
<img src="/img/2025/catalan_triangulation_trivial_case.svg" alt=""/></p>
<p>למה זה המקרה הקיצוני? כי אם עכשיו אני מסיר את הצלע 1-2 אני מקבל "מצולע" בעל שני קודקודים, <span class="math">\(\left\{ 1,6\right\} \)</span>:</p>
<p><img src="/img/2025/catalan_triangulation_trivial_case_erase.svg" alt=""/></p>
<p>אבל זו בדיוק הסיבה שבגללה אמרתי קודם שנוח לי לחשוב גם על המקרה הזה בתור מצולע, עם שילוש יחיד. למי שהגישה הזו מפריעה לו אפשר לנסח עוד דרכים לחשוב על זה - למשל, שאנחנו פשוט גוזרים את כל המשולש 1-2-6 מהמצולע ונשארנו רק עם מצולע יחיד להתמודד איתו. זה לא באמת משנה - השורה התחתונה היא שאני מקבל <span class="math">\(T_{k-1}\cdot T_{\left(n+1\right)-\left(k-1\right)}\)</span> אפשרויות תמיד, לכל <span class="math">\(k\)</span>, כולל מקרי הקיצון של <span class="math">\(k=3\)</span> ו-<span class="math">\(k=n\)</span>.</p>
<p>אם כך, אפשר לחשוב על בניית שילוש של מצולע בתור תהליך שבו אנחנו בוחרים <span class="math">\(k\)</span>, ועבור ה-<span class="math">\(k\)</span> שבחרנו יש לנו <span class="math">\(T_{k-1}\cdot T_{\left(n+1\right)-\left(k-1\right)}\)</span> אפשרויות לבנות שילוש. כאן זה לא תהליך דו-שלבי אלא סיטואציה של "או זה, או זה, או זה". במקרה הזה <strong>עקרון החיבור</strong> בקומבינטוריקה אומר שאנחנו צריכים לחבר את מספר האפשרויות בכל אחד מהמקרים. אצלנו <span class="math">\(3\le k\le n\)</span> ולכן בסך הכל קיבלנו את הנוסחה</p>
<p><span class="math">\(T_{n}=\sum_{k=3}^{n}T_{k-1}T_{\left(n+1\right)-\left(k-1\right)}\)</span></p>
<p>מה שאני אוהב בנוסחה הזו הוא שברור לנו איך היא התקבלה. הבעיה היא שהיא לא יפה במיוחד - יש קטסטרופה שלמה עם האינדקסים שם. אז המתמטיקאים אומרים - היי, בעצם, סדרת ה-<span class="math">\(T\)</span>-ים הזו "מבזבזת" את שני האינדקסים הראשונים של, <span class="math">\(T_{0},T_{1}\)</span> שבכלל לא מוגדרים. בואו נשנה סימון ונתחיל עם סדרה שכן מתחילה מאפס. נסמן ב-<span class="math">\(C\)</span> את האיברים שלה, כלומר <span class="math">\(C_{0}=T_{2}\)</span> ו-<span class="math">\(C_{1}=T_{3}\)</span> וכדומה - באופן כללי, <span class="math">\(C_{n}=T_{n+2}\)</span>. אז נוסחת הנסיגה תהפוך להיות:</p>
<p><span class="math">\(C_{n}=T_{n+2}=\sum_{k=3}^{n+2}T_{k-1}T_{\left(n+3\right)-\left(k-1\right)}=\sum_{k=3}^{n+2}C_{k-3}C_{\left(n+1\right)-\left(k-1\right)}=\)</span></p>
<p><span class="math">\(=\sum_{i=0}^{n-1}C_{i}C_{n+1-\left(i+2\right)}=\sum_{i=0}^{n-1}C_{i}C_{n-1-i}\)</span></p>
<p>כאן השתמשתי בשינוי האינדקס <span class="math">\(i=k-3\)</span> כדי לפשט עוד יותר, ויש כאלו שכדאי שהנוסחה תהיה עוד יותר פשוטה מעדיפים להציג אותה ככה, עם <span class="math">\(C_{n+1}\)</span> במקום <span class="math">\(C_{n}\)</span>:</p>
<p><span class="math">\(C_{n+1}=\sum_{i=0}^{n}C_{i}C_{n-i}\)</span></p>
<p>זו נוסחת הנסיגה המהותית שמגדירה את מספרי קטלן, והיא מה שאוילר מצא (והסיק ממנה את מה שנקרא <strong>הפונקציה היוצרת</strong> של הסדרה ובשיטות מפוקפקות של חשבון דיפרנציאלי ואינטגרלי הסיק ממנה את הנוסחה הסגורה של הסדרה, שנראה בהמשך). כשהיא מוצגת כך, אפשר להבין למה מספרי קטלן הם כל כך בסיסיים - הנוסחה בעצם מתארת כל סיטואציה שבה כדי לבנות אובייקט מגודל <span class="math">\(n+1\)</span> אנחנו בונים זוג אובייקטים שהגודל שלהם מסתכם אל <span class="math">\(n\)</span>, וכל זוג כזה מייצר לנו באופן ייחודי אובייקט מגודל <span class="math">\(n+1\)</span>. זה טיפה טריקי (לפחות עבורי) לראות את זה ישירות עבור שילוש של מצולעים בגלל שמצולע מ"גודל" <span class="math">\(n+1\)</span> במקרה הזה הוא מצולע עם <span class="math">\(n+3\)</span> קודקודים ובהתאם, כשאנחנו מפרקים אותו לאובייקט מגודל <span class="math">\(i\)</span> ומגודל <span class="math">\(n-i\)</span> יש לנו מצולעים עם <span class="math">\(i+2\)</span> קודקודים ו-<span class="math">\(n-i+2\)</span> קודקודים ולכן בסך הכל <span class="math">\(n+4\)</span> קודקודים שאחד מהם (קודקוד <span class="math">\(i\)</span>) נספר פעמיים ולכן הם בדיוק <span class="math">\(n+3\)</span> הקודקודים של המצולע המקורי. הצלחתן לעקוב? יופי, כי אני לא. בכל פעם שבה אני מנסה לראות את זה ככה אני מסתבך בגלל כל עניין הפלוס 2 הזה; לכן הצגתי את זה קודם עם ה-<span class="math">\(T\)</span>-ים.</p>
<p>למרבה המזל יש בעיות קומבינטוריות שנותנות את <span class="math">\(C_{n}\)</span> בצורה ישירה יותר.</p>
<h2>מסלולי שריג</h2>

<p>גם כאן, תמונה אחת עוזרת מאוד להבין מה אני בכלל רוצה. ראשית, תמונה של כל ה-14 אובייקטים מגודל 4 שאני הולך לספור:<br />
<img src="/img/2025/grid_walks_4.svg" alt=""/></p>
<p>אוקיי, אולי זה לא לגמרי ברור. בואו נראה עוד דוגמא קונקרטית:<br />
<img src="/img/2025/grid_walk_basic.svg" alt=""/></p>
<p>יש לנו כאן לוח משבצות, אבל אני מתעניין פחות במשבצות הפעם ויותר בקודקודים שלהן ובקווים שמחברים אותן - לרשת כזו של קודקודים וקווים במרווחים שווים קוראים <strong>שריג</strong>. עכשיו, אני נותן קואורדינטות לכל נקודות השריג כך ש-<span class="math">\(\left(0,0\right)\)</span> היא הנקודה השמאלית-תחתונה ו-<span class="math">\(\left(7,7\right)\)</span> היא הקואורדינטה הימנית-עליונה, ואני מסתכל על <strong>מסלול</strong> שמתחיל מ-<span class="math">\(\left(0,0\right)\)</span> ומסתיים ב-<span class="math">\(\left(7,7\right)\)</span>. כל צעד במסלול עובר מקודקוד אחד לאחר על הקו שמחבר ביניהם, המסלול הספציפי שלי מתחיל בצעד ימינה, ואז למעלה, ימינה, למעלה... טוב, זה כאב ראש לתאר הכל במפורש, אבל אפשר לתאר בצורה קומפקטית בתור רצף של אותיות: R מסמן צעד ימינה ו-U מסמן צעד למעלה, ואז המסלול שמתואר באיור הוא</p>
<p>RURURRRUURUUUR</p>
<p>ספירה מהירה תראה שיש במסלול הזה 14 צעדים - בדיוק 7 צעדי R ו-7 צעדי U, מה שלא כל כך מפתיע כי כדי להגיע מלמטה למעלה צריך 7 צעדים, וכך גם כדי להגיע משמאל לימין. השאלה היא רק מה יהיה הסדר הפנימי בין הצעדים הללו. עכשיו, אפשר להוסיף גם צעדים שמאלה/למטה, אבל הם רק יובילו לכך שהמסלול יהיה ארוך יותר, ואנחנו מתעניינים בשאלה כמה מסלולים קצרים ביותר יש. באופן כללי, לכל <span class="math">\(n\)</span> טבעי, אנחנו שואלים את השאלה כמה מסלולי שריג יש מ-<span class="math">\(\left(0,0\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span> שאורכם בדיוק <span class="math">\(2n\)</span>.</p>
<p>מתברר שזו שאלה <strong>קלה</strong> שאנחנו לא צריכים את מספרי קטלן עבורה, אבל כן צריך להכיר קצת קומבינטוריקה בסיסית מהסוג שתיארתי <a href="https://gadial.net/2010/06/20/combinatorics_intro/">בפוסט הזה</a>: שם דיברתי על כך שמספר האפשרויות לבחור <span class="math">\(k\)</span> מתוך <span class="math">\(n\)</span> איברים, כשאין חשיבות לסדר שבו האיברים נבחרים ואי אפשר לבחור איבר פעמיים, הוא בדיוק מה שמסומן בתור <span class="math">\({n \choose k}\)</span> (קרי: "<span class="math">\(n\)</span> בחר <span class="math">\(k\)</span>") ושווה ל-<span class="math">\({n \choose k}=\frac{n!}{k!\left(n-k\right)!}\)</span>. אני אניח פה שהדבר הזה מוכר.</p>
<p>עכשיו, אפשר לחשוב על מסלול מאורך <span class="math">\(2n\)</span> שכולל בדיוק <span class="math">\(n\)</span> צעדי U ו-<span class="math">\(n\)</span> צעדי R בתור משהו שניתן להרכיב כך: ראשית, מבין <span class="math">\(2n\)</span> הצעדים במסלול (הצעד הראשון, השני, השלישי וכו') אנחנו בוחרים בדיוק <span class="math">\(n\)</span> ומציבים בהם U, ואז בכל השאר מציבים R. זו בחירה <strong>בלי</strong> חשיבות לסדר, כי זה לא משנה אם קודם החלטתי שבצעד 1 יהיה U ואז החלטתי שבצעד 5 יהיה גם U או אם החלטתי את זה קודם עבור צעד 5 ורק אז עבור צעד 1. זו גם בחירה שבה אי אפשר לבחור איבר פעמיים, כי אני לא יכול להחליט שאני רוצה לדחוף לצעד 5 "פעמיים U". לכן מספר מסלולי השריג מאורך <span class="math">\(2n\)</span> מ-<span class="math">\(\left(0,0\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span> הוא בדיוק <span class="math">\({2n \choose n}\)</span>. זה היה קל.</p>
<p>אז בואו נסבך קצת את הבעיה. אני הולך למתוח <strong>אלכסון</strong> בלוח שלי, ולחפש רק את המסלולים <strong>שלא מגיעים מעל האלכסון</strong>, כלומר לא מבקרים באף משבצת מהצורה <span class="math">\(\left(a,b\right)\)</span> כך ש-<span class="math">\(a<b\)</span>. המסלול שציירתי קודם <strong>כמעט</strong> מקיים את זה, אבל נכשל ברגע האחרון:</p>
<p><img src="/img/2025/grid_walk_wrong.svg" alt=""/></p>
<p>כדי שיהיה קל להבין מה הולך פה, האיור שלי משתמש בויזואליזציה נחמדה שראיתי במקור בויקיפדיה האנגלית: צובעים את כל המשבצות <strong>מתחת</strong> למסלול בצבע כתום, והקריטריון לכך שהמסלול תקין הוא שהאלכסון (הקו המקווקו) לא עובר בתוך אף משבצת כתומה. כמה מסלולים כאלו יש? האינטואיציה הראשונית שלי היא שחצי ממספר המסלולים הכולל, כלומר <span class="math">\(\frac{1}{2}{2n \choose n}\)</span>, כי אנחנו לוקחים רק את המסלולים ש<strong>מתחת</strong> לאלכסון ולכל מסלול כזה יש מסלול סימטרי <strong>מעל</strong> האלכסון (כזה שבו כל צעד "למעלה" מוחלף בצעד "ימינה" וכל צעד "ימינה" מוחלף בצעד "למעלה"). רק שכמובן שזה לא עובד כי רוב המסלולים הם בכלל כאלו ש<strong>חוצים</strong> את האלכסון, לא שנשארים רק מעליו או מתחתיו. אז מה עושים?</p>
<p>אני אתחיל מלמצוא נוסחה רקורסיבית עבור מספר המסלולים, והפלא ופלא נקבל בדיוק את הנוסחה הרקורסיבית שכבר ראינו עבור <span class="math">\(C_{n}\)</span>. אחרי זה נראה להטוט שאני מאוד אוהב שיאפשר לנו לקבל עבור <span class="math">\(C_{n}\)</span> את הנוסחה המדויקת <span class="math">\(C_{n}=\frac{1}{n+1}{2n \choose n}\)</span>. אם היקום היה מושלם, אז הלהטוט היה פשוט לראות בעיה קומבינטורית שקל באופן ישיר לראות שיש לה <span class="math">\(\frac{1}{n+1}{2n \choose n}\)</span> פתרונות, אבל את זה אני לא יודע איך עושים אז אעשה משהו קצת יותר מתוסבך, אבל לא הרבה יותר.</p>
<p>אז איך נראה מסלול שריג "חוקי", כזה שבשום שלב לא עובר מעל האלכסון? דבר אחד שאנחנו יודעים בודאות הוא שהצעד הראשון חייב להיות R, אחרת המסלול יגיע מעל האלכסון כבר בצעד הראשון שלו. אז בואו נתחיל את זה:<br />
<img src="/img/2025/grid_walk_example_1.svg" alt=""/></p>
<p>אחרי הצעד הזה, המסלול לא נוגע באלכסון - הוא מתחתיו. הדבר השני שאנחנו יודעים הוא ש<strong>מתישהו</strong> המסלול הולך לגעת באלכסון - לכל המאוחר הוא יגיע אליו ממש בסוף, כשיגיע אל <span class="math">\(\left(n,n\right)\)</span>, אבל הוא בהחלט יכול להגיע לשם עוד קודם ולגעת בו כמה פעמים. מה שאני הולך להסתכל עליו הוא מה שקורה למסלול עד הפעם <strong>הראשונה</strong> שבה הוא מגיע אל האלכסון. מה שברור הוא שבצעד האחרון, שבו מגיעים אל האלכסון, המסלול הולך <strong>למעלה</strong> (כי אם הוא היה הולך ימינה ומגיע אל האלכסון, זה אומר שהוא נמצא מעליו, וזה לא חוקי). אז מה קורה למסלול <strong>בין</strong> ה-R ההתחלתי וה-U האחרון הזה? אפשר לצייר <strong>עוד</strong> אלכסון, מתחת לאלכסון המרכזי שלנו, לקרוא לו "האלכסון המשני" ולראות שהמסלול שלנו בין הצעד הראשון והאחרון נמצא כולו <strong>מתחת לאלכסון המשני</strong>. פשוט כי לעלות מעל האלכסון המשני אומר להגיע ולגעת באלכסון הראשי, וזה מה שאמרתי שקורה רק בסוף. במילים אחרות - בין הצעד הראשון והאחרון יש לנו <strong>עוד</strong> משהו שמתנהג בדיוק כמו מסלול שריג חוקי, פשוט על שריג קטן יותר. בדוגמא שלי צבעתי באדום את הצעדים שמתאימים למסלול הזה והאורך שלו הוא 6 (כלומר, 3 צעדי R ו-3 צעדי U).<br />
<img src="/img/2025/grid_walk_example_2.svg" alt=""/></p>
<p><strong>אחרי</strong> ההגעה לאלכסון הראשי, יש לנו עוד מסלול שמתנהג כמו מסלול שריג חוקי שלא עובר מעל האלכסון, פשוט על שריג קטן יותר - המשבצות שנותרו. אצלי צבעתי אותו בכחול והאורך שלו הוא גם כן 3:</p>
<p><img src="/img/2025/grid_walk_example_3.svg" alt=""/></p>
<p>זו החוקיות הכללית: כל מסלול חוקי מאורך <span class="math">\(2n\)</span> מורכב מ-R בהתחלה (שמביא את המסלול אל <span class="math">\(\left(1,0\right)\)</span>), ואז מסלול חוקי מאורך <span class="math">\(2k\)</span> כלשהו (שמביא את המסלול אל <span class="math">\(\left(k+1,k\right)\)</span>), ואז U (שמביא את המסלול אל <span class="math">\(\left(k+1,k+1\right)\)</span>) ואז עוד מסלול חוקי (שמגיע אל <span class="math">\(\left(n,n\right)\)</span>). מכיוון שהאורך הכולל של המסלולים הוא <span class="math">\(2n\)</span> ו"בזבזנו" 2 צעדים על ה-R בהתחלה וה-U בהמשך ובזבזנו עוד <span class="math">\(2k\)</span> צעדים על המסלול החוקי הראשון, אז השני יהיה מאורך <span class="math">\(2n-2-2k=2\left(n-k-1\right)\)</span>. כדי שהמספרים ייראו נחמד, בואו נדבר על מסלול מאורך <span class="math">\(2\left(n+1\right)\)</span>, נמשיך לקרוא לאורך של המסלול הראשון <span class="math">\(2k\)</span> ואז האורך של השני יהיה <span class="math">\(2\left(n-k\right)\)</span>.</p>
<p>קל לנחש את הצעד הבא: אני אסמן ב-<span class="math">\(C_{n}\)</span> את מספר המסלולים מאורך <span class="math">\(2n\)</span>, אז קיבלתי ש-</p>
<p><span class="math">\(C_{n+1}=\sum_{k=0}^{n}C_{k}C_{n-k}\)</span></p>
<p>מה שאנחנו רואים פה בפעולה הוא בדיוק את העיקרון של "שני אובייקטים בלתי תלויים שסכום הגדלים שלהם הוא <span class="math">\(n\)</span> מצטרפים ליצירת אובייקט חדש מגודל <span class="math">\(n+1\)</span>" (כאן ה"גודל" הוא, נאמר, מספר צעדי ה-R). עבורי, כשאני סתם רואה את הנוסחה של קטלן, השאלה שבאה מעצמה היא "למה בעצם איברים שסכום הגדלים שלהם הוא <span class="math">\(n\)</span> יוצרים משהו מגודל <span class="math">\(n+1\)</span>? מאיפה הפלוס אחד הזה בא?" וכאן אנחנו רואים דוגמא לדרך שבה הוא עשוי לבוא - אין לנו <strong>חופש בחירה</strong> מלא של איך לבנות את האובייקט החדש מתוך הקיימים; אנחנו <strong>חייבים</strong> לתת צעד ראשון R, מה ש"מבזבז" לנו צעד אחד.</p>
<p>אגב, מה מקרה הקיצון כאן? מה קורה בעצם כש-<span class="math">\(k=0\)</span>? במקרה הזה המסלול הראשון הוא "ריק" ולא כולל צעדים: המסלול הגדול פשוט עושה את ה-R בהתחלה ואז מייד את ה-U שמביא אותו אל האלכסון הראשי - וזה בסדר, אנחנו סופרים את המסלול הריק פעם אחת והנוסחה מסתדרת יפה ("מסלול ריק" זו לא איזו המצאה תלושה; זו בסך הכל סדרה ריקה, דהיינו פונקציה שהתחום שלה ריק, כלומר קבוצה ריקה - אפשר לפרמל את זה עד הסוף, אבל האם זה באמת עוזר לנו להבין את זה יותר טוב?)</p>
<p>טוב ויפה, אז שוכנענו שמספר מסלולי השריג שלא עולים מעל האלכסון הוא בדיוק מספר קטלן, אבל הבטחתי להראות דרך למצוא נוסחה סגורה עבורם בעזרת מסלולי שריג. בואו נראה את זה קורה. מה שאני הולך לעשות בפועל הוא לספור את המסלולים <strong>הלא חוקיים</strong>, אלו שכן חוצים את האלכסון. אני אוכיח שהמספר שלהם, עבור השריג מגודל <span class="math">\(n\)</span>, הוא <span class="math">\({2n \choose n-1}\)</span>. עכשיו אפשר לעשות טיפה אלגברה:</p>
<p><span class="math">\({2n \choose n-1}=\frac{\left(2n\right)!}{\left(n-1\right)!\left(n+1\right)!}=\left(2n\right)!\cdot\frac{n}{n!}\cdot\frac{1}{n!\left(n+1\right)}=\frac{\left(2n\right)!}{n!n!}\cdot\frac{n}{n+1}={2n \choose n}\cdot\frac{n}{n+1}\)</span></p>
<p>מכיוון שמספר המסלולים הכללי הוא <span class="math">\({2n \choose n}\)</span>, אני אקבל שמספר המסלולים החוקיים הוא:</p>
<p><span class="math">\({2n \choose n}-{2n \choose n-1}={2n \choose n}-{2n \choose n}\cdot\frac{n}{n+1}\)</span></p>
<p><span class="math">\(={2n \choose n}\left(1-\frac{n}{n+1}\right)=\frac{1}{n+1}{2n \choose n}\)</span></p>
<p>קיבלנו את הנוסחה הסגורה <span class="math">\(C_{n}=\frac{1}{n+1}{2n \choose n}\)</span>. יש כאמור עוד שלל דרכים להסיק אותה (ואוילר עשה את זה אלגברית, בעזרת הפונקציה היוצרת) אבל אני אוהב את הדרך הקומבינטורית שאראה עכשיו כי היא מאוד ציורית.</p>
<p>האתגר שלנו הוא לספור כמה מסלולים קיימים ש<strong>כן</strong> עולים מעל האלכסון. בדומה למה שעשיתי קודם, גם עכשיו הרעיון יהיה להסתכל על מסלול כללי כזה ולפרק אותו לחלק שלפני המעבר על החוק, והחלק שאחריו, ואז לעשות איזו מניפולציה. בואו נראה דוגמא:<br />
<img src="/img/2025/grid_walk_mirror_1.svg" alt=""/></p>
<p>הפעם הראשונה שבה המסלול הזה מגיע אל מעל האלכסון המרכזי הוא בקואורדינטה <span class="math">\(\left(4,5\right)\)</span>. מה שקורה אז הוא שהמסלול נוגע לראשונה באלכסון <strong>המשני</strong> שנמצא מעל האלכסון הראשי - כלומר האלכסון <span class="math">\(y=x+1\)</span>.</p>
<p>עכשיו מגיע הטריק: אני הולך <strong>לשקף</strong> את החלק של המסלול עד להגעה אל <span class="math">\(\left(4,5\right)\)</span>, ולשקף אותו ביחס לאלכסון המשני הזה. זה הולך להיראות ככה:<br />
<img src="/img/2025/grid_walk_mirror_2.svg" alt=""/></p>
<p>המסלול המשוקף עושה בדיוק ההפך ממה שהמסלול הרגיל עושה - בכל פעם שהרגיל עושה U המשוקף עושה R, ולהפך. הבדל נוסף הוא בנקודת ההתחלה: המסלול הרגיל מתחיל בנקודה <span class="math">\(\left(0,0\right)\)</span>, שהיא צעד R אחד מהנקודה <span class="math">\(\left(-1,0\right)\)</span> שדרכה עובר האלכסון המשני; המסלול המשוקף מתחיל בנקודה שהיא צעד U אחד מאותה נקודה, כלומר הוא מתחיל מ-<span class="math">\(\left(-1,1\right)\)</span>.</p>
<p>עכשיו, אם ניקח את המסלול המשוקף עד שהוא מגיע לנקודה <span class="math">\(\left(4,5\right)\)</span> ואז נמשיך ללכת במסלול <strong>הרגיל</strong>, מה שקיבלנו הוא מסלול מ-<span class="math">\(\left(-1,1\right)\)</span> אל <span class="math">\(\left(10,10\right)\)</span>, והיופי הוא כמובן שזה עובד באופן כללי. כלומר, הטכניקה הזו של "לקחת מסלול שעובר מעל האלכסון הראשי, להעביר אלכסון משני מהנקודה הראשונה שבה זה קורה, לשקף ולחבר עם המשך המסלול" - זו טכניקה שבהינתן מסלול שעובר מעל האלכסון הראשי נותנת לנו מסלול מ-<span class="math">\(\left(-1,1\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span>. לא קשה להוכיח את זה פורמלית: הרי מסלול הוא בסך הכל סדרה של U ו-R, ומה שעושה פעולת השיקוף היא כאמור להפוך כל R אל U וכל U אל R. אם אנחנו עושים את זה עבור מסלול כללי עד הנקודה שבה המסלול הגיע לנקודה מהצורה <span class="math">\(\left(a,a+1\right)\)</span>, זה אומר שהמסלול כלל <span class="math">\(a\)</span> צעדי R ו-<span class="math">\(a+1\)</span> צעדי U ולכן המסלול המשוקף כולל <span class="math">\(a\)</span> צעדי U ו-<span class="math">\(a+1\)</span> צעדי R - ולכן אם הוא מתחיל מ-<span class="math">\(\left(-1,1\right)\)</span> הוא יגיע אל <span class="math">\(\left(-1+\left(a+1\right),1+a\right)=\left(a,a+1\right)\)</span> ומשם אפשר יהיה להמשיך אותו כרגיל.</p>
<p>העניין הוא שאפשר לעשות גם <strong>את ההפך</strong>: לקחת מסלול <strong>כלשהו</strong> מ-<span class="math">\(\left(-1,1\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span> ולקבל ממנו מסלול מ-<span class="math">\(\left(0,0\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span> שעובר מעל האלכסון. הרעיון פשוט: ברגע שהמסלול שלנו נוגע באלכסון המשני <span class="math">\(y=x+1\)</span>, לבצע עליו את אותה פעולת שיקוף בדיוק. והנה הפאנץ': <strong>כל</strong> מסלול מ-<span class="math">\(\left(-1,1\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span> חייב מתישהו להגיע אל האלכסון המשני, כי הוא מתחיל את המסלול <strong>מעליו</strong> אבל מסיים את המסלול <strong>מתחתיו</strong>. מכאן שבאמת אפשר להפוך ככה כל מסלול מ-<span class="math">\(\left(-1,1\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span>, ובמילים אחרות - ההתאמה בין מסלולים מ-מ-<span class="math">\(\left(-1,1\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span> ומסלולים לא חוקיים מ-<span class="math">\(\left(0,0\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span> היא התאמה חח"ׂע ועל - גודל שתי הקבוצות הללו זהה. אבל מסלולים <strong>כלשהם</strong> מ-<span class="math">\(\left(-1,1\right)\)</span> אל <span class="math">\(\left(n,n\right)\)</span> שכוללים רק צעדי U ו-R - את זה קל לספור. מסלול כזה חייב להכיל <span class="math">\(n+1\)</span> צעדי R ו-<span class="math">\(n-1\)</span> צעדי U, ולכן מספר הצעדים הכולל שלו הוא <span class="math">\(\left(n-1\right)+\left(n+1\right)=2n\)</span> ומתוכם צריך לבחור <span class="math">\(n-1\)</span> כדי להציב בהם את ה-U - וזה בדיוק <span class="math">\({2n \choose n-1}\)</span>. קיבלנו את התוצאה שחיפשנו.</p>
<p>למסלולי שריג יש שם: <strong>מסלולי דיק</strong> (Dyck), והם קשורים בצורה ישירה לסדרות של תווים שנקראות <strong>מילות דיק</strong>. הרעיון במילת דיק, בהקשר הזה, הוא שזו מילה מאורך <span class="math">\(2n\)</span> שמורכבת משני תווים שכל אחד מופיע <span class="math">\(n\)</span> פעמים - אלו בדיוק ה-U,R אצלנו. הדרישה הנוספת, שתואמת את הדרישה שהמסלול לא יעבור מעל האלכסון, היא שבאף <strong>רישא</strong> של המילה לא יהיו יותר U מאשר R-ים (רישא היא תת-מילה שמקבלים מכך שמתחילים מהאות הראשונה במילה, מתקדמים הלאה ועוצרים מתישהו). דרך אחרת לתאר מסלולי דיק היא אם מפרשים את U בתור "למטה וימינה" ואת R בתור "למעלה וימינה" ואז מקבלים מסלול מ-<span class="math">\(\left(0,0\right)\)</span> אל <span class="math">\(\left(n,0\right)\)</span> שלא יורד מתחת לציר <span class="math">\(x\)</span> בשום שלב. הנה ציור סכמטי של איך 14 המסלולים מאורך 4 נראים:<br />
<img src="/img/2025/dyck_paths_4.svg" alt=""/></p>
<p>דרך נחמדה אחת לחשוב על מילות דיק היא אם מפרשים את R בתור סוגריים שמאליים, כלומר הסימן ")", ואת U בתור סוגריים ימניים, כלומר "(". כשכותבים סוגריים, מקובל לפעמים לשים סוגריים בתוך סוגריים (אמנם, לא תמיד אבל זה די נפוץ (למשל פראצ'ט מאוד אהב התחכמויות כאלו (האמת שאני לא בטוח אם פראצ'ט השתמש בסוגריים בתוך סוגריים או בהערות שוליים בתוך הערות שוליים) והוא לא היחיד מסוגו) ולכן כשאני משתמש בזה כאן זה לא כזה חריג). כשכותבים משמאל לימין, כמו למשל במתמטיקה, הכלל הוא שסוגריים שמאליים פותחים קונטקסט חדש וסוגריים ימניים סוגרים את הקונטקסט הפתוח הנוכחי. אם ברישא כלשהי יהיו יותר סוגריים ימניים משמאליים, זה אומר שייסגרו יותר קונטקסטים מאשר נפתחו עד כה, וזה לא הגיוני - ולכן זה "אסור". ובאמת, כשמנסים לנתח ביטוי שכולל סוגריים הרבה פעמים עושים בדיוק את הפירוק שראינו כאן - הולכים עד הפעם הראשונה שבה מספר הסוגריים הימניים משתווה לשמאליים, ומפרקים ל"מה שבין הסוגר הימני שבהתחלה והסוגר השמאלי שעכשיו, וכל מה שבא אחר כך".</p>
<h2>עצים</h2>

<p>נראה לי שכבר הבנו את הרעיון - אני מציג משהו חדש שמתאים למספרי קטלן, קודם כל אני מראה תמונה של 14 האובייקטים שמתאימים לגודל 4, כלומר למקרה <span class="math">\(C_{4}=14\)</span>:<br />
<img src="/img/2025/binary_trees_4.svg" alt=""/></p>
<p>מה שאנחנו רואים פה הוא <strong>עצים בינאריים</strong> עם 4 צמתים. עצים בינאריים כאלו הם מקרה פרטי של <strong>גרף</strong> - הרעיון בגרף הוא שיש לנו אוסף של נקודות שנקראות "צמתים" וקווים שמחברים אותם, שנקראים "קשתות". הרעיון הכללי ב"עץ" הוא שזה גרף שבו יש צומת מיוחד - "השורש" - שאפשר להגיע ממנו לכל הצמתים האחרים בגרף. אנחנו אוהבים לצייר עצים כך שהשורש הוא הצומת העליון ביותר וה"כיוון" של העץ הוא כלפי מטה (אבל אם רוצים אפשר גם להגדיר שמותר לעלות למעלה בחזרה, מה שאומר שכל צומת הוא בעצם שורש, וזו לא בעיה). אם אנחנו משתמשים בקונבנציה הזו של "מלמעלה למטה" אז בסיטואציה שבה יש קשת מצומת א' לצומת ב' הנמוך יותר, אומרים שא' הוא <strong>אבא</strong> של ב' ושב' הוא <strong>ילד</strong> של א'. הרעיון בעץ <strong>בינארי</strong> הוא שלכל צומת יש לכל היותר שני בנים - ויותר מכך, יש ביניהם <strong>סדר</strong>. יש בן ימני ובן שמאלי, וזה נשאר כך גם אם אחד מהבנים חסר. כלומר, לכל צומת יש ארבע אפשרויות: או שיש לו שני בנים, או שאין לו בנים, או שיש לו בן ימני או שיש לו בן שמאלי.</p>
<p>עצים בינאריים הם מושג חשוב ומועיל במדעי המחשב - למשל, נוח לאחסן בהם נתונים בצורה שהופכת חיפושים ליעילים. אבל כאן אנחנו מתעניינים <strong>במספר</strong> שלהם, וכצפוי התוצאה היא שמספר העצים הבינאריים עם <span class="math">\(n\)</span> צמתים הוא <span class="math">\(C_{n}\)</span>. גם פה קל לראות את זה בעזרת בניה רקורסיבית, ועצים הם אולי המקרה הטבעי ביותר שבו בניה כזו צצה; זה ממש נעוץ בהגדרה. אני מגדיר <strong>עץ בינארי</strong> באופן הבא: עץ ריק (עם 0 צמתים) הוא עץ בינארי, ובהינתן שני עצים בינאריים <span class="math">\(T_{1},T_{2}\)</span> ניתן לבנות מהם עץ בינארי חדש על ידי הוספת צומת שורש חדש כך שאם יש ל-<span class="math">\(T_{1}\)</span> שורש, הוא הבן הימני של השורש החדש, ואם יש ל-<span class="math">\(T_{2}\)</span> שורש הוא הבן השמאלי של השורש החדש.</p>
<p>עם ההגדרה הזו, מה קיבלנו? שמשני עצים אנחנו מקבלים עץ חדש <strong>על ידי הוספת צומת</strong>. כלומר, אם קודם סכום הצמתים ב-<span class="math">\(T_{1},T_{2}\)</span> היה <span class="math">\(n\)</span>, בעץ החדש יש <span class="math">\(n+1\)</span> צמתים. מכאן הנוסחה הרקורסיבית מגיעה מייד - והפעם הבניה הייתה סימטרית, להבדיל ממה שקרה עבור שילושים או מסלולי שריג.</p>
<p>יופי, זה היה פשוט! בואו נעבור למשהו קצת יותר מוזר:<br />
<img src="/img/2025/plane_trees_4.svg" alt=""/></p>
<p>מה אנחנו רואים כאן? גם זה נראה כמו עצים, אבל לא בינאריים - יש צמתים עם יותר משני בנים. אלו גם לא עצים עם 4 צמתים אלא דווקא עם 5 צמתים, אז מה הקטע? עצים כאלו נקראים "עצים סדורים" (או plane trees ועוד כל מני שמות) וההסבר הכי פשוט מה הם הוא פשוט ההגדרה: עץ סדור הוא גרף שכולל צומת מיוחד שנקרא <strong>השורש</strong> של העץ, ובנוסף יש רשימה <span class="math">\(P_{1},\ldots,P_{n}\)</span> (אולי ריקה) של עצים סדורים כך שלכל <span class="math">\(i\)</span> יש קשת מהשורש של העץ אל השורש של <span class="math">\(P_{i}\)</span>, והסדר בין הבנים של צומת הוא חשוב (כלומר, הרשימות <span class="math">\(P_{1},P_{2}\)</span> ו-<span class="math">\(P_{2},P_{1}\)</span> ייתנו עצים שונים אם <span class="math">\(P_{1}\ne P_{2}\)</span>).</p>
<p>עבור עצים סדורים מתקיים שמספר העצים הסדורים עם <span class="math">\(n+1\)</span> צמתים הוא <span class="math">\(C_{n}\)</span>, וזה מה שמודגם באיור. במבט ראשון זה קצת מפתיע - עץ סדור זו הגדרה יותר "חופשית" מעצים בינאריים, אז איך ייתכן שיש <strong>יותר</strong> עצים בינארים מעצים סדורים? הרי בהינתן <span class="math">\(n\)</span> יש <span class="math">\(C_{n}\)</span> עצים בינאריים אבל רק <span class="math">\(C_{n-1}\)</span> עצים סדורים עם <span class="math">\(n\)</span> צמתים. העניין הוא שבעץ בינארי מקרים של בנים חסרים <strong>עדיין נספרים</strong>. כמו שאמרתי קודם, אנחנו מבדילים בין המקרה שבו יש לצומת רק בן ימני והמקרה שיש לו רק בן שמאלי - ואת זה אין בעצים סדורים. אם יש רק בן יחיד לצומת, אז זה מקרה אחד שלא הולך להיספר פעמיים.</p>
<p>טוב ויפה, אז איך מראים שעצים סדורים מקיימים את הנוסחה הרקורסיבית? ובכן... אה... אני לא יודע. עבורי זה מקרה מעניין בדיוק בגלל שעצים סדורים <strong>לא</strong> נראים ממבט ראשון כמו משהו שקל להתאים לבניה רקורסיבית של שני חלקים. אני מניח שאם מתאמצים קצת אפשר למצוא דרך לקבל את הנוסחה הרקורסיבית גם כאן, אבל אני לא רוצה לעשות את זה כי יש התאמה חד-חד-ערכית ועל יפהפיה בין עצים בינאריים ועצים סדורים. בואו נראה דוגמא לאיך זה עובד, באדיבות הספר של Stanely:<br />
<img src="/img/2025/trees_bijaction_diragram.svg" alt=""/></p>
<p>בצד שמאל יש לנו עץ סדור ובצד ימין יש לנו את העץ הבינארי שמתאים לו, כשבמרכז יש לנו איזה שהוא "ייצוג ביניים" שמסביר איך מקבלים אחד מהשני. איך זה עובד? נתחיל מהעץ הסדור בצד השמאל ונבצע עליו את הפעולות הבאות:</p>
<ol> <li>לכל צומת, נחבר כל בן של הצומת לבן הבא בתור של הצומת בקו מקוווקו.</li>


<li>לכל צומת, נמחק את כל הקשתות ממנו לבנים שלו חוץ מאשר לבן השמאלי ביותר.</li>


<li>נמחק את צומת השורש מהגרף.</li>


<li>נהפוך את הקווים המקווקווים לקווים רגילים.</li>

</ol>

<p>במילים אחרות, כל צומת "איבד" את כל הבנים שלו חוץ מאחד, אבל "הרוויח" את אחד האחים שלו (אם יש כזה). הבנים של הצומת שנותקו לא הלכו לאיבוד כי כולם עדיין מחוברים אל הבן שלא נותק, והעץ בינארי כי עכשיו לכל צומת יש לכל היותר שני בנים: הבן השמאלי המקורי שלו (אם היו לו בנים) והאח שמימין לו (אם היה לו כזה).</p>
<p>למה זו התאמה חח"ע ועל? כי אפשר <strong>להפוך</strong> אותה, כלומר מכל עץ בינארי לקבל עץ סדור, ובצורה כזו שאם נתחיל מעץ סדור, נהפוך אותו לבינארי ואז חזרה לעץ סדור, אכן נחזור לעץ שהתחלנו ממנו. הנה השיטה:</p>
<ol> <li>נוסיף לגרף צומת חדש שיהיה מחובר לבן שמאלי יחיד - השורש של הגרף המקורי.</li>


<li>לכל צומת, אם יש לו בן ימני נהפוך את הקו שמחבר אותם למקווקו.</li>


<li>לכל צומת <span class="math">\(a\)</span>, אם יש לו בן שמאלי <span class="math">\(b\)</span>, נלך ימינה על גבי הקווים המקווקווים החל מ-<span class="math">\(b\)</span> ונהפוך כל צומת שנפגוש בדרך לבן של הצומת <span class="math">\(a\)</span>, כשהסדר שלהם הוא כמו הסדר שבו פוגשים אותם על המסלול (<span class="math">\(b\)</span> נותר הבן הכי שמאלי).</li>


<li>נמחק את הקווים המקווקווים מהגרף.</li>

</ol>

<p>קל לראות שזה באמת עובד - ובחיי שזו התאמה מרהיבה.</p>
<h2>דברים שלא נחתכים</h2>

<p>בואו נראה עוד תמונה של 14 דברים!<br />
<img src="/img/2025/nonintersecting_chords_4.svg" alt=""/></p>
<p>מה שיש לנו כאן הוא קבוצות של 8 נקודות <strong>על מעגל</strong>. אני לא מצייר את המעגל כי הוא רק מקשה להבין מה קורה פה, אבל מכאן הנקודות מגיעות. חלק מהנקודות מחוברות בקווים שעוברים בתוך המעגל - <strong>מיתרים</strong>. הפואנטה פה היא שאנחנו מחלקים את הנקודות לזוגות, ובין כל זוג מעבירים מיתר, כך שהמיתרים <strong>לא נחתכים</strong>. עבור <span class="math">\(n\)</span> מיתרים שאנחנו מעבירים דרך <span class="math">\(2n\)</span> נקודות נקבל <span class="math">\(C_{n}\)</span> אפשרויות שונות לעשות את זה.</p>
<p>אם מנסים לפרמל את זה די מהר רואים דרך פשוטה לתאר סיטואציה של "היחתכות" בלי גאומטריה: אם אני אמספר את הנקודות על ידי <span class="math">\(1,2,\ldots,2n\)</span>, אז המיתר <span class="math">\(\left(a,b\right)\)</span> חותך את המיתר <span class="math">\(\left(c,d\right)\)</span>, כאשר אני מניח בלי הגבלת הכלליות ש-<span class="math">\(a<c\)</span>, רק אם <span class="math">\(c<b\)</span> וגם <span class="math">\(d>b\)</span>. בניסוח שונה, אם אני אתאר את נקודות ההתחלה והסיום של אחד המיתרים עם סוגריים עגולים ושל מיתר אחר עם סוגריים מרובעים, אז הסיטואציה הבאה מובילה לחיתוך: <span class="math">\()[(]\)</span>, וזאת להבדיל מ-<span class="math">\(\left(\right)\left[\right]\)</span> שהיא בסדר (זה <span class="math">\(c>b\)</span>) או <span class="math">\(\left(\left[\right]\right)\)</span> שהיא גם בסדר (זה <span class="math">\(d<b\)</span>).</p>
<p>כדי להוכיח שזה שקול למשהו שאנחנו כבר מכירים, בואו נעבור לייצוג ביניים שהוא בעיה מעניינת בפני עצמה:<br />
<img src="/img/2025/nonintersecting_arcs_4.svg" alt=""/></p>
<p>כאן אנחנו מציירים <span class="math">\(2n\)</span> נקודות <strong>בשורה</strong> ומחברים אותן בקשתות שלא נחתכות. זה באופן מובהק אותו הדבר בדיוק כמו הנקודות על המעגל, אבל הציור שונה (ולשם שינוי קשה לי לסדר אותו בשתי שורות של שבע פריטים כל אחת, כי כל שורת נקודות כזו היא די ארוכה).</p>
<p>הרעיון הוא להתאים לכל סידור כזה מילת דיק, שאציג בתור סדרת סוגריים מאוזנת - כלומר, סדרה של אותו מספר של ")"{} ו-"(" כך שבכל רישא אין יותר "(" מאשר ")". הנה איך זה עובד:<br />
<img src="/img/2025/nonintersecting_arcs_example.svg" alt=""/></p>
<p>הרעיון פשוט: לכל נקודה, אם היא <strong>הראשונה</strong> בזוג שלה, שמים ")"{} ואם היא <strong>השניה</strong> שמים "(", כשהולכים משמאל לימין. מכיוון שיש לנו חלוקה של <span class="math">\(2n\)</span> הנקודות ל-<span class="math">\(n\)</span> זוגות יהיו לנו בסך הכל <span class="math">\(n\)</span> מופעים של כל סוג סוגריים, אבל למה התנאי על הרישא מתקיים? זה די פשוט: בכל פעם שמופיע "(" זה בגלל שהנקודה שמעליו <strong>היא השניה בזוג</strong>, כלומר בשלב מוקדם יותר פגשנו את הנקודה הראשונה שהתאימה לה ואז כתבנו ")". לכן ההתאמה עובדת - אנחנו תמיד מקבלים מילת דיק חוקית.</p>
<p>כדי להשלים את ההתאמה צריך להסביר את הכיוון השני - איך בונים ממילת דיק התאמה כזו של נקודות לזוגות? גם זה קל: מעל כל אות במילת הדיק מציירים נקודה, ואז עוברים עליהן משמאל לימין. בכל פעם שבה נתקלים ב-"(", מתחילים ללכת שמאלה שוב עד שמגיעים אל הנקודה הראשונה שטרם חוברה למישהו. היא בודאות תהיה מסומנת ב-")"{} כי כאמור, בכל פעם שבה אנחנו נתקלים ב-"(" אנחנו מייד מחברים את הנקודה שלו למישהו. התנאי על הרישות של מילות דיק מבטיח שתמיד נמצא <strong>מישהו</strong> להתחבר אליו, ומכיוון שאנחנו תמיד מתחברים לנקודה הפנויה הראשונה שאנחנו מגיעים אליה לא יכולים להיווצר חיתוכים.</p>
<p>כדי לראות את זה, בואו נחשוב שאני הנקודה <span class="math">\(b\)</span> ואני מתחיל ללכת שמאלה כדי לחפש מישהו להתחבר אליו עד שאני מוצא <span class="math">\(a\)</span> פנוי. עכשיו, האם ייתכן שיש נקודות <span class="math">\(c,d\)</span> כך ש-<span class="math">\(a<c<b<d\)</span>? לא! כי אם <span class="math">\(c\)</span> מחוברת ל-<span class="math">\(d\)</span> זה אומר שבזמן ש-<span class="math">\(d\)</span> חיפש אל מי להתחבר, <span class="math">\(c\)</span> הייתה <strong>פנויה</strong>, אבל אם זה היה המצב - למה <span class="math">\(b\)</span> לא התחברה אליה אלא המשיכה עד <span class="math">\(a\)</span>? אוקיי, אז <span class="math">\(a<c<b<d\)</span> הוא בלתי אפשרי. מה בדבר <span class="math">\(c<a<d<b\)</span>? במקרה הזה, מאותו שיקול, <span class="math">\(d\)</span> לא הייתה יכולה להיות מחוברת אל <span class="math">\(c\)</span> כי היא הייתה מתחברת אל <span class="math">\(a\)</span> לפני כן. זה מסיים את ההוכחה.</p>
<h2>מגדלי קפלר</h2>

<p>שמרתי לסוף את הדבר הכי חדש והכי מוזר: מגדלי קפלר.<br />
<img src="/img/2025/kepler_towers_4.svg" alt=""/></p>
<p>מה הולך כאן? כרגע זה בעיקר מזכיר לי את הסמל של ערוץ 1 העתיק, אבל חלק מהעניין הוא שבמקרה הזה, המגדלים מגודל 4 הם קטנים מדי מכדי שאפשר יהיה להסביר בצורה טובה את ההגדרה הכללית, אז אלך על דוגמא מורכבת יותר. המגדלים הוצגו במאמר Three Catalan Bijections של דונלד קנות' שמספר שהם הומצאו בפברואר 2005 (חדשים!) על ידי Xavier Viennot שנתן להם את שמם. למה "קפלר"? קנות' מסביר שזה בגלל שהדיאגרמה של מגדל קפלר (כמו אלו שרואים למעלה) מזכירה את מודל מערכת השמש של קפלר.<br />
<img src="/img/2025/kepler_tower_example.svg" alt=""/></p>
<p>כדי לעזור להבין את הדוגמא הזו אני כבר אספר שאפשר לתאר מגדל קפלר בצורה פשוטה גם בתור רשימה של רשימות של רשימות של מספרים - פשוט! במקרה שלנו, המגדל הוא <span class="math">\(T=\left(W_{1},W_{2},W_{3}\right)\)</span> כאשר <span class="math">\(W_{1}=\left[\left(1\right),\left(2\right),\left(3\right)\right]\)</span> ו-<span class="math">\(W_{2}=\left[\left(1,3\right),\left(4\right),\left(1,3\right)\right]\)</span> ו-<span class="math">\(W_{3}=\left[\left(1,3,5,7\right),\left(1,4,7\right),\left(3,8\right),\left(2,4,7\right),\left(1,7\right)\right]\)</span>.</p>
<p>עכשיו, כפי שאפשר לראות מהתמונה, מגדל קפלר מורכב מאוסף של מעגלים. כל מעגל כזה מכונה <strong>טבעת</strong> (Ring) ואפשר לראות שיש בכל טבעת קשתות שחורות בולטות. הקשתות הללו מכונות <strong>לבנים</strong> (Bricks) והן מה שאנחנו סופרים: יש בדיוק <span class="math">\(C_{n}\)</span> מגדלי קפלר עם <span class="math">\(n\)</span> לבנים.</p>
<p>עכשיו, אפשר גם לראות שהטבעות מאוגדות בקבוצות, עם רווחים גדולים שמסמנים מתי קבוצה אחת נגמרת והבאה בתור מתחילה. כל קבוצה כזו מכונה <strong>חומה</strong> (Wall). האינטואיציה הציורית שלנו יכולה להיות זו: חומה היא הדבר הרגיל שאנחנו חושבים עליו - אוסף של לבנים שמונחות בשכבות אחת מעל השניה. במקרה הזה השכבות הן מעגליות, וכל שכבה מכונה "טבעת" ומכילה כמה "לבנים". קנות' מציע לנו לחשוב על הלבנים כאילו הן עשויות מלגו, כך שאפשר "להדביק" לבנים זו לזו, כך שכדי שלבנה לא תיפול מספיק שתהיה מתחתיה לבנה במקום כלשהו, אפילו אם מרכז המסה שלה בולט החוצה.</p>
<p>בואו נעבור לדבר על זה קצת יותר פורמלי. בצורת הרישום <span class="math">\(T=\left(W_{1},W_{2},\ldots,W_{m}\right)\)</span> כל <span class="math">\(W_{k}\)</span> כזה הוא חומה, וכל חומה היא מהצורה <span class="math">\(W_{k}=\left(R_{1}^{k},R_{2}^{k},\ldots,R_{t_{k}}^{k}\right)\)</span>, כלומר כל חומה היא רשימה של טבעות, ובחומות שונות יכולים להיות מספרים שונים של טבעות. המוסכמה היא שאנחנו מתחילים מהמרכז ומתקדמים החוצה - כלומר, החומה הראשונה היא זו שהכי פנימית, והטבעת הראשונה בכל חומה היא זו שהכי פנימית וכן הלאה.</p>
<p>עכשיו, מה יש בכל טבעת? כאן העניינים מתחילים להסתבך. קונספטואלית, אנחנו מחלקים את המעגל לחלקים, וכל טבעת מכילה לבנים שהן חלק מהחלקים הללו. השאלה <strong>לכמה</strong> חלקים מחלקים את המעגל תלויה במספר החומה הנוכחי. בחומה הראשונה, כל המעגלים מחולקים ל-2 חלקים. בחומה השניה הם מחולקים ל-4 חלקים; בשלישית ל-8 וכן הלאה עם חזקות של 2. בניסוח פורמלי, <span class="math">\(R_{i}^{k}\subseteq\left[2^{k}\right]\)</span>, כאשר הסימון <span class="math">\(\left[n\right]\)</span> הוא סימון סטנדרטי ל-<span class="math">\(\left\{ 1,2,3,\ldots,n\right\} \)</span>.</p>
<p>עכשיו, החוק שמגדיר את מגדלי קפלר קובע שבכל חומה, הטבעת הראשונה תמיד מכילה בדיוק את כל הלבנים האי-זוגיות, כלומר <span class="math">\(R_{1}^{k}=\left\{ 1,3,5,\ldots,2^{k}-1\right\} \)</span>. כל טבעת אחרת יכולה להכיל איזה מספרים שרוצים, אבל יש <strong>שתי מגבלות</strong>. כדי להבין איך הן נראות באופן ציורי, תעיפו לרגע מבט בציור - אפשר לראות שאני מצייר לבנים לא בתור בדיוק חצי עיגול, רבע עיגול וכו' אלא <strong>קצת יותר מזה</strong>, כאילו הוספתי צ'ופצ'יקים בקצוות. זה אומר שאם היו לי שתי לבנים סמוכות באותה טבעת הן היו עולות אחת על השניה <strong>וזה אסור</strong>. זה גם אומר שאם יש לי בטבעת אחת לבנה במקום <span class="math">\(x\)</span> ובטבעת שלפניה לבנה במקום <span class="math">\(x+1\)</span> או <span class="math">\(x-1\)</span>, זה נראה שהן עולות אחת על השניה. אז הנה החוקים:</p>
<ul> <li>אסור שבאותה טבעת יהיו שתי לבנים שעולות זו על זו. כלומר, אם <span class="math">\(x\in R_{i}^{k}\)</span> אז <span class="math">\(x-1,x+1\notin R_{i}^{k}\)</span>, כאשר פעולות החשבון הן מודולו <span class="math">\(2^{k}\)</span>.</li>


<li>אם בטבעת שאיננה הראשונה בחומה יש לבנה כלשהי, היא חייבת להישען על לבנה בטבעת שלפניה. כלומר, אם <span class="math">\(x\in R_{i+1}^{k}\)</span> <span class="math">\(x\in R_{i}^{k}\)</span> או <span class="math">\(x-1\in R_{i}^{k}\)</span> או <span class="math">\(x+1\in R_{i}^{k}\)</span> כששוב, החשבון הוא מודולו <span class="math">\(2^{k}\)</span>.</li>

</ul>

<p>זהו, זו כל ההגדרה! טיפה מסובך, אבל אין קושי עקרוני לכתוב קוד שבודק אם רשימה של רשימות של רשימות של מספרים הוא מגדל קפלר חוקי, או קוד שיודע לייצר את כל המגדלים עם <span class="math">\(n\)</span> לבנים (בצורה לא יעילה) וכדומה.</p>
<p>מה שקנות' עושה במאמר שלו הוא להראות התאמה חח"ע ועל מפורשת בין מגדלי קפלר עם <span class="math">\(n\)</span> לבנים ומסלולי דיק מאורך <span class="math">\(2n\)</span>, ואני רוצה להציג את זה כאן, אם כי בצורה טיפה שונה ממה שקנות' עושה. פישוט אחד שהוא לא קריטי אבל בהחלט יעזור לקוד שאני אציג להיות קצת פחות מסורבל הוא לשנות את איך שממספרים לבנים: במקום שהלבנים בקיר ה-<span class="math">\(k\)</span> יהיו <span class="math">\(\left\{ 1,2,3,\ldots,2^{k}\right\} \)</span> אני אסמן אותן ב-<span class="math">\(\left\{ 0,1,2,3,\ldots,2^{k}-1\right\} \)</span>. זה נוח, כי כשלוקחים דברים מודולו <span class="math">\(2^{k}\)</span> מקבלים מספרים בקבוצה הזו; אם היינו מסתכלים על הקבוצה מ-<span class="math">\(1\)</span> עד <span class="math">\(2^{k}\)</span> היינו צריכים טיפה לשנות את איך שעושים מודולו, וזה סתם מסרבל.</p>
<p>הרעיון המבריק של קנות' הולך ככה: אנחנו מסתכלים על מסלול דיק מאורך <span class="math">\(2n\)</span>. אפשר לחשוב על מסלול כזה בתור סדרה של U ו-D כך ש-U הוא צעד למעלה-ימינה ו-D הוא צעד למטה-ימינה, והמסלול מתחיל בגובה 0, מסיים בגובה 0 ולא יורד מתחת לגובה 0 בשום שלב. הרעיון של קנות' הוא עכשיו לשים "גבולות" - בגובה 1, בגובה 3, בגובה 7 וכן הלאה - בגובה <span class="math">\(2^{k}-1\)</span> לכל <span class="math">\(k\ge0\)</span>. כעת, חומה מספר <span class="math">\(k\)</span> תיבנה על פי בסיס החלק של המסלול שמתחיל עם ההגעה הראשונה לגבול <span class="math">\(2^{k}-1\)</span> ומסתיים עם ההגעה הראשונה לגבול <span class="math">\(2^{k+1}-1\)</span>, או מסתיים בסוף המסלול אם לא מגיעים לגובה הזה.</p>
<p>בואו נראה דוגמא:<br />
<img src="/img/2025/dyck_split.svg" alt=""/></p>
<p>מה שיש כאן הוא המסלול שמתאים למחרוזת הבאה:</p>
<p>UUDUDUDDUUUDUDDUUDDDUDUDUUUUUDUUUDDDUDDDUUDUUDDDDD</p>
<p>צבעתי את המסלול בשלושה צבעים - החלק הראשון בכחול, השני בירוק והשלישי באדום. הרעיון הוא שנשתמש בכל המסלול כדי לבנות מגדל קפלר: החומה הראשונה תיבנה על בסיס החלק הכחול, החומה השניה על בסיס החלק הירוק והשלישית על בסיס החלק האדום. מתי חלק מתחיל? החל מהפעם הראשונה שבה המסלול מגיע לקו הגבול שלו, ומרגע זה והלאה המסלול הקודם נזנח לאנחות. אפשר לראות שבאיור, הצעד הראשון צבוע בשחור - זה בגלל שעדיין לא הגענו אפילו לקו הגבול הראשון ולכן עוד לא התחלנו לבנות את החומות (אבל הצעד הראשון הוא תמיד למעלה ולכן תמיד נתחיל לבנות את החומה הראשונה מייד אחריו).</p>
<p>הרעיון עכשיו הוא זה: בחומה מס' <span class="math">\(k\)</span> יכולות להופיע לבנים שממוספרות ב-<span class="math">\(0,1,\ldots,2^{k}-1\)</span>, כלומר, מספרים שהם החל מ-0 וכלה בגובה של הגבול שהגעה אליו התחילה את המסלול שלנו. כפי שרואים טוב עם המסלול הירוק, המסלול יכול להיות <strong>מעל</strong> הגבול, וגם <strong>מתחת</strong> לגבול. בשני המקרים הללו העקרון הוא - אם המסלול ביצע צעד <strong>לכיוון הגבול</strong>, אז הצעד הזה יתורגם להוספת לבנה לחומה; אחרת הוא לא ישפיע על המגדל שאותו בונים. כך למשל במסלול הירוק, הצעד הראשון הוא <strong>למטה</strong> והוא מתרחק מהגבול, ולכן הצעד הזה <strong>לא</strong> יוסיף לבנה למגדל; אבל הצד השני הוא <strong>למעלה</strong> ומתקרב אל הגבול (ואפילו מגיע אליו) ולכן הוא כן יוסיף לבנה למגדל.</p>
<p>איזו לבנה הולכים להוסיף? זה תלוי <strong>בגובה</strong> של המקום שהגענו אליו אחרי הצעד. אם היינו <strong>מתחת</strong> לגבול וביצענו צעד למעלה, אז נוסיף את הלבנה שהמספר שלה הוא כמו הגובה של המסלול. אם היינו <strong>מעל</strong> הגבול וביצענו צעד אחד למטה, אז נוסיף את הלבנה שהמספר שלה הוא כמו הגובה של המסלול <strong>מעל הגבול</strong>, כלומר אם הגבול הוא 3 ואנחנו בגובה 5, אז נוסיף את לבנה 2. ככה זה נראה בדוגמא שלנו:<br />
<img src="/img/2025/dyck_split_with_nums.svg" alt=""/></p>
<p>למשל, ה-0-ים בהתחלה מגיעים מכך שהקו הכחול שוב ושוב <strong>יורד</strong> אל הגבול. אחר כך הוא חוצה אותו כלפי מטה ואז <strong>עולה</strong> שוב - ולכן הפעם זה נספר בתור הגעה לגובה 1. או למשל, בחלק של הירוק שבו הוא מתחיל לעלות ולעלות הוא בהתחלה מוסיף את הלבנים 1,2,3 ואז פתאום מפסיק למרות שהעלייה נמשכת - למה? כי הוא חצה את קו הגבול 3, ומרגע שהוא חוצה אותו, לבנים חדשות מתווספות כשהוא <strong>יורד</strong>, לא כשהוא עולה.</p>
<p>מה בעצם הרעיון כאן? תסתכלו על המסלול הכחול: אסור לו לרדת מתחת ל-0 (כי כל מסלול דיק מקיים את זה) ו"אסור" לו להגיע אל 3 (כי בפעם הראשונה שבה הוא יגיע אל 3 הוא יהפוך להיות מסלול שונה, המסלול הירוק), כך שכל "מרחב התמרון" שלו הוא פס צר סביב קו הגבול 1: הוא יכול להיות ב-0,1,2 ולכן הלבנים שהוא יכול להוסיף <strong>מתחת</strong> לגבול הן 0 ו-1 (הגבהים האפשריים שלו מתחת לגבול, עד שמגיעים אליו) והלבנים שהוא יכול להוסיף <strong>מעל</strong> לגבול הן גם כן 0,1 (הגבהים שלו מעל הגבול הזה). כלומר, "מרחב התמרון" של המסלול הכחול מאפשר לו רק להוסיף לבנים עם המספר 0,1 ואלו <strong>בדיוק</strong> הלבנים שיכולות להופיע בחומה הראשונה במגדל.</p>
<p>המסלול השני, הירוק, מקבל מרחב תמרון רחב יותר ויכול להוסיף את הלבנים <span class="math">\(0,1,2,3\)</span> שהן בדיוק מה שיכול להופיע בחומה השניה במגדל, וכן הלאה.</p>
<p>עכשיו, אפשר לשאול - בשביל מה זה טוב, שיש גם חלק <strong>מעל</strong> וגם חלק <strong>מתחת</strong> לקו הגבול, אם הם מייצרים את אותן לבנים בדיוק? ובכן, זה כל היופי פה: זה מאפשר למסלול ליצור לבנים <strong>כשהוא רוצה</strong>. תראו למשל את הסיום של המסלול האדום - הוא <strong>חייב</strong> לסיים בכך שהוא יורד עד 0, אבל מרגע שהוא מתחת לקו הגבול, עוד ירידה לא תוסיף לבנים - אז הצורך לרדת עד הסוף לא מכריח את המסלול להוסיף לבנים למגדל שהוא בונה. זה נותן לנו בדיוק את הגמישות שאנחנו צריכים כאן.</p>
<p>אם כן, טוב ויפה, אבל מה זה בעצם אומר, "להוסיף לבנה"? איך בוחרים לאיזו טבעת להוסיף אותה? ובכן, זה קל: פשוט זורקים אותה ורואים מה קורה.</p>
<p>בואו ניזכר איך חומה בנויה. ברגע שמתחילים חומה חדשה, כי המסלול הגיע לגובה מתאים חדש ושינה צבע, אוטומטית יוצרים חומה חדשה עם טבעת ראשונה שכוללת את כל המספרים שהטבעת הראשונה חייבת לכלול. כלומר, כשמגיעים לראשונה לגובה <span class="math">\(2^{k}-1\)</span> יוצרים חומה חדשה עם הטבעת <span class="math">\(\left\{ 0,2,4,\ldots,2^{k}-2\right\} \)</span>. זה עדיין לא החלק של "להוסיף לבנים למגדל", זה פשוט יוצר לנו את החומה הבסיסית שהמסלול יבנה מעליה.</p>
<p>עכשיו, אם המסלול רוצה להוסיף את הלבנה <span class="math">\(s\)</span> למגדל, אנחנו עוברים על הטבעות במגדל מהעליונה ביותר אל התחתונה. לכל טבעת כזו, אם <span class="math">\(s\)</span> או <span class="math">\(s+1\)</span> או <span class="math">\(s-1\)</span> (מודולו <span class="math">\(2^{k}\)</span>) נמצאות בה - "נתקענו" - אי אפשר להכניס את הלבנה לטבעת הזו (היא תתנגש באחת מהלבנים הללו) וגם אי אפשר לדחוף אותה דרכן אל טבעת נמוכה יותר כי הן חוסמות את הדרך (זו הצורה שבה כדאי לחשוב על זה כי זה נותן אינטואיציה למה הוספת לבנה מתנהגת כפי שהיא מתנהגת; הסיבה <strong>האמיתית</strong> להתנהגות הזו היא כי ככה הבניה עובדת). אם אף אחת מהלבנים הללו לא נמצאת בטבעת, אפשר לעבור לטבעת הבאה בתור, הנמוכה יותר, ולראות אם גם שם אפשר להתקדם או שנתקעים. בסופו של דבר מוסיף את הלבנה החדשה לטבעת הנמוכה ביותר שמצאנו שאפשר להוסיף את <span class="math">\(s\)</span> אליה - או, אם לא הייתה כזו, פותחים טבעת חדשה שכוללת רק את <span class="math">\(s\)</span>.</p>
<p>זהו, זו כל הבניה! הנה קוד פייתון שעושה את הכל ואני מקווה שברור וחף מבאגים:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">add_brick</span><span class="p">(</span><span class="n">wall</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="n">s</span> <span class="ow">in</span> <span class="n">wall</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">wall</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">wall</span><span class="p">[</span><span class="n">m</span><span class="p">]):</span>
        <span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># new ring</span>
        <span class="n">wall</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="n">wall</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">generate_kepler_tower_from_dyck</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">tower</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tower</span><span class="p">)</span>
        <span class="n">current_border</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">next_border</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">height</span> <span class="o">&gt;=</span> <span class="n">current_border</span> <span class="ow">and</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span>
            <span class="n">add_brick</span><span class="p">(</span><span class="n">tower</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">height</span> <span class="o">-</span> <span class="n">current_border</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="n">current_border</span> <span class="ow">and</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>
            <span class="n">add_brick</span><span class="p">(</span><span class="n">tower</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">height</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">height</span> <span class="o">==</span> <span class="n">next_border</span><span class="p">:</span>
            <span class="n">new_wall</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="p">)]]</span>
            <span class="n">tower</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_wall</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tower</span>
</code></pre></div>

<p>השאלה הראשונה שאנחנו צריכים לשאול את עצמנו היא אם הבניה הזו באמת נותנת מגדל קפלר, אבל ברור שהיא עושה את זה כי כללי הוספת הלבנים שלנו מבטיחים שתמיד יהיה לנו מגדל חוקי - אנחנו מוסיף במפורש את הטבעת הראשונה בכל חומה, וכשאנחנו מוסיפים לבנה אנחנו מקפידים שהיא תיכנס למקום שבו מותר לה להיות, ובטבעת שמתחתיה היא כבר לא יכולה להיכנס כי יש שם לבנה <strong>שעליה היא יכולה להישען</strong>.</p>
<p>שאלה קצת יותר טריקית היא למה מסלול מאורך <span class="math">\(2n\)</span> נותן מגדל קפלר עם בדיוק <span class="math">\(n\)</span> לבנים. בדוגמא שראינו למעלה, המסלול שלי היה מאורך 50, כלומר <span class="math">\(n=25\)</span>. אם סופרים את הלבנים שהמסלולים מוסיפים (המספרים שמתחת למסלולים, באיור השני) מגיעים ל-18. איפה הלבנים החסרות? ובכן, בטבעת הראשונה בכל חומה. יש לנו שלוש חומות. בחומה הראשונה הטבעת הראשונה היא <span class="math">\(\left\{ 0\right\} \)</span>, בשניה היא <span class="math">\(\left\{ 0,2\right\} \)</span> ובשלישית היא <span class="math">\(\left\{ 0,2,4,6\right\} \)</span>. בסך הכל קיבלנו את שבע הלבנים החסרות - אבל איך בדיוק אנחנו יודעים שזה לא הסתדר בפוקס?</p>
<p>בואו נדמיין לרגע שהמסלול שלנו כולו מאותו צבע. במסלול הזה, בכל פעם שאנחנו מבצעים צעד "למעלה", יהיה אי שם בהמשך צעד "למטה" שיקזז אותו, כי בסוף אנחנו חוזרים אל 0. אני אחדד: אם היה לנו צעד "למעלה" שהעלה אותנו מגובה <span class="math">\(h\)</span> אל גובה <span class="math">\(h+1\)</span>, יהיה צעד "למטה" שיוריד אותנו מגובה <span class="math">\(h+1\)</span> אל גובה <span class="math">\(h\)</span>. עכשיו, אם הצעדים הללו התבצעו <strong>מתחת לגבול</strong> אז צעד ה"למעלה" הוסיף לבנה וצעד ה"למטה" לא הוסיף; ואם הם התבצעו <strong>מעל לגבול</strong> אז צעד ה"למטה" הוסיף וצעד ה"למעלה" לא הוסיף. בשני המקרים בדיוק חצי מהצעדים שלנו הוסיפו לבנה.</p>
<p>אם נסתכל על האיור שבדוגמא, קל להיזכר שיש חריג - הצעד הראשון, שהוא צעד "למעלה" אל הגבול אבל הוא לא מוסיף לבנה, כי בשלב הזה המסלול הכחול עוד לא קיים. זה מתקזז עם העובדה שכשהגענו לגבול, יצרנו חומה חדשה עם טבעת ראשונה <span class="math">\(\left\{ 0\right\} \)</span>. זה גם מה שהולך לקרות <strong>באופן כללי</strong> כשיש לנו מסלול שמשנה צבע: כשהמסלול הירוק הגיע לגובה 7 ושינה את הצבע שלו, מה שקרה הוא שנוצרו אצלו צעדים שקודם <strong>לא הוסיפו</strong> לבנים אבל עכשיו יתקזזו עם עוד צעדים ש<strong>לא יוסיפו</strong> לבנים: הצעדים החל מהגבול ומעלה, כלומר <span class="math">\(3\to4\to5\to6\to7\)</span>. ארבעה צעדים שעכשיו כשיתבצעו בכיוון ההפוך גם כן לא יוסיפו לבנים - אבל עכשיו מתקזזים עם העובדה שהמסלול האדום נפתח עם הוספת הטבעת <span class="math">\(\left\{ 0,2,4,6\right\} \)</span>.</p>
<p>זה קורה גם באופן כללי: אם היה לנו מסלול סביב קו הגבול <span class="math">\(2^{k}-1\)</span> והוא הגיע אל <span class="math">\(2^{k+1}-1\)</span> אז "איבדנו" את כל הצעדים <span class="math">\(2^{k}-1\to2^{k}\to\ldots\to2^{k+1}-1\)</span>, כלומר <span class="math">\(2^{k}\)</span> צעדים; אבל אז אנחנו יוצרים קיר חדש שבטבעת הראשונה שלו יש את <span class="math">\(\left\{ 0,2,\ldots,2^{k+1}-2\right\} \)</span>, כלומר בדיוק <span class="math">\(2^{k}\)</span> הלבנים שהיו חסרות לנו.</p>
<p>זה מוכיח שקיבלנו פונקציה ממסלולי דיק מאורך <span class="math">\(2n\)</span> אל מגדלי קפלר מגודל <span class="math">\(n\)</span>. כדי להראות שהיא חח"ע ועל, צריך להסביר איך להפוך אותה.</p>
<p>הרעיון הוא די פשוט: בהינתן מגדל קפלר, נבנה את המסלול שיוצר אותו "מהסוף להתחלה", על ידי כך שנפרק לאט ובזהירות את החומות של המגדל. אם נעקוב אחרי הגובה הנוכחי של המסלול, נוכל לראות שבהינתן הגובה הזה והמצב הנוכחי של המגדל, יש בדיוק אפשרות אחת למצב של המגדל והגובה של המסלול בצעד הקודם שהביאו אותנו לכאן.</p>
<p>בואו נחזור למסלול שראינו קודם. כשמייצרים ממנו מגדל קפלר, מקבלים את זה:<br />
<img src="/img/2025/kepler_tower_from_dyck.svg" alt=""/></p>
<p>אנחנו רוצים להבין איך אפשר לקבל ממנו בחזרה את המסלול הזה:<br />
<img src="/img/2025/dyck_split.svg" alt=""/></p>
<p>כאמור - אני ארכיב את המסלול מהסוף להתחלה. בשביל זה צריך לדעת בכל רגע נתון מה קו הגבול הנוכחי, שקובע איזו לבנה מוסיפים למגדל. עבור המסלול האדום קו הגבול הזה הוא ב-7. איך אפשר לדעת את זה רק מהסתכלות על מגדל הקפלר שלנו? אנחנו סופרים כמה <strong>חומות</strong> יש בו - כאן יש שלוש, מה שאומר שהחומה החיצונית ביותר, זו שאנחנו מתחילים מלפרק אותה, זו שתיתן את המסלול האדום - מורכבת מהלבנים <span class="math">\(\left\{ 0,1,2,\ldots,2^{3}-1\right\} \)</span>.</p>
<p>עכשיו, אנחנו זוכרים בכל רגע נתון מה הגובה הנוכחי של המסלול שאנחנו משחזרים מהסוף להתחלה, ומה המצב הנוכחי של המגדל (שאמור להיות תואם את המצב של המגדל כשהוא נבנה על ידי המסלול המקורי עד שהוא מגיע בדיוק אל הנקודה בשחזור שבה אנחנו נמצאים). אנחנו מתחילים מגובה 0. אם אני בגובה 0, מה היה הצעד הקודם? זה היה <strong>חייב</strong> להיות צעד D כי אם זה היה צעד U, והצעד הזה הביא אותי לגובה 0, זה אומר שקודם הייתי בגובה <span class="math">\(-1\)</span> וזה בלתי אפשרי. באופן דומה, אם במהלך הבניה של המסלול האדום הייתי איכשהו מטפס עד לגובה 14, הייתי יודע שהצעד הקודם היה חייב להיות U, כי צעד D היה אומר שקודם הייתי בגובה 15 <strong>וזה היה יוצר מסלול חדש</strong>, עם חומה חדשה - יותר חומות מאשר יש במגדל. אז אלו שני מקרי הקיצון שבהם אנחנו יודעים בדיוק מה חייב לקרות אפילו בלי לבדוק מה הולך עם הלבנים שבתוך המגדל שלנו - ובשני המקרים הללו, הצעדים שעושים הם <strong>לכיוון</strong> קו הגבול שבאמצע ולכן לא מוסיפים לבנים, ולכן אין לי מה <strong>להסיר</strong> לבנים מהמגדל שאני מפרק.</p>
<p>יש עוד אפשרויות. אם אני בגובה <span class="math">\(s\)</span> שהוא 1 לפחות אבל עדיין מתחת לקו האמצע, יכלתי להגיע לגובה הזו או בפעולת D שלא הייתה מוסיפה לבנה למגדל, או בפעולת U שכן הייתה מוסיפה - והיא הייתה מוסיפה בדיוק את הלבנה <span class="math">\(s\)</span>, כי זה מה שקורה כשאנחנו מתחת לקו האמצע, אנחנו מוסיפים לבנה ששווה לגובה שהגענו אליו <strong>אחרי</strong> ביצוע הצעד. אז אנחנו מנסים להסיר מהמגדל שלנו את הלבנה <span class="math">\(s\)</span>, כלומר בודקים אם היא נמצאת בחומה הנוכחית, במיקום שבו אין לבנים אחרות שיושבות עליה, באחת מהטבעות <strong>מעל</strong> הטבעת הראשונה (הטבעת הראשונה כזכור נבנית בצורה שונה). אם היא שם, אנחנו מסירים אותה ומסמנים שבוצע צעד U, ואחרת פשוט מסמנים שבוצע צעד D, ומעדכנים את הגובה שלנו בהתאם (אם בוצע צעד U אנחנו <strong>מקטינים</strong> את הגובה, כי הרי אנחנו רוצים לדעת באיזה גובה היינו <strong>קודם</strong>). באופן דומה מטפלים גם במקרה שבו אנחנו מעל קו האמצע.</p>
<p>המקרה הכי בעייתי הוא זה שהוא אנחנו נמצאים <strong>בדיוק</strong> על קו האמצע. במקרה הזה יש שתי אפשרויות שונות להגעה לשם, ששתיהן מוסיפות לבנה למגדל - או עלייה למעלה שמוסיפה את הלבנה <span class="math">\(2^{k}-1\)</span>, או ירידה למטה שמוסיפה את הלבנה 0. אז מנסים לחלץ מהמגדל את שתי הלבנים הללו ורואים איזו מהן הצליחה. ברור ש<strong>רק אחת</strong> היא אפשרית, כי שתי הלבנים הללו הן שכנות ולכן מתנגשות אחת עם השניה ולא יכולות להיות באותה טבעת, ולכן אם הן נמצאות במגדל, אחת נמצאת גבוה יותר והיא זו שתקבע לנו איזה מהלך אנחנו משחזרים. אבל למה בעצם שאחת משתיהן תהיה במגדל? אי אפשר להנדס מגדלים שבהם זה לא קורה? זה הטיעון הכי עדין כאן: אפשר להראות שאלא אם החומה התרוקנה למעט הטבעת הראשונה, זה לא יכול לקרות כי <strong>בדרך</strong> אל קו האמצע הזה היינו מרוקנים מהחומה כל לבנה שלא תקועה - חוץ מאשר הלבנים <span class="math">\(0,2^{k-1}\)</span> שאפשר להוציא רק כשמגיעים לאמצע, וכל לבנה אחרת שאי אפשר להוציא כי אחת משתי הלבנים הללו חוסמת אותה. זה טיעון קצת מעצבן להוכחה פורמלית אבל הוא עובד; כל מה שנשאר לעשות הוא לדבר על מה שקורה כשמגיעים לאמצע כשהחומה ריקה חוץ מהטבעת הראשונה, וברור מה עושים בשלב הזה - מעיפים את החומה ומתחילים לשחזר את המסלול מהצבע הבא (כלומר, הקודם).</p>
<p>הנה קוד (חף מבאגים, אני מקווה - היו בו כל כך הרבה בהתחלה!) שעושה את זה:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">remove_brick</span><span class="p">(</span><span class="n">wall</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># we are trying to understand if it&#39;s possible that s was the latest brick added to the tower</span>
    <span class="c1"># for this, it&#39;s not enough that it&#39;s IN the tower, the way for it must be clear, meaning no s+1 and no s-1 in the way</span>
    <span class="c1"># print(f&quot;Trying to remove brick {s} from wall {wall}, num_segments={num_segments}&quot;)</span>
    <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">wall</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span> <span class="c1"># skip the first ring, it&#39;s not touched by add_brick()</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">:</span>
            <span class="n">ring</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if the ring is empty, remove it</span>
                <span class="n">wall</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ring</span> <span class="ow">or</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span><span class="w"> </span><span class="nf">generate_dyck_from_kepler</span><span class="p">(</span><span class="n">tower</span><span class="p">):</span>
    <span class="n">tower</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tower</span><span class="p">)</span> <span class="c1"># we&#39;re going to remove bricks</span>
    <span class="n">word</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tower</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># go over the walls from last to first</span>
        <span class="n">wall</span> <span class="o">=</span> <span class="n">tower</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">current_border</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">height</span> <span class="o">!=</span> <span class="n">current_border</span><span class="p">:</span> <span class="c1"># continue until wall is empty except the first ring</span>
            <span class="k">if</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">current_border</span><span class="p">:</span>
                <span class="c1"># we&#39;re near the next border. we can&#39;t reach it, otherwise the tower would have had more walls</span>
                <span class="n">word</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
                <span class="n">height</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># we&#39;re at the bottom, we can&#39;t go down anymore</span>
                <span class="n">word</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
                <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="n">current_border</span><span class="p">:</span> <span class="c1"># if s_down is in the tower, we made a &quot;down&quot; move, else nothing</span>
                <span class="k">if</span> <span class="n">remove_brick</span><span class="p">(</span><span class="n">wall</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="n">current_border</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="n">word</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
                    <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">word</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
                    <span class="n">height</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">height</span> <span class="o">&lt;</span> <span class="n">current_border</span><span class="p">:</span> <span class="c1"># if s_up is in the tower, we made an &quot;up&quot; move, else nothing</span>
                <span class="k">if</span> <span class="n">remove_brick</span><span class="p">(</span><span class="n">wall</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="n">word</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
                    <span class="n">height</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">word</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
                    <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">height</span> <span class="o">==</span> <span class="n">current_border</span><span class="p">:</span>
                <span class="c1"># we reached the border either by &quot;down&quot; from above, and then s_down is in the tower, or by &quot;up&quot; from below, and then s_up is in the tower</span>
                <span class="c1"># they can&#39;t both be in the tower since in this case, s_down = 1 and s_up = current_border + 1, which are adjacent (modulo current_border + 1)</span>
                <span class="c1"># print(&quot;height == current_border, so we are at the border, trying to remove bricks&quot;, s_down, s_up)</span>
                <span class="k">if</span> <span class="n">remove_brick</span><span class="p">(</span><span class="n">wall</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="n">current_border</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="n">word</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
                    <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">remove_brick</span><span class="p">(</span><span class="n">wall</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="n">word</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
                    <span class="n">height</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This should not happen&quot;</span><span class="p">)</span>
    <span class="n">word</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span> <span class="c1"># first step is always U</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>
</code></pre></div>

<p>זה מסיים את הסיפור מבחינתי, אבל מספרי קטלן לא נגמרים שם - הספר של Stanely עמוס בשלל דוגמאות אחרות (אם כי חייבים להודות שרובן הן פשוט וריאציות עם כל מני מגבלות ופרמטרים על אותה בעיה), אבל שולי הפוסט הזה כבר צרים מלהכילן.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>