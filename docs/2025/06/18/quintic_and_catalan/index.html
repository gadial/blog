<!DOCTYPE html>
<html lang="he" dir="rtl"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>האם נמצאה נוסחה לפתרון משוואה ממעלה חמישית?! (לא) | לא מדויק</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="האם נמצאה נוסחה לפתרון משוואה ממעלה חמישית?! (לא)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
<meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
<link rel="canonical" href="http://gadial.net/2025/06/18/quintic_and_catalan/" />
<meta property="og:url" content="http://gadial.net/2025/06/18/quintic_and_catalan/" />
<meta property="og:site_name" content="לא מדויק" />
<meta property="og:image" content="http://gadial.net/assets/img/main/default-card.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-06-18T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="http://gadial.net/assets/img/main/default-card.png" />
<meta property="twitter:title" content="האם נמצאה נוסחה לפתרון משוואה ממעלה חמישית?! (לא)" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://gadial.net/2025/06/18/quintic_and_catalan/"},"url":"http://gadial.net/2025/06/18/quintic_and_catalan/","@type":"BlogPosting","description":"לא מדויק - בלוג על מתמטיקה ומדעי המחשב","headline":"האם נמצאה נוסחה לפתרון משוואה ממעלה חמישית?! (לא)","dateModified":"2025-06-18T00:00:00+00:00","datePublished":"2025-06-18T00:00:00+00:00","image":"http://gadial.net/assets/img/main/default-card.png","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/favicon.ico" type="image/x-icon"><link type="application/atom+xml" rel="alternate" href="http://gadial.net/feed.xml" title="לא מדויק" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-3924539-2', 'auto');
  ga('send', 'pageview');
}
</script>
  
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        processEscapes: true
      },
      TeX: {extensions: ["AMSmath.js","AMSsymbols.js"]},
      "HTML-CSS": { 
        linebreaks: { automatic: true }
      },
      SVG: { 
        linebreaks: { automatic: true } 
      }
    });
  </script>
  <!-- "https://www.gadial.net/wp-includes/js/xypic.js" -->

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

</head>
<body><header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <a class="navbar-brand" href="/">לא מדויק</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarCollapse">
      <ul class="navbar-nav mr-auto">
        
            
            <li class="nav-item">
                <a class="nav-link" href="/">דף הבית</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/post_list">רשימת הפוסטים</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/categories">קטגוריות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/random">פוסטים אקראיים</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/lecture_notes">סיכומי הרצאות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">אודות</a>
            </li>
            
        
      </ul>
      <form class="form-inline mt-2 mt-md-0" action="/post_list/" method="get">
        <input class="form-control mr-sm-2" type="text" placeholder="חיפוש" aria-label="חיפוש" name="s">
        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">חיפוש</button>
      </form>
    </div>
  </nav>
</header><main class="page-content" aria-label="Content" role="main">
      <div class="wrapper text-right">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><div class="PageNavigation">
    
      <a class="prev" href="/2025/06/11/catalan_numbers_and_generating_functions/">&laquo; פונקציות יוצרות ומספרי קטלן</a>
    
    
      <a class="next" href="/2025/09/06/unitary_diagonalization/">לכסון אוניטרי &raquo;</a>
    
  </div><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">האם נמצאה נוסחה לפתרון משוואה ממעלה חמישית?! (לא)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-06-18T00:00:00+00:00" itemprop="datePublished">Jun 18, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2>מבוא</h2>

<p>לפני כמה שבועות נתקלתי בכותרת מפוצצת: “Mathematician solves algebra’s oldest problem using intriguing new number sequences”. חיפוש זריז העלה עוד כותרות מפוצצות דומות: ““The Oldest Algebra Problem Solved”: Australian Mathematician Cracks Ancient Mystery That Baffled Minds for Over 4,000 Years” וגם “200-year-old “algebra wall” shattered with a bold new approach” ואיך אפשר בלי “Researchers Solve “Impossible” Math Problem After 200 Years”. כותרות המשנה היו מפוצצות לא פחות, למשל “A mathematician has developed an algebraic solution to an equation that was long thought to be unsolvable.”.</p>

<p>במילים פשוטות, מאמר מתמטי (שאפשר לקרוא <a href="https://www.tandfonline.com/doi/full/10.1080/00029890.2025.2460966\#abstract">כאן</a>) עם השם הנאה “A Hyper-Catalan Series Solution to Polynomial Equations, and the Geode” הצליח איכשהו להגיע לכותרות, והוא הגיע לשם על ידי רכיבה על הטענה שהוא עושה את הבלתי אפשרי: נותן <strong>נוסחה לפתרון משוואה ממעלה חמישית</strong>, דבר שהוכח כבר לפני מאתיים שנה שהוא בלתי אפשרי וגם אני <a href="https://gadial.net/2018/07/12/insolvability_of_the_quintic/">כבר תיארתי</a> אותו בבלוג. אני כבר מורגל בכותרות כאלו ולכן אחרי שהתחלתי לקרוא לא הופתעתי לגלות ש:</p>

<ul> <li>המאמר לא עושה את מה שהכותרות מבטיחות.</li>


<li>הבעיה שהיא בלתי אפשרית נותרה בלתי אפשרית כי היא בלתי אפשרית במובן מאוד <strong>ספציפי.</strong></li>


<li>יש שיטות אחרות שפותרות את הבעיה הבלתי אפשרית בשיטות אחרות בצורה טובה יותר ממה שהמאמר עושה.</li>


<li>מה שהמאמר <strong>כן</strong> עושה הוא בהחלט נחמד ויפה, אבל במובן פורמלי ספציפי שאני לא חושב שמי שכתבו את המאמרים בעיתון מבינים.</li>

</ul>

<p>אז בואו נדבר על זה. כרגיל בעניינים כאלו אני רוצה להפריד בין התוכן המתמטי של המאמר העצמו, שהוא <strong>אחלה</strong>, ובין המילים הגבוהות שבהן עוטפים את התוכן, שהן בולשיט (ואני חושש שחלק מהבולשיט במקרה הנוכחי מגיע ישירות מהחלק הלא מתמטי של המאמר).</p>

<p>לפני שניכנס לעובי הקורה, הנה התקציר: הרעיון המרכזי של המאמר הוא להציע נוסחה לפתרון משוואות פולינומיות, שמתארת את הפתרון בתור <strong>סכום אינסופי</strong>. בסכום האינסופי הזה מופיעים מספרים שקשורים למקדמים של המשוואה הפולינומית שאותה פותרים, ולהכללה של <strong>מספרי קטלן</strong>, <a href="https://gadial.net/2025/05/31/catalan_numbers/">שתיארתי לא מזמן בבלוג</a> בפירוט בדיוק בתור הכנה לפוסט הזה (וכי זה נושא נהדר בפני עצמו שהייתי צריך לקבל דחיפה קטנה כדי לכתוב עליו).</p>

<ul> <li>האם זה סותר את התוצאה שאין נוסחה לפתרון משוואה ממעלה חמישית? לא, כי התוצאה הזו מדברת על <strong>סוג מסוים</strong> של נוסחאות: כאלו שבנויות ממספר <strong>סופי</strong> של פעולות חיבור, חיסור, כפל, חילוק והוצאות שורש. כאן מחליפים את ה"סופי" ב"אינסופי", ונותנים הצדקה כלשהי לכך שגם הוצאת שורש היא משהו אינסופי במהות שלו. האם אני מסכים עם הנימוק הזה? לא ממש, אבל זה פחות רלוונטי לשאלה אם זה סותר את התוצאה - זה בבירור לא סותר את התוצאה הקיימת ולכן הכותרות המפוצצות שמנגידות את התוצאה לכך שהבעיה "בלתי אפשרית" או שנפרצה "חומה" פשוט לא קשורות למה שקרה כאן.</li>


<li>האם זה נותן שיטה <strong>יעילה</strong> לפתרון משוואות ממעלה חמישית ביחס למה שכבר היה ידוע? ובכן, לא. אני אציג בפוסט שיטה סטנדרטית לפתרון משוואות כאלו שנקראת <strong>שיטת ניוטון-רפסון</strong> שהיא יעילה מאוד (ויפה מאוד), ונשווה בינה לבין מה שהשיטה החדשה נותנת ונגלה למרבה ההפתעה שניוטון-רפסון כנראה טובה יותר. אגב, ניוטון-רפסון הייתה ידועה גם לפני מאתיים שנים, כשאבל וגלואה הוכיחו את התוצאות שלהם על משוואות ממעלה חמישית. חישוב יעיל הוא פשוט לא הסיפור פה (למרות שהמאמר גולש גם לכיוון הזה).</li>


<li>אבל, וזה אולי הכי חשוב - האם זה יפה? מעניין? לטעמי כן, התוצאה שיש במאמר היא מאוד נחמדה ואני מקווה שההשוואות יעזרו לנו גם להבין קצת יותר טוב למה.</li>

</ul>

<p>יופי, אז עכשיו אנחנו מבינים מה אנחנו רוצים להשיג פה, בואו נעשה את זה לאט ובזהירות.</p>

<h2>מספרי קטלן ומשוואות ממעלה שניה - מבוא</h2>

<p>החלק הטכני של המאמר מתחיל בדוגמא שמתבססת על האופן שבו אפשר להשתמש במספרי קטלן עבור משוואות ממעלה שניה. אני אציג את זה בערך כפי שזה מוצג במאמר: הם מתחילים מלכתוב את המשוואה הריבועית בצורה הבאה: <span>\( 1-\alpha+t\alpha^{2}=0 \)</span>. זו בוודאי לא הדרך “הסטנדרטית” שבה כותבים משוואה כזו, שהיא <span>\( ax^{2}+bx+c=0 \)</span>, אבל אם נניח ש-<span>\( b=-c \)</span> (זו הנחה שבהמשך יהיה קל להיפטר ממנה), ואז נחלק את כל המשוואה ב-<span>\( c \)</span> (בהנחה שהוא שונה מאפס) נקבל את המשוואה <span>\( 1-x+\frac{a}{c}x^{2}=0 \)</span> ולכן אם נסמן <span>\( t=\frac{a}{c} \)</span> נקבל את הצורה שהמאמר מניח. במקרה הספציפי הזה, אפשר להשתמש בנוסחת השורשים כדי לפתור את המשוואה ולקבל <span>\( \alpha=\frac{1}{2t}\left(1\pm\sqrt{1-4t}\right) \)</span>. עכשיו המאמר מכניס לתמונה את הבינום המוכלל של ניוטון, שתיארתי בפוסט הקודם. הרעיון בו הוא שאפשר לכתוב באופן כללי:</p>

<p><span>\( \left(1+x\right)^{r}=\sum_{n=0}^{\infty}{r \choose n}x^{n} \)</span></p>

<p>כאשר <span>\( {r \choose n}=\frac{r\left(r-1\right)\left(r-2\right)\cdots\left(r-n+1\right)}{n!} \)</span></p>

<p>הנכונות של הבינום לא מובנת מאליה; זו טענה שמוכיחים בעזרת חשבון דיפרנציאלי ואינטגרלי, וכדי שזה יעבוד צריך להתקיים <span>\( \left|x\right|&lt;1 \)</span>. אחרת… ובכן, למה לא לראות בעצמנו? הנה קוד פייתון פשוט שמחשב בינום מוכלל:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">generalized_binomial</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></code></pre></figure>

<p>נניח שאני רוצה להשתמש בקוד הזה כדי לחשב את, נאמר, <span>\( \sqrt{\frac{1}{4}}=\frac{1}{2} \)</span>. אז אני אציב <span>\( x=-\frac{3}{4} \)</span> כדי לקבל <span>\( 1+x=\frac{1}{4} \)</span>, ו-<span>\( r=\frac{1}{2} \)</span>, ואקבל:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">x</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">0.75</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">val</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">generalized_binomial</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"</span><span class="si">{</span><span class="n">val</span><span class="p">:.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span></code></pre></figure>

<p>כשאני מריץ את הקוד הזה אני מקבל <span>\( 0.5000000000 \)</span> - יופי של דבר! ומה אם, למשל, אני רוצה לקבל את <span>\( \sqrt{2} \)</span>? אני אציב <span>\( x=1 \)</span> ואקבל <span>\( 1.4143562059 \)</span> שזה לא רע בכלל אחרי בסך הכל 100 איברים שאני מחבר. ואם אני רוצה לחשב את <span>\( \sqrt{4}=2 \)</span>? אז אני אציב <span>\( x=3 \)</span> ואקבל… אה… את זה:</p>

<p>36897381732338865935269100862142478752415744.0000000000</p>

<p>אוקיי, משהו כאן בבירור הפסיק לעבוד.</p>

<p>ברוכים הבאים לעולם המופלא של טורי חזקות. לטור חזקות <span>\( \sum_{n=0}^{\infty}a_{n}x^{n} \)</span> יש תמיד <strong>רדיוס התכנסות</strong>. מספר <span>\( R \)</span> כך שאם <span>\( \left|x\right|&lt;R \)</span> אז הטור מתכנס, ואם <span>\( \left|x\right|&gt;R \)</span> אז הטור מתבדר (גדל עוד ועוד עד אינסוף). מה קורה ב-<span>\( \left|x\right|=R \)</span>? כאן לא מובטח כלום. זה יכול להתכנס ויכול להתבדר, אין חוקים.</p>

<p>רדיוס ההתכנסות של טור חזקות תלוי במקדמים שלו, יש שתי שיטות מקובלות לחשב אותו: שיטת השורש ושיטת המנה. בשיטת השורש, מגדירים <span>\( R \)</span> על ידי</p>

<p><span>\( \frac{1}{R}=\lim\sup_{n\to\infty}\sqrt[n]{\left|a_{n}\right|} \)</span></p>

<p>כאשר אם הגבול בצד ימין יוצא 0 אז <span>\( R=\infty \)</span> (הטור מתכנס לכל ערך) ואם הוא יוצא אינסוף אז <span>\( R=0 \)</span> (הטור לא מתכנס בכלל). ייתכן שאתם לא מכירים את <span>\( \lim\sup_{n\to\infty} \)</span>. הצגתי את המושג <a href="https://gadial.net/2014/04/08/limsup_and_liminf/">בפוסט הזה</a>, אבל הנה תזכורת זריזה:</p>

<p>באופן כללי, <span>\( \lim\sup_{n\to\infty}x_{n}=\lim_{n\to\infty}\left(\sup_{m\ge n}x_{m}\right) \)</span> כלומר - הרעיון הוא לעבור מהסדרה המקורית <span>\( \left\{ x_{n}\right\} _{n=1}^{\infty} \)</span>שיכולה “להשתגע” ולקפץ מעלה-ומטה ומהומות ובעיות, אל סדרה שמתנהגת יותר נחמד: <span>\( \left\{ y_{n}\right\} _{n=1}^{\infty} \)</span> כך ש-<span>\( y_{n}=\sup\left\{ x_{m}\ |\ m\ge n\right\}  \)</span>. כאשר <span>\( \sup \)</span> הוא המושג הרגיל של חסם עליון. הסיבה לשימוש ב-<span>\( \lim\sup \)</span> היא כדי להבטיח שהגבול תמיד יהיה קיים (למרות שהוא יכול להיות אינסוף), כך שהנוסחה “תמיד עובדת”.</p>

<p>לפעמים יותר קל לחשב את <span>\( R \)</span> באופן הבא: <span>\( R=\lim_{n\to\infty}\left|\frac{a_{n}}{a_{n+1}}\right| \)</span> - זו “שיטת המנה” שהזכרתי, אבל הבעיה בה היא שלא תמיד הגבול קיים. מה שמובטח הוא שאם הגבול קיים, הוא שווה לרדיוס ההתכנסות.</p>

<p>איך זה מתקשר לדוגמא שראינו? בדוגמא שלנו, <span>\( a_{n}={r \choose n}=\frac{r\left(r-1\right)\left(r-2\right)\cdots\left(r-n+1\right)}{n!} \)</span>. ההגדרה הזו נראית מתאימה עבור מבחן המנה:</p>

<p><span>\( \frac{a_{n}}{a_{n+1}}=\frac{\left(n+1\right)!}{n!}\frac{r\left(r-1\right)\left(r-2\right)\cdots\left(r-n+1\right)}{r\left(r-1\right)\left(r-2\right)\cdots\left(r-n\right)}=\frac{n}{r-n}=\frac{1}{\frac{r}{n}-1} \)</span></p>

<p>החשבון הזה מניח ש-<span>\( r \)</span> הוא לא מספר טבעי ולכן אין סיכון שיופיע לנו 0 במונה ובמכנה (אם <span>\( r \)</span> הוא טבעי אז נוסחת הבינום נותנת לנו סכום סופי שמתכנס תמיד) ומכיוון ש-<span>\( \lim_{n\to\infty}\frac{r}{n}=0 \)</span> אנחנו מקבלים ממנו שרדיוס ההתכנסות הוא תמיד 1, מה שמתאים יפה להתנהגות שראינו, עם הדוגמה של <span>\( \sqrt{\frac{1}{4}} \)</span> שעבדה יפה (<span>\( x=-\frac{3}{4} \)</span>), הדוגמא של <span>\( \sqrt{2} \)</span> שעדיין עבדה למרות שהיא על רדיוס ההתכנסות (<span>\( x=1 \)</span>) והדוגמא של <span>\( \sqrt{4} \)</span> שהיא לכאורה חישוב פשוט אבל נכשלה לחלוטין כי זה כבר מעבר לרדיוס ההתכנסות (<span>\( x=3 \)</span>).</p>

<p>נחזור אל המאמר. המאמר הגיע אל הנוסחה <span>\( \alpha=\frac{1}{2t}\left(1\pm\sqrt{1-4t}\right) \)</span> ואז אמר שנשתמש בבינום של ניוטון על הפתרון עם סימן המינוס ונקבל</p>

<p><span>\( \alpha=\sum_{n=0}^{\infty}\frac{\left(2n\right)!}{n!\left(n+1\right)!}t^{n}=\sum_{n=0}^{\infty}C_{n}t^{n} \)</span></p>

<p>כאשר <span>\( C_{n} \)</span> הם מספרי קטלן.</p>

<p>יש כאן, כמובן, דילוג על כמה שלבים של חישוב, אבל למרבה המזל כבר עשיתי את הכל בפירוט בפוסט הקודם שלי, על הפונקציה היוצרת של מספרי קטלן: ראינו שם שהיא <span>\( C\left(x\right)=\frac{1-\sqrt{1-4x}}{2x} \)</span>, כאשר <span>\( C\left(x\right)=\sum_{n=0}^{\infty}C_{n}x^{n} \)</span>. ה-<span>\( \frac{\left(2n\right)!}{n!\left(n+1\right)!} \)</span> שמופיע במאמר זו פשוט דרך מפורשת לכתוב את מספרי קטלן, <span>\( C_{n}=\frac{\left(2n\right)!}{n!\left(n+1\right)!}=\frac{1}{n+1}{2n \choose n} \)</span>. המאמר משתמש ב-<span>\( t \)</span> בתור המשתנה של הסכימה ולא ב-<span>\( x \)</span>, אבל זה כל ההבדל.</p>

<p>ועכשיו נשאלת השאלה - אוקיי, אז מה עשינו כאן בעצם? למאמר יש ניסוח טכני מדויק למה שעשינו כאן (שהוא לא מגדיר בשום מקום את משמעותו):</p>

<blockquote dir="ltr" class="quote-ltr">
Applying Newton’s binomial expansion to the minus sign solution reveals the generating series of the Catalan numbers as the formal power series solution:
</blockquote>

<p>מילות המפתח כאן הן “Formal power series solution”. מה זה טור חזקות פורמלי - הקדשתי את כל הפוסט הקודם כדי להסביר, ואני לא אחזור על הפרטים הטכניים כאן אבל הרעיון המרכזי הוא זה: השוויון <span>\( \frac{1-\sqrt{1-4x}}{2x}=\sum_{n=0}^{\infty}C_{n}x^{n} \)</span> הוא נכון <strong>בלי להציב ערכים</strong> ב-<span>\( x \)</span>. השוויון הזה לא אומר “לכל ערך שנציב ב-<span>\( x \)</span>, אגף שמאל יהיה שווה לאגף ימין”. זו לא משוואה במובן הזה. השוויון אומר “האובייקט המתמטי שמופיע בצד שמאל הוא בדיוק אותו אובייקט כמו זה שמופיע באגף ימין”, כש”האובייקט” הוא מה שנקרא <strong>טור חזקות פורמלי</strong>. בטור שכזה האיקסים הם לא משהו שמציבים בו ערכים אלא משהו ש”מחזיק” את המקדמים. נשמע מוזר? כן, לכן הפוסט הקודם שלי מדבר על זה. ברצינות, אם זה מפריע לכם, קראו את הפוסט הקודם.</p>

<p>אבל אם מבינים את <span>\( \frac{1-\sqrt{1-4x}}{2x} \)</span> בתור ביטוי פורמלי נטו, משהו שלא אמורים להציב בו דברים, מה המשמעות של לכתוב <span>\( \alpha=\frac{1-\sqrt{1-4t}}{2t} \)</span>, כמו שהמאמר עושה? המאמר מתחיל עם המשוואה <span>\( 1-\alpha+t\alpha^{2}=0 \)</span>. מה זו המשוואה הזו? גם זה ביטוי פורמלי או שהרעיון פה הוא שמציבים ערך בפרמטר <span>\( t \)</span> ואז מקבלים משוואה שבאמת אפשר לפתור? כלומר, האם <span>\( \alpha \)</span> כאן מייצג <strong>מספר</strong> שמאופיין על ידי כך שהוא פותר משוואה פולינומית ואנחנו מחפשים דרך טובה לייצר את המספר הזה, או ש-<span>\( \alpha \)</span> מייצג כאן מלכתחילה <strong>טור חזקות פורמלי</strong> ולכן ה”פתרון” של המשוואה <span>\( 1-\alpha+t\alpha^{2}=0 \)</span> הוא נוסחה מפורשת לסדרת המקדמים של הטור הזה?</p>

<p>זה העניין; המאמר לא אומר. אז מלכתחילה לא לגמרי ברור מה המאמר עושה. אפשר ללכת אחורה, אל פרק המבוא, כדי לנסות להבין מה המטרה; אבל אני דווקא מעדיף לא לעשות את זה. פרקי מבוא הם לרוב המקומות שבהם מחפפים, כדי לתת לקורא מושג כללי לגבי מה שהולך לבוא בהמשך - ההמשך זה המקום שבו המושגים המדויקים צריכים להגיע. אבל אוקיי, אנחנו עדיין רק רואים דוגמא, אז אפשר לזרום עם זה ולראות לאן זה הולך.</p>

<p>השאלה המעניינת שעולה כרגע היא - אוקיי, אנחנו מקבלים את זה שהראינו את השוויון הפורמלי <span>\( \alpha=\frac{1-\sqrt{1-4t}}{2t}=\sum_{n=0}^{\infty}C_{n}t^{n} \)</span>. האם אפשר להשתמש בזה כדי לחשב פתרונות של המשוואה הריבועית <span>\( 1-\alpha+t\alpha^{2}=0 \)</span> עבור ערכים <strong>קונקרטיים</strong> של <span>\( t \)</span>? כלומר, להציב ערך מספרי ב-<span>\( t \)</span> ואז לחשב את <span>\( \sum_{n=0}^{\infty}C_{n}t^{n} \)</span> ולקבל את הערך? התשובה היא שבהחלט אפשר! אבל… בכפוף לקטע הזה של “רדיוס התכנסות”, מה שאומר שעבור רוב ערכי <span>\( t \)</span> זה לא יעבוד.</p>

<p>מה רדיוס ההתכנסות של הטור? אפשר להשתמש במבחן המנה כמו קודם:</p>

<p><span>\( \frac{C_{n}}{C_{n+1}}=\frac{\left(2n\right)!}{n!\left(n+1\right)!}\frac{\left(n+1\right)!\left(n+2\right)!}{\left(2n+2\right)!}=\frac{\left(n+1\right)\left(n+2\right)}{\left(2n+1\right)\left(2n+2\right)}=\frac{n^{2}+2n+2}{4n^{2}+6n+2}\to\frac{1}{4} \)</span></p>

<p>כלומר, הרדיוס הוא <span>\( R=\frac{1}{4} \)</span>.</p>

<p>רציתי לבחור <span>\( t \)</span> קטן מהרדיוס שעדיין נותן עבור <span>\( \alpha \)</span> ערך “נחמד” שאפשר לחשב ידנית, אז הינדסתי את <span>\( t=\frac{2}{9} \)</span>. הערך הזה נותן לנו את המשוואה הריבועית <span>\( 2\alpha^{2}-9\alpha+9=0 \)</span> שהפתרונות שלה הם</p>

<p><span>\( \alpha_{1,2}=\frac{9\pm\sqrt{81-72}}{4}=\frac{9\pm\sqrt{9}}{4}=\frac{9\pm3}{4}=3,1.5 \)</span></p>

<p>כאשר <span>\( 1.5 \)</span> הוא הפתרון שמתקבל מהמינוס. עכשיו, הנה קוד שיאפשר לנו לחשב מה קורה:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>   
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="n">k</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">9</span>
<span class="n">val</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span> <span class="n">t</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"</span><span class="si">{</span><span class="n">val</span><span class="p">:.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span></code></pre></figure>

<p>כשאני מריץ אותו אני מקבל <span>\( 1.4999999653 \)</span> שזה יפה מאוד, ואם אני מעלה את <span>\( N \)</span> אל <span>\( 200 \)</span> אני מקבל כבר <span>\( 1.5 \)</span> (זה עדיין לא <strong>בדיוק</strong> <span>\( 1.5 \)</span> אלא רק במסגרת 10 ספרות הדיוק שאני מציג). כלומר זה עובד, ועובד יפה! כל עוד <span>\( t&lt;\frac{1}{4} \)</span>.</p>

<p>מה קורה אם <span>\( t=\frac{1}{4} \)</span>? כאן אז אנחנו מקבלים את המשוואה <span>\( \alpha^{2}-4t+4=0 \)</span> שנפתרת על ידי <span>\( \alpha=2 \)</span>. אם נחשב את הטור <span>\( \sum_{n=0}^{\infty}\frac{C_{n}}{4^{n}} \)</span> עם הקוד שלי נקבל עבור <span>\( N=100 \)</span> את התוצאה <span>\( 1.8873030420 \)</span> שזה… אה… די קרוב ל-2! בטח אם אני אחבר יותר איברים, כלומר אגדיל את <span>\( N \)</span>, אני אתקרב עוד יותר ל-2. אם אני מציב <span>\( N=500 \)</span> אני מקבל <span>\( 1.9495499636 \)</span>, שזה טוב! זה הולך ומתקרב אל 2! אבל אז…! כשאני מציב <span>\( N=600 \)</span>! אני פתאום מקבל “nan”. מה זה אומר בכלל? זה אומר שתש כוחו של פייתון. היכולת שלו לעשות חישובים עם המספרים הרלוונטיים נגמרה. במקרה הנוכחי, מה שגומר אותו זה ה-<span>\( \frac{1}{4^{n}} \)</span> שהופך להיות כל כך קטן ששיטת הייצוג הסטנדרטית של נקודה צפה (דיברתי על זה קצת <a href="https://gadial.net/2017/08/24/0x5f3759df_part_2/">כאן</a>) כבר לא מסוגלת לייצג אותו. זה נשמע כמובן טיפה הזוי - אם זה מספר <strong>כל כך קטן</strong> למה שהוא בכלל עוד ישפיע על הסכום? כלומר, למה אפילו ב-<span>\( N=500 \)</span> עדיין לא קיבלנו את התוצאה 2 ברמת דיוק של 10 ספרות? ובכן, כי כמה ש-<span>\( \frac{1}{4^{n}} \)</span> הוא קטן מתקזז עם כמה ש-<span>\( C_{n} \)</span> הוא גדול. במילים אחרות, ייצוג כזה באמצעות טור הוא לא ייצוג <strong>יעיל</strong>, כי הטור מורכב משני גורמים אקספוננציאליים שרבים זה עם זה ומקזזים זה את זה. זה בעצם מה שמבחני המנה והשורש מראים לנו - מה קצב הגידול של המקדמים שהחזקה נאלצת להתמודד איתם. כל עוד החזקה גדולה יותר מקצב הגידול הזה, הטור יתכנס מהר יחסית; אבל כשהם שווים זה יכול להיות עניין כואב ביותר ושום דבר לא מובטח, ואם הם גדולים יותר…</p>

<p>אם אני מציב למשל <span>\( t=-2 \)</span> אני מקבל את המשוואה <span>\( 2\alpha^{2}+\alpha-1=0 \)</span> עם הפתרונות <span>\( \alpha_{1,2}=\frac{-1\pm\sqrt{1+8}}{4}=\frac{-1\pm3}{4}=-1,0.5 \)</span> אבל אם אציב את זה בקוד שלי, אפילו עבור <span>\( N=10 \)</span>, אני אקבל בערך <span>\( -2170881 \)</span> ומשם זה רק נהיה יותר ויותר גרוע. הטור לא עובד במקרים כאלו, תשכחו מזה.</p>

<p>יש לכאורה עוד בעיה פה - הטור נותן לי רק פתרון אחד, מה עם השני? זה פחות מפריע לי כי תמיד אפשר לפתור משוואות בצורה הבאה: אם <span>\( p\left(x\right) \)</span> הוא הפולינום שמקודד את המשוואה, מוצאים שורש אחד ספציפי <span>\( p\left(\alpha\right)=0 \)</span> ואז מחלקים ומקבלים <span>\( q\left(x\right)=\frac{p\left(x\right)}{x-\alpha} \)</span>. זה עובד, ושורש של <span>\( q\left(x\right) \)</span> יהיה גם שורש של <span>\( p\left(x\right) \)</span> ובצורה הזו אפשר למצוא את כל השורשים… אם כי אני בעצם מניח כאן במובלע שאם את <span>\( p\left(x\right) \)</span> הייתי מסוגל לפתור עם הטור הזה אני אוכל לפתור גם את <span>\( q\left(x\right) \)</span> באותה צורה, וראינו כבר שזה לא בהכרח נכון - זה מאוד תלוי במקדמים.</p>

<p>האם זה אומר שיש משוואות שהשיטה פשוט לא מסוגלת לפתור? לא! בהמשך המאמר יש התייחסות לזה. אז בואו נראה את השלב שבו הוא מתחיל לפרמל דברים.</p>

<h2>מספרי קטלן ומשוואות ממעלה שניה - הגישה הפורמלית של המאמר</h2>

<p>בחלק 4 שלו, המאמר ממשיך לדבר על המקרה של מספרי קטלן ומשוואות ממעלה שניה, אבל מציג את הלב הטכני של מה שהוא עושה - אם מבינים את זה, אפשר להבין את התוצאה הכללית שלו די בקלות.</p>

<p>ראשית, המאמר בוחר בעיה קומבינטורית ספציפית שמספרי קטלן פותרים, ומתמקד בה. תיארתי שלל בעיות כאלו <a href="https://gadial.net/2025/05/31/catalan_numbers/">בפוסט שלי</a> על מספרי קטלן, והמאמר בוחר להתבסס על אחת מוכרת במיוחד, זו שדי ייסדה את התחום כשאוילר פתר אותה - שילושים של מצולעים.</p>

<p>כשמתעסקים בשילושים של מצולעים, צריך איכשהו להבדיל בין שני שילושים שנראים “אותו דבר עד כדי סיבוב”. בפוסט שלי הדרך להשיג את זה הייתה <strong>למספר את הקודקודים</strong> של המצולע; המאמר משיג את האפקט הזה על ידי סימון אחת הצלעות של המצולע בתור “גג” וכשמציירים את המצולע, היא מצויירת למעלה - זה היה התפקיד של הצלע 1-2 אצלי. לפוליגון עם צלע שהיא גג שכבר עבר חלוקה למשולשים המאמר קורא Triagon ומשתמש בסימון <span>\( | \)</span> (קו אנכי) כדי לתאר את המקרה המנוון של “מצולע” בן שתי צלעות - משהו שראינו בפוסט שלי שמשתלם לספור. המאמר מסמן ב-<span>\( \mathcal{T}_{n} \)</span> את אוסף הטריגונים עם <span>\( n \)</span> <strong>פאות</strong>; כלומר, מספר המשולשים שיש בתוך הטריגון. זו דרך חכמה לעקוף את ניג’וס ה-<span>\( n+2 \)</span> שמתלווה לפוליגונים הללו כשסופרים את הקודקודים. עם הסימון הזה, <span>\( \left|\mathcal{T}_{n}\right|=C_{n} \)</span>. כמובן, זה מניח שאנחנו <strong>מזהים</strong> טריגונים שהם “אותו הדבר” אפילו אם הצורה שלהם קצת שונה - אני מניח שאנחנו בסדר עם זה.</p>

<p>עכשיו המאמר מסביר בצורה מפורטת איך אפשר לבנות טריגון חדש משניים קיימים. בגדול, זה ההיפוך של התהליך שתיארתי בפוסט שלי - שם הסרנו את הצלע 1-2 וקיבלנו שני טריגונים, כך שמספר הפאות הכולל שלהם הוא כמספר הפאות בטריגון שהתחלנו ממנו, פחות 1. כשמסמנים את הפונקציה היוצרת של הטריגונים על ידי <span>\( T\left[t\right] \)</span> כפי שהמאמר עושה, זה מוביל למשוואה</p>

<p><span>\( T=1+tT^{2} \)</span></p>

<p>בניות כאלו מוסברות בצורה יותר מקיפה בספר הנהדר Analytic Combinatorics של Flajolet ו-Sedgewick שכרגע זמין במלואו באופן חופשי <a href="https://algo.inria.fr/flajolet/Publications/book.pdf">כאן</a>. הבניה עבור קטלן מוסברת בעמוד 35-36; בגדול, אפשר לחשוב על כל טריגון בתור אחד משני דברים: או הטריגון המנוון <span>\( | \)</span> וכזה יש בדיוק 1, מגודל 0, ולכן התרומה שלו ל-<span>\( T\left[t\right] \)</span> היא <span>\( 1\cdot t^{0} \)</span>; או טריגון שאפשר לתאר בתור משהו שבנוי משלושה טריגונים: שניים מגודל כלשהו ואחד מגודל 1 (המשולש שמסירים כשמוחקים את הצלע 1-2). מכיוון שמכפלה של פונקציות יוצרות מתאימה בדיוק לסיטואציה של בניה של אובייקט קומבינטורי מהאובייקטים שמתוארים על ידי הפונקציות שמכפילים, כך שהגודל של האובייקט הקומבינטורי הזה הוא סכום הגדלים של המוכפלים, מקבלים עבור המקרה הזה את <span>\( T\cdot t\cdot T=tT^{2} \)</span>. דרך ההתבוננות הזו היא ממש מועילה ולמי שזה מעניין אותה אני ממליץ לקרוא את הספר (רק את החלק הראשון שלו! היתר זה נושאים, אה, שונים) והתייחסתי לזה קצת יותר <a href="https://gadial.net/2011/08/07/generating_functions_hardcore_1/">בפוסטים שכתבתי בשעתו</a>.</p>

<p>בקיצור, קיבלנו את הנוסחה <span>\( T=1+tT^{2} \)</span> שבפוסט הקודם שלי ראינו כבר שהיא הנוסחה שמקיימים מספרי קטלן ומכאן המאמר מרשה לעצמו לכתוב <span>\( T=\sum_{n=0}^{\infty}C_{n}t^{n} \)</span>.</p>

<p>עכשיו, אם נעביר את <span>\( T \)</span> אגף נקבל את המשוואה <span>\( 1-T+tT^{2}=0 \)</span>, כלומר <span>\( T \)</span> מקיים משוואה ריבועית מצורה ספציפית: המקדם החופשי הוא 1 והמקדם של החזקה הבאה הוא <span>\( -1 \)</span>. המאמר אומר שפולינום שמקיים את שתי הדרישות הללו הוא <strong>בצורה גאומטרית</strong> ושהמשוואה הריבועית <span>\( 1-\alpha+t\alpha^{2} \)</span> היא <strong>המשוואה הריבועית הגאומטרית הכללית</strong>. בהתבסס על התוצאה הקומבינטורית שהוא הראה (שהיא, כאמור, סטנדרטית) הוא מסיק את מה שהוא מכנה <strong>משפט </strong><strong>1</strong>: שלמשוואה <span>\( 1-\alpha+t\alpha^{2} \)</span> יש “formal power series solution” שהוא</p>

<p><span>\( \alpha=T\left[t\right]=\sum_{n=0}^{\infty}C_{n}t^{n} \)</span></p>

<p>אני חייב להודות שאני לא בטוח מה התוכן של המשפט הזה מעבר ל”הפונקציה היוצרת של מספרי קטלן מקיימת את המשוואה הריבועית <span>\( 1-\alpha+t\alpha^{2} \)</span>” - וזו כאמור טענה סטנדרטית עוד מימי אוילר. המאמר קורא לזה <strong>הנוסחה הגאומטרית הריבועית הרכה</strong> שזה שם מפוצץ לדבר קיים, אבל מייד אחר כך מגיע תוכן קצת יותר מעניין - הסבר איך אפשר לעבור מהמקרה הזה לפתרון של משוואה ריבועית <strong>כללית</strong>, לא כזו שהיא בצורה גאומטרית. לזה הוא קורא <strong>משפט </strong><strong>2</strong> ונותן לו את השם הטיפה פחות מפוצץ <strong>הנוסחה הריבועית הרכה</strong>. זה הולך ככה: נסמן משוואה ריבועית כללית בתור <span>\( c_{0}-c_{1}x+c_{2}x^{2}=0 \)</span>. עכשיו נבצע החלפת משתנים: נסמן, <span>\( x=\frac{c_{0}}{c_{1}}\alpha \)</span> נציב במשוואה ונקבל</p>

<p><span>\( c_{0}\left(1-\alpha+\frac{c_{0}c_{2}}{c_{1}^{2}}\alpha^{2}\right)=0 \)</span></p>

<p>עכשיו נשתמש במשפט הקודם עם <span>\( t=\frac{c_{0}c_{2}}{c_{1}^{2}} \)</span> ונקבל את הפתרון הבא:</p>

<p><span>\( \alpha=\sum_{n=0}^{\infty}C_{n}\frac{c_{0}^{n}c_{2}^{n}}{c_{1}^{2n}} \)</span></p>

<p>אלא שאנחנו רוצים את <span>\( x \)</span>, לא את <span>\( \alpha \)</span>, אז נכפול הכל ב-<span>\( c_{0} \)</span> ונחלק ב-<span>\( c_{1} \)</span> ונקבל</p>

<p><span>\( x=\sum_{n=0}^{\infty}C_{n}\frac{c_{0}^{1+n}c_{2}^{n}}{c_{1}^{1+2n}} \)</span></p>

<p>וזו כבר נוסחה קונקרטית ומעניינת! רק מה, היא… לא לגמרי עובדת. ראשית, יש לנו חלוקה ב-<span>\( c_{1} \)</span>, זה אומר שאם <span>\( c_{1}=0 \)</span> (כמו למשל במשוואה <span>\( x^{2}=2 \)</span>) השיטה נכשלת. המאמר מתייחס לזה:</p>

<blockquote dir="ltr" class="quote-ltr">
It’s curious that the equation with the easiest solution in radicals is the least accessible with this method. A simple change of variables lets us skirt around the problem.
</blockquote>

<p>אם <span>\( c_{0}=0 \)</span> אז המשוואה שלנו היא מהצורה <span>\( c_{2}x^{2}=c_{1}x \)</span> ולכן יש לה את הפתרון הטריוויאלי <span>\( x=0 \)</span>; זה מה שהנוסחה משיגה במקרה הזה; בשביל להשיג את הפתרון השני צריך להשתמש בטריק החלוקה שתיארתי קודם. האם זה אומר שהנוסחה שהם מצאו היא “לא כללית”? אני לא חושב שזה כזה בעייתי. אם תסתכלו בפוסט שלי על <a href="https://gadial.net/2018/07/16/solving_cubic_equations/">פתרון משוואה ממעלה שלישית</a>, גם שם משתמשים בטריקים של החלפת משתנים, למשל. כדי להרגיש שיש בעיה עם מקרי הקיצון הללו צריך להיות ממש טהרנים לגבי מה זה אומר שיש “פתרון כללי” למשוואה.</p>

<p>אבל הבעיה האמיתית, שכבר ראינו קודם, היא שהטור הזה פשוט <strong>לא מתכנס</strong> עבור חלק מהמספרים. המאמר לא מתייחס לזה שם, ואני מניח שזה בצדק מבחינתו כי לומר “formal power series solution” זה לכאורה לצאת ידי חובה. בהמשך, כאמור, תהיה התייחסות יותר רצינית לזה אז נעזוב את זה לבינתיים.</p>

<p>יופי, אז הבנו את הסיפור עם משוואה ממעלה שניה. עכשיו, מה קורה באופן כללי? למרבה המזל זה יהיה השלב הקל יחסית להבנה אם עיכלנו את מה שקרה עד כה.</p>

<h2>מספרי היפר-קטלן ומשוואות ממעלה כלשהי</h2>

<p>לפני שנראה מה המאמר עושה, בואו נחשוב שניה מה היינו רוצים שיקרה. עבור משוואה ממעלה שניה, מספרי קטלן נתנו לנו את הנוסחה <span>\( T=1+tT^{2} \)</span>. עבור משוואה ממעלה שלישית, אולי אפשר למצוא בעיה מקבילה עם משוואה מהצורה <span>\( T=1+tT^{2}+tT^{3} \)</span>? זה לא כזה קשה - רק צריך למצוא אובייקט שנספר על ידי <span>\( T \)</span>, יש 1 ממנו שהוא מגודל 0, ואפשר לבנות אותו מחיבור של שניים או שלושה אובייקטים, ואז הגודל שלו הוא סכום הגדלים שלהם ועוד 1. להמציא כזה אובייקט זה כנראה לא כל כך קשה (אם תפתחו ב-Analytic Combinatorics את החלק של Context-free specifications and languages תראו דרך כללית לעשות דברים כאלו) אבל יש כאן שתי בעיות. ראשית, לא ברור אם נוכל למצוא נוסחה מפורשת לכמות האיברים שמתאימים לאובייקט, כמו זו שהייתה לנו עבור קטלן; ושנית, המשוואה שלנו יוצאת מאוד מוגבלת - המקדם של <span>\( T^{2} \)</span> זהה למקדם של <span>\( T^{3} \)</span>, וללהטוטים שעשינו קודם יש גבול, הם לא יצליחו לטפל גם בזה.</p>

<p>אז כאן המאמר עושה משהו <strong>יפה</strong>: במקום לעבוד עם פונקציה יוצרת במשתנה בודד, הוא עובר לעבוד עם פונקציה יוצרת במספר משתנים. בואו נבין איך זה ייראה עבור משוואה ממעלה שלישית, ואז נוכל להגיע כבר למשוואה כללית. עבור מעלה שלישית, המטרה היא למצוא פונקציה יוצרת <span>\( S\left[t_{2},t_{3}\right] \)</span> כך ש-<span>\( S=1+t_{2}S^{2}+t_{3}S^{3} \)</span>.</p>

<p>מה <span>\( S \)</span> הולכת לספור? ובכן, קודם היה לנו את <span>\( T=\sum_{n=0}^{\infty}\left|\mathcal{T}_{n}\right|t^{n} \)</span>, כך ש-<span>\( \mathcal{T}_{n} \)</span> הייתה קבוצה של טריגונים, כלומר פוליגונים עם צלע מובחנת ספציפית שמחולקים <strong>למשולשים</strong>, וספציפית ב-<span>\( \mathcal{T}_{n} \)</span> היו הטריגונים שמחולקים ל-<span>\( n \)</span> משולשים. אבל מה אם נרשה חלוקה גם למשולשים וגם <strong>למרובעים</strong>? אפשר לסמן ב- <span>\( \mathcal{S}_{\left[m_{2},m_{3}\right]} \)</span> את מספר הפוליגונים עם צלע מובחנת שמחולקים ל-<span>\( m_{2} \)</span> משולשים ו-<span>\( m_{3} \)</span> מרובעים, ו-<span>\( \left[m_{2},m_{3}\right] \)</span> ייקרא <strong>הטיפוס</strong> של ה… אה… לא נקרא לזה טריגון (כי tri זה שלוש, ועברנו לדבר על חלוקה פנימית לדברים עם יותר משלוש צלעות) - במאמר קוראים לזה סבדיגון (subdigon). עכשיו נגדיר את מספר ההיפר-קטלן <span>\( C_{\left[m_{2},m_{3}\right]} \)</span> בתור מספר הסבדיגונים מטיפוס <span>\( \left[m_{2},m_{3}\right] \)</span> ונגדיר פונקציה יוצרת עם שני משתנים,</p>

<p><span>\( S=S\left[t_{2},t_{3}\right]=\sum_{m_{2},m_{3}\ge0}C_{\left[m_{2},m_{3}\right]}t_{2}^{m_{2}}t_{3}^{m_{3}} \)</span></p>

<p>כאן הרעיון הוא שהחזקה של <span>\( t_{2} \)</span> סופרת כמה <strong>משולשים</strong> יש בסבדיגון שלנו, והחזקה של <span>\( t_{3} \)</span> סופרת כמה <strong>מרובעים</strong>.</p>

<p>הכתיב הזה טיפה מסורבל, וגם לא לגמרי ברור על מה משתנה הסכימה רץ, אז המאמר מפשט את זה ומסמן <span>\( \mathbf{m}=\left[m_{2},m_{3}\right] \)</span> וכותב <span>\( \mathbf{m}\ge0 \)</span> כדי לסמן את זה ש-<span>\( \mathbf{m} \)</span> רץ על כל הזוגות <span>\( \left[m_{2},m_{3}\right] \)</span> שבהם <span>\( m_{2}\ge0 \)</span> וגם <span>\( m_{3}\ge0 \)</span>. אפשר להשתמש גם בסימון <span>\( \mathbf{t}^{\mathbf{m}}=t_{2}^{m_{2}}t_{3}^{m_{3}} \)</span> ולקבל מעין “שחזור” של הנוסחה הקודמת:</p>

<p><span>\( S=\sum_{\mathbf{m}\ge0}C_{\mathbf{m}}\mathbf{t}^{\mathbf{m}} \)</span></p>

<p>עכשיו יש שתי שאלות:</p>

<ul> <li>איזו נוסחה פולינומית מקיימת <span>\( S \)</span> הזו? אנחנו רוצים הכללה של <span>\( T=1+tT^{2} \)</span>.</li>


<li>איך מחשבים מספרית את <span>\( C_{\mathbf{m}} \)</span>? אנחנו רוצים חישוב נוח כמו של <span>\( C_{n} \)</span>.</li>

</ul>

<p>למרבה השמחה, בשני המקרים יש לזה תשובה טובה. ראשית, הנוסחה הפולינומית ש-<span>\( S \)</span> מקיימת. קודם, במקרה של <span>\( T \)</span>, קיבלנו את <span>\( T=1+tT^{2} \)</span> באופן הבא: ה-1 היה הטריגון היחיד עם 0 משולשים, שסומן <span>\( | \)</span>, ואילו <span>\( tT^{2} \)</span> תיאר בניה של טריגון מתוך שני טריגונים קיימים (זה <span>\( T \)</span> כפול <span>\( T \)</span>) ועוד משולש אחד שדוחפים ביניהם (זה <span>\( t \)</span>). הרעיון הוא שבמשולש שדוחפים ביניהם אחת מהצלעות תהיה הצלע המובחנת של הטריגון שבונים, ואל שתי הצלעות האחרות “מדביקים” את שני הטריגונים שבחרנו. כשאנחנו עובדים עם סבדיגונים את פעולת הבניה הזו <strong>אפשר לעשות גם עם מרובע</strong>, כלומר לקחת מרובע, לסמן את אחת הצלעות שלו בתור הצלע המובחנת, ולהדביק לו <strong>שלושה</strong> סבדיגונים. התוצאה של זה תהיה <span>\( t_{3}S^{3} \)</span>: החזקה השלישית של <span>\( S \)</span> היא כי אנחנו מדביקים שלושה סבדיגונים; המכפלה ב-<span>\( t_{3} \)</span> היא כי הוספנו לסבדיגון שאנחנו בונים <strong>מרובע</strong> שאליו כולם נדבקים, ו-<span>\( t_{3} \)</span> סופר כמה מרובעים יש.</p>

<p>הבניה הקודמת, שבה לוקחים <strong>משולש</strong> ומדביקים לו שני סבדיגונים, עדיין אפשרית גם כן, ונספרת על ידי <span>\( t_{2}S^{2} \)</span>. ובגלל שאלו שתי בניות שונות שמניבות אובייקטים שונים, סופרים אותן בנפרד (“עקרון החיבור”) ויחד עם מקרה הבסיס, נקבל את הנוסחה</p>

<p><span>\( S=1+t_{2}S^{2}+t_{3}S^{3} \)</span></p>

<p>ועכשיו אפשר כמו קודם להסתכל על המשוואה</p>

<p><span>\( 0=1-\alpha+t_{2}\alpha^{2}+t_{3}\alpha^{3} \)</span></p>

<p>ולהגיד שיש לה formal power series solution שהוא</p>

<p><span>\( \alpha=S=S\left[t_{2},t_{3}\right]=\sum_{m_{2},m_{3}\ge0}C_{\left[m_{2},m_{3}\right]}t_{2}^{m_{2}}t_{3}^{m_{3}}=\sum_{\mathbf{m}\ge0}C_{\mathbf{m}}\mathbf{t}^{\mathbf{m}} \)</span></p>

<p>כדי להשלים את התמונה, מסתכלים על משוואה פולינומית כללית ממעלה 3:</p>

<p><span>\( 0=c_{0}-c_{1}x+c_{2}x^{2}+c_{3}x^{3} \)</span></p>

<p>ומשתמשים באותה החלפה, <span>\( \alpha=\frac{c_{0}}{c_{1}}x \)</span> והצבות <span>\( t_{k}=\frac{c_{0}^{k-1}c_{k}}{c_{1}^{k}} \)</span> עבור <span>\( k=2,3 \)</span> כדי לקבל</p>

<p><span>\( x=\sum_{m_{2},m_{3}\ge0}C_{\left[m_{2},m_{3}\right]}\frac{c_{0}^{1+m_{2}+2m_{3}}}{c_{1}^{1+2m_{2}+3m_{3}}}c_{2}^{m_{2}}c_{3}^{m_{3}} \)</span></p>

<p>ושוב - המאמר מתעלם באלגנטיות כאן מהשאלה האם בכלל הטור מתכנס עבור כזו הצבה של ערכים ב-<span>\( t \)</span>-ים.</p>

<p>זהו, זה כל הרעיון - וזו הדרך שבה המאמר מוכיח את התוצאה המרכזית שלו. אלא שהוא לא עושה את זה רק עבור משוואות ממעלה שלישית; הוא עושה את זה לכל מעלה, כי הההכללה של מה שראינו היא פשוטה מאוד: אמרנו שסבדיגון יכול להיות מטיפוס <span>\( \left[m_{2},m_{3}\right] \)</span>? אנחנו מרשים לו להיות מטיפוס יותר כללי, <span>\( \mathbf{m}=\left[m_{2},m_{3},m_{4},\ldots\right] \)</span> כאשר המגבלה היחידה היא שכל ה-<span>\( m \)</span>-ים הם 0 החל ממקום מסוים. <span>\( \mathcal{S}_{\left[m_{2},m_{3},m_{4},\ldots\right]} \)</span> סופרת את הפוליגונים עם צלע מובחנת שמחולקים ל-<span>\( m_{2} \)</span> משולשים, <span>\( m_{3} \)</span> מרובעים, <span>\( m_{4} \)</span> מחומשים וכן הלאה - באופן כללי, <span>\( m_{k} \)</span> מצולעים עם <span>\( k+1 \)</span> צלעות והמספר מסומן ב-<span>\( C_{\left[m_{2},m_{3},\ldots\right]} \)</span> (ומכיוון שאנחנו סופרים רק צורות סופיות, ברור שלא ייתכן ש-<span>\( \left[m_{2},m_{3},m_{4},\ldots\right] \)</span> יהיה אינסופי “באמת” אלא חייב להיות 0 החל ממקום מסוים). עכשיו כותבים</p>

<p><span>\( S=S\left[t_{2},t_{3}\right]=\sum_{m_{2},m_{3},\ldots\ge0}C_{\left[m_{2},m_{3},\ldots\right]}t_{2}^{m_{2}}t_{3}^{m_{3}}\ldots \)</span></p>

<p>זה טיפה מוזר - התחלנו מלדבר על פונקציה יוצרת עם משנה אחד, עברנו לשני משתנים ועכשיו יש לנו אינסוף משתנים (אבל בכל מונום יש רק מספר סופי שלהם) אבל זה עובד סבבה. עכשיו, כמו שיצרנו סבדיגון עם חיבור סבדיגונים למשולש ולמרובע אפשר גם למחומשים וכן הלאה, ולכן מקבלים את המשוואה</p>

<p><span>\( \alpha=S=S\left[t_{2},t_{3},\ldots\right]=\sum_{m_{2},m_{3},\ldots\ge0}C_{\left[m_{2},m_{3},\ldots\right]}t_{2}^{m_{2}}t_{3}^{m_{3}}\ldots=\sum_{\mathbf{m}\ge0}C_{\mathbf{m}}\mathbf{t}^{\mathbf{m}} \)</span></p>

<p>זה התוכן של <strong>משפט </strong><strong>3</strong> במאמר, והנוסחה הזו נקראת <strong>הנוסחה הגאומטרית הפולינומית הרכה</strong>. אחר כך נפטרים מה”גאומטרית” עם <strong>משפט </strong><strong>4</strong> שמבצע את הצבת ה-<span>\( c \)</span>-ים שראינו ומקבל את <strong>הנוסחה הפולינומית הרכה</strong>,</p>

<p><span>\( x=\sum_{m_{2},m_{3},\ldots\ge0}C_{\left[m_{2},m_{3},\ldots\right]}\frac{c_{0}^{1+m_{2}+2m_{3}+\ldots}}{c_{1}^{1+2m_{2}+3m_{3}+\ldots}}c_{2}^{m_{2}}c_{3}^{m_{3}}\ldots \)</span></p>

<p>וזו, זו התוצאה המרכזית של המאמר - זו הנוסחה ש”פותרת” משוואה פולינומית כללית, וזה… די מגניב! יש לנו בהחלט נוסחה בודדת שאיכשהו מציגה פתרונות של <strong>כל</strong> משוואה פולינומית בתור סכום. אמנם אינסופי; אמנם עם אינסוף אינדקסים; אמנם לא מתכנס רוב הזמן; אבל עדיין, זה יפה ממש.</p>

<p>בואו ניקח רגע להעריך את זה לפני שנתקדם.</p>

<p>אוקיי, אז קיבלנו נוסחה, אבל בנוסחה הזו מופיעים המספרים <span>\( C_{\left[m_{2},m_{3},\ldots\right]} \)</span>, ואם אין לנו דרך נוחה לחשב אותם, אז מה עשינו בזה? למרבה השמחה, יש נוסחה פשוטה עבורם, כמו שיש עבור מספרי קטלן. המאמר לא מוכיח את זה אלא מצטט תוצאה מוכרת אם <span>\( \mathbf{m}=\left[m_{2},m_{3},m_{4},\ldots\right] \)</span> אז</p>

<p><span>\( C_{\mathbf{m}}=\frac{\left(2m_{2}+3m_{3}+4m_{4}+\ldots\right)!}{\left(1+m_{2}+2m_{3}+3m_{4}+\ldots\right)!m_{2}!m_{3}!m_{4}!\cdots} \)</span></p>

<p>עכשיו המאמר מנצל את זה כדי להציג עוד דרכים יפות לכתוב את הנוסחה, אבל אני לא מנסה להציג כאן את כל המאמר; בהחלט שווה לקרוא אותו אם זה מעניין אתכם (יש עוד חלק שלם בסוף שאני לא מזכיר בכלל).</p>

<h2>בואו נלכלך ידיים וננסה להבין - האם זה יעיל?</h2>

<p>הנוסחה שהמאמר נותן היא יפה. האם היא גם נותנת לנו דרך יעילה לחשב את הפתרונות של משוואות פולינומיות? ובכן, יעיל בהשוואה אל מה?</p>

<p>ראשית, נניח שיש לנו משוואה ריבועית, <span>\( ax^{2}+bx+c=0 \)</span>. נוסחת השורשים נותנת לנו את הפתרון <span>\( x_{1,2}=\frac{-b\pm\sqrt{b^{2}-4ac}}{2a} \)</span>. מה יש לנו כאן? כדי לחשב את הנוסחה צריך</p>

<ul> <li>להעלות את <span>\( b \)</span> בריבוע (פעולת כפל)</li>


<li>לחשב את <span>\( 4ac \)</span> (שתי פעולות כפל)</li>


<li>לחשב את <span>\( b^{2}-4ac \)</span> (פעולת חיסור)</li>


<li>לחשב את <span>\( \sqrt{b^{2}-4ac} \)</span> (פעולת הוצאת שורש)</li>


<li>לחשב את <span>\( \pm\sqrt{b^{2}-4ac}-b \)</span> (פעולת חיסור)</li>


<li>לחשב את <span>\( 2a \)</span> (פעולת כפל)</li>


<li>לחשב את <span>\( \frac{-b\pm\sqrt{b^{2}-4ac}}{2a} \)</span> (פעולת חילוק)</li>

</ul>

<p>איך מודדים את הסיבוכיות של כל צעד? ובכן, זה כבר דורש סדרת פוסטים משל עצמה, נכון? בגדול, פעולות חיבור וחיסור עולות פחות מכפל וחילוק, אבל פעולה כמו חישוב של <span>\( 2a \)</span>? זה טריוויאלי לביצוע במחשב - זו הזזה של ביט אחד הצידה, אפשר לעשות את זה מהר מאוד. לכן אני לא רואה טעם למדוד את הסיבוכיות של כל הסיפור הזה מעבר לאמירה שיש כאן כמה פעולות כפל וחילוק ופעולת <strong>הוצאת שורש</strong> שהיא בכל מקרה הדבר הכבד פה.</p>

<p>המאמר, בהקדמה, מדבר בדיוק על זה: הוא מנסה להציג את פעולת הוצאת השורש בתור משהו בעייתי כל כך שהופך את כל החיפוש הזה אחרי נוסחה לפתרון משוואה בעזרת רדיקלים לקצת מטופש. ראשית, אין לנו דרך לחשב שורש במדויק, ממילא נקבל רק קירוב:</p>

<blockquote dir="ltr" class="quote-ltr">
Our modern quadratic formula involves a square root operation, which even in ancient times was known to generally not terminate, yielding only approximate solutions
</blockquote>

<p>שנית, כל הקטע הזה של נוסחה שיש בה פעולות מקוננות (פעולות שמבוצעות זו בתוך זו; למשל, במשוואה ממעלה שלישית בהחלט יש הוצאת שורש בתוך הוצאת שורש שלישי - אנחנו מקבלים משהו שנראה כמו <span>\( \sqrt[3]{-\frac{27}{2}q+\frac{3}{2}\sqrt{-3D}} \)</span>) מפריע להם, לעומת סכום “פשוט יותר”:</p>

<blockquote dir="ltr" class="quote-ltr">
After all, if we’re permitted nested unending nth root calculations, why not a simpler ongoing sum that actually solves polynomials beyond degree four
</blockquote>

<p>אני אישית חושב שהוצאת שורש היא דבר די פשוט. ראשית, מבחינה קונספטואלית: עם איבר כמו <span>\( \sqrt{a} \)</span> אני יכול לעבוד בקלות, אלגברית: למשל, אני יודע ש-<span>\( \left(3+\sqrt{a}\right)^{2}=9+6\sqrt{a}+a=\left(9+a\right)+6\sqrt{a} \)</span>. כלומר, אני יודע לבצע אלגברה עם ביטויים שמכילים שורשים ולקבל בחזרה ביטוי שהוא באותה רמת סיבוך - עדיין יש לו רק שורשים מאותה רמה. עם פתרון שנתון בנוסחת ההיפר-קטלן אני לא יודע אם אני יכול לעשות את זה באותה קלות - אבל זה דיון רחב מאוד שאני לא הולך להיכנס אליו וממילא לא תהיה בו הכרעה ברורה ולא צריכה להיות בו הכרעה ברורה כי חלק ממה שנחמד במתמטיקה הוא שיש שלל ייצוגים שונים לאותו דבר, וכל ייצוג מביא איתו נקודת מבט שונה שיכולה להיות שימושית לפעמים.</p>

<p>אז נתמקד בשאלה פשוטה יותר, מה שעניין את פותרי המשוואות האיטלקיים שמהם כל הטירוף הזה התפתח - מה יותר <strong>יעיל</strong>? מה מאפשר לי לחשב יותר בנוחות? ובשביל זה, אנחנו רואים שאנחנו צריכים להסביר איך מחשבים שורשים ביעילות, וזה מאפשר לי להציג את אחת משיטות הקירוב המוכרות והפופולריות ביותר, שתהיה רלוונטית גם לחישוב שורשים וגם לפתרון משוואות פולינומיות כלליות: <strong>שיטת ניוטון-רפסון</strong>.</p>

<p>השימושיות של ניוטון-רפסון חורגת מאשר “סתם” מציאת שורשים לפולינומים, ובהקשר של שורשים לפולינומים יש שיטות לשפר את היעילות שלה, אבל זה מצדיק פוסט בפני עצמו (שאין לי). כאן אני אסתפק בלהציג את השיטה בצורה הפשוטה ביותר שלה ונראה אם זה יספיק. הרעיון המרכזי בניוטון-רפסון הוא זה: אם נתונה לנו פונקציה <span>\( f\left(x\right) \)</span> ואנחנו רוצים למצוא <span>\( a \)</span> כך ש-<span>\( f\left(a\right)=0 \)</span>, בואו נגדיר <strong>סדרה</strong> של קירובים ל-<span>\( a \)</span> הזו, שהולכת ומשתפרת. נתחיל עם קירוב כלשהו, <span>\( a_{0} \)</span>, ואז נגדיר סדרה <span>\( a_{n} \)</span> על ידי הכלל</p>

<p><span>\( a_{n+1}=a_{n}-\frac{f\left(a_{n}\right)}{f^{\prime}\left(a_{n}\right)} \)</span></p>

<p>למה? מאיפה זה מגיע? <a href="https://gadial.net/2017/08/22/0x5f3759df_part_1/">בפוסט הזה</a> שלי אני מנסה (בפרק השלישי) לתת לזה אינטואיציה - לא אכנס לזה עכשיו שוב (אבל בהחלט צריך פוסט ייעודי על הנושא הזה!). במקום זה, בואו נראה איך זה עובד עבור הבעיה הפשוטה של חישוב שורש. במקרה הזה, נניח שאני רוצה לחשב את השורש <span>\( \sqrt{D} \)</span> עבור מספר ממשי <span>\( D \)</span> כלשהו. אני אגדיר פונקציה <span>\( f\left(x\right)=x^{2}-D \)</span>, אז בבירור <span>\( f\left(\sqrt{D}\right)=0 \)</span> ולכן זו הפונקציה שאני רוצה להשתמש בה. חישוב הנגזרת של פונקציה כזו הוא טריוויאלי: <span>\( f^{\prime}\left(x\right)=2x \)</span>, ולכן נקבל את הסדרה</p>

<p><span>\( a_{n+1}=a_{n}-\frac{a_{n}^{2}-D}{2a_{n}}=\frac{2a_{n}^{2}-a_{n}^{2}+D}{2a_{n}}=\frac{a_{n}^{2}+D}{2a_{n}}=\frac{1}{2}\left(a_{n}+\frac{D}{a_{n}}\right) \)</span></p>

<p>אני מאוד אוהב את התוצאה הזו, כי הנוסחה <span>\( a_{n+1}=\frac{1}{2}\left(a_{n}+\frac{D}{a_{n}}\right) \)</span> הייתה למעשה קיימת הרבה לפני ניוטון - זו שיטה שתוארה על ידי הרון מאלכסנדריה לפני 2,000 שנים בערך, ויש לה אינטואיציה גאומטרית יפהפיה: אם נסתכל על ריבוע ששטחו <span>\( D \)</span>, אז אורך צלעו יהיה <span>\( \sqrt{D} \)</span>. מה שהרון מציע הוא להתחיל עם <strong>מלבן</strong> שאורך אחת מצלעותיו הוא <span>\( a_{0} \)</span> ושטחו <span>\( D \)</span>, ואז אורך צלעו השניה תהיה <span>\( \frac{D}{a_{n}} \)</span>. אנחנו רוצים שאורכי הצלעות ישתוו, אז אנחנו מחליפים את <span>\( a_{n} \)</span> בממוצע בין <span>\( a_{n} \)</span> והצלע השניה, ומקבלים סדרה שהולכת ומשתפרת של מלבנים שהופכים לקרובים יותר ויותר לריבוע.</p>

<p>כל איטרציה כוללת פעולת חילוק “קשה” אחת: החילוק <span>\( \frac{D}{a_{n}} \)</span>. בנוסף יש פעולת חיבור ופעולת חילוק “קלה יותר”, חילוק ב-2. זה לא כל כך הרבה!</p>

<p>הנה קוד שמריץ את זה ומקבל תוצאה שהיא מדויקת בכל ספרות הדיוק שהוא מציג:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">D</span> <span class="o">=</span> <span class="mi">137</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">D</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">D</span><span class="o">/</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"Newton's method: sqrt(</span><span class="si">{</span><span class="n">D</span><span class="si">}</span><span class="s">) = </span><span class="si">{</span><span class="n">a</span><span class="p">:.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span></code></pre></figure>

<p>הקוד מבצע בסך הכל 10 איטרציות. לא רע! אבל האם אפשר להסתפק בפחות? אם תנסו להריץ, תראו שגם עבור <span>\( N=8 \)</span> מקבלים את אותה התוצאה, אבל לפני כן לא. אבל… האם באמת היינו צריכים להתחיל מ-<span>\( D \)</span>? האם אין דרך טובה יותר לנחש ערך התחלתי? ובכן, יש שלל דרכים, הנה אחת פשוטה: נסתכל כמה ביטים נדרשים כדי לייצג את <span>\( D \)</span> בזיכרון, ניקח רק חצי מהן ואז ניקח מספר שמיוצג על ידי כמות הביטים הזו - הוא יהיה בערך מסדר גודל כמו השורש של <span>\( D \)</span>. הנה דרך פשוטה לעשות את זה בפייתון:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">D</span><span class="p">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span></code></pre></figure>

<p>אם נשתמש בדרך הזו, מספר האיטרציות שצריך בשביל רמת הדיוק שלנו יקטן ל-<span>\( N=4 \)</span>. לא רע בכלל!</p>

<p>באופן כללי שאלת הקירוב ההתחלתי היעיל היא ממש מעניינת - כבר <a href="\%20[https://gadial.net/2017/08/22/0x5f3759df_part_1/\%7C\%7C\%D7\%91\%D7\%A4\%D7\%95\%D7\%A1\%D7\%98\%20\%D7\%94\%D7\%96\%D7\%94]">קישרתי פה אל פוסט</a> שאני מאוד אוהב שבעצם המהות שלו היא שיטה אחת כזו. מצד שני, אפשר לראות את זה בתור חיסרון של ניוטון-רפסון אל מול גישת “יש לי טור. תחברו איברים בטור. זהו” שלכאורה מציעה נוסחת קטלן. אבל האמנם…? כפי שאנחנו זוכרים, נוסחת קטלן פשוט <strong>לא עובדת</strong> לכל מני ערכים - מה שיוצא בפועל הוא שגם בה מתחבא היטב קונספט של “לבחור ערך התחלתי מתאים”.</p>

<p>המאמר נוגע בזה ישירות בחלק 8 שלו, שמסתכל על המקרה של משוואה ממעלה שלישית ומדגים איך אפשר לקבל קירוב לפתרון באמצעות הנוסחה הכללית. הוא מתחיל מהמשוואה</p>

<p><span>\( 1-\alpha+t_{2}\alpha^{2}+t_{3}\alpha^{3} \)</span></p>

<p>ומציג במפורש את הפתרון הכללי שהוא מצא עבורה:</p>

<p><span>\( \alpha=\sum_{m_{2}\ge0}\sum_{m_{3}\ge0}\frac{\left(2m_{2}+3m_{3}\right)!}{\left(1+m_{2}+2m_{3}\right)!m_{2}!m_{3}!}t_{2}^{m_{2}}t_{3}^{m_{3}} \)</span></p>

<p>עוד נחזור אל הנוסחה הכללית הזו, אבל לפני כן בואו נזרום עם המאמר. הוא מסתכל על משוואה ספציפית מאוד:</p>

<p><span>\( f\left(x\right)=x^{3}-2x-5=0 \)</span></p>

<p>שבה ג’ון וואליס השתמש כדי להדגים את שיטת ניוטון-רפסון. עכשיו, כדי לקבל קירוב לפתרון של המשוואה הזו המאמר לא לוקח את הסכום האינסופי, אלא רק את המונומים שלו שהם עד וכולל דרגה 3, מה שיוצא:</p>

<p><span>\( Q\left(t_{2},t_{3}\right)=1+\left(t_{2}+t_{3}\right)+\left(2t_{2}^{2}+5t_{2}t_{3}+3t_{3}^{2}\right)+\left(5t_{2}^{3}+21t_{2}^{2}t_{3}+28t_{2}t_{3}^{2}+12t_{3}^{3}\right) \)</span></p>

<p>ועכשיו, כדי לפתור משוואה כללית <span>\( c_{0}-c_{1}x+c_{2}x^{2}+c_{3}x^{3}=0 \)</span>, הנוסחה שהמאמר מצא אומרת לנו לחשב את הביטוי שהם מסמנים ב-<span>\( K\left(c_{0},c_{1},c_{2},c_{3}\right) \)</span> ומוגדר כך:</p>

<p><span>\( K\left(c_{0},c_{1},c_{2},c_{3}\right)=\frac{c_{0}}{c_{1}}Q\left(\frac{c_{0}c_{2}}{c_{1}^{2}},\frac{c_{0}^{2}c_{3}}{c_{1}^{3}}\right) \)</span></p>

<p>והם מציבים בו את המקדמים של <span>\( f\left(x\right)=x^{3}-2x-5 \)</span>, כלומר מחשבים את <span>\( K\left(-5,2,0,1\right) \)</span> ומקבלים… משהו שהוא בערך <span>\( -999.082031 \)</span>, מה שהם מכנים ``clearly a fail’’. זו ההתייחסות הכי ישירה שראיתי במאמר לכך שבכלל רדיוס ההתכנסות (שבבירור לא מתקיים כאן) הוא רלוונטי.</p>

<p>אבל הכישלון הזה נותן להם את ההזדמנות להראות איך מתגברים על זה. הם אומרים ש-<span>\( x=2 \)</span> הוא קירוב ראשון סביר (לא אתווכח עם זה) אז במקום לפתור את הבעיה “איזה ערך צריך להציב ב-<span>\( f \)</span> כדי לקבל 0” הם מנסים לפתור את הבעיה “כמה צריך לזוז מהערך <span>\( x=2 \)</span> כדי ש-<span>\( f \)</span> יקבל 0” ואת זה עושים פורמלית על ידי הגדרת <span>\( g\left(x\right)=f\left(2+x\right)=x^{3}+6x^{2}+10x-1 \)</span> ואז חישוב של <span>\( K\left(-1,-10,6,1\right)=0.0945345708\ldots \)</span> וזה יוצא קירוב נכון ב-4 הספרות הראשונות (הערך האמיתי הוא בערך <span>\( 2.0945514815423\ldots \)</span>).</p>

<p>אוקיי, מעניין. מה יש לניוטון-רפסון לומר בעניין הזה? הנוסחה של ניוטון-רפסון שמופעלת על <span>\( f\left(x\right)=x^{3}-2x-5 \)</span> נותנת את הסדרה</p>

<p><span>\( a_{n+1}=a_{n}-\frac{f\left(a_{n}\right)}{f^{\prime}\left(a_{n}\right)}=a_{n}-\frac{a_{n}^{3}-2a_{n}-5}{3a_{n}^{2}-2}=\frac{2a_{n}^{3}+5}{3a_{n}^{2}-2} \)</span></p>

<p>בואו נרוץ על זה ישירות, החל מהקירוב <span>\( a_{0}=2 \)</span> שהם הציעו:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"Newton's method: </span><span class="si">{</span><span class="n">a</span><span class="p">:.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span></code></pre></figure>

<p>ארבע איטרציות מספיקות כאן כדי להגיע לכל ספרות הדיוק שאני מודד. כבר עבור <span>\( N=2 \)</span> מקבלים את רמת הדיוק שלהם ועוד טיפ טיפה יותר טוב (הספרה הבאה פחות שגויה). זה לא מקרי. ניוטון-רפסון מתכנס <strong>מהר</strong>, רק צריך קירוב התחלתי שקרוב מספיק לתוצאה.</p>

<p>עדיין, מאוד מעניין להשוות בין שני הדברים שקיבלנו פה. בניוטון-רפסון קיבלנו את הביטוי <span>\( a_{n+1}=\frac{2a_{n}^{3}+5}{3a_{n}^{2}-2} \)</span>, שהוא <strong>איטרציה</strong> של <strong>פונקציה רציונלית</strong>. פונקציה רציונלית, נזכיר, היא פונקציה שהיא מנה של שני פולינומים, משהו מהצורה <span>\( \frac{p\left(x\right)}{q\left(x\right)} \)</span>. לעומת זאת, ה-<span>\( Q\left(t_{2},t_{3}\right) \)</span> שהמאמר השתמש בו הוא <strong>פולינום</strong> (בשני משתנים). אבל קצת קשה להשוות את שתי הסיטואציות, כי אחרי שמציבים ערכים מספריים ב-<span>\( Q \)</span> הסיפור נגמר - מקבלים את הקירוב שרצינו - בעוד שב-<span>\( a_{n+1}=\frac{2a_{n}^{3}+5}{3a_{n}^{2}-2} \)</span> חלק מהחישוב כבר בוצע בזה שהגעתי בכלל לפונקציה רציונלית יפה; מה שנשאר הוא החישובים של האיטרציה, שזה משהו שבכלל לא קיים בשיטה הקודמת. מצד שני, ראינו שהשיטה הקודמת <strong>נכשלת</strong> ודרשה בעצמה ביצוע של סוג של איטרציה - החלפה של <span>\( x \)</span> ב-<span>\( x+2 \)</span>, מה שדורש חישוב משל עצמו. במילים אחרות - השוואה בין השיטות היא עסק רציני יותר ממה שהמאמר באמת מנסה להיכנס אליו, ואני מנחש בזהירות שאם היה לו שיפור משמעותי להציג ביחס לניוטון-רפסון הוא היה מרחיב על העניין הזה, כי זו באמת הייתה תוצאה מהממת.</p>

<p>אני יכול לעצור כאן, אבל האמת שמתחשק לי לעשות ניסוי משל עצמי, בלי שאני אדע מראש מה הולך לצאת. כמובן, גם זה לא יהיה ניסוי רציני - אני לא באמת מהתחום - אבל אני לא רוצה לעשות את זה בשביל השוואה רצינית אלא בשביל הכיף.</p>

<p>ראשית, בואו נכתוב קוד שיודע לעשות ניוטון-רפסון לכל משוואה פולינומית שהמקדמים שלה נתונים, במקום שאני אחשב דברים ידנית. משוואה כזו נראית כך:</p>

<p><span>\( f\left(x\right)=c_{n}x^{n}+c_{n-1}x^{n-1}+\ldots+c_{0} \)</span></p>

<p>הנגזרת של זה קלה מאוד לחישוב:</p>

<p><span>\( f^{\prime}\left(x\right)=nc_{n}x^{n-1}+\left(n-1\right)c_{n-1}x^{n-2}+\ldots+c_{1} \)</span></p>

<p>עכשיו, <span>\( x-\frac{f\left(x\right)}{f^{\prime}\left(x\right)} \)</span> דורש לכפול את <span>\( x \)</span> במכנה ולחסר מזה את המונה. גם את זה קל לעשות ידנית, כי</p>

<p><span>\( xf^{\prime}\left(x\right)=nc_{n}x^{n}+\left(n-1\right)c_{n-1}x^{n-1}+\ldots+c_{1}x \)</span></p>

<p>ולכן נקבל</p>

<p><span>\( x-\frac{f\left(x\right)}{f^{\prime}\left(x\right)}=\frac{\left(n-1\right)c_{n}x^{n}+\left(n-2\right)c_{n-1}x^{n-1}+\ldots+c_{2}x^{2}-c_{0}}{nc_{n}x^{n-1}+\left(n-1\right)c_{n-1}x^{n-2}+\ldots+c_{1}} \)</span></p>

<p>הנה קוד שעושה את זה:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">newton</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)]</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">f_x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">numerator</span><span class="p">))</span>
        <span class="n">f_prime_x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">denominator</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">f_prime_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"Derivative is zero"</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">f_x</span> <span class="o">/</span> <span class="n">f_prime_x</span>
    <span class="k">return</span> <span class="n">x</span></code></pre></figure>

<p>אל מול הקוד הזה אני רוצה להעמיד קוד שמדמה את מה שהמאמר עושה עם מספרי היפר-קטלן: בהינתן פולינום <span>\( f\left(x\right) \)</span> ממעלה <span>\( k \)</span> שמנסים למצוא לו שורש, מייצרים את הפולינום מרובה המשתנים <span>\( Q\left(t_{2},t_{3},\ldots,t_{k}\right) \)</span>. בהינתן קירוב התחלתי <span>\( x_{0} \)</span> לשורש שאנחנו מנסים למצוא, מחשבים את <span>\( g\left(x\right)=f\left(x+x_{0}\right)=c_{0}-c_{1}x+c_{2}x^{2}+\ldots+c_{k}x^{k} \)</span> ואז מחשבים את <span>\( \frac{c_{0}}{c_{1}}Q\left(\frac{c_{0}c_{2}}{c_{1}^{2}},\frac{c_{0}^{2}c_{3}}{c_{1}^{3}},\ldots,\frac{c_{0}^{k-1}c_{k}}{c_{1}^{k}}\right) \)</span>.</p>

<p>בשביל לחשב את <span>\( Q \)</span> צריך לדעת לחשב את מספרי היפר-קטלן, <span>\( C_{\mathbf{m}}=\frac{\left(2m_{2}+3m_{3}+4m_{4}+\ldots\right)!}{\left(1+m_{2}+2m_{3}+3m_{4}+\ldots\right)!m_{2}!m_{3}!m_{4}!\cdots} \)</span>. חישוב של זה הוא קצת כאב ראש בצורה ישירה כי יש לנו המון מספרים עם עצרת, אז נקבל מנה של שני מספרי ענק וזה ייצא לא מדויק. למרבה השמחה, אפשר לרתום <strong>לוגריתמים</strong> לעזרתנו. כפי שהסברתי <a href="https://gadial.net/2020/06/08/what_are_logarithms/">בפוסט שלי</a> על לוגריתמים, הם הומצאו כדי לעזור לנו לחשב מכפלות ומנות של מספרים גדולים, והם עדיין משמשים טוב לזה. אם אני אפעיל <span>\( \ln \)</span> על שני האגפים, אני אקבל</p>

<p><span>\( \ln C_{\mathbf{m}}=\ln\left(\left(2m_{2}+3m_{3}+4m_{4}+\ldots\right)!\right)-\ln\left(\left(1+m_{2}+2m_{3}+3m_{4}+\ldots\right)!\right)-\sum_{k=2}\ln\left(m_{k}!\right) \)</span></p>

<p>לוגריתם של עצרת הוא כלי כל כך שימושי בחישובים, שספריות מתמטיות סטנדרטיות לרוב מציעות אותו כפונקציה בסיסית. ליתר דיוק, לוגריתם של מה שנקרא <strong>פונקציית גמא</strong>, <span>\( \Gamma \)</span>, שהיא פונקציה שמקיימת <span>\( \Gamma\left(n+1\right)=n! \)</span>, ובנוסף לכך יש לה שלל תכונות נחמדות שלא ניכנס אליהן כאן. השורה התחתונה היא שהקוד הזה מחשב את <span>\( C_{\mathbf{m}} \)</span> בצורה מדויקת ויעילה, תוך התבססות על כך שהוא צריך לצאת מספר טבעי ולכן אפשר להסתמך על חישוב שהוא טיפה לא מדויק ואז לעגל:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">hyperC</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">m_i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="n">B</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m_i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    
    <span class="n">log_numerator</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">lgamma</span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">log_denominator</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">lgamma</span><span class="p">(</span><span class="n">B</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">lgamma</span><span class="p">(</span><span class="n">m_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_numerator</span> <span class="o">-</span> <span class="n">log_denominator</span><span class="p">))</span></code></pre></figure>

<p>עם הקוד הזה וספריית האלגברה הסימבולית sympy אפשר לייצר את <span>\( Q \)</span>. הפרמטרים שלנו הם <span>\( N \)</span> שהוא הסכום המקסימלי של אברי <span>\( \mathbf{m} \)</span> (בדוגמה שלהם, <span>\( N=3 \)</span>) ו-<span>\( k \)</span> שהוא המימד של <span>\( \mathbf{m} \)</span>, כלומר כמה משתנים יש שם. ראשית אני מגדיר פונקציה רקורסיבית, partitions, שעוברת על כל הדרכים לחלק את המספר <span>\( N \)</span> לסכום של <span>\( k \)</span> מספרים טבעיים:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">partitions</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">N</span><span class="p">]]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></code></pre></figure>

<p>עכשיו אפשר להשתמש בה כדי לייצר את הפולינום:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Add</span>
<span class="k">def</span> <span class="nf">generate_polynomial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">f't2:</span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="n">monomials</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">hyperC</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">coeff</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m_i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">term</span> <span class="o">*=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="n">m_i</span>
            <span class="n">monomials</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">monomials</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F</span></code></pre></figure>

<p>כל החישובים הללו “לא נחשבים” מבחינתי כשבאים למצוא פתרון למשוואה ספציפית, כי אפשר לעשות אותם באופן חד פעמי מראש - הרי <span>\( Q \)</span> לא תלוי במשוואה ספציפית, רק במספר המשתנים ובשאלה כמה <span>\( N \)</span> שלנו יהיה גדול (ככל ש-<span>\( N \)</span> גדול יותר הקירוב יהיה טוב יותר אבל נצטרך לסכום <span>\( \Theta\left(N^{k}\right) \)</span> איברים).</p>

<p>לסיום, אני צריך דרך כלשהי לבצע את שינוי המקדמים <span>\( g\left(x\right)=f\left(x+a\right) \)</span>. כאן אני יכול להשתמש <strong>בבינום של ניוטון</strong>, באופן הבא: אם <span>\( f\left(x\right)=\sum_{k=0}^{n}a_{k}x^{k} \)</span> אז</p>

<p><span>\( f\left(x+a\right)=\sum_{k=0}^{n}a_{k}\left(x+a\right)^{k}=\sum_{k=0}^{n}a_{k}\sum_{i=0}^{k}{k \choose i}x^{i}a^{k-i} \)</span></p>

<p>אפשר לשנות את סדר הסכימה כדי לאגד לכל <span>\( x^{i} \)</span> את כל המקדמים שלו:</p>

<p><span>\( =\sum_{i=0}^{n}\left(\sum_{k=i}^{n}a_{k}{k \choose i}a^{k-i}\right)x^{i} \)</span></p>

<p>כלומר, נגדיר</p>

<p><span>\( b_{i}=\sum_{k=i}^{n}a_{k}{k \choose i}a^{k-i} \)</span></p>

<p>ונקבל ש-<span>\( g\left(x\right)=f\left(x+a\right)=\sum_{i=0}^{n}b_{i}x^{i} \)</span></p>

<p>הנה קוד שעושה את החישוב הזה:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">shift_polynomial</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
    <span class="n">shifted</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">shifted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">shifted</span></code></pre></figure>

<p>ועכשיו אפשר לכתוב את הקוד שמשתמש בנוסחה של המאמר כדי לפתור משוואה ממעלה כלשהי:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">catalan</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">shift_polynomial</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">f't2:</span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">generate_polynomial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">subs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">c0</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">c1</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))}</span>
    <span class="k">return</span> <span class="n">x0</span> <span class="o">+</span> <span class="p">(</span><span class="n">c0</span><span class="o">/</span><span class="n">c1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span><span class="p">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs_dict</span><span class="p">)</span></code></pre></figure>

<p>הייתי יכול גם לוותר לגמרי על השימוש ב-sympy אבל אני דווקא אוהב את זה שאפשר להשיג את הפולינום בצורה סימבולית ולשחק איתו.</p>

<p>ועכשיו, אפשר לעשות בדיקה חפיפניקית כדי לראות מי מצליח יותר - ניוטון או קטלן?</p>

<p>הנה קוד לדוגמא שעושה בדיקה כזו:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">catalan</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"Catalan method result: </span><span class="si">{</span><span class="n">result</span><span class="p">:.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"Newton method result: </span><span class="si">{</span><span class="n">result</span><span class="p">:.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span></code></pre></figure>

<p>יש כאן בבירור השוואה בין תפוזים ותפוחים - אני משתמש באותו <span>\( N \)</span> בתור “פרמטר הקירוב” גם עבור ניוטון וגם עבור קטלן, אבל בשיטת ניוטון <span>\( N \)</span> הוא בסך הכל מספר האיטרציות שמבצעים, ובשיטה של המאמר <span>\( N \)</span> הוא חסם על גודל סכום האיברים ב-<span>\( \mathbf{m} \)</span>. כלומר, בעוד שהגדלת <span>\( N \)</span> ב-1 אצל ניוטון פשוט מוסיפה עוד איטרציה אחת, שרמת הסיבוכיות שלה דומה לקודמותיה, בשיטת קטלן ההגדלה הזו מוסיפה <span>\( \Theta\left(N^{k-1}\right) \)</span> איברים לסכום. במילים אחרות, השימוש ב-<span>\( N \)</span> בצורה כזו <strong>עוזר</strong> לקטלן כי הוא מאפשר לו להגדיל את מספר הצעדים שהוא מבצע הרבה יותר מאשר ניוטון.</p>

<p>זה לא מפריע לי.</p>

<p>כשמריצים את הקוד למעלה, עם הפרמטרים <span>\( x_{0}=2 \)</span> ו-<span>\( N=5 \)</span>, מקבלים עבור ניוטון את התוצאה <span>\( 2.0945514815 \)</span> (שהיא מדויקת בכל הספרות) ועבור קטלן את <span>\( 2.0945508795 \)</span> (שהיא עדיין די מדויקת אבל רק עד ה-55). לרמת הדיוק של ניוטון קטלן הגיע ב-<span>\( N=13 \)</span>; בשלב הזה ניוטון כבר מקבל <span>\( 2.0945514815423269539 \)</span> (המאמר נוקב ב-<span>\( 2.0945514815423265915 \)</span> בתור הקירוב של 19 הספרות הראשונות). בקיצור, על הדוגמא שלהם קטלן לא באמת נותן תחרות לניוטון.</p>

<p>אם אני מתחיל מקירוב יותר נאיבי, <span>\( x_{0}=0 \)</span>, אז ניוטון צריך שאבקש <span>\( N=19 \)</span> כדי לקבל את הקירוב של 10 הספרות שראינו קודם (כמובן, בעולם האמיתי לא צריך להגיד לניוטון כמה איטרציות לעשות; מבקשים ממנו לעצור אחרי שהוא רואה שהפעלת איטרציה קיבעה את 10 הספרות הראשונות) אבל קטלן, כמו שהבטיחו במאמר, נכשל לגמרי ונותן <span>\( -108653171492152000000000 \)</span>. אם תשאלו אותי, זה יתרון גדול של ניוטון; אפילו אם אגדיר <span>\( x_{0}=-1000000000000 \)</span>, עבור <span>\( N=100 \)</span> אקבל את אותו קירוב לפתרון. כשהפונקציה שמנסים לטפל בה היא נחמדה (ופולינום היא פונקציה נחמדה), ניוטון זה כמו מגנט שנדבק בכוח אל הפתרון די מהר. השיטה של המאמר פשוט לא יודעת לעשות את זה - היא תלויה הרבה יותר בכך שנמצא לה קירוב ראשוני מתאים.</p>

<p>אז הרושם הראשוני שהשיטה במאמר לא יודעת לטפל ב”כל” משוואה אלא רק במשוואות שהפרמטרים שלהן נופלות תחת רדיוס ההתכנסות של הטור הרלוונטי - הרושם הזה <strong>שגוי</strong>, בהחלט אפשר ליצור אלגוריתם טוב שמטפל בכל משוואה (כמעט… לא התייחסתי למקרה של <span>\( c_{1}=0 \)</span>) <strong>אבל</strong> האלגוריתם הזה יהיה <strong>רגיש לתנאי ההתחלה</strong>, הרבה יותר מאשר ניוטון רגיש. וזה קצת נשמע מוזר כי אם רק מסתכלים על הכותרת של המאמר לא ברור בכלל שיש צורך שיהיו “תנאי התחלה” שכאלו.</p>

<p>איך אפשר לעשות עוד מבחנים כאלו? ובכן, הכי טוב לייצר פולינום אקראי, אז הנה קוד שעושה את זה ומריץ “מבחן” עליו:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">random</span>
<span class="k">def</span> <span class="nf">random_coefficients</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="n">random_coefficients</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">1.4</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">catalan</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"Catalan method result: </span><span class="si">{</span><span class="n">result</span><span class="p">:.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"Newton's method result: </span><span class="si">{</span><span class="n">result</span><span class="p">:.</span><span class="mi">10</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span></code></pre></figure>

<p>במקרה הנוכחי בחרתי פולינום ממעלה 10 וקיבלתי את המקדמים <span>\( [10,-7,-10,-2,-3,-3,-6,-7,7,-8,8] \)</span>. אחר כך הרצתי ניוטון בצד עם המון איטרציות כדי לדעת מה הערך ה”נכון” שאנחנו מחפשים, וראיתי שהוא קרוב ל-<span>\( 1.4 \)</span> והזנתי את זה לקטלן. למה <span>\( N=5 \)</span> ולא משהו גדול יותר? כי בשלב הזה, מכיוון שהפולינום הוא ממעלה גבוהה אז ה-<span>\( k \)</span> שבחזקה שלו מעלים את <span>\( N \)</span> הוא די גבוה, ולכן זמן הריצה כבר מורגש - לקוד הזה לקחו יותר מ-15 שניות לרוץ, למרות שניוטון מסיים מייד. אחרי הריצה הזו ניוטון השיג <span>\( 1.4042602427 \)</span> (זו התוצאה הנכונה, במסגרת ספרות הדיוק) וקטלן השיג <span>\( 1.4042602426 \)</span>, שזה… יפה מאוד! כמעט אותו דבר! אבל כמובן, זה בזכות קירוב התחלתי טוב; אם אני מתחיל מ-<span>\( x_{0}=2 \)</span> קטלן <strong>טיפה</strong> פחות מצליח, ומקבל <span>\( 1.6666226398 \)</span> לעומת ה-<span>\( 1.4187182359 \)</span> של ניוטון. עבור ערכים גדולים יותר של <span>\( x_{0} \)</span> קטלן מחזיר תוצאות פחות מדויקות אבל לא מתחרבש לגמרי אפילו עבור <span>\( x_{0}=100 \)</span>. זה לא כל כך מפתיע; כשמבצעים את ההזזה <span>\( g\left(x\right)=f\left(x+a\right) \)</span> זה מנפח מאוד את המקדמים הקטנים ופחות את הגדולים. ואז מציבים ערך מהצורה <span>\( \frac{c_{0}^{i-1}c_{i}}{c_{1}^{i}} \)</span> בפולינום. מה שקורה הוא ש-<span>\( c_{0}^{i-1} \)</span>מבטל “בערך” את ה-<span>\( c_{1}^{i-1} \)</span> שבמכנה ומשאיר <span>\( \frac{c_{i}}{c_{1}} \)</span>, ואם <span>\( c_{1} \)</span> גדול מאוד ביחס ל-<span>\( c_{i} \)</span> נקבל מספר קטן - כלומר, המספרים שנציב יהיו בסיכוי טוב בתוך רדיוס ההתכנסות. לכן דווקא הניחוש ההתחלתי <span>\( x_{0}=0 \)</span>, למרות שהוא קרוב הרבה יותר לתוצאה האמיתית מאשר <span>\( x_{0}=100 \)</span>, הולך להוביל לקטסטרופה. העניין הוא שעבור <span>\( x_{0}=100 \)</span> אמנם לא נקבל קטסטרופה אלא תוצאה שהיא הגיונית, אבל היא לא קירוב טוב במיוחד (מקבלים <span>\( 80.6474783702 \)</span> עבור <span>\( N=5 \)</span>).</p>

<p>אז לסיכום - אם מה שמעניין אותנו הוא <strong>לחשב</strong> את הפתרונות של משוואה פולינומית, עבור איזו רמת דיוק שנרצה, הרושם שאני מקבל הוא שניוטון-רפסון היא שיטה הרבה יותר יעילה ומתאימה. כמובן, המאמר בשום מקום לא טוען אחרת. לכן אולי הגיע הזמן לדבר על מה שנאמר <strong>מחוץ</strong> למאמר, ובזה נסיים.</p>

<h2>בואו נתלונן על הצגה לא נאמנה של המתמטיקה בתקשורת, כי זה כבר מזמן לא קרה</h2>

<p>בראשית ימי הבלוג חשבתי שאחד מהדברים המרכזיים שאעשה בו הוא להתלונן על כל מני הצגות שגויות של המתמטיקה בתקשורת, כי זה כיף וזה נותן תירוץ לדבר על דברים מתמטיים מגניבים. אחר כך הבנתי שאני יכול לדבר על דברים מתמטיים מגניבים בלי תירוצים ושזה בדרך כלל עדיף להציג דברים מגישה חיובית ולא לפתוח ב”אההה הצילו כל מה שכתוב בעיתון הזה לא נכון”. אז אני כבר כמעט ולא עושה את זה (ובימינו יש רשתות חברתיות שיותר מתאימות לתלונות כאלו) אבל עדיין, בואו ננסה לראות מה היו חלק מהכותרות המפוצצות שגרמו לי לשים לב למאמר מלכתחילה ונבין מה עומד מאחוריהן (ולפני התלונות, שימו לב למובן מאליו - <strong>בלי</strong> הכותרות המפוצצות לא הייתי קורא את המאמר, שהוא כאמור די מגניב).</p>

<p>נתחיל מהכותרת הראשונה שבה נתקלתי: Mathematician solves algebra’s oldest problem using intriguing new number sequences. היא מגיעה מהפרסום <a href="https://www.unsw.edu.au/newsroom/news/2025/05/mathematician-solves-algebras-oldest-problem-using-intriguing-new-number-sequences">כאן</a>, שהוא לא כתבה עיתונאית אלא פרסום של האוניברסיטה עצמה. ככזה, הוא יחסית מדויק. עדיין, יש דבר או שניים שמרגיזים אותי.</p>

<p>למשל, הם כותבים שם ש-</p>
<blockquote dir="ltr" class="quote-ltr">
A general method for solving ‘higher order’ polynomial equations, where x is raised to the power of five or higher, has historically proven elusive.
</blockquote>

<blockquote dir="ltr" class="quote-ltr">
Now, UNSW Honorary Professor Norman Wildberger has revealed a new approach using novel number sequences, outlined in a recent publication with computer scientist Dr. Dean Rubine.
</blockquote>

<p>מה שמקפיץ אותי הוא ה-novel number sequences - הרי מספרי ההיפר-קטלן הם לא חדשים; המאמר מצטט ספרות יפה שעוסקת בהם עוד מהמאה ה-19. החידוש במאמר הוא להסתכל על הפונקציה היוצרת שלהם ולהגיד - היי, תראו, זה סוג של נותן פתרון של משוואה.</p>

<p>הדבר שיותר מרגיז אותי מגיע אחרי התיאור של גלואה וההוכחה לאי הפתירות על ידי רדיקלים של משוואות ממעלה חמישית ומעלה:</p>
<blockquote dir="ltr" class="quote-ltr">
Approximate solutions for higher-degree polynomials have since been developed and are widely used in applications but, Prof. Wildberger says, these don’t belong to pure algebra.
</blockquote>

<p>ראשית, יש פה טעות היסטורית - זה לא שפתרונות מקורבים פותחו <strong>אחר כך</strong>, הם היו ידועים <strong>קודם</strong>. המאמר עצמו מזכיר את זה במפורש - הוא מדבר על איך שוואליס (במאה ה-17!) השתמש בשיטת ניוטון כדי למצוא את הפתרון של פולינום מסויים (למעשה, שיטת ניוטון עברה שלל גלגולים לאורך השנים אבל כבר בגרסה הגולמית שלה אצל ניוטון היא שימשה לפתרון משוואות פולינומיות).</p>

<p>שנית, מה בכלל המשמעות של “pure algebra” כאן? בסופו של דבר, הדרך לקבל פתרון קונקרטי למשוואה בשיטה של המאמר היא להציב מספרים בתור טור אינסופי ולקוות שיתכנס. זה לגמרי פתרון אנליטי. לכן אני משער שב”אלגברה טהורה” הכוונה למה שראינו בפוסט הקודם - לכך שכדי להגדיר שוויון <strong>ברמת הפונקציות היוצרות</strong> לא צריך בכלל חשבון דיפרנציאלי ואינטגרלי. זו הנקודה שהמאמר אכן מקפיד עליה - לומר שהפתרון הוא “כטור חזקות פורמלי” אבל כבר אמרתי שאני לא מבין איך זה בעצם פתרון - כי בטור חזקות פורמלי מה שמעניין אותנו הוא לקודד <strong>את המקדמים</strong> של הטור, ואילו כאן הטור לכאורה מקודד מספר שמתקבל <strong>על ידי הצבה</strong>.</p>

<p>עניין אחר שמוזכר שם הוא שהכותב מתאר את עצמו כ”לא מאמין במספרים אי רציונליים” ועל זה אני אומר… אוקיי, עזבו. מילא לא היה מאמין באינסוף, את זה הייתי מבין - אבל די התבססת כאן על טורים אינסופיים, פורמליים או לא.</p>

<p>הלאה, בואו נעבור למאמר עם הכותרת “The Oldest Algebra Problem Solved”: Australian Mathematician Cracks Ancient Mystery That Baffled Minds for Over 4,000 Years” שאפשר לראות <a href="https://www.sustainability-times.com/research/the-oldest-algebra-problem-solved-australian-mathematician-cracks-ancient-mystery-that-baffled-minds-for-over-4000-years/">כאן</a>. המאמר נפתח בסתם בלבול תמים שגורם לו לחשוב שנוסחת השורשים (הנוסחה לפתרון משוואה ממעלה שניה) היא מה שנותן לנו את הפתרון למשוואות ממעלה שלישית ורביעית (הו לא, כל כך לא). מה שבאמת מרגיז אותי פה הוא שהמאמר כותב ש”בדיקות על משוואה מפורסמת ממעלה שלישית בה השתמש וואליס במאה ה-17 הדגימו את יעילות השיטה” - אבל הם לא אומרים <strong>איך</strong> וואליס השתמש במשוואה הזו; כזכור, הוא השתמש בה כדי להדגים את שיטת ניוטון - השיטה שמניבה למשוואה הזו פתרונות <strong>טובים יותר</strong>. יותר מזה, המאמר עובר להתלונן על כך שעד כה היו רק פתרונות <strong>מקורבים</strong> שלא שייכים לאלגברה “טהורה” אבל השיטה החדשה היא “יותר מדויקת”.</p>

<p>במילים אחרות, לכותבים אין שמץ של מושג מה בעצם קורה כאן. הם לא מבינים שיש פה טריידאוף: או שאתה אלגברי “טהור” אבל לא תוכל לקבל ערך מספרי לפתרונות, בכלל; או שאתה לא אלגברי טהור, ואתה יכול לקבל ליד פתרונות מקורבים, אבל אז השיטה שלך פחות טובה מהקיימות. לצערי, אני מרגיש שיש למאמר חלק בזה - אין בו הבהרה של ממש מה בעצם <strong>המשמעות</strong> של זה שהפתרון נתון בעזרת פונקציות יוצרות.</p>

<p>מה עם “200-year-old “algebra wall” shattered with a bold new approach” שנמצא <a href="https://newatlas.com/science/algebras-oldest-problem/">כאן</a>? יש בו פסקה מעצבנת במיוחד:</p>

<blockquote dir="ltr" class="quote-ltr">Mathematician Norman Wildberger, an Honorary Professor at Australia's University of New South Wales, and computer scientist Dean Rubine have thrown out the rulebook and presented a new way to solve polynomial equations that go beyond x to the power of four -- something that has only been resolved with "approximate solutions." While this won't mean a whole lot to school students in math class, accuracy in answering higher-order polynomial problems could have huge implications in the fields of science and technology.
</blockquote>

<p>הפסקה הזו מראה נפילה מוחלטת להטעיה של יחסי הציבור - בזה שהפתרונות הקודמים נפסלים בתור “פתרונות מקורבים” איכשהו נוצר הרושם שהפתרון החדש “מדויק יותר” והרי אנחנו יודעים שהדיוק חשוב כשאנחנו מנסים להנחית חללית על מאדים! אבל שוב - הדיוק של השיטה החדשה <strong>פחות גדול</strong> מאשר אצל ניוטון. המובן היחיד שבו היא “מדויקת” היא בדיוק המובן שבו אין לנו דרך לקבל את הפתרון בצורה מפורשת.</p>

<p>וזה נמשך:</p>

<blockquote dir="ltr" class="quote-ltr">
“One of the equations we tested was a famous cubic equation used by Wallis in the 17th century to demonstrate Newton's method," Wildberger explained. "Our solution worked beautifully." 
</blockquote>

<p>כאן הם ליטרלי מזכירים את ניוטון - ועדיין לא מתייחסים למשמעות של זה. נכון, הפתרון שלהם עובד בצורה יפהפיה ברגע שבוחרים קירוב התחלתי טוב מספיק; אבל השיטה של ניוטון עובדת בצורה עוד יותר יפהפיה. במובן הספציפי הזה, הבעיה כבר הייתה פתורה מאות שנים.</p>

<p>ולסיום, המאמר מנסה להצדיק את הכותרת שלו:</p>
<blockquote dir="ltr" class="quote-ltr">
If you're still with me, this new method solves for equations that can't generally be resolved using traditional methods, like using root-taking approaches. In this sense, it breaks through a centuries-old mathematical wall. The novel approach removes the limitations presented by the kind of simple finite formula we were taught at school.
</blockquote>

<p>הבעיה פה היא שאנשים פשוט לא מבינים מהן השיטות המסורתיות, ולמה ביחס אליהן זו בעיה פתורה. אז הם מדמיינים שיש פה חומה שצריך לשבור.</p>

<p>ומה עם “Researchers Solve “Impossible” Math Problem After 200 Years”? טוב, זה כמעט מועתק מילה במילה מהקומוניקט של האוניברסיטה, אז אין טעם להתעסק גם בו - אבל זה ממחיש את העניין. כל המאמרים הללו נכתבו על ידי אנשים שדי בבירור לא מבינים את הנושא ופשוט מתבססים על מה שהאוניברסיטה סיפרה להם, והאוניברסיטה סיפרה להם את האמת… אבל לא את כל האמת. זה הטריק הכי ישן בספר, כמובן.</p>

<p>אני רוצה להדגיש את מה שפתחתי איתו: זה מאמר נחמד. מה שהוא עושה, למרות שהוא לא מורכב במיוחד, הוא יפה. אבל כל ההצגה הבומבסטית שיש מאחוריו נראית לי לא קשורה לשום דבר. אם מאמר באמת הצליח לפרוץ דרך שנראתה בלתי אפשרית, הדבר הראשון שהייתי מצפה לראות הוא איך השיטה החדשה פותרת בעיות שמעולם לא נפתרו. וזה… לא קורה.</p>

<p>אבל היי, סוף סוף הייתה לי מוטיבציה לכתוב על מספרי קטלן בבלוג, אז אני אסיר תודה.</p>

  </div>

  <hr />
  <p>
    נהניתם? התעניינתם? אם תרצו, אתם מוזמנים לתת טיפ:
  </p>
  <a href='https://ko-fi.com/H2H5XFBQ' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://az743702.vo.msecnd.net/cdn/kofi2.png?v=2' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a><div class="PageNavigation">
    
      <a class="prev" href="/2025/06/11/catalan_numbers_and_generating_functions/">&laquo; פונקציות יוצרות ומספרי קטלן</a>
    
    
      <a class="next" href="/2025/09/06/unitary_diagonalization/">לכסון אוניטרי &raquo;</a>
    
  </div><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://gadial.net/2025/06/18/quintic_and_catalan/';
      this.page.identifier = 'http://gadial.net/2025/06/18/quintic_and_catalan/';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://not-precise.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/2025/06/18/quintic_and_catalan/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">לא מדויק</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">לא מדויק</li><li><a class="u-email" href="mailto:gadial@gmail.com">gadial@gmail.com</a></li><li>&copy; כל הזכויות שמורות לגדי אלכסנדרוביץ'</li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/%D7%9C%D7%90-%D7%9E%D7%93%D7%95%D7%99%D7%A7-163347110378474"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">לא מדויק</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>RSS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>בלוג על מתמטיקה ומדעי המחשב</p>
      </div>
    </div>

  </div>

</footer><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script>

<!-- Default Statcounter code for New blog
http://www.gadial.net/ -->
<script type="text/javascript">
  var sc_project=5444342; 
  var sc_invisible=1; 
  var sc_security="4a89cbe4"; 
  </script>
  <script type="text/javascript"
  src="https://www.statcounter.com/counter/counter.js"
  async></script>
  <noscript><div class="statcounter"><a title="Web Analytics"
  href="https://statcounter.com/" target="_blank"><img
  class="statcounter"
  src="https://c.statcounter.com/5444342/0/4a89cbe4/1/"
  alt="Web Analytics"></a></div></noscript>
  <!-- End of Statcounter Code --></body>

</html>
