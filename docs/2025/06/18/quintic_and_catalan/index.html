<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>האם נמצאה נוסחה לפתרון משוואה ממעלה חמישית?! (לא) - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2025/06/18/quintic_and_catalan/">
    <meta property="og:title" content="האם נמצאה נוסחה לפתרון משוואה ממעלה חמישית?! (לא)">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2025/06/18/quintic_and_catalan/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="האם נמצאה נוסחה לפתרון משוואה ממעלה חמישית?! (לא)">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <a href="/lecture_notes.html">סיכומי הרצאות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2025/06/11/catalan_numbers_and_generating_functions/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">פונקציות יוצרות ומספרי קטלן</span>
            </a>
            

            
            <a href="/2025/09/06/unitary_diagonalization/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">לכסון אוניטרי</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>האם נמצאה נוסחה לפתרון משוואה ממעלה חמישית?! (לא)</h1>
            <div class="post-meta">
                <span class="date">2025-06-18</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/קומבינטוריקה.html">קומבינטוריקה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/מספרי קטלן.html">מספרי קטלן</a>
                    
                    <a href="/tags/פונקציות יוצרות.html">פונקציות יוצרות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <h2>מבוא</h2>

<p>לפני כמה שבועות נתקלתי בכותרת מפוצצת: "Mathematician solves algebra’s oldest problem using intriguing new number sequences". חיפוש זריז העלה עוד כותרות מפוצצות דומות: "“The Oldest Algebra Problem Solved”: Australian Mathematician Cracks Ancient Mystery That Baffled Minds for Over 4,000 Years" וגם "200-year-old "algebra wall" shattered with a bold new approach" ואיך אפשר בלי "Researchers Solve “Impossible” Math Problem After 200 Years". כותרות המשנה היו מפוצצות לא פחות, למשל "A mathematician has developed an algebraic solution to an equation that was long thought to be unsolvable.".</p>
<p>במילים פשוטות, מאמר מתמטי (שאפשר לקרוא <a href="https://www.tandfonline.com/doi/full/10.1080/00029890.2025.2460966\#abstract">כאן</a>) עם השם הנאה "A Hyper-Catalan Series Solution to Polynomial Equations, and the Geode" הצליח איכשהו להגיע לכותרות, והוא הגיע לשם על ידי רכיבה על הטענה שהוא עושה את הבלתי אפשרי: נותן <strong>נוסחה לפתרון משוואה ממעלה חמישית</strong>, דבר שהוכח כבר לפני מאתיים שנה שהוא בלתי אפשרי וגם אני <a href="https://gadial.net/2018/07/12/insolvability_of_the_quintic/">כבר תיארתי</a> אותו בבלוג. אני כבר מורגל בכותרות כאלו ולכן אחרי שהתחלתי לקרוא לא הופתעתי לגלות ש:</p>
<ul> <li>המאמר לא עושה את מה שהכותרות מבטיחות.</li>


<li>הבעיה שהיא בלתי אפשרית נותרה בלתי אפשרית כי היא בלתי אפשרית במובן מאוד <strong>ספציפי.</strong></li>


<li>יש שיטות אחרות שפותרות את הבעיה הבלתי אפשרית בשיטות אחרות בצורה טובה יותר ממה שהמאמר עושה.</li>


<li>מה שהמאמר <strong>כן</strong> עושה הוא בהחלט נחמד ויפה, אבל במובן פורמלי ספציפי שאני לא חושב שמי שכתבו את המאמרים בעיתון מבינים.</li>

</ul>

<p>אז בואו נדבר על זה. כרגיל בעניינים כאלו אני רוצה להפריד בין התוכן המתמטי של המאמר העצמו, שהוא <strong>אחלה</strong>, ובין המילים הגבוהות שבהן עוטפים את התוכן, שהן בולשיט (ואני חושש שחלק מהבולשיט במקרה הנוכחי מגיע ישירות מהחלק הלא מתמטי של המאמר).</p>
<p>לפני שניכנס לעובי הקורה, הנה התקציר: הרעיון המרכזי של המאמר הוא להציע נוסחה לפתרון משוואות פולינומיות, שמתארת את הפתרון בתור <strong>סכום אינסופי</strong>. בסכום האינסופי הזה מופיעים מספרים שקשורים למקדמים של המשוואה הפולינומית שאותה פותרים, ולהכללה של <strong>מספרי קטלן</strong>, <a href="https://gadial.net/2025/05/31/catalan_numbers/">שתיארתי לא מזמן בבלוג</a> בפירוט בדיוק בתור הכנה לפוסט הזה (וכי זה נושא נהדר בפני עצמו שהייתי צריך לקבל דחיפה קטנה כדי לכתוב עליו).</p>
<ul> <li>האם זה סותר את התוצאה שאין נוסחה לפתרון משוואה ממעלה חמישית? לא, כי התוצאה הזו מדברת על <strong>סוג מסוים</strong> של נוסחאות: כאלו שבנויות ממספר <strong>סופי</strong> של פעולות חיבור, חיסור, כפל, חילוק והוצאות שורש. כאן מחליפים את ה"סופי" ב"אינסופי", ונותנים הצדקה כלשהי לכך שגם הוצאת שורש היא משהו אינסופי במהות שלו. האם אני מסכים עם הנימוק הזה? לא ממש, אבל זה פחות רלוונטי לשאלה אם זה סותר את התוצאה - זה בבירור לא סותר את התוצאה הקיימת ולכן הכותרות המפוצצות שמנגידות את התוצאה לכך שהבעיה "בלתי אפשרית" או שנפרצה "חומה" פשוט לא קשורות למה שקרה כאן.</li>


<li>האם זה נותן שיטה <strong>יעילה</strong> לפתרון משוואות ממעלה חמישית ביחס למה שכבר היה ידוע? ובכן, לא. אני אציג בפוסט שיטה סטנדרטית לפתרון משוואות כאלו שנקראת <strong>שיטת ניוטון-רפסון</strong> שהיא יעילה מאוד (ויפה מאוד), ונשווה בינה לבין מה שהשיטה החדשה נותנת ונגלה למרבה ההפתעה שניוטון-רפסון כנראה טובה יותר. אגב, ניוטון-רפסון הייתה ידועה גם לפני מאתיים שנים, כשאבל וגלואה הוכיחו את התוצאות שלהם על משוואות ממעלה חמישית. חישוב יעיל הוא פשוט לא הסיפור פה (למרות שהמאמר גולש גם לכיוון הזה).</li>


<li>אבל, וזה אולי הכי חשוב - האם זה יפה? מעניין? לטעמי כן, התוצאה שיש במאמר היא מאוד נחמדה ואני מקווה שההשוואות יעזרו לנו גם להבין קצת יותר טוב למה.</li>

</ul>

<p>יופי, אז עכשיו אנחנו מבינים מה אנחנו רוצים להשיג פה, בואו נעשה את זה לאט ובזהירות.</p>
<h2>מספרי קטלן ומשוואות ממעלה שניה - מבוא</h2>

<p>החלק הטכני של המאמר מתחיל בדוגמא שמתבססת על האופן שבו אפשר להשתמש במספרי קטלן עבור משוואות ממעלה שניה. אני אציג את זה בערך כפי שזה מוצג במאמר: הם מתחילים מלכתוב את המשוואה הריבועית בצורה הבאה: <span class="math">\(1-\alpha+t\alpha^{2}=0\)</span>. זו בוודאי לא הדרך "הסטנדרטית" שבה כותבים משוואה כזו, שהיא <span class="math">\(ax^{2}+bx+c=0\)</span>, אבל אם נניח ש-<span class="math">\(b=-c\)</span> (זו הנחה שבהמשך יהיה קל להיפטר ממנה), ואז נחלק את כל המשוואה ב-<span class="math">\(c\)</span> (בהנחה שהוא שונה מאפס) נקבל את המשוואה <span class="math">\(1-x+\frac{a}{c}x^{2}=0\)</span> ולכן אם נסמן <span class="math">\(t=\frac{a}{c}\)</span> נקבל את הצורה שהמאמר מניח. במקרה הספציפי הזה, אפשר להשתמש בנוסחת השורשים כדי לפתור את המשוואה ולקבל <span class="math">\(\alpha=\frac{1}{2t}\left(1\pm\sqrt{1-4t}\right)\)</span>. עכשיו המאמר מכניס לתמונה את הבינום המוכלל של ניוטון, שתיארתי בפוסט הקודם. הרעיון בו הוא שאפשר לכתוב באופן כללי:</p>
<p><span class="math">\(\left(1+x\right)^{r}=\sum_{n=0}^{\infty}{r \choose n}x^{n}\)</span></p>
<p>כאשר <span class="math">\({r \choose n}=\frac{r\left(r-1\right)\left(r-2\right)\cdots\left(r-n+1\right)}{n!}\)</span></p>
<p>הנכונות של הבינום לא מובנת מאליה; זו טענה שמוכיחים בעזרת חשבון דיפרנציאלי ואינטגרלי, וכדי שזה יעבוד צריך להתקיים <span class="math">\(\left|x\right|<1\)</span>. אחרת... ובכן, למה לא לראות בעצמנו? הנה קוד פייתון פשוט שמחשב בינום מוכלל:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generalized_binomial</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>

<p>נניח שאני רוצה להשתמש בקוד הזה כדי לחשב את, נאמר, <span class="math">\(\sqrt{\frac{1}{4}}=\frac{1}{2}\)</span>. אז אני אציב <span class="math">\(x=-\frac{3}{4}\)</span> כדי לקבל <span class="math">\(1+x=\frac{1}{4}\)</span>, ו-<span class="math">\(r=\frac{1}{2}\)</span>, ואקבל:</p>
<div class="highlight"><pre><span></span><code><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">x</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">0.75</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">val</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">generalized_binomial</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>כשאני מריץ את הקוד הזה אני מקבל <span class="math">\(0.5000000000\)</span> - יופי של דבר! ומה אם, למשל, אני רוצה לקבל את <span class="math">\(\sqrt{2}\)</span>? אני אציב <span class="math">\(x=1\)</span> ואקבל <span class="math">\(1.4143562059\)</span> שזה לא רע בכלל אחרי בסך הכל 100 איברים שאני מחבר. ואם אני רוצה לחשב את <span class="math">\(\sqrt{4}=2\)</span>? אז אני אציב <span class="math">\(x=3\)</span> ואקבל... אה... את זה:</p>
<p>36897381732338865935269100862142478752415744.0000000000</p>
<p>אוקיי, משהו כאן בבירור הפסיק לעבוד.</p>
<p>ברוכים הבאים לעולם המופלא של טורי חזקות. לטור חזקות <span class="math">\(\sum_{n=0}^{\infty}a_{n}x^{n}\)</span> יש תמיד <strong>רדיוס התכנסות</strong>. מספר <span class="math">\(R\)</span> כך שאם <span class="math">\(\left|x\right|<R\)</span> אז הטור מתכנס, ואם <span class="math">\(\left|x\right|>R\)</span> אז הטור מתבדר (גדל עוד ועוד עד אינסוף). מה קורה ב-<span class="math">\(\left|x\right|=R\)</span>? כאן לא מובטח כלום. זה יכול להתכנס ויכול להתבדר, אין חוקים.</p>
<p>רדיוס ההתכנסות של טור חזקות תלוי במקדמים שלו, יש שתי שיטות מקובלות לחשב אותו: שיטת השורש ושיטת המנה. בשיטת השורש, מגדירים <span class="math">\(R\)</span> על ידי</p>
<p><span class="math">\(\frac{1}{R}=\lim\sup_{n\to\infty}\sqrt[n]{\left|a_{n}\right|}\)</span></p>
<p>כאשר אם הגבול בצד ימין יוצא 0 אז <span class="math">\(R=\infty\)</span> (הטור מתכנס לכל ערך) ואם הוא יוצא אינסוף אז <span class="math">\(R=0\)</span> (הטור לא מתכנס בכלל). ייתכן שאתם לא מכירים את <span class="math">\(\lim\sup_{n\to\infty}\)</span>. הצגתי את המושג <a href="https://gadial.net/2014/04/08/limsup_and_liminf/">בפוסט הזה</a>, אבל הנה תזכורת זריזה:</p>
<p>באופן כללי, <span class="math">\(\lim\sup_{n\to\infty}x_{n}=\lim_{n\to\infty}\left(\sup_{m\ge n}x_{m}\right)\)</span> כלומר - הרעיון הוא לעבור מהסדרה המקורית <span class="math">\(\left\{ x_{n}\right\} _{n=1}^{\infty}\)</span>שיכולה "להשתגע" ולקפץ מעלה-ומטה ומהומות ובעיות, אל סדרה שמתנהגת יותר נחמד: <span class="math">\(\left\{ y_{n}\right\} _{n=1}^{\infty}\)</span> כך ש-<span class="math">\(y_{n}=\sup\left\{ x_{m}\ |\ m\ge n\right\} \)</span>. כאשר <span class="math">\(\sup\)</span> הוא המושג הרגיל של חסם עליון. הסיבה לשימוש ב-<span class="math">\(\lim\sup\)</span> היא כדי להבטיח שהגבול תמיד יהיה קיים (למרות שהוא יכול להיות אינסוף), כך שהנוסחה "תמיד עובדת".</p>
<p>לפעמים יותר קל לחשב את <span class="math">\(R\)</span> באופן הבא: <span class="math">\(R=\lim_{n\to\infty}\left|\frac{a_{n}}{a_{n+1}}\right|\)</span> - זו "שיטת המנה" שהזכרתי, אבל הבעיה בה היא שלא תמיד הגבול קיים. מה שמובטח הוא שאם הגבול קיים, הוא שווה לרדיוס ההתכנסות.</p>
<p>איך זה מתקשר לדוגמא שראינו? בדוגמא שלנו, <span class="math">\(a_{n}={r \choose n}=\frac{r\left(r-1\right)\left(r-2\right)\cdots\left(r-n+1\right)}{n!}\)</span>. ההגדרה הזו נראית מתאימה עבור מבחן המנה:</p>
<p><span class="math">\(\frac{a_{n}}{a_{n+1}}=\frac{\left(n+1\right)!}{n!}\frac{r\left(r-1\right)\left(r-2\right)\cdots\left(r-n+1\right)}{r\left(r-1\right)\left(r-2\right)\cdots\left(r-n\right)}=\frac{n}{r-n}=\frac{1}{\frac{r}{n}-1}\)</span></p>
<p>החשבון הזה מניח ש-<span class="math">\(r\)</span> הוא לא מספר טבעי ולכן אין סיכון שיופיע לנו 0 במונה ובמכנה (אם <span class="math">\(r\)</span> הוא טבעי אז נוסחת הבינום נותנת לנו סכום סופי שמתכנס תמיד) ומכיוון ש-<span class="math">\(\lim_{n\to\infty}\frac{r}{n}=0\)</span> אנחנו מקבלים ממנו שרדיוס ההתכנסות הוא תמיד 1, מה שמתאים יפה להתנהגות שראינו, עם הדוגמה של <span class="math">\(\sqrt{\frac{1}{4}}\)</span> שעבדה יפה (<span class="math">\(x=-\frac{3}{4}\)</span>), הדוגמא של <span class="math">\(\sqrt{2}\)</span> שעדיין עבדה למרות שהיא על רדיוס ההתכנסות (<span class="math">\(x=1\)</span>) והדוגמא של <span class="math">\(\sqrt{4}\)</span> שהיא לכאורה חישוב פשוט אבל נכשלה לחלוטין כי זה כבר מעבר לרדיוס ההתכנסות (<span class="math">\(x=3\)</span>).</p>
<p>נחזור אל המאמר. המאמר הגיע אל הנוסחה <span class="math">\(\alpha=\frac{1}{2t}\left(1\pm\sqrt{1-4t}\right)\)</span> ואז אמר שנשתמש בבינום של ניוטון על הפתרון עם סימן המינוס ונקבל</p>
<p><span class="math">\(\alpha=\sum_{n=0}^{\infty}\frac{\left(2n\right)!}{n!\left(n+1\right)!}t^{n}=\sum_{n=0}^{\infty}C_{n}t^{n}\)</span></p>
<p>כאשר <span class="math">\(C_{n}\)</span> הם מספרי קטלן.</p>
<p>יש כאן, כמובן, דילוג על כמה שלבים של חישוב, אבל למרבה המזל כבר עשיתי את הכל בפירוט בפוסט הקודם שלי, על הפונקציה היוצרת של מספרי קטלן: ראינו שם שהיא <span class="math">\(C\left(x\right)=\frac{1-\sqrt{1-4x}}{2x}\)</span>, כאשר <span class="math">\(C\left(x\right)=\sum_{n=0}^{\infty}C_{n}x^{n}\)</span>. ה-<span class="math">\(\frac{\left(2n\right)!}{n!\left(n+1\right)!}\)</span> שמופיע במאמר זו פשוט דרך מפורשת לכתוב את מספרי קטלן, <span class="math">\(C_{n}=\frac{\left(2n\right)!}{n!\left(n+1\right)!}=\frac{1}{n+1}{2n \choose n}\)</span>. המאמר משתמש ב-<span class="math">\(t\)</span> בתור המשתנה של הסכימה ולא ב-<span class="math">\(x\)</span>, אבל זה כל ההבדל.</p>
<p>ועכשיו נשאלת השאלה - אוקיי, אז מה עשינו כאן בעצם? למאמר יש ניסוח טכני מדויק למה שעשינו כאן (שהוא לא מגדיר בשום מקום את משמעותו): </p>
<blockquote dir="ltr" class="quote-ltr">
Applying Newton’s binomial expansion to the minus sign solution reveals the generating series of the Catalan numbers as the formal power series solution:
</blockquote>

<p>מילות המפתח כאן הן "Formal power series solution". מה זה טור חזקות פורמלי - הקדשתי את כל הפוסט הקודם כדי להסביר, ואני לא אחזור על הפרטים הטכניים כאן אבל הרעיון המרכזי הוא זה: השוויון <span class="math">\(\frac{1-\sqrt{1-4x}}{2x}=\sum_{n=0}^{\infty}C_{n}x^{n}\)</span> הוא נכון <strong>בלי להציב ערכים</strong> ב-<span class="math">\(x\)</span>. השוויון הזה לא אומר "לכל ערך שנציב ב-<span class="math">\(x\)</span>, אגף שמאל יהיה שווה לאגף ימין". זו לא משוואה במובן הזה. השוויון אומר "האובייקט המתמטי שמופיע בצד שמאל הוא בדיוק אותו אובייקט כמו זה שמופיע באגף ימין", כש"האובייקט" הוא מה שנקרא <strong>טור חזקות פורמלי</strong>. בטור שכזה האיקסים הם לא משהו שמציבים בו ערכים אלא משהו ש"מחזיק" את המקדמים. נשמע מוזר? כן, לכן הפוסט הקודם שלי מדבר על זה. ברצינות, אם זה מפריע לכם, קראו את הפוסט הקודם.</p>
<p>אבל אם מבינים את <span class="math">\(\frac{1-\sqrt{1-4x}}{2x}\)</span> בתור ביטוי פורמלי נטו, משהו שלא אמורים להציב בו דברים, מה המשמעות של לכתוב <span class="math">\(\alpha=\frac{1-\sqrt{1-4t}}{2t}\)</span>, כמו שהמאמר עושה? המאמר מתחיל עם המשוואה <span class="math">\(1-\alpha+t\alpha^{2}=0\)</span>. מה זו המשוואה הזו? גם זה ביטוי פורמלי או שהרעיון פה הוא שמציבים ערך בפרמטר <span class="math">\(t\)</span> ואז מקבלים משוואה שבאמת אפשר לפתור? כלומר, האם <span class="math">\(\alpha\)</span> כאן מייצג <strong>מספר</strong> שמאופיין על ידי כך שהוא פותר משוואה פולינומית ואנחנו מחפשים דרך טובה לייצר את המספר הזה, או ש-<span class="math">\(\alpha\)</span> מייצג כאן מלכתחילה <strong>טור חזקות פורמלי</strong> ולכן ה"פתרון" של המשוואה <span class="math">\(1-\alpha+t\alpha^{2}=0\)</span> הוא נוסחה מפורשת לסדרת המקדמים של הטור הזה?</p>
<p>זה העניין; המאמר לא אומר. אז מלכתחילה לא לגמרי ברור מה המאמר עושה. אפשר ללכת אחורה, אל פרק המבוא, כדי לנסות להבין מה המטרה; אבל אני דווקא מעדיף לא לעשות את זה. פרקי מבוא הם לרוב המקומות שבהם מחפפים, כדי לתת לקורא מושג כללי לגבי מה שהולך לבוא בהמשך - ההמשך זה המקום שבו המושגים המדויקים צריכים להגיע. אבל אוקיי, אנחנו עדיין רק רואים דוגמא, אז אפשר לזרום עם זה ולראות לאן זה הולך.</p>
<p>השאלה המעניינת שעולה כרגע היא - אוקיי, אנחנו מקבלים את זה שהראינו את השוויון הפורמלי <span class="math">\(\alpha=\frac{1-\sqrt{1-4t}}{2t}=\sum_{n=0}^{\infty}C_{n}t^{n}\)</span>. האם אפשר להשתמש בזה כדי לחשב פתרונות של המשוואה הריבועית <span class="math">\(1-\alpha+t\alpha^{2}=0\)</span> עבור ערכים <strong>קונקרטיים</strong> של <span class="math">\(t\)</span>? כלומר, להציב ערך מספרי ב-<span class="math">\(t\)</span> ואז לחשב את <span class="math">\(\sum_{n=0}^{\infty}C_{n}t^{n}\)</span> ולקבל את הערך? התשובה היא שבהחלט אפשר! אבל... בכפוף לקטע הזה של "רדיוס התכנסות", מה שאומר שעבור רוב ערכי <span class="math">\(t\)</span> זה לא יעבוד.</p>
<p>מה רדיוס ההתכנסות של הטור? אפשר להשתמש במבחן המנה כמו קודם:</p>
<p><span class="math">\(\frac{C_{n}}{C_{n+1}}=\frac{\left(2n\right)!}{n!\left(n+1\right)!}\frac{\left(n+1\right)!\left(n+2\right)!}{\left(2n+2\right)!}=\frac{\left(n+1\right)\left(n+2\right)}{\left(2n+1\right)\left(2n+2\right)}=\frac{n^{2}+2n+2}{4n^{2}+6n+2}\to\frac{1}{4}\)</span></p>
<p>כלומר, הרדיוס הוא <span class="math">\(R=\frac{1}{4}\)</span>.</p>
<p>רציתי לבחור <span class="math">\(t\)</span> קטן מהרדיוס שעדיין נותן עבור <span class="math">\(\alpha\)</span> ערך "נחמד" שאפשר לחשב ידנית, אז הינדסתי את <span class="math">\(t=\frac{2}{9}\)</span>. הערך הזה נותן לנו את המשוואה הריבועית <span class="math">\(2\alpha^{2}-9\alpha+9=0\)</span> שהפתרונות שלה הם </p>
<p><span class="math">\(\alpha_{1,2}=\frac{9\pm\sqrt{81-72}}{4}=\frac{9\pm\sqrt{9}}{4}=\frac{9\pm3}{4}=3,1.5\)</span></p>
<p>כאשר <span class="math">\(1.5\)</span> הוא הפתרון שמתקבל מהמינוס. עכשיו, הנה קוד שיאפשר לנו לחשב מה קורה:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">C</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>   
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="n">k</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">9</span>
<span class="n">val</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span> <span class="n">t</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>כשאני מריץ אותו אני מקבל <span class="math">\(1.4999999653\)</span> שזה יפה מאוד, ואם אני מעלה את <span class="math">\(N\)</span> אל <span class="math">\(200\)</span> אני מקבל כבר <span class="math">\(1.5\)</span> (זה עדיין לא <strong>בדיוק</strong> <span class="math">\(1.5\)</span> אלא רק במסגרת 10 ספרות הדיוק שאני מציג). כלומר זה עובד, ועובד יפה! כל עוד <span class="math">\(t<\frac{1}{4}\)</span>.</p>
<p>מה קורה אם <span class="math">\(t=\frac{1}{4}\)</span>? כאן אז אנחנו מקבלים את המשוואה <span class="math">\(\alpha^{2}-4t+4=0\)</span> שנפתרת על ידי <span class="math">\(\alpha=2\)</span>. אם נחשב את הטור <span class="math">\(\sum_{n=0}^{\infty}\frac{C_{n}}{4^{n}}\)</span> עם הקוד שלי נקבל עבור <span class="math">\(N=100\)</span> את התוצאה <span class="math">\(1.8873030420\)</span> שזה... אה... די קרוב ל-2! בטח אם אני אחבר יותר איברים, כלומר אגדיל את <span class="math">\(N\)</span>, אני אתקרב עוד יותר ל-2. אם אני מציב <span class="math">\(N=500\)</span> אני מקבל <span class="math">\(1.9495499636\)</span>, שזה טוב! זה הולך ומתקרב אל 2! אבל אז...! כשאני מציב <span class="math">\(N=600\)</span>! אני פתאום מקבל "nan". מה זה אומר בכלל? זה אומר שתש כוחו של פייתון. היכולת שלו לעשות חישובים עם המספרים הרלוונטיים נגמרה. במקרה הנוכחי, מה שגומר אותו זה ה-<span class="math">\(\frac{1}{4^{n}}\)</span> שהופך להיות כל כך קטן ששיטת הייצוג הסטנדרטית של נקודה צפה (דיברתי על זה קצת <a href="https://gadial.net/2017/08/24/0x5f3759df_part_2/">כאן</a>) כבר לא מסוגלת לייצג אותו. זה נשמע כמובן טיפה הזוי - אם זה מספר <strong>כל כך קטן</strong> למה שהוא בכלל עוד ישפיע על הסכום? כלומר, למה אפילו ב-<span class="math">\(N=500\)</span> עדיין לא קיבלנו את התוצאה 2 ברמת דיוק של 10 ספרות? ובכן, כי כמה ש-<span class="math">\(\frac{1}{4^{n}}\)</span> הוא קטן מתקזז עם כמה ש-<span class="math">\(C_{n}\)</span> הוא גדול. במילים אחרות, ייצוג כזה באמצעות טור הוא לא ייצוג <strong>יעיל</strong>, כי הטור מורכב משני גורמים אקספוננציאליים שרבים זה עם זה ומקזזים זה את זה. זה בעצם מה שמבחני המנה והשורש מראים לנו - מה קצב הגידול של המקדמים שהחזקה נאלצת להתמודד איתם. כל עוד החזקה גדולה יותר מקצב הגידול הזה, הטור יתכנס מהר יחסית; אבל כשהם שווים זה יכול להיות עניין כואב ביותר ושום דבר לא מובטח, ואם הם גדולים יותר...</p>
<p>אם אני מציב למשל <span class="math">\(t=-2\)</span> אני מקבל את המשוואה <span class="math">\(2\alpha^{2}+\alpha-1=0\)</span> עם הפתרונות <span class="math">\(\alpha_{1,2}=\frac{-1\pm\sqrt{1+8}}{4}=\frac{-1\pm3}{4}=-1,0.5\)</span> אבל אם אציב את זה בקוד שלי, אפילו עבור <span class="math">\(N=10\)</span>, אני אקבל בערך <span class="math">\(-2170881\)</span> ומשם זה רק נהיה יותר ויותר גרוע. הטור לא עובד במקרים כאלו, תשכחו מזה.</p>
<p>יש לכאורה עוד בעיה פה - הטור נותן לי רק פתרון אחד, מה עם השני? זה פחות מפריע לי כי תמיד אפשר לפתור משוואות בצורה הבאה: אם <span class="math">\(p\left(x\right)\)</span> הוא הפולינום שמקודד את המשוואה, מוצאים שורש אחד ספציפי <span class="math">\(p\left(\alpha\right)=0\)</span> ואז מחלקים ומקבלים <span class="math">\(q\left(x\right)=\frac{p\left(x\right)}{x-\alpha}\)</span>. זה עובד, ושורש של <span class="math">\(q\left(x\right)\)</span> יהיה גם שורש של <span class="math">\(p\left(x\right)\)</span> ובצורה הזו אפשר למצוא את כל השורשים... אם כי אני בעצם מניח כאן במובלע שאם את <span class="math">\(p\left(x\right)\)</span> הייתי מסוגל לפתור עם הטור הזה אני אוכל לפתור גם את <span class="math">\(q\left(x\right)\)</span> באותה צורה, וראינו כבר שזה לא בהכרח נכון - זה מאוד תלוי במקדמים.</p>
<p>האם זה אומר שיש משוואות שהשיטה פשוט לא מסוגלת לפתור? לא! בהמשך המאמר יש התייחסות לזה. אז בואו נראה את השלב שבו הוא מתחיל לפרמל דברים.</p>
<h2>מספרי קטלן ומשוואות ממעלה שניה - הגישה הפורמלית של המאמר</h2>

<p>בחלק 4 שלו, המאמר ממשיך לדבר על המקרה של מספרי קטלן ומשוואות ממעלה שניה, אבל מציג את הלב הטכני של מה שהוא עושה - אם מבינים את זה, אפשר להבין את התוצאה הכללית שלו די בקלות.</p>
<p>ראשית, המאמר בוחר בעיה קומבינטורית ספציפית שמספרי קטלן פותרים, ומתמקד בה. תיארתי שלל בעיות כאלו <a href="https://gadial.net/2025/05/31/catalan_numbers/">בפוסט שלי</a> על מספרי קטלן, והמאמר בוחר להתבסס על אחת מוכרת במיוחד, זו שדי ייסדה את התחום כשאוילר פתר אותה - שילושים של מצולעים.</p>
<p>כשמתעסקים בשילושים של מצולעים, צריך איכשהו להבדיל בין שני שילושים שנראים "אותו דבר עד כדי סיבוב". בפוסט שלי הדרך להשיג את זה הייתה <strong>למספר את הקודקודים</strong> של המצולע; המאמר משיג את האפקט הזה על ידי סימון אחת הצלעות של המצולע בתור "גג" וכשמציירים את המצולע, היא מצויירת למעלה - זה היה התפקיד של הצלע 1-2 אצלי. לפוליגון עם צלע שהיא גג שכבר עבר חלוקה למשולשים המאמר קורא Triagon ומשתמש בסימון <span class="math">\(|\)</span> (קו אנכי) כדי לתאר את המקרה המנוון של "מצולע" בן שתי צלעות - משהו שראינו בפוסט שלי שמשתלם לספור. המאמר מסמן ב-<span class="math">\(\mathcal{T}_{n}\)</span> את אוסף הטריגונים עם <span class="math">\(n\)</span> <strong>פאות</strong>; כלומר, מספר המשולשים שיש בתוך הטריגון. זו דרך חכמה לעקוף את ניג'וס ה-<span class="math">\(n+2\)</span> שמתלווה לפוליגונים הללו כשסופרים את הקודקודים. עם הסימון הזה, <span class="math">\(\left|\mathcal{T}_{n}\right|=C_{n}\)</span>. כמובן, זה מניח שאנחנו <strong>מזהים</strong> טריגונים שהם "אותו הדבר" אפילו אם הצורה שלהם קצת שונה - אני מניח שאנחנו בסדר עם זה.</p>
<p>עכשיו המאמר מסביר בצורה מפורטת איך אפשר לבנות טריגון חדש משניים קיימים. בגדול, זה ההיפוך של התהליך שתיארתי בפוסט שלי - שם הסרנו את הצלע 1-2 וקיבלנו שני טריגונים, כך שמספר הפאות הכולל שלהם הוא כמספר הפאות בטריגון שהתחלנו ממנו, פחות 1. כשמסמנים את הפונקציה היוצרת של הטריגונים על ידי <span class="math">\(T\left[t\right]\)</span> כפי שהמאמר עושה, זה מוביל למשוואה</p>
<p><span class="math">\(T=1+tT^{2}\)</span></p>
<p>בניות כאלו מוסברות בצורה יותר מקיפה בספר הנהדר Analytic Combinatorics של Flajolet ו-Sedgewick שכרגע זמין במלואו באופן חופשי <a href="https://algo.inria.fr/flajolet/Publications/book.pdf">כאן</a>. הבניה עבור קטלן מוסברת בעמוד 35-36; בגדול, אפשר לחשוב על כל טריגון בתור אחד משני דברים: או הטריגון המנוון <span class="math">\(|\)</span> וכזה יש בדיוק 1, מגודל 0, ולכן התרומה שלו ל-<span class="math">\(T\left[t\right]\)</span> היא <span class="math">\(1\cdot t^{0}\)</span>; או טריגון שאפשר לתאר בתור משהו שבנוי משלושה טריגונים: שניים מגודל כלשהו ואחד מגודל 1 (המשולש שמסירים כשמוחקים את הצלע 1-2). מכיוון שמכפלה של פונקציות יוצרות מתאימה בדיוק לסיטואציה של בניה של אובייקט קומבינטורי מהאובייקטים שמתוארים על ידי הפונקציות שמכפילים, כך שהגודל של האובייקט הקומבינטורי הזה הוא סכום הגדלים של המוכפלים, מקבלים עבור המקרה הזה את <span class="math">\(T\cdot t\cdot T=tT^{2}\)</span>. דרך ההתבוננות הזו היא ממש מועילה ולמי שזה מעניין אותה אני ממליץ לקרוא את הספר (רק את החלק הראשון שלו! היתר זה נושאים, אה, שונים) והתייחסתי לזה קצת יותר <a href="https://gadial.net/2011/08/07/generating_functions_hardcore_1/">בפוסטים שכתבתי בשעתו</a>.</p>
<p>בקיצור, קיבלנו את הנוסחה <span class="math">\(T=1+tT^{2}\)</span> שבפוסט הקודם שלי ראינו כבר שהיא הנוסחה שמקיימים מספרי קטלן ומכאן המאמר מרשה לעצמו לכתוב <span class="math">\(T=\sum_{n=0}^{\infty}C_{n}t^{n}\)</span>.</p>
<p>עכשיו, אם נעביר את <span class="math">\(T\)</span> אגף נקבל את המשוואה <span class="math">\(1-T+tT^{2}=0\)</span>, כלומר <span class="math">\(T\)</span> מקיים משוואה ריבועית מצורה ספציפית: המקדם החופשי הוא 1 והמקדם של החזקה הבאה הוא <span class="math">\(-1\)</span>. המאמר אומר שפולינום שמקיים את שתי הדרישות הללו הוא <strong>בצורה גאומטרית</strong> ושהמשוואה הריבועית <span class="math">\(1-\alpha+t\alpha^{2}\)</span> היא <strong>המשוואה הריבועית הגאומטרית הכללית</strong>. בהתבסס על התוצאה הקומבינטורית שהוא הראה (שהיא, כאמור, סטנדרטית) הוא מסיק את מה שהוא מכנה <strong>משפט </strong><strong>1</strong>: שלמשוואה <span class="math">\(1-\alpha+t\alpha^{2}\)</span> יש "formal power series solution" שהוא </p>
<p><span class="math">\(\alpha=T\left[t\right]=\sum_{n=0}^{\infty}C_{n}t^{n}\)</span></p>
<p>אני חייב להודות שאני לא בטוח מה התוכן של המשפט הזה מעבר ל"הפונקציה היוצרת של מספרי קטלן מקיימת את המשוואה הריבועית <span class="math">\(1-\alpha+t\alpha^{2}\)</span>" - וזו כאמור טענה סטנדרטית עוד מימי אוילר. המאמר קורא לזה <strong>הנוסחה הגאומטרית הריבועית הרכה</strong> שזה שם מפוצץ לדבר קיים, אבל מייד אחר כך מגיע תוכן קצת יותר מעניין - הסבר איך אפשר לעבור מהמקרה הזה לפתרון של משוואה ריבועית <strong>כללית</strong>, לא כזו שהיא בצורה גאומטרית. לזה הוא קורא <strong>משפט </strong><strong>2</strong> ונותן לו את השם הטיפה פחות מפוצץ <strong>הנוסחה הריבועית הרכה</strong>. זה הולך ככה: נסמן משוואה ריבועית כללית בתור <span class="math">\(c_{0}-c_{1}x+c_{2}x^{2}=0\)</span>. עכשיו נבצע החלפת משתנים: נסמן, <span class="math">\(x=\frac{c_{0}}{c_{1}}\alpha\)</span> נציב במשוואה ונקבל</p>
<p><span class="math">\(c_{0}\left(1-\alpha+\frac{c_{0}c_{2}}{c_{1}^{2}}\alpha^{2}\right)=0\)</span></p>
<p>עכשיו נשתמש במשפט הקודם עם <span class="math">\(t=\frac{c_{0}c_{2}}{c_{1}^{2}}\)</span> ונקבל את הפתרון הבא:</p>
<p><span class="math">\(\alpha=\sum_{n=0}^{\infty}C_{n}\frac{c_{0}^{n}c_{2}^{n}}{c_{1}^{2n}}\)</span></p>
<p>אלא שאנחנו רוצים את <span class="math">\(x\)</span>, לא את <span class="math">\(\alpha\)</span>, אז נכפול הכל ב-<span class="math">\(c_{0}\)</span> ונחלק ב-<span class="math">\(c_{1}\)</span> ונקבל</p>
<p><span class="math">\(x=\sum_{n=0}^{\infty}C_{n}\frac{c_{0}^{1+n}c_{2}^{n}}{c_{1}^{1+2n}}\)</span></p>
<p>וזו כבר נוסחה קונקרטית ומעניינת! רק מה, היא... לא לגמרי עובדת. ראשית, יש לנו חלוקה ב-<span class="math">\(c_{1}\)</span>, זה אומר שאם <span class="math">\(c_{1}=0\)</span> (כמו למשל במשוואה <span class="math">\(x^{2}=2\)</span>) השיטה נכשלת. המאמר מתייחס לזה:</p>
<blockquote dir="ltr" class="quote-ltr">
It’s curious that the equation with the easiest solution in radicals is the least accessible with this method. A simple change of variables lets us skirt around the problem.
</blockquote>

<p>אם <span class="math">\(c_{0}=0\)</span> אז המשוואה שלנו היא מהצורה <span class="math">\(c_{2}x^{2}=c_{1}x\)</span> ולכן יש לה את הפתרון הטריוויאלי <span class="math">\(x=0\)</span>; זה מה שהנוסחה משיגה במקרה הזה; בשביל להשיג את הפתרון השני צריך להשתמש בטריק החלוקה שתיארתי קודם. האם זה אומר שהנוסחה שהם מצאו היא "לא כללית"? אני לא חושב שזה כזה בעייתי. אם תסתכלו בפוסט שלי על <a href="https://gadial.net/2018/07/16/solving_cubic_equations/">פתרון משוואה ממעלה שלישית</a>, גם שם משתמשים בטריקים של החלפת משתנים, למשל. כדי להרגיש שיש בעיה עם מקרי הקיצון הללו צריך להיות ממש טהרנים לגבי מה זה אומר שיש "פתרון כללי" למשוואה.</p>
<p>אבל הבעיה האמיתית, שכבר ראינו קודם, היא שהטור הזה פשוט <strong>לא מתכנס</strong> עבור חלק מהמספרים. המאמר לא מתייחס לזה שם, ואני מניח שזה בצדק מבחינתו כי לומר "formal power series solution" זה לכאורה לצאת ידי חובה. בהמשך, כאמור, תהיה התייחסות יותר רצינית לזה אז נעזוב את זה לבינתיים.</p>
<p>יופי, אז הבנו את הסיפור עם משוואה ממעלה שניה. עכשיו, מה קורה באופן כללי? למרבה המזל זה יהיה השלב הקל יחסית להבנה אם עיכלנו את מה שקרה עד כה.</p>
<h2>מספרי היפר-קטלן ומשוואות ממעלה כלשהי</h2>

<p>לפני שנראה מה המאמר עושה, בואו נחשוב שניה מה היינו רוצים שיקרה. עבור משוואה ממעלה שניה, מספרי קטלן נתנו לנו את הנוסחה <span class="math">\(T=1+tT^{2}\)</span>. עבור משוואה ממעלה שלישית, אולי אפשר למצוא בעיה מקבילה עם משוואה מהצורה <span class="math">\(T=1+tT^{2}+tT^{3}\)</span>? זה לא כזה קשה - רק צריך למצוא אובייקט שנספר על ידי <span class="math">\(T\)</span>, יש 1 ממנו שהוא מגודל 0, ואפשר לבנות אותו מחיבור של שניים או שלושה אובייקטים, ואז הגודל שלו הוא סכום הגדלים שלהם ועוד 1. להמציא כזה אובייקט זה כנראה לא כל כך קשה (אם תפתחו ב-Analytic Combinatorics את החלק של Context-free specifications and languages תראו דרך כללית לעשות דברים כאלו) אבל יש כאן שתי בעיות. ראשית, לא ברור אם נוכל למצוא נוסחה מפורשת לכמות האיברים שמתאימים לאובייקט, כמו זו שהייתה לנו עבור קטלן; ושנית, המשוואה שלנו יוצאת מאוד מוגבלת - המקדם של <span class="math">\(T^{2}\)</span> זהה למקדם של <span class="math">\(T^{3}\)</span>, וללהטוטים שעשינו קודם יש גבול, הם לא יצליחו לטפל גם בזה.</p>
<p>אז כאן המאמר עושה משהו <strong>יפה</strong>: במקום לעבוד עם פונקציה יוצרת במשתנה בודד, הוא עובר לעבוד עם פונקציה יוצרת במספר משתנים. בואו נבין איך זה ייראה עבור משוואה ממעלה שלישית, ואז נוכל להגיע כבר למשוואה כללית. עבור מעלה שלישית, המטרה היא למצוא פונקציה יוצרת <span class="math">\(S\left[t_{2},t_{3}\right]\)</span> כך ש-<span class="math">\(S=1+t_{2}S^{2}+t_{3}S^{3}\)</span>.</p>
<p>מה <span class="math">\(S\)</span> הולכת לספור? ובכן, קודם היה לנו את <span class="math">\(T=\sum_{n=0}^{\infty}\left|\mathcal{T}_{n}\right|t^{n}\)</span>, כך ש-<span class="math">\(\mathcal{T}_{n}\)</span> הייתה קבוצה של טריגונים, כלומר פוליגונים עם צלע מובחנת ספציפית שמחולקים <strong>למשולשים</strong>, וספציפית ב-<span class="math">\(\mathcal{T}_{n}\)</span> היו הטריגונים שמחולקים ל-<span class="math">\(n\)</span> משולשים. אבל מה אם נרשה חלוקה גם למשולשים וגם <strong>למרובעים</strong>? אפשר לסמן ב- <span class="math">\(\mathcal{S}_{\left[m_{2},m_{3}\right]}\)</span> את מספר הפוליגונים עם צלע מובחנת שמחולקים ל-<span class="math">\(m_{2}\)</span> משולשים ו-<span class="math">\(m_{3}\)</span> מרובעים, ו-<span class="math">\(\left[m_{2},m_{3}\right]\)</span> ייקרא <strong>הטיפוס</strong> של ה... אה... לא נקרא לזה טריגון (כי tri זה שלוש, ועברנו לדבר על חלוקה פנימית לדברים עם יותר משלוש צלעות) - במאמר קוראים לזה סבדיגון (subdigon). עכשיו נגדיר את מספר ההיפר-קטלן <span class="math">\(C_{\left[m_{2},m_{3}\right]}\)</span> בתור מספר הסבדיגונים מטיפוס <span class="math">\(\left[m_{2},m_{3}\right]\)</span> ונגדיר פונקציה יוצרת עם שני משתנים, </p>
<p><span class="math">\(S=S\left[t_{2},t_{3}\right]=\sum_{m_{2},m_{3}\ge0}C_{\left[m_{2},m_{3}\right]}t_{2}^{m_{2}}t_{3}^{m_{3}}\)</span></p>
<p>כאן הרעיון הוא שהחזקה של <span class="math">\(t_{2}\)</span> סופרת כמה <strong>משולשים</strong> יש בסבדיגון שלנו, והחזקה של <span class="math">\(t_{3}\)</span> סופרת כמה <strong>מרובעים</strong>.</p>
<p>הכתיב הזה טיפה מסורבל, וגם לא לגמרי ברור על מה משתנה הסכימה רץ, אז המאמר מפשט את זה ומסמן <span class="math">\(\mathbf{m}=\left[m_{2},m_{3}\right]\)</span> וכותב <span class="math">\(\mathbf{m}\ge0\)</span> כדי לסמן את זה ש-<span class="math">\(\mathbf{m}\)</span> רץ על כל הזוגות <span class="math">\(\left[m_{2},m_{3}\right]\)</span> שבהם <span class="math">\(m_{2}\ge0\)</span> וגם <span class="math">\(m_{3}\ge0\)</span>. אפשר להשתמש גם בסימון <span class="math">\(\mathbf{t}^{\mathbf{m}}=t_{2}^{m_{2}}t_{3}^{m_{3}}\)</span> ולקבל מעין "שחזור" של הנוסחה הקודמת:</p>
<p><span class="math">\(S=\sum_{\mathbf{m}\ge0}C_{\mathbf{m}}\mathbf{t}^{\mathbf{m}}\)</span></p>
<p>עכשיו יש שתי שאלות:</p>
<ul> <li>איזו נוסחה פולינומית מקיימת <span class="math">\(S\)</span> הזו? אנחנו רוצים הכללה של <span class="math">\(T=1+tT^{2}\)</span>.</li>


<li>איך מחשבים מספרית את <span class="math">\(C_{\mathbf{m}}\)</span>? אנחנו רוצים חישוב נוח כמו של <span class="math">\(C_{n}\)</span>.</li>

</ul>

<p>למרבה השמחה, בשני המקרים יש לזה תשובה טובה. ראשית, הנוסחה הפולינומית ש-<span class="math">\(S\)</span> מקיימת. קודם, במקרה של <span class="math">\(T\)</span>, קיבלנו את <span class="math">\(T=1+tT^{2}\)</span> באופן הבא: ה-1 היה הטריגון היחיד עם 0 משולשים, שסומן <span class="math">\(|\)</span>, ואילו <span class="math">\(tT^{2}\)</span> תיאר בניה של טריגון מתוך שני טריגונים קיימים (זה <span class="math">\(T\)</span> כפול <span class="math">\(T\)</span>) ועוד משולש אחד שדוחפים ביניהם (זה <span class="math">\(t\)</span>). הרעיון הוא שבמשולש שדוחפים ביניהם אחת מהצלעות תהיה הצלע המובחנת של הטריגון שבונים, ואל שתי הצלעות האחרות "מדביקים" את שני הטריגונים שבחרנו. כשאנחנו עובדים עם סבדיגונים את פעולת הבניה הזו <strong>אפשר לעשות גם עם מרובע</strong>, כלומר לקחת מרובע, לסמן את אחת הצלעות שלו בתור הצלע המובחנת, ולהדביק לו <strong>שלושה</strong> סבדיגונים. התוצאה של זה תהיה <span class="math">\(t_{3}S^{3}\)</span>: החזקה השלישית של <span class="math">\(S\)</span> היא כי אנחנו מדביקים שלושה סבדיגונים; המכפלה ב-<span class="math">\(t_{3}\)</span> היא כי הוספנו לסבדיגון שאנחנו בונים <strong>מרובע</strong> שאליו כולם נדבקים, ו-<span class="math">\(t_{3}\)</span> סופר כמה מרובעים יש.</p>
<p>הבניה הקודמת, שבה לוקחים <strong>משולש</strong> ומדביקים לו שני סבדיגונים, עדיין אפשרית גם כן, ונספרת על ידי <span class="math">\(t_{2}S^{2}\)</span>. ובגלל שאלו שתי בניות שונות שמניבות אובייקטים שונים, סופרים אותן בנפרד ("עקרון החיבור") ויחד עם מקרה הבסיס, נקבל את הנוסחה</p>
<p><span class="math">\(S=1+t_{2}S^{2}+t_{3}S^{3}\)</span></p>
<p>ועכשיו אפשר כמו קודם להסתכל על המשוואה</p>
<p><span class="math">\(0=1-\alpha+t_{2}\alpha^{2}+t_{3}\alpha^{3}\)</span></p>
<p>ולהגיד שיש לה formal power series solution שהוא </p>
<p><span class="math">\(\alpha=S=S\left[t_{2},t_{3}\right]=\sum_{m_{2},m_{3}\ge0}C_{\left[m_{2},m_{3}\right]}t_{2}^{m_{2}}t_{3}^{m_{3}}=\sum_{\mathbf{m}\ge0}C_{\mathbf{m}}\mathbf{t}^{\mathbf{m}}\)</span></p>
<p>כדי להשלים את התמונה, מסתכלים על משוואה פולינומית כללית ממעלה 3:</p>
<p><span class="math">\(0=c_{0}-c_{1}x+c_{2}x^{2}+c_{3}x^{3}\)</span></p>
<p>ומשתמשים באותה החלפה, <span class="math">\(\alpha=\frac{c_{0}}{c_{1}}x\)</span> והצבות <span class="math">\(t_{k}=\frac{c_{0}^{k-1}c_{k}}{c_{1}^{k}}\)</span> עבור <span class="math">\(k=2,3\)</span> כדי לקבל</p>
<p><span class="math">\(x=\sum_{m_{2},m_{3}\ge0}C_{\left[m_{2},m_{3}\right]}\frac{c_{0}^{1+m_{2}+2m_{3}}}{c_{1}^{1+2m_{2}+3m_{3}}}c_{2}^{m_{2}}c_{3}^{m_{3}}\)</span></p>
<p>ושוב - המאמר מתעלם באלגנטיות כאן מהשאלה האם בכלל הטור מתכנס עבור כזו הצבה של ערכים ב-<span class="math">\(t\)</span>-ים.</p>
<p>זהו, זה כל הרעיון - וזו הדרך שבה המאמר מוכיח את התוצאה המרכזית שלו. אלא שהוא לא עושה את זה רק עבור משוואות ממעלה שלישית; הוא עושה את זה לכל מעלה, כי הההכללה של מה שראינו היא פשוטה מאוד: אמרנו שסבדיגון יכול להיות מטיפוס <span class="math">\(\left[m_{2},m_{3}\right]\)</span>? אנחנו מרשים לו להיות מטיפוס יותר כללי, <span class="math">\(\mathbf{m}=\left[m_{2},m_{3},m_{4},\ldots\right]\)</span> כאשר המגבלה היחידה היא שכל ה-<span class="math">\(m\)</span>-ים הם 0 החל ממקום מסוים. <span class="math">\(\mathcal{S}_{\left[m_{2},m_{3},m_{4},\ldots\right]}\)</span> סופרת את הפוליגונים עם צלע מובחנת שמחולקים ל-<span class="math">\(m_{2}\)</span> משולשים, <span class="math">\(m_{3}\)</span> מרובעים, <span class="math">\(m_{4}\)</span> מחומשים וכן הלאה - באופן כללי, <span class="math">\(m_{k}\)</span> מצולעים עם <span class="math">\(k+1\)</span> צלעות והמספר מסומן ב-<span class="math">\(C_{\left[m_{2},m_{3},\ldots\right]}\)</span> (ומכיוון שאנחנו סופרים רק צורות סופיות, ברור שלא ייתכן ש-<span class="math">\(\left[m_{2},m_{3},m_{4},\ldots\right]\)</span> יהיה אינסופי "באמת" אלא חייב להיות 0 החל ממקום מסוים). עכשיו כותבים</p>
<p><span class="math">\(S=S\left[t_{2},t_{3}\right]=\sum_{m_{2},m_{3},\ldots\ge0}C_{\left[m_{2},m_{3},\ldots\right]}t_{2}^{m_{2}}t_{3}^{m_{3}}\ldots\)</span></p>
<p>זה טיפה מוזר - התחלנו מלדבר על פונקציה יוצרת עם משנה אחד, עברנו לשני משתנים ועכשיו יש לנו אינסוף משתנים (אבל בכל מונום יש רק מספר סופי שלהם) אבל זה עובד סבבה. עכשיו, כמו שיצרנו סבדיגון עם חיבור סבדיגונים למשולש ולמרובע אפשר גם למחומשים וכן הלאה, ולכן מקבלים את המשוואה</p>
<p><span class="math">\(\alpha=S=S\left[t_{2},t_{3},\ldots\right]=\sum_{m_{2},m_{3},\ldots\ge0}C_{\left[m_{2},m_{3},\ldots\right]}t_{2}^{m_{2}}t_{3}^{m_{3}}\ldots=\sum_{\mathbf{m}\ge0}C_{\mathbf{m}}\mathbf{t}^{\mathbf{m}}\)</span></p>
<p>זה התוכן של <strong>משפט </strong><strong>3</strong> במאמר, והנוסחה הזו נקראת <strong>הנוסחה הגאומטרית הפולינומית הרכה</strong>. אחר כך נפטרים מה"גאומטרית" עם <strong>משפט </strong><strong>4</strong> שמבצע את הצבת ה-<span class="math">\(c\)</span>-ים שראינו ומקבל את <strong>הנוסחה הפולינומית הרכה</strong>, </p>
<p><span class="math">\(x=\sum_{m_{2},m_{3},\ldots\ge0}C_{\left[m_{2},m_{3},\ldots\right]}\frac{c_{0}^{1+m_{2}+2m_{3}+\ldots}}{c_{1}^{1+2m_{2}+3m_{3}+\ldots}}c_{2}^{m_{2}}c_{3}^{m_{3}}\ldots\)</span></p>
<p>וזו, זו התוצאה המרכזית של המאמר - זו הנוסחה ש"פותרת" משוואה פולינומית כללית, וזה... די מגניב! יש לנו בהחלט נוסחה בודדת שאיכשהו מציגה פתרונות של <strong>כל</strong> משוואה פולינומית בתור סכום. אמנם אינסופי; אמנם עם אינסוף אינדקסים; אמנם לא מתכנס רוב הזמן; אבל עדיין, זה יפה ממש.</p>
<p>בואו ניקח רגע להעריך את זה לפני שנתקדם.</p>
<p>אוקיי, אז קיבלנו נוסחה, אבל בנוסחה הזו מופיעים המספרים <span class="math">\(C_{\left[m_{2},m_{3},\ldots\right]}\)</span>, ואם אין לנו דרך נוחה לחשב אותם, אז מה עשינו בזה? למרבה השמחה, יש נוסחה פשוטה עבורם, כמו שיש עבור מספרי קטלן. המאמר לא מוכיח את זה אלא מצטט תוצאה מוכרת אם <span class="math">\(\mathbf{m}=\left[m_{2},m_{3},m_{4},\ldots\right]\)</span> אז</p>
<p><span class="math">\(C_{\mathbf{m}}=\frac{\left(2m_{2}+3m_{3}+4m_{4}+\ldots\right)!}{\left(1+m_{2}+2m_{3}+3m_{4}+\ldots\right)!m_{2}!m_{3}!m_{4}!\cdots}\)</span></p>
<p>עכשיו המאמר מנצל את זה כדי להציג עוד דרכים יפות לכתוב את הנוסחה, אבל אני לא מנסה להציג כאן את כל המאמר; בהחלט שווה לקרוא אותו אם זה מעניין אתכם (יש עוד חלק שלם בסוף שאני לא מזכיר בכלל).</p>
<h2>בואו נלכלך ידיים וננסה להבין - האם זה יעיל?</h2>

<p>הנוסחה שהמאמר נותן היא יפה. האם היא גם נותנת לנו דרך יעילה לחשב את הפתרונות של משוואות פולינומיות? ובכן, יעיל בהשוואה אל מה?</p>
<p>ראשית, נניח שיש לנו משוואה ריבועית, <span class="math">\(ax^{2}+bx+c=0\)</span>. נוסחת השורשים נותנת לנו את הפתרון <span class="math">\(x_{1,2}=\frac{-b\pm\sqrt{b^{2}-4ac}}{2a}\)</span>. מה יש לנו כאן? כדי לחשב את הנוסחה צריך</p>
<ul> <li>להעלות את <span class="math">\(b\)</span> בריבוע (פעולת כפל)</li>


<li>לחשב את <span class="math">\(4ac\)</span> (שתי פעולות כפל)</li>


<li>לחשב את <span class="math">\(b^{2}-4ac\)</span> (פעולת חיסור)</li>


<li>לחשב את <span class="math">\(\sqrt{b^{2}-4ac}\)</span> (פעולת הוצאת שורש)</li>


<li>לחשב את <span class="math">\(\pm\sqrt{b^{2}-4ac}-b\)</span> (פעולת חיסור)</li>


<li>לחשב את <span class="math">\(2a\)</span> (פעולת כפל)</li>


<li>לחשב את <span class="math">\(\frac{-b\pm\sqrt{b^{2}-4ac}}{2a}\)</span> (פעולת חילוק)</li>

</ul>

<p>איך מודדים את הסיבוכיות של כל צעד? ובכן, זה כבר דורש סדרת פוסטים משל עצמה, נכון? בגדול, פעולות חיבור וחיסור עולות פחות מכפל וחילוק, אבל פעולה כמו חישוב של <span class="math">\(2a\)</span>? זה טריוויאלי לביצוע במחשב - זו הזזה של ביט אחד הצידה, אפשר לעשות את זה מהר מאוד. לכן אני לא רואה טעם למדוד את הסיבוכיות של כל הסיפור הזה מעבר לאמירה שיש כאן כמה פעולות כפל וחילוק ופעולת <strong>הוצאת שורש</strong> שהיא בכל מקרה הדבר הכבד פה.</p>
<p>המאמר, בהקדמה, מדבר בדיוק על זה: הוא מנסה להציג את פעולת הוצאת השורש בתור משהו בעייתי כל כך שהופך את כל החיפוש הזה אחרי נוסחה לפתרון משוואה בעזרת רדיקלים לקצת מטופש. ראשית, אין לנו דרך לחשב שורש במדויק, ממילא נקבל רק קירוב:</p>
<blockquote dir="ltr" class="quote-ltr">
Our modern quadratic formula involves a square root operation, which even in ancient times was known to generally not terminate, yielding only approximate solutions
</blockquote>

<p>שנית, כל הקטע הזה של נוסחה שיש בה פעולות מקוננות (פעולות שמבוצעות זו בתוך זו; למשל, במשוואה ממעלה שלישית בהחלט יש הוצאת שורש בתוך הוצאת שורש שלישי - אנחנו מקבלים משהו שנראה כמו <span class="math">\(\sqrt[3]{-\frac{27}{2}q+\frac{3}{2}\sqrt{-3D}}\)</span>) מפריע להם, לעומת סכום "פשוט יותר":</p>
<blockquote dir="ltr" class="quote-ltr">
After all, if we’re permitted nested unending nth root calculations, why not a simpler ongoing sum that actually solves polynomials beyond degree four
</blockquote>

<p>אני אישית חושב שהוצאת שורש היא דבר די פשוט. ראשית, מבחינה קונספטואלית: עם איבר כמו <span class="math">\(\sqrt{a}\)</span> אני יכול לעבוד בקלות, אלגברית: למשל, אני יודע ש-<span class="math">\(\left(3+\sqrt{a}\right)^{2}=9+6\sqrt{a}+a=\left(9+a\right)+6\sqrt{a}\)</span>. כלומר, אני יודע לבצע אלגברה עם ביטויים שמכילים שורשים ולקבל בחזרה ביטוי שהוא באותה רמת סיבוך - עדיין יש לו רק שורשים מאותה רמה. עם פתרון שנתון בנוסחת ההיפר-קטלן אני לא יודע אם אני יכול לעשות את זה באותה קלות - אבל זה דיון רחב מאוד שאני לא הולך להיכנס אליו וממילא לא תהיה בו הכרעה ברורה ולא צריכה להיות בו הכרעה ברורה כי חלק ממה שנחמד במתמטיקה הוא שיש שלל ייצוגים שונים לאותו דבר, וכל ייצוג מביא איתו נקודת מבט שונה שיכולה להיות שימושית לפעמים.</p>
<p>אז נתמקד בשאלה פשוטה יותר, מה שעניין את פותרי המשוואות האיטלקיים שמהם כל הטירוף הזה התפתח - מה יותר <strong>יעיל</strong>? מה מאפשר לי לחשב יותר בנוחות? ובשביל זה, אנחנו רואים שאנחנו צריכים להסביר איך מחשבים שורשים ביעילות, וזה מאפשר לי להציג את אחת משיטות הקירוב המוכרות והפופולריות ביותר, שתהיה רלוונטית גם לחישוב שורשים וגם לפתרון משוואות פולינומיות כלליות: <strong>שיטת ניוטון-רפסון</strong>.</p>
<p>השימושיות של ניוטון-רפסון חורגת מאשר "סתם" מציאת שורשים לפולינומים, ובהקשר של שורשים לפולינומים יש שיטות לשפר את היעילות שלה, אבל זה מצדיק פוסט בפני עצמו (שאין לי). כאן אני אסתפק בלהציג את השיטה בצורה הפשוטה ביותר שלה ונראה אם זה יספיק. הרעיון המרכזי בניוטון-רפסון הוא זה: אם נתונה לנו פונקציה <span class="math">\(f\left(x\right)\)</span> ואנחנו רוצים למצוא <span class="math">\(a\)</span> כך ש-<span class="math">\(f\left(a\right)=0\)</span>, בואו נגדיר <strong>סדרה</strong> של קירובים ל-<span class="math">\(a\)</span> הזו, שהולכת ומשתפרת. נתחיל עם קירוב כלשהו, <span class="math">\(a_{0}\)</span>, ואז נגדיר סדרה <span class="math">\(a_{n}\)</span> על ידי הכלל</p>
<p><span class="math">\(a_{n+1}=a_{n}-\frac{f\left(a_{n}\right)}{f^{\prime}\left(a_{n}\right)}\)</span></p>
<p>למה? מאיפה זה מגיע? <a href="https://gadial.net/2017/08/22/0x5f3759df_part_1/">בפוסט הזה</a> שלי אני מנסה (בפרק השלישי) לתת לזה אינטואיציה - לא אכנס לזה עכשיו שוב (אבל בהחלט צריך פוסט ייעודי על הנושא הזה!). במקום זה, בואו נראה איך זה עובד עבור הבעיה הפשוטה של חישוב שורש. במקרה הזה, נניח שאני רוצה לחשב את השורש <span class="math">\(\sqrt{D}\)</span> עבור מספר ממשי <span class="math">\(D\)</span> כלשהו. אני אגדיר פונקציה <span class="math">\(f\left(x\right)=x^{2}-D\)</span>, אז בבירור <span class="math">\(f\left(\sqrt{D}\right)=0\)</span> ולכן זו הפונקציה שאני רוצה להשתמש בה. חישוב הנגזרת של פונקציה כזו הוא טריוויאלי: <span class="math">\(f^{\prime}\left(x\right)=2x\)</span>, ולכן נקבל את הסדרה</p>
<p><span class="math">\(a_{n+1}=a_{n}-\frac{a_{n}^{2}-D}{2a_{n}}=\frac{2a_{n}^{2}-a_{n}^{2}+D}{2a_{n}}=\frac{a_{n}^{2}+D}{2a_{n}}=\frac{1}{2}\left(a_{n}+\frac{D}{a_{n}}\right)\)</span></p>
<p>אני מאוד אוהב את התוצאה הזו, כי הנוסחה <span class="math">\(a_{n+1}=\frac{1}{2}\left(a_{n}+\frac{D}{a_{n}}\right)\)</span> הייתה למעשה קיימת הרבה לפני ניוטון - זו שיטה שתוארה על ידי הרון מאלכסנדריה לפני 2,000 שנים בערך, ויש לה אינטואיציה גאומטרית יפהפיה: אם נסתכל על ריבוע ששטחו <span class="math">\(D\)</span>, אז אורך צלעו יהיה <span class="math">\(\sqrt{D}\)</span>. מה שהרון מציע הוא להתחיל עם <strong>מלבן</strong> שאורך אחת מצלעותיו הוא <span class="math">\(a_{0}\)</span> ושטחו <span class="math">\(D\)</span>, ואז אורך צלעו השניה תהיה <span class="math">\(\frac{D}{a_{n}}\)</span>. אנחנו רוצים שאורכי הצלעות ישתוו, אז אנחנו מחליפים את <span class="math">\(a_{n}\)</span> בממוצע בין <span class="math">\(a_{n}\)</span> והצלע השניה, ומקבלים סדרה שהולכת ומשתפרת של מלבנים שהופכים לקרובים יותר ויותר לריבוע.</p>
<p>כל איטרציה כוללת פעולת חילוק "קשה" אחת: החילוק <span class="math">\(\frac{D}{a_{n}}\)</span>. בנוסף יש פעולת חיבור ופעולת חילוק "קלה יותר", חילוק ב-2. זה לא כל כך הרבה!</p>
<p>הנה קוד שמריץ את זה ומקבל תוצאה שהיא מדויקת בכל ספרות הדיוק שהוא מציג:</p>
<div class="highlight"><pre><span></span><code><span class="n">D</span> <span class="o">=</span> <span class="mi">137</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">D</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">D</span><span class="o">/</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Newton&#39;s method: sqrt(</span><span class="si">{</span><span class="n">D</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">a</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>הקוד מבצע בסך הכל 10 איטרציות. לא רע! אבל האם אפשר להסתפק בפחות? אם תנסו להריץ, תראו שגם עבור <span class="math">\(N=8\)</span> מקבלים את אותה התוצאה, אבל לפני כן לא. אבל... האם באמת היינו צריכים להתחיל מ-<span class="math">\(D\)</span>? האם אין דרך טובה יותר לנחש ערך התחלתי? ובכן, יש שלל דרכים, הנה אחת פשוטה: נסתכל כמה ביטים נדרשים כדי לייצג את <span class="math">\(D\)</span> בזיכרון, ניקח רק חצי מהן ואז ניקח מספר שמיוצג על ידי כמות הביטים הזו - הוא יהיה בערך מסדר גודל כמו השורש של <span class="math">\(D\)</span>. הנה דרך פשוטה לעשות את זה בפייתון:</p>
<div class="highlight"><pre><span></span><code><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div>

<p>אם נשתמש בדרך הזו, מספר האיטרציות שצריך בשביל רמת הדיוק שלנו יקטן ל-<span class="math">\(N=4\)</span>. לא רע בכלל!</p>
<p>באופן כללי שאלת הקירוב ההתחלתי היעיל היא ממש מעניינת - כבר <a href="\%20[https://gadial.net/2017/08/22/0x5f3759df_part_1/\%7C\%7C\%D7\%91\%D7\%A4\%D7\%95\%D7\%A1\%D7\%98\%20\%D7\%94\%D7\%96\%D7\%94]">קישרתי פה אל פוסט</a> שאני מאוד אוהב שבעצם המהות שלו היא שיטה אחת כזו. מצד שני, אפשר לראות את זה בתור חיסרון של ניוטון-רפסון אל מול גישת "יש לי טור. תחברו איברים בטור. זהו" שלכאורה מציעה נוסחת קטלן. אבל האמנם...? כפי שאנחנו זוכרים, נוסחת קטלן פשוט <strong>לא עובדת</strong> לכל מני ערכים - מה שיוצא בפועל הוא שגם בה מתחבא היטב קונספט של "לבחור ערך התחלתי מתאים".</p>
<p>המאמר נוגע בזה ישירות בחלק 8 שלו, שמסתכל על המקרה של משוואה ממעלה שלישית ומדגים איך אפשר לקבל קירוב לפתרון באמצעות הנוסחה הכללית. הוא מתחיל מהמשוואה</p>
<p><span class="math">\(1-\alpha+t_{2}\alpha^{2}+t_{3}\alpha^{3}\)</span></p>
<p>ומציג במפורש את הפתרון הכללי שהוא מצא עבורה:</p>
<p><span class="math">\(\alpha=\sum_{m_{2}\ge0}\sum_{m_{3}\ge0}\frac{\left(2m_{2}+3m_{3}\right)!}{\left(1+m_{2}+2m_{3}\right)!m_{2}!m_{3}!}t_{2}^{m_{2}}t_{3}^{m_{3}}\)</span></p>
<p>עוד נחזור אל הנוסחה הכללית הזו, אבל לפני כן בואו נזרום עם המאמר. הוא מסתכל על משוואה ספציפית מאוד:</p>
<p><span class="math">\(f\left(x\right)=x^{3}-2x-5=0\)</span></p>
<p>שבה ג'ון וואליס השתמש כדי להדגים את שיטת ניוטון-רפסון. עכשיו, כדי לקבל קירוב לפתרון של המשוואה הזו המאמר לא לוקח את הסכום האינסופי, אלא רק את המונומים שלו שהם עד וכולל דרגה 3, מה שיוצא:</p>
<p><span class="math">\(Q\left(t_{2},t_{3}\right)=1+\left(t_{2}+t_{3}\right)+\left(2t_{2}^{2}+5t_{2}t_{3}+3t_{3}^{2}\right)+\left(5t_{2}^{3}+21t_{2}^{2}t_{3}+28t_{2}t_{3}^{2}+12t_{3}^{3}\right)\)</span></p>
<p>ועכשיו, כדי לפתור משוואה כללית <span class="math">\(c_{0}-c_{1}x+c_{2}x^{2}+c_{3}x^{3}=0\)</span>, הנוסחה שהמאמר מצא אומרת לנו לחשב את הביטוי שהם מסמנים ב-<span class="math">\(K\left(c_{0},c_{1},c_{2},c_{3}\right)\)</span> ומוגדר כך:</p>
<p><span class="math">\(K\left(c_{0},c_{1},c_{2},c_{3}\right)=\frac{c_{0}}{c_{1}}Q\left(\frac{c_{0}c_{2}}{c_{1}^{2}},\frac{c_{0}^{2}c_{3}}{c_{1}^{3}}\right)\)</span></p>
<p>והם מציבים בו את המקדמים של <span class="math">\(f\left(x\right)=x^{3}-2x-5\)</span>, כלומר מחשבים את <span class="math">\(K\left(-5,2,0,1\right)\)</span> ומקבלים... משהו שהוא בערך <span class="math">\(-999.082031\)</span>, מה שהם מכנים ``clearly a fail''. זו ההתייחסות הכי ישירה שראיתי במאמר לכך שבכלל רדיוס ההתכנסות (שבבירור לא מתקיים כאן) הוא רלוונטי.</p>
<p>אבל הכישלון הזה נותן להם את ההזדמנות להראות איך מתגברים על זה. הם אומרים ש-<span class="math">\(x=2\)</span> הוא קירוב ראשון סביר (לא אתווכח עם זה) אז במקום לפתור את הבעיה "איזה ערך צריך להציב ב-<span class="math">\(f\)</span> כדי לקבל 0" הם מנסים לפתור את הבעיה "כמה צריך לזוז מהערך <span class="math">\(x=2\)</span> כדי ש-<span class="math">\(f\)</span> יקבל 0" ואת זה עושים פורמלית על ידי הגדרת <span class="math">\(g\left(x\right)=f\left(2+x\right)=x^{3}+6x^{2}+10x-1\)</span> ואז חישוב של <span class="math">\(K\left(-1,-10,6,1\right)=0.0945345708\ldots\)</span> וזה יוצא קירוב נכון ב-4 הספרות הראשונות (הערך האמיתי הוא בערך <span class="math">\(2.0945514815423\ldots\)</span>).</p>
<p>אוקיי, מעניין. מה יש לניוטון-רפסון לומר בעניין הזה? הנוסחה של ניוטון-רפסון שמופעלת על <span class="math">\(f\left(x\right)=x^{3}-2x-5\)</span> נותנת את הסדרה</p>
<p><span class="math">\(a_{n+1}=a_{n}-\frac{f\left(a_{n}\right)}{f^{\prime}\left(a_{n}\right)}=a_{n}-\frac{a_{n}^{3}-2a_{n}-5}{3a_{n}^{2}-2}=\frac{2a_{n}^{3}+5}{3a_{n}^{2}-2}\)</span></p>
<p>בואו נרוץ על זה ישירות, החל מהקירוב <span class="math">\(a_{0}=2\)</span> שהם הציעו:</p>
<div class="highlight"><pre><span></span><code><span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Newton&#39;s method: </span><span class="si">{</span><span class="n">a</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>ארבע איטרציות מספיקות כאן כדי להגיע לכל ספרות הדיוק שאני מודד. כבר עבור <span class="math">\(N=2\)</span> מקבלים את רמת הדיוק שלהם ועוד טיפ טיפה יותר טוב (הספרה הבאה פחות שגויה). זה לא מקרי. ניוטון-רפסון מתכנס <strong>מהר</strong>, רק צריך קירוב התחלתי שקרוב מספיק לתוצאה.</p>
<p>עדיין, מאוד מעניין להשוות בין שני הדברים שקיבלנו פה. בניוטון-רפסון קיבלנו את הביטוי <span class="math">\(a_{n+1}=\frac{2a_{n}^{3}+5}{3a_{n}^{2}-2}\)</span>, שהוא <strong>איטרציה</strong> של <strong>פונקציה רציונלית</strong>. פונקציה רציונלית, נזכיר, היא פונקציה שהיא מנה של שני פולינומים, משהו מהצורה <span class="math">\(\frac{p\left(x\right)}{q\left(x\right)}\)</span>. לעומת זאת, ה-<span class="math">\(Q\left(t_{2},t_{3}\right)\)</span> שהמאמר השתמש בו הוא <strong>פולינום</strong> (בשני משתנים). אבל קצת קשה להשוות את שתי הסיטואציות, כי אחרי שמציבים ערכים מספריים ב-<span class="math">\(Q\)</span> הסיפור נגמר - מקבלים את הקירוב שרצינו - בעוד שב-<span class="math">\(a_{n+1}=\frac{2a_{n}^{3}+5}{3a_{n}^{2}-2}\)</span> חלק מהחישוב כבר בוצע בזה שהגעתי בכלל לפונקציה רציונלית יפה; מה שנשאר הוא החישובים של האיטרציה, שזה משהו שבכלל לא קיים בשיטה הקודמת. מצד שני, ראינו שהשיטה הקודמת <strong>נכשלת</strong> ודרשה בעצמה ביצוע של סוג של איטרציה - החלפה של <span class="math">\(x\)</span> ב-<span class="math">\(x+2\)</span>, מה שדורש חישוב משל עצמו. במילים אחרות - השוואה בין השיטות היא עסק רציני יותר ממה שהמאמר באמת מנסה להיכנס אליו, ואני מנחש בזהירות שאם היה לו שיפור משמעותי להציג ביחס לניוטון-רפסון הוא היה מרחיב על העניין הזה, כי זו באמת הייתה תוצאה מהממת.</p>
<p>אני יכול לעצור כאן, אבל האמת שמתחשק לי לעשות ניסוי משל עצמי, בלי שאני אדע מראש מה הולך לצאת. כמובן, גם זה לא יהיה ניסוי רציני - אני לא באמת מהתחום - אבל אני לא רוצה לעשות את זה בשביל השוואה רצינית אלא בשביל הכיף.</p>
<p>ראשית, בואו נכתוב קוד שיודע לעשות ניוטון-רפסון לכל משוואה פולינומית שהמקדמים שלה נתונים, במקום שאני אחשב דברים ידנית. משוואה כזו נראית כך:</p>
<p><span class="math">\(f\left(x\right)=c_{n}x^{n}+c_{n-1}x^{n-1}+\ldots+c_{0}\)</span></p>
<p>הנגזרת של זה קלה מאוד לחישוב:</p>
<p><span class="math">\(f^{\prime}\left(x\right)=nc_{n}x^{n-1}+\left(n-1\right)c_{n-1}x^{n-2}+\ldots+c_{1}\)</span></p>
<p>עכשיו, <span class="math">\(x-\frac{f\left(x\right)}{f^{\prime}\left(x\right)}\)</span> דורש לכפול את <span class="math">\(x\)</span> במכנה ולחסר מזה את המונה. גם את זה קל לעשות ידנית, כי</p>
<p><span class="math">\(xf^{\prime}\left(x\right)=nc_{n}x^{n}+\left(n-1\right)c_{n-1}x^{n-1}+\ldots+c_{1}x\)</span></p>
<p>ולכן נקבל</p>
<p><span class="math">\(x-\frac{f\left(x\right)}{f^{\prime}\left(x\right)}=\frac{\left(n-1\right)c_{n}x^{n}+\left(n-2\right)c_{n-1}x^{n-1}+\ldots+c_{2}x^{2}-c_{0}}{nc_{n}x^{n-1}+\left(n-1\right)c_{n-1}x^{n-2}+\ldots+c_{1}}\)</span></p>
<p>הנה קוד שעושה את זה:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">newton</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)]</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">f_x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">numerator</span><span class="p">))</span>
        <span class="n">f_prime_x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">denominator</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">f_prime_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Derivative is zero&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">f_x</span> <span class="o">/</span> <span class="n">f_prime_x</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div>

<p>אל מול הקוד הזה אני רוצה להעמיד קוד שמדמה את מה שהמאמר עושה עם מספרי היפר-קטלן: בהינתן פולינום <span class="math">\(f\left(x\right)\)</span> ממעלה <span class="math">\(k\)</span> שמנסים למצוא לו שורש, מייצרים את הפולינום מרובה המשתנים <span class="math">\(Q\left(t_{2},t_{3},\ldots,t_{k}\right)\)</span>. בהינתן קירוב התחלתי <span class="math">\(x_{0}\)</span> לשורש שאנחנו מנסים למצוא, מחשבים את <span class="math">\(g\left(x\right)=f\left(x+x_{0}\right)=c_{0}-c_{1}x+c_{2}x^{2}+\ldots+c_{k}x^{k}\)</span> ואז מחשבים את <span class="math">\(\frac{c_{0}}{c_{1}}Q\left(\frac{c_{0}c_{2}}{c_{1}^{2}},\frac{c_{0}^{2}c_{3}}{c_{1}^{3}},\ldots,\frac{c_{0}^{k-1}c_{k}}{c_{1}^{k}}\right)\)</span>.</p>
<p>בשביל לחשב את <span class="math">\(Q\)</span> צריך לדעת לחשב את מספרי היפר-קטלן, <span class="math">\(C_{\mathbf{m}}=\frac{\left(2m_{2}+3m_{3}+4m_{4}+\ldots\right)!}{\left(1+m_{2}+2m_{3}+3m_{4}+\ldots\right)!m_{2}!m_{3}!m_{4}!\cdots}\)</span>. חישוב של זה הוא קצת כאב ראש בצורה ישירה כי יש לנו המון מספרים עם עצרת, אז נקבל מנה של שני מספרי ענק וזה ייצא לא מדויק. למרבה השמחה, אפשר לרתום <strong>לוגריתמים</strong> לעזרתנו. כפי שהסברתי <a href="https://gadial.net/2020/06/08/what_are_logarithms/">בפוסט שלי</a> על לוגריתמים, הם הומצאו כדי לעזור לנו לחשב מכפלות ומנות של מספרים גדולים, והם עדיין משמשים טוב לזה. אם אני אפעיל <span class="math">\(\ln\)</span> על שני האגפים, אני אקבל</p>
<p><span class="math">\(\ln C_{\mathbf{m}}=\ln\left(\left(2m_{2}+3m_{3}+4m_{4}+\ldots\right)!\right)-\ln\left(\left(1+m_{2}+2m_{3}+3m_{4}+\ldots\right)!\right)-\sum_{k=2}\ln\left(m_{k}!\right)\)</span></p>
<p>לוגריתם של עצרת הוא כלי כל כך שימושי בחישובים, שספריות מתמטיות סטנדרטיות לרוב מציעות אותו כפונקציה בסיסית. ליתר דיוק, לוגריתם של מה שנקרא <strong>פונקציית גמא</strong>, <span class="math">\(\Gamma\)</span>, שהיא פונקציה שמקיימת <span class="math">\(\Gamma\left(n+1\right)=n!\)</span>, ובנוסף לכך יש לה שלל תכונות נחמדות שלא ניכנס אליהן כאן. השורה התחתונה היא שהקוד הזה מחשב את <span class="math">\(C_{\mathbf{m}}\)</span> בצורה מדויקת ויעילה, תוך התבססות על כך שהוא צריך לצאת מספר טבעי ולכן אפשר להסתמך על חישוב שהוא טיפה לא מדויק ואז לעגל:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">hyperC</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">m_i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="n">B</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m_i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>

    <span class="n">log_numerator</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">lgamma</span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">log_denominator</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">lgamma</span><span class="p">(</span><span class="n">B</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">lgamma</span><span class="p">(</span><span class="n">m_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_numerator</span> <span class="o">-</span> <span class="n">log_denominator</span><span class="p">))</span>
</code></pre></div>

<p>עם הקוד הזה וספריית האלגברה הסימבולית sympy אפשר לייצר את <span class="math">\(Q\)</span>. הפרמטרים שלנו הם <span class="math">\(N\)</span> שהוא הסכום המקסימלי של אברי <span class="math">\(\mathbf{m}\)</span> (בדוגמה שלהם, <span class="math">\(N=3\)</span>) ו-<span class="math">\(k\)</span> שהוא המימד של <span class="math">\(\mathbf{m}\)</span>, כלומר כמה משתנים יש שם. ראשית אני מגדיר פונקציה רקורסיבית, partitions, שעוברת על כל הדרכים לחלק את המספר <span class="math">\(N\)</span> לסכום של <span class="math">\(k\)</span> מספרים טבעיים:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">partitions</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">N</span><span class="p">]]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>

<p>עכשיו אפשר להשתמש בה כדי לייצר את הפולינום:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Add</span>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_polynomial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;t2:</span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">monomials</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">hyperC</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">coeff</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m_i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">term</span> <span class="o">*=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="n">m_i</span>
            <span class="n">monomials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">monomials</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F</span>
</code></pre></div>

<p>כל החישובים הללו "לא נחשבים" מבחינתי כשבאים למצוא פתרון למשוואה ספציפית, כי אפשר לעשות אותם באופן חד פעמי מראש - הרי <span class="math">\(Q\)</span> לא תלוי במשוואה ספציפית, רק במספר המשתנים ובשאלה כמה <span class="math">\(N\)</span> שלנו יהיה גדול (ככל ש-<span class="math">\(N\)</span> גדול יותר הקירוב יהיה טוב יותר אבל נצטרך לסכום <span class="math">\(\Theta\left(N^{k}\right)\)</span> איברים).</p>
<p>לסיום, אני צריך דרך כלשהי לבצע את שינוי המקדמים <span class="math">\(g\left(x\right)=f\left(x+a\right)\)</span>. כאן אני יכול להשתמש <strong>בבינום של ניוטון</strong>, באופן הבא: אם <span class="math">\(f\left(x\right)=\sum_{k=0}^{n}a_{k}x^{k}\)</span> אז </p>
<p><span class="math">\(f\left(x+a\right)=\sum_{k=0}^{n}a_{k}\left(x+a\right)^{k}=\sum_{k=0}^{n}a_{k}\sum_{i=0}^{k}{k \choose i}x^{i}a^{k-i}\)</span></p>
<p>אפשר לשנות את סדר הסכימה כדי לאגד לכל <span class="math">\(x^{i}\)</span> את כל המקדמים שלו:</p>
<p><span class="math">\(=\sum_{i=0}^{n}\left(\sum_{k=i}^{n}a_{k}{k \choose i}a^{k-i}\right)x^{i}\)</span></p>
<p>כלומר, נגדיר</p>
<p><span class="math">\(b_{i}=\sum_{k=i}^{n}a_{k}{k \choose i}a^{k-i}\)</span></p>
<p>ונקבל ש-<span class="math">\(g\left(x\right)=f\left(x+a\right)=\sum_{i=0}^{n}b_{i}x^{i}\)</span></p>
<p>הנה קוד שעושה את החישוב הזה:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">shift_polynomial</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
    <span class="n">shifted</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">shifted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">shifted</span>
</code></pre></div>

<p>ועכשיו אפשר לכתוב את הקוד שמשתמש בנוסחה של המאמר כדי לפתור משוואה ממעלה כלשהי:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">catalan</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">shift_polynomial</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;t2:</span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">generate_polynomial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">subs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">c0</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">c1</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))}</span>
    <span class="k">return</span> <span class="n">x0</span> <span class="o">+</span> <span class="p">(</span><span class="n">c0</span><span class="o">/</span><span class="n">c1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs_dict</span><span class="p">)</span>
</code></pre></div>

<p>הייתי יכול גם לוותר לגמרי על השימוש ב-sympy אבל אני דווקא אוהב את זה שאפשר להשיג את הפולינום בצורה סימבולית ולשחק איתו.</p>
<p>ועכשיו, אפשר לעשות בדיקה חפיפניקית כדי לראות מי מצליח יותר - ניוטון או קטלן?</p>
<p>הנה קוד לדוגמא שעושה בדיקה כזו:</p>
<div class="highlight"><pre><span></span><code><span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">catalan</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Catalan method result: </span><span class="si">{</span><span class="n">result</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Newton method result: </span><span class="si">{</span><span class="n">result</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>יש כאן בבירור השוואה בין תפוזים ותפוחים - אני משתמש באותו <span class="math">\(N\)</span> בתור "פרמטר הקירוב" גם עבור ניוטון וגם עבור קטלן, אבל בשיטת ניוטון <span class="math">\(N\)</span> הוא בסך הכל מספר האיטרציות שמבצעים, ובשיטה של המאמר <span class="math">\(N\)</span> הוא חסם על גודל סכום האיברים ב-<span class="math">\(\mathbf{m}\)</span>. כלומר, בעוד שהגדלת <span class="math">\(N\)</span> ב-1 אצל ניוטון פשוט מוסיפה עוד איטרציה אחת, שרמת הסיבוכיות שלה דומה לקודמותיה, בשיטת קטלן ההגדלה הזו מוסיפה <span class="math">\(\Theta\left(N^{k-1}\right)\)</span> איברים לסכום. במילים אחרות, השימוש ב-<span class="math">\(N\)</span> בצורה כזו <strong>עוזר</strong> לקטלן כי הוא מאפשר לו להגדיל את מספר הצעדים שהוא מבצע הרבה יותר מאשר ניוטון.</p>
<p>זה לא מפריע לי.</p>
<p>כשמריצים את הקוד למעלה, עם הפרמטרים <span class="math">\(x_{0}=2\)</span> ו-<span class="math">\(N=5\)</span>, מקבלים עבור ניוטון את התוצאה <span class="math">\(2.0945514815\)</span> (שהיא מדויקת בכל הספרות) ועבור קטלן את <span class="math">\(2.0945508795\)</span> (שהיא עדיין די מדויקת אבל רק עד ה-55). לרמת הדיוק של ניוטון קטלן הגיע ב-<span class="math">\(N=13\)</span>; בשלב הזה ניוטון כבר מקבל <span class="math">\(2.0945514815423269539\)</span> (המאמר נוקב ב-<span class="math">\(2.0945514815423265915\)</span> בתור הקירוב של 19 הספרות הראשונות). בקיצור, על הדוגמא שלהם קטלן לא באמת נותן תחרות לניוטון.</p>
<p>אם אני מתחיל מקירוב יותר נאיבי, <span class="math">\(x_{0}=0\)</span>, אז ניוטון צריך שאבקש <span class="math">\(N=19\)</span> כדי לקבל את הקירוב של 10 הספרות שראינו קודם (כמובן, בעולם האמיתי לא צריך להגיד לניוטון כמה איטרציות לעשות; מבקשים ממנו לעצור אחרי שהוא רואה שהפעלת איטרציה קיבעה את 10 הספרות הראשונות) אבל קטלן, כמו שהבטיחו במאמר, נכשל לגמרי ונותן <span class="math">\(-108653171492152000000000\)</span>. אם תשאלו אותי, זה יתרון גדול של ניוטון; אפילו אם אגדיר <span class="math">\(x_{0}=-1000000000000\)</span>, עבור <span class="math">\(N=100\)</span> אקבל את אותו קירוב לפתרון. כשהפונקציה שמנסים לטפל בה היא נחמדה (ופולינום היא פונקציה נחמדה), ניוטון זה כמו מגנט שנדבק בכוח אל הפתרון די מהר. השיטה של המאמר פשוט לא יודעת לעשות את זה - היא תלויה הרבה יותר בכך שנמצא לה קירוב ראשוני מתאים.</p>
<p>אז הרושם הראשוני שהשיטה במאמר לא יודעת לטפל ב"כל" משוואה אלא רק במשוואות שהפרמטרים שלהן נופלות תחת רדיוס ההתכנסות של הטור הרלוונטי - הרושם הזה <strong>שגוי</strong>, בהחלט אפשר ליצור אלגוריתם טוב שמטפל בכל משוואה (כמעט... לא התייחסתי למקרה של <span class="math">\(c_{1}=0\)</span>) <strong>אבל</strong> האלגוריתם הזה יהיה <strong>רגיש לתנאי ההתחלה</strong>, הרבה יותר מאשר ניוטון רגיש. וזה קצת נשמע מוזר כי אם רק מסתכלים על הכותרת של המאמר לא ברור בכלל שיש צורך שיהיו "תנאי התחלה" שכאלו.</p>
<p>איך אפשר לעשות עוד מבחנים כאלו? ובכן, הכי טוב לייצר פולינום אקראי, אז הנה קוד שעושה את זה ומריץ "מבחן" עליו:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="k">def</span><span class="w"> </span><span class="nf">random_coefficients</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="n">random_coefficients</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">1.4</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">catalan</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Catalan method result: </span><span class="si">{</span><span class="n">result</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Newton&#39;s method result: </span><span class="si">{</span><span class="n">result</span><span class="si">:</span><span class="s2">.10f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>במקרה הנוכחי בחרתי פולינום ממעלה 10 וקיבלתי את המקדמים <span class="math">\([10,-7,-10,-2,-3,-3,-6,-7,7,-8,8]\)</span>. אחר כך הרצתי ניוטון בצד עם המון איטרציות כדי לדעת מה הערך ה"נכון" שאנחנו מחפשים, וראיתי שהוא קרוב ל-<span class="math">\(1.4\)</span> והזנתי את זה לקטלן. למה <span class="math">\(N=5\)</span> ולא משהו גדול יותר? כי בשלב הזה, מכיוון שהפולינום הוא ממעלה גבוהה אז ה-<span class="math">\(k\)</span> שבחזקה שלו מעלים את <span class="math">\(N\)</span> הוא די גבוה, ולכן זמן הריצה כבר מורגש - לקוד הזה לקחו יותר מ-15 שניות לרוץ, למרות שניוטון מסיים מייד. אחרי הריצה הזו ניוטון השיג <span class="math">\(1.4042602427\)</span> (זו התוצאה הנכונה, במסגרת ספרות הדיוק) וקטלן השיג <span class="math">\(1.4042602426\)</span>, שזה... יפה מאוד! כמעט אותו דבר! אבל כמובן, זה בזכות קירוב התחלתי טוב; אם אני מתחיל מ-<span class="math">\(x_{0}=2\)</span> קטלן <strong>טיפה</strong> פחות מצליח, ומקבל <span class="math">\(1.6666226398\)</span> לעומת ה-<span class="math">\(1.4187182359\)</span> של ניוטון. עבור ערכים גדולים יותר של <span class="math">\(x_{0}\)</span> קטלן מחזיר תוצאות פחות מדויקות אבל לא מתחרבש לגמרי אפילו עבור <span class="math">\(x_{0}=100\)</span>. זה לא כל כך מפתיע; כשמבצעים את ההזזה <span class="math">\(g\left(x\right)=f\left(x+a\right)\)</span> זה מנפח מאוד את המקדמים הקטנים ופחות את הגדולים. ואז מציבים ערך מהצורה <span class="math">\(\frac{c_{0}^{i-1}c_{i}}{c_{1}^{i}}\)</span> בפולינום. מה שקורה הוא ש-<span class="math">\(c_{0}^{i-1}\)</span>מבטל "בערך" את ה-<span class="math">\(c_{1}^{i-1}\)</span> שבמכנה ומשאיר <span class="math">\(\frac{c_{i}}{c_{1}}\)</span>, ואם <span class="math">\(c_{1}\)</span> גדול מאוד ביחס ל-<span class="math">\(c_{i}\)</span> נקבל מספר קטן - כלומר, המספרים שנציב יהיו בסיכוי טוב בתוך רדיוס ההתכנסות. לכן דווקא הניחוש ההתחלתי <span class="math">\(x_{0}=0\)</span>, למרות שהוא קרוב הרבה יותר לתוצאה האמיתית מאשר <span class="math">\(x_{0}=100\)</span>, הולך להוביל לקטסטרופה. העניין הוא שעבור <span class="math">\(x_{0}=100\)</span> אמנם לא נקבל קטסטרופה אלא תוצאה שהיא הגיונית, אבל היא לא קירוב טוב במיוחד (מקבלים <span class="math">\(80.6474783702\)</span> עבור <span class="math">\(N=5\)</span>).</p>
<p>אז לסיכום - אם מה שמעניין אותנו הוא <strong>לחשב</strong> את הפתרונות של משוואה פולינומית, עבור איזו רמת דיוק שנרצה, הרושם שאני מקבל הוא שניוטון-רפסון היא שיטה הרבה יותר יעילה ומתאימה. כמובן, המאמר בשום מקום לא טוען אחרת. לכן אולי הגיע הזמן לדבר על מה שנאמר <strong>מחוץ</strong> למאמר, ובזה נסיים.</p>
<h2>בואו נתלונן על הצגה לא נאמנה של המתמטיקה בתקשורת, כי זה כבר מזמן לא קרה</h2>

<p>בראשית ימי הבלוג חשבתי שאחד מהדברים המרכזיים שאעשה בו הוא להתלונן על כל מני הצגות שגויות של המתמטיקה בתקשורת, כי זה כיף וזה נותן תירוץ לדבר על דברים מתמטיים מגניבים. אחר כך הבנתי שאני יכול לדבר על דברים מתמטיים מגניבים בלי תירוצים ושזה בדרך כלל עדיף להציג דברים מגישה חיובית ולא לפתוח ב"אההה הצילו כל מה שכתוב בעיתון הזה לא נכון". אז אני כבר כמעט ולא עושה את זה (ובימינו יש רשתות חברתיות שיותר מתאימות לתלונות כאלו) אבל עדיין, בואו ננסה לראות מה היו חלק מהכותרות המפוצצות שגרמו לי לשים לב למאמר מלכתחילה ונבין מה עומד מאחוריהן (ולפני התלונות, שימו לב למובן מאליו - <strong>בלי</strong> הכותרות המפוצצות לא הייתי קורא את המאמר, שהוא כאמור די מגניב).</p>
<p>נתחיל מהכותרת הראשונה שבה נתקלתי: Mathematician solves algebra’s oldest problem using intriguing new number sequences. היא מגיעה מהפרסום <a href="https://www.unsw.edu.au/newsroom/news/2025/05/mathematician-solves-algebras-oldest-problem-using-intriguing-new-number-sequences">כאן</a>, שהוא לא כתבה עיתונאית אלא פרסום של האוניברסיטה עצמה. ככזה, הוא יחסית מדויק. עדיין, יש דבר או שניים שמרגיזים אותי.</p>
<p>למשל, הם כותבים שם ש- </p>
<blockquote dir="ltr" class="quote-ltr">
A general method for solving ‘higher order’ polynomial equations, where x is raised to the power of five or higher, has historically proven elusive.
</blockquote>

<blockquote dir="ltr" class="quote-ltr">
Now, UNSW Honorary Professor Norman Wildberger has revealed a new approach using novel number sequences, outlined in a recent publication with computer scientist Dr. Dean Rubine.
</blockquote>

<p>מה שמקפיץ אותי הוא ה-novel number sequences - הרי מספרי ההיפר-קטלן הם לא חדשים; המאמר מצטט ספרות יפה שעוסקת בהם עוד מהמאה ה-19. החידוש במאמר הוא להסתכל על הפונקציה היוצרת שלהם ולהגיד - היי, תראו, זה סוג של נותן פתרון של משוואה.</p>
<p>הדבר שיותר מרגיז אותי מגיע אחרי התיאור של גלואה וההוכחה לאי הפתירות על ידי רדיקלים של משוואות ממעלה חמישית ומעלה:</p>
<blockquote dir="ltr" class="quote-ltr">
Approximate solutions for higher-degree polynomials have since been developed and are widely used in applications but, Prof. Wildberger says, these don’t belong to pure algebra.
</blockquote>

<p>ראשית, יש פה טעות היסטורית - זה לא שפתרונות מקורבים פותחו <strong>אחר כך</strong>, הם היו ידועים <strong>קודם</strong>. המאמר עצמו מזכיר את זה במפורש - הוא מדבר על איך שוואליס (במאה ה-17!) השתמש בשיטת ניוטון כדי למצוא את הפתרון של פולינום מסויים (למעשה, שיטת ניוטון עברה שלל גלגולים לאורך השנים אבל כבר בגרסה הגולמית שלה אצל ניוטון היא שימשה לפתרון משוואות פולינומיות).</p>
<p>שנית, מה בכלל המשמעות של "pure algebra" כאן? בסופו של דבר, הדרך לקבל פתרון קונקרטי למשוואה בשיטה של המאמר היא להציב מספרים בתור טור אינסופי ולקוות שיתכנס. זה לגמרי פתרון אנליטי. לכן אני משער שב"אלגברה טהורה" הכוונה למה שראינו בפוסט הקודם - לכך שכדי להגדיר שוויון <strong>ברמת הפונקציות היוצרות</strong> לא צריך בכלל חשבון דיפרנציאלי ואינטגרלי. זו הנקודה שהמאמר אכן מקפיד עליה - לומר שהפתרון הוא "כטור חזקות פורמלי" אבל כבר אמרתי שאני לא מבין איך זה בעצם פתרון - כי בטור חזקות פורמלי מה שמעניין אותנו הוא לקודד <strong>את המקדמים</strong> של הטור, ואילו כאן הטור לכאורה מקודד מספר שמתקבל <strong>על ידי הצבה</strong>.</p>
<p>עניין אחר שמוזכר שם הוא שהכותב מתאר את עצמו כ"לא מאמין במספרים אי רציונליים" ועל זה אני אומר... אוקיי, עזבו. מילא לא היה מאמין באינסוף, את זה הייתי מבין - אבל די התבססת כאן על טורים אינסופיים, פורמליים או לא.</p>
<p>הלאה, בואו נעבור למאמר עם הכותרת "The Oldest Algebra Problem Solved”: Australian Mathematician Cracks Ancient Mystery That Baffled Minds for Over 4,000 Years" שאפשר לראות <a href="https://www.sustainability-times.com/research/the-oldest-algebra-problem-solved-australian-mathematician-cracks-ancient-mystery-that-baffled-minds-for-over-4000-years/">כאן</a>. המאמר נפתח בסתם בלבול תמים שגורם לו לחשוב שנוסחת השורשים (הנוסחה לפתרון משוואה ממעלה שניה) היא מה שנותן לנו את הפתרון למשוואות ממעלה שלישית ורביעית (הו לא, כל כך לא). מה שבאמת מרגיז אותי פה הוא שהמאמר כותב ש"בדיקות על משוואה מפורסמת ממעלה שלישית בה השתמש וואליס במאה ה-17 הדגימו את יעילות השיטה" - אבל הם לא אומרים <strong>איך</strong> וואליס השתמש במשוואה הזו; כזכור, הוא השתמש בה כדי להדגים את שיטת ניוטון - השיטה שמניבה למשוואה הזו פתרונות <strong>טובים יותר</strong>. יותר מזה, המאמר עובר להתלונן על כך שעד כה היו רק פתרונות <strong>מקורבים</strong> שלא שייכים לאלגברה "טהורה" אבל השיטה החדשה היא "יותר מדויקת".</p>
<p>במילים אחרות, לכותבים אין שמץ של מושג מה בעצם קורה כאן. הם לא מבינים שיש פה טריידאוף: או שאתה אלגברי "טהור" אבל לא תוכל לקבל ערך מספרי לפתרונות, בכלל; או שאתה לא אלגברי טהור, ואתה יכול לקבל ליד פתרונות מקורבים, אבל אז השיטה שלך פחות טובה מהקיימות. לצערי, אני מרגיש שיש למאמר חלק בזה - אין בו הבהרה של ממש מה בעצם <strong>המשמעות</strong> של זה שהפתרון נתון בעזרת פונקציות יוצרות.</p>
<p>מה עם "200-year-old "algebra wall" shattered with a bold new approach" שנמצא <a href="https://newatlas.com/science/algebras-oldest-problem/">כאן</a>? יש בו פסקה מעצבנת במיוחד: </p>
<blockquote dir="ltr" class="quote-ltr">Mathematician Norman Wildberger, an Honorary Professor at Australia's University of New South Wales, and computer scientist Dean Rubine have thrown out the rulebook and presented a new way to solve polynomial equations that go beyond x to the power of four -- something that has only been resolved with "approximate solutions." While this won't mean a whole lot to school students in math class, accuracy in answering higher-order polynomial problems could have huge implications in the fields of science and technology.
</blockquote>

<p>הפסקה הזו מראה נפילה מוחלטת להטעיה של יחסי הציבור - בזה שהפתרונות הקודמים נפסלים בתור "פתרונות מקורבים" איכשהו נוצר הרושם שהפתרון החדש "מדויק יותר" והרי אנחנו יודעים שהדיוק חשוב כשאנחנו מנסים להנחית חללית על מאדים! אבל שוב - הדיוק של השיטה החדשה <strong>פחות גדול</strong> מאשר אצל ניוטון. המובן היחיד שבו היא "מדויקת" היא בדיוק המובן שבו אין לנו דרך לקבל את הפתרון בצורה מפורשת.</p>
<p>וזה נמשך:</p>
<blockquote dir="ltr" class="quote-ltr">
“One of the equations we tested was a famous cubic equation used by Wallis in the 17th century to demonstrate Newton's method," Wildberger explained. "Our solution worked beautifully." 
</blockquote>

<p>כאן הם ליטרלי מזכירים את ניוטון - ועדיין לא מתייחסים למשמעות של זה. נכון, הפתרון שלהם עובד בצורה יפהפיה ברגע שבוחרים קירוב התחלתי טוב מספיק; אבל השיטה של ניוטון עובדת בצורה עוד יותר יפהפיה. במובן הספציפי הזה, הבעיה כבר הייתה פתורה מאות שנים.</p>
<p>ולסיום, המאמר מנסה להצדיק את הכותרת שלו: </p>
<blockquote dir="ltr" class="quote-ltr">
If you're still with me, this new method solves for equations that can't generally be resolved using traditional methods, like using root-taking approaches. In this sense, it breaks through a centuries-old mathematical wall. The novel approach removes the limitations presented by the kind of simple finite formula we were taught at school.
</blockquote>

<p>הבעיה פה היא שאנשים פשוט לא מבינים מהן השיטות המסורתיות, ולמה ביחס אליהן זו בעיה פתורה. אז הם מדמיינים שיש פה חומה שצריך לשבור.</p>
<p>ומה עם "Researchers Solve “Impossible” Math Problem After 200 Years"? טוב, זה כמעט מועתק מילה במילה מהקומוניקט של האוניברסיטה, אז אין טעם להתעסק גם בו - אבל זה ממחיש את העניין. כל המאמרים הללו נכתבו על ידי אנשים שדי בבירור לא מבינים את הנושא ופשוט מתבססים על מה שהאוניברסיטה סיפרה להם, והאוניברסיטה סיפרה להם את האמת... אבל לא את כל האמת. זה הטריק הכי ישן בספר, כמובן.</p>
<p>אני רוצה להדגיש את מה שפתחתי איתו: זה מאמר נחמד. מה שהוא עושה, למרות שהוא לא מורכב במיוחד, הוא יפה. אבל כל ההצגה הבומבסטית שיש מאחוריו נראית לי לא קשורה לשום דבר. אם מאמר באמת הצליח לפרוץ דרך שנראתה בלתי אפשרית, הדבר הראשון שהייתי מצפה לראות הוא איך השיטה החדשה פותרת בעיות שמעולם לא נפתרו. וזה... לא קורה.</p>
<p>אבל היי, סוף סוף הייתה לי מוטיבציה לכתוב על מספרי קטלן בבלוג, אז אני אסיר תודה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>