<!DOCTYPE html>
<html lang="he" dir="rtl"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>תורת הקבוצות - מחלקות, אקסיומת ההחלפה ואינדוקציה ורקורסיה על-סופיות | לא מדויק</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="תורת הקבוצות - מחלקות, אקסיומת ההחלפה ואינדוקציה ורקורסיה על-סופיות" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
<meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
<link rel="canonical" href="http://gadial.net/2023/01/18/classes_and_transfinite/" />
<meta property="og:url" content="http://gadial.net/2023/01/18/classes_and_transfinite/" />
<meta property="og:site_name" content="לא מדויק" />
<meta property="og:image" content="http://gadial.net/assets/img/main/set_theory.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-01-18T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="http://gadial.net/assets/img/main/set_theory.png" />
<meta property="twitter:title" content="תורת הקבוצות - מחלקות, אקסיומת ההחלפה ואינדוקציה ורקורסיה על-סופיות" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
{"url":"http://gadial.net/2023/01/18/classes_and_transfinite/","@type":"BlogPosting","description":"לא מדויק - בלוג על מתמטיקה ומדעי המחשב","headline":"תורת הקבוצות - מחלקות, אקסיומת ההחלפה ואינדוקציה ורקורסיה על-סופיות","dateModified":"2023-01-18T00:00:00+00:00","datePublished":"2023-01-18T00:00:00+00:00","image":"http://gadial.net/assets/img/main/set_theory.png","mainEntityOfPage":{"@type":"WebPage","@id":"http://gadial.net/2023/01/18/classes_and_transfinite/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/favicon.ico" type="image/x-icon"><link type="application/atom+xml" rel="alternate" href="http://gadial.net/feed.xml" title="לא מדויק" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-3924539-2', 'auto');
  ga('send', 'pageview');
}
</script>
  
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        processEscapes: true
      },
      TeX: {extensions: ["AMSmath.js","AMSsymbols.js"]},
      "HTML-CSS": { 
        linebreaks: { automatic: true }
      },
      SVG: { 
        linebreaks: { automatic: true } 
      }
    });
  </script>
  <!-- "https://www.gadial.net/wp-includes/js/xypic.js" -->

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

</head>
<body><header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <a class="navbar-brand" href="/">לא מדויק</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarCollapse">
      <ul class="navbar-nav mr-auto">
        
            
            <li class="nav-item">
                <a class="nav-link" href="/lecture_notes">סיכומי הרצאות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/">דף הבית</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/categories">קטגוריות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/random">דף אקראי</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">אודות</a>
            </li>
            
        
      </ul>
      <form class="form-inline mt-2 mt-md-0" action="/post_list/" method="get">
        <input class="form-control mr-sm-2" type="text" placeholder="חיפוש" aria-label="חיפוש" name="s">
        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">חיפוש</button>
      </form>
    </div>
  </nav>
</header><main class="page-content" aria-label="Content" role="main">
      <div class="wrapper text-right">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><div class="PageNavigation">
    
      <a class="prev" href="/2023/01/14/ordinal_arithmetic/">&laquo; תורת הקבוצות - אריתמטיקה של סודרים</a>
    
    
      <a class="next" href="/2023/01/24/cardinals/">תורת הקבוצות - עוצמות &raquo;</a>
    
  </div><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">תורת הקבוצות - מחלקות, אקסיומת ההחלפה ואינדוקציה ורקורסיה על-סופיות</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-01-18T00:00:00+00:00" itemprop="datePublished">Jan 18, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2>מה זו מחלקה ולמה זו לא רמאות</h2>

<p><a href="https://gadial.net/2023/01/14/ordinal_arithmetic/">בפוסט הקודם</a> הצגתי את ההגדרות לאריתמטיקה של סודרים. הכל היה (בתקווה) די פשוט ואינטואיטיבי, אבל הזהרתי שאני לא פורמלי עד הסוף, כי ההגדרה שלי הייתה רקורסיבית ולא נתתי עדיין נימוק למה “מותר” להשתמש בהגדרות כאלו. בפוסט הזה אני רוצה לדבר על הגדרות רקורסיביות, ועל הוכחות באינדוקציה שדרושות בשבילן ובשביל שלל דברים נוספים, בהקשר של הסודרים. בהקשר הזה קוראים להן “אינדוקציה על-סופית” ו”רקורסיה על-סופית” (Transfinite באנגלית). אלא שאי אפשר לדבר על הדברים הללו בלי להגיע סוף סוף לעניין קצת מלוכלך שטאטאתי עד כה מתחת לשטיח כי העדפתי לא להסביר בלי דוגמא צמודה, והגענו בדיוק אל הדוגמא הזו. המשהו המלוכלך זה מה שנקרא <strong>מחלקות</strong>, ובשמיעה ראשונה עליו יכול להישמע כמו רמאות גדולה במיוחד, ודי קריטי שנבין למה זו לא רמאות לפני שנמשיך.</p>

<p>כבר <a href="https://gadial.net/2019/10/19/what_is_set_theory/">כשהתחלתי לדבר</a> על תורת הקבוצות הצגתי את <strong>הפרדוקס של ראסל</strong>. הפרדוקס הזה מלמד אותנו שאי אפשר סתם לקרוא בשם “קבוצה” לכל אוסף של איברים; אינטואיטיבית, יש אוספים שהם גדולים מדי מכדי להיחשב קבוצות, וההנחה שהן קבוצות מובילה לפרדוקסים. כפועל יוצא מכך הגיעו אקסיומות צרמלו-פרנקל שמדברות בדיוק על איך נראות קבוצות ואיך אפשר לבנות אותן זו מזו.</p>

<p>עכשיו, בואו נסתכל על אוסף כל הסודרים, שאני מכנה <span>\( \text{Ord} \)</span>. האם הוא קבוצה? ובכן, ראינו בפוסט מוקדם יותר שאם יש לנו קבוצה <span>\( A \)</span> של סודרים, גם <span>\( \bigcup A \)</span> היא סודר. כלומר, גם <span>\( \bigcup\text{Ord} \)</span> צריך להיות סודר. אבל אם הוא סודר, יש לו עוקב, <span>\( \bigcup\text{Ord}+1 \)</span>. מכיוון שגם העוקב הזה הוא סודר, הוא שייך לקבוצת כל הסודרים, <span>\( \text{Ord} \)</span>, ולכן נקבל <span>\( \bigcup\text{Ord}+1\in\text{Ord}\subseteq\bigcup\text{Ord} \)</span>, כלומר <span>\( \bigcup\text{Ord}+1&lt;\bigcup\text{Ord} \)</span> ומצד שני <span>\( \bigcup\text{Ord}&lt;\bigcup\text{Ord}+1 \)</span> וזה כמובן בלתי אפשרי. קיבלנו סתירה בסגנון הפרדוקס של ראסל שמראה לנו ש-<span>\( \text{Ord} \)</span> לא יכול להיות קבוצה. אז מה הוא <strong>כן</strong>?</p>

<p>ובכן, אנחנו קוראים לאוסף הזה <strong>מחלקה</strong> (Class). זה השם ה”רשמי” שלנו כדי לתאר אוסף <strong>שאנחנו מסוגלים לתאר</strong> אבל הוא לא בהכרח קבוצה בעצמו (משתמשים ב-Proper Class כדי לתאר מחלקה שאכן איננה קבוצה, ואני ככל הנראה אשתמש חופשי ב”מחלקה” כדי לומר “מחלקה שאיננה קבוצה”). מה זאת אומרת “מסוגלים לתאר”, בעזרת מה? בלי להסביר את זה בצורה הכי מדוקדקת שאפשר זה נשמע כאילו אני מרמה. התשובה היא - בעזרת <strong>לוגיקה מסדר ראשון</strong>. ספציפית, בעזרת התורה מסדר ראשון של קבוצות.</p>

<p><a href="https://gadial.net/2012/06/17/first_order_logic/">יש לי פוסטים</a> על לוגיקה מסדר ראשון, ולכן כאן אני אסתפק בתיאור קצר יחסית. האובייקט הבסיסי בלוגיקה מסדר ראשון הוא <strong>נוסחה</strong>, שהיא סדרה סופית של תווים. יש לנו תווים שמתארים <strong>משתנים</strong>, למשל <span>\( x,y,z,A,B,C \)</span> וכדומה (אפשר להניח שיש לנו אינסוף כאלו). בין כל שני משתנים אפשר לכתוב אחד משני סימני יחס: או לכתוב <span>\( x=y \)</span> או לכתוב <span>\( x\in y \)</span>. שני הביטויים הללו הם <strong>נוסחאות הבסיס</strong> שלנו - כלומר, כל נוסחת בסיס <span>\( \varphi \)</span> מורכבת משני משתנים עם אחד משני סימני היחס ביניהם. הרעיון בנוסחאות בסיס הוא שבהינתן <strong>השמה למשתנים</strong> כל נוסחת בסיס מקבלת ערך שהוא או “אמת”, T או “שקר”, F; אם שמנו במשתנה <span>\( x \)</span> את הקבוצה <span>\( a \)</span> ושמנו במשתנה <span>\( y \)</span> את הקבוצה <span>\( b \)</span>, אז הנוסחה <span>\( x=y \)</span> מקבלת ערך “אמת” רק אם <span>\( a,b \)</span> הן אותה קבוצה בדיוק, ו-<span>\( x\in y \)</span> מקבלת ערך “אמת” רק אם הקבוצה <span>\( a \)</span> היא איבר של הקבוצה <span>\( b \)</span>.</p>

<p>מנוסחאות בסיס אפשר לבנות נוסחאות מורכבות יותר בעזרת <strong>קשרים לוגיים</strong>: <span>\( \neg\varphi,\varphi\wedge\psi,\varphi\vee\psi,\varphi\to\psi,\varphi\leftrightarrow\psi \)</span>. הקשרים הללו הם פונקציות על ערכי אמת: <span>\( \neg \)</span> (“שלילה”) הופך T ל-F ו-F ל-T; <span>\( \wedge \)</span> (“וגם”) מחזיר T רק אם שני הקלטים היו T; <span>\( \vee \)</span> (“או”) מחזיר F רק אם שני הקלטים היו F, <span>\( \to \)</span> (“גרירה”) מחזיר F רק אם הקלט השמאלי היה T והימני היה F; ו-<span>\( \leftrightarrow \)</span> (“שקילות”) מחזיר T רק אם שני הקלטים שווים.</p>

<p>המרכיב האחרון בבניית נוסחת הוא <strong>כמתים</strong>. אם <span>\( \varphi \)</span> היא נוסחה, אז גם <span>\( \forall x\varphi \)</span> (“לכל <span>\( x \)</span> מתקיים <span>\( \varphi \)</span>”) ו-<span>\( \exists x\varphi \)</span> (“קיים <span>\( x \)</span> שעבורו מתקיים <span>\( \varphi \)</span>”) הן נוסחאות. <span>\( \forall x\varphi \)</span> מקבלת ערך T רק אם לכל קבוצה שמציבים במקום <span>\( x \)</span> בנוסחה <span>\( \varphi \)</span> מקבלים ערך T, ו-<span>\( \exists x\varphi \)</span> מקבלת ערך T רק אם קיימת קבוצה שאם מציבים אותה במקום <span>\( x \)</span> בנוסחה <span>\( \varphi \)</span> מקבלים ערך T.</p>

<p>החלק המוזר בכל הסיפור הזה הוא האמירה שלי “קיימת קבוצה” כי אני לא מסביר - קיימת קבוצה <strong>איפה</strong>? וכאן הסיפור באמת מתחיל להסתבך. כשיש לי אוסף של נוסחאות מסדר ראשון, מה שאני קורא לו <strong>תורה</strong>, ואני בא להבין מה ערכי האמת של נוסחאות מסדר ראשון, צריך להתחיל עם <strong>פרשנות</strong> לסימונים שמופיעים בה. כאן אנחנו מניחים במובלע קיום של יקום מתמטי שממנו נלקחות הקבוצות שאפשר להציב בתוך המשתנים, אבל אנחנו לא יכולים לשלול את הקיום של <strong>כמה יקומים שונים</strong> כאלו, ובפרט לא לשלול את אפשרות הקיום של יקומי “צעצוע” שהם קטנים למדי ביחס ליקום המפלצתי שאנחנו חושבים עליו. למשל, אפשר לקחת בתור יקום מתמטי את <span>\( \omega \)</span> עצמו; זה אומר שכל קבוצה שנציב במשתנים שלנו תהיה איבר של <span>\( \omega \)</span> ושום דבר חוץ מזה. אם זה יהיה היקום שלנו, נראה מהר מאוד שבניסוח הפורמלי של אקסיומות צרמלו-פרנקל, כל האקסיומות מתקיימות יפה מאוד, למעט אחת: אקסיומת האינסוף. כלומר, מנקודת המבט הזו אקסיומת האינסוף לא מראה לנו שמשהו קיים, אלא <strong>שוללת פרשנות</strong> אפשרית אחת לתורה שלנו. זו דרך מאוד מועילה לחשוב על אקסיומות - בתור “פילטרים” שמסננים פרשנויות לא מתאימות של התורה שלנו. עוד נחזור לכל העניינים הללו בהמשך.</p>

<p>כרגע, אבל, אני לא מניח עוד הנחות על היקום המתמטי שלנו חוץ מזה שכל איבריו הם קבוצות. אני מסמן אותו ב-<span>\( V \)</span> וחסל. כזכור, <span>\( V \)</span> הזה לא יכול להיות קבוצה (“קבוצת כל הקבוצות” לא קיימת), אבל קל לתת נוסחה ש”מתארת” אותו: <span>\( x=x \)</span>. הנוסחה הזו נכונה <strong>לכל</strong> איבר של <span>\( V \)</span>, ולכן אפשר לתאר את <span>\( V \)</span> בתור “אוסף כל האיברים שמקיימים <span>\( x=x \)</span>”, או אפילו להתחצף ולכתוב <span>\( V=\left\{ x\ |\ x=x\right\}  \)</span>. הכתיב הזה הוא חצוף משתי סיבות: ראשית, כי אני מערבב בין <span>\( x \)</span> שהוא סימן של משתנה (מה שמופיע בנוסחה <span>\( x=x \)</span>) ובין <span>\( x \)</span> שהוא סימון של איבר קונקרטי של <span>\( V \)</span> (מה שמופיע בצד שמאל) אבל זה לא נורא. מה שבאמת נורא הוא שאני משתמש בכתיב הסוגריים המסולסלים שמשמש אותנו להגדיר קבוצות, למרות ש-<span>\( V \)</span> היא לא קבוצה. ומה ש<strong>הכי</strong> נורא זה שאני אשתמש בסימון כמו <span>\( x\in V \)</span> כדי לתאר שייכות למחלקה. כל זה נראה לגמרי כאילו אני מתייחס למחלקות בתור קבוצות. אז למה זה בסדר? ובכן, כי כל מה שאני עושה עם מחלקות זה בסך הכל <strong>כתיב מקוצר</strong>. אני יכול להעלים את הכתיב המקוצר הזה ולהישאר במקומו עם נוסחאות לוגיות והכל יעבוד באותה מידה בדיוק.</p>

<p>בואו נראה דוגמא יותר קונקרטית - הסודרים. כשאני כותב <span>\( \alpha\in\text{Ord} \)</span>, כלומר “<span>\( \alpha \)</span> הוא סודר”, למה אני מתכוון? אם נחזור להגדרה, סודר הוא קבוצה שהיא 1) טרנזיטיבית ו-2) סדורה בסדר מלא על ידי <span>\( \in \)</span>. את שני אלו אפשר לנסח באמצעות נוסחה לוגית:</p>

<p><span>\( \forall\beta\forall\gamma\left(\left(\gamma\in\beta\wedge\beta\in\alpha\right)\to\gamma\in\alpha\right)\wedge\forall\beta\forall\gamma\left(\left(\beta\in\alpha\wedge\gamma\in\alpha\right)\to\left(\beta\in\gamma\vee\gamma\in\beta\right)\right) \)</span></p>

<p>במקום לכתוב את כל הנוסחה הזו, אפשר לכתוב פשוט <span>\( \alpha\in\text{Ord} \)</span>; זה סימון מקוצר מוסכם. זה לא אומר ש-<span>\( \text{Ord} \)</span> היא קבוצה; כלומר, זה לא אומר שיש איבר ביקום שהאיברים שלו הם בדיוק האיברים של <span>\( \text{Ord} \)</span>. הטענה שיש כזה איבר מנוסחת כך:</p>

<p><span>\( \exists A\left(\alpha\in A\leftrightarrow\alpha\in\text{Ord}\right) \)</span></p>

<p>כאשר כאמור, ה-<span>\( \alpha\in\text{Ord} \)</span> הוא פשוט העתק-הדבק של הנוסחה הגדולה מקודם. עכשיו, מה שראינו הוא שהנוסחה הזו של ה-<span>\( \exists A \)</span> היא <strong>שקר</strong>, כלומר לא קיימת <span>\( A \)</span> כזו. זו הסיבה שאנחנו אומרים ש-<span>\( \text{Ord} \)</span> היא “מחלקה ממש”.</p>

<p>מוזר? כן, אז בואו נעבור לראות עוד שימוש של המושג הזה. איך אמר ג’ון פון-נוימן? “במתמטיקה לא מבינים דברים, במתמטיקה מתרגלים לדברים”. אחרי שמתרגלים גם קל יותר להבין.</p>

<h2>אקסיומת ההחלפה</h2>

<p>מבין כל האקסיומות של צרמלו-פרנקל שתיארתי בסדרת הפוסטים הזו, אקסיומת ההחלפה היא זו שהכי חיפפתי וטרם הצגתי בצורה פורמלית, למרות השימושיות הרבה שלה. סוף סוף הגיע הזמן להציג אותה פורמלית, אז כמובן שכדאי להתחיל מהצגה לא פורמלית: בהצגה הזו, אקסיומת ההחלפה אומרת שאם מחלקה <span>\( F \)</span> היא פונקציה ו-<span>\( A \)</span> היא קבוצה, אז <span>\( F\left(A\right) \)</span> היא קבוצה.</p>

<p>אבל רגע, מה זאת אומרת “מחלקה <span>\( F \)</span> היא פונקציה”? הרי “פונקציה” הוגדרה בתור סוג של יחס, שהוא קבוצה. איך משהו שאיננו קבוצה יכול להיות פונקציה? אנחנו שוב מותחים את השימוש בשפה שלנו. מה שקורה בפועל הוא ש-<span>\( F \)</span> כזו היא סימון מקוצר לנוסחה <span>\( \varphi\left(x,y,a_{1},\ldots,a_{n}\right) \)</span>. הכתיב הזה עם הסוגריים אומר “יש בנוסחה <span>\( \varphi \)</span> את המשתנים החופשיים <span>\( x,y,a_{1},\ldots,a_{n} \)</span>” כש”משתנה חופשי” הוא משתנה שלא נופל תחת הטווח של כמת עם השם שלו. למשל בנוסחה <span>\( \forall x\left(x=y\right) \)</span> המשתנה <span>\( y \)</span> חופשי והמשתנה <span>\( x \)</span> לא (אם ההגדרות הללו לא ברורות באמת שכדאי לקרוא קודם על לוגיקה מסדר ראשון, זה לא כזה קשה!)</p>

<p>בנוסחה <span>\( \varphi\left(x,y,a_{1},\ldots,a_{n}\right) \)</span> הזו אני חושב על <span>\( x,y \)</span> בתור האיברים של הזוג ש-<span>\( \varphi \)</span> מגדירה, ועל <span>\( a_{1},\ldots,a_{n} \)</span> בתור “פרמטרים” שמאפיינים את <span>\( \varphi \)</span>. למשל, הנוסחה שהמשתנים שלה הם רק <span>\( x,y \)</span> (בלי פרמטרים)</p>

<p><span>\( x\in y\wedge\forall z\in x\left(z\in y\right)\wedge\forall z\in y\left(z=x\vee z\in x\right) \)</span></p>

<p>מה היא אומרת? ש-<span>\( y=x\cup\left\{ x\right\}  \)</span> (מה שעבור סודרים סימנתי ב-<span>\( y=x+1 \)</span> אבל כאן אנחנו עוסקים בקבוצות כלליות, לאו דווקא סודרים). כלומר, <span>\( \varphi\left(x,y\right) \)</span> מקבלת ערך T אם ורק אם <span>\( y=x\cup\left\{ x\right\}  \)</span>. אפשר גם לסמן את זה <span>\( \left(x,y\right)\in F \)</span>, כפי שכבר עשיתי קודם עם מחלקות.</p>

<p>עכשיו, קל להוכיח שאם <span>\( \varphi\left(x,y_{1}\right) \)</span> מקבלת ערך T וגם <span>\( \varphi\left(x,y_{2}\right) \)</span> מקבלת ערך T (עבור הצבות קונקרטיות של קבוצות <span>\( x,y_{1},y_{2} \)</span> למשתנים) אז <span>\( y_{1}=y_{2} \)</span>; זו בדיוק התכונה שאנחנו דורשים מפונקציות. אז אפשר להשתמש בסימון <span>\( F\left(x\right) \)</span> כדי לציין את <span>\( y \)</span>, ואפשר לכתוב <span>\( F\left(x\right)=x\cup\left\{ x\right\}  \)</span> ויהיה ברור אל מה הכוונה אפילו אם <span>\( F \)</span> איננה קבוצה. ואם <span>\( A \)</span> היא כן קבוצה, אני יכול לחשוב על הקבוצה <span>\( F\left(A\right)=\left\{ F\left(a\right)\ |\ a\in A\right\}  \)</span>, אבל “לחשוב על הקבוצה” לא מוכיח שהיא קיימת; בשביל זה אני צריך את אקסיומת ההחלפה.</p>

<p>פורמלית, אקסיומת ההחלפה היא לא אקסיומה בודדת, כלומר פסוק אחד ויחיד; יש לנו אקסיומת החלפה לכל נוסחה <span>\( \varphi\left(x,y,a_{1},\ldots,a_{n}\right) \)</span> אפשרית (לכן לפעמים מדברים על <strong>סכמת</strong> אקסיומת ההחלפה - מין תבנית כזו שיוצקים לתוכה את ה-<span>\( \varphi \)</span> ומקבלים אקסיומה), ועבור <span>\( \varphi \)</span> הזה אקסיומת ההחלפה היא</p>

<p><span>\( \forall x\forall y\forall z\left(\varphi\left(x,y,a_{1},\ldots,a_{n}\right)\wedge\varphi\left(x,z,a_{1},\ldots,a_{n}\right)\to y=z\right)\to \)</span></p>

<p><span>\( \to\forall A\exists B\forall y\left(y\in B\leftrightarrow\left(\exists x\in A\right)\varphi\left(x,y,a_{1},\ldots,a_{n}\right)\right) \)</span></p>

<p>החצי הראשון של האקסיומה אומר “<strong>אם</strong> <span>\( \varphi \)</span> מתארת פונקציה” והחצי השני אומר “<strong>אז</strong> לכל קבוצה <span>\( A \)</span> שעליה מפעילים את הפונקציה, קיימת קבוצה <span>\( B \)</span> שהיא התמונה של <span>\( A \)</span>”.</p>

<p>עכשיו אפשר סוף סוף לעשות עם זה משהו: אינדוקציה ורקורסיה על-סופיות. אבל מה זה אומר בכלל?</p>

<h2>אינדוקציה על-סופית</h2>

<p>במתמטיקה הרבה פעמים משתמשים בחופשיות במושגים “אינדוקציה” ו”רקורסיה” בתור מילים נרדפות, אבל עמוק בפנים יש להן משמעות פורמלית שונה. <strong>אינדוקציה</strong> מתארת את האופן שבו <strong>מוכיחים</strong> משהו בתהליך של הסקה מהפרט אל הכלל; <strong>רקורסיה</strong> מתארת את האופן שבו <strong>מגדירים</strong> משהו על קלט מסוים מתוך גרסאות פשוטות יותר של אותו הקלט. זה מה שצריך להיות לנו בראש - עם רקורסיה מגדירים, עם אינדוקציה מוכיחים.</p>

<p>כשאני מדבר על אינדוקציה או רקורסיה “על-סופיות” (“טרנספיניטיות”) אני מתכוון לכאלו שמסתמכות על כלל הסודרים; ככה אפשר להבדיל מסוגים אחרים של אינדוקציה ורקורסיה. למשל, האינדוקציה ה”רגילה” מתבססת רק על המספרים הטבעיים.</p>

<p>בואו ניזכר איך אינדוקציה רגילה עובדת: יש לנו טענה <span>\( P \)</span> שיכולה להיות נכונה או שגויה עבור מספרים טבעיים שונים ומשונים. אנחנו כותבים <span>\( P\left(n\right) \)</span> כדי לומר “הטענה <span>\( P \)</span> מתקיימת עבור המספר הטבעי <span>\( n \)</span>”. הוכחה באינדוקציה פירושה להוכיח ש-<span>\( P \)</span> מתקיימת <strong>לכל</strong> הטבעיים, וזאת על ידי הוכחה של שתי טענות:</p>

<ol> <li><span>\( P\left(0\right) \)</span> (הטענה מתקיימת עבור המספר הטבעי 0)</li>


<li><span>\( P\left(n\right)\to P\left(n+1\right) \)</span> (<strong>אם</strong> הטענה מתקיימת עבור המספר הטבעי <span>\( n \)</span> <strong>אז</strong> היא מתקיימת עבור המספר הטבעי <span>\( n+1 \)</span>).</li>

</ol>

<p>שני אלו ביחד, כאמור, מוכיחים שהטענה מתקיימת לכל הטבעיים, כלומר <span>\( \forall nP\left(n\right) \)</span> כשהכמת <span>\( \forall \)</span> (“לכל”) רץ על כל הטבעיים.</p>

<p>לפעמים אוהבים קצת לחסוך בכתיבה ולנסח אינדוקציה מתמטית בצורה הבאה:</p>

<p><span>\( \forall n\left(\forall k&lt;n\left(P\left(k\right)\right)\to P\left(n\right)\right)\to\forall nP\left(n\right) \)</span></p>

<p>הזוועה הזו אומרת “אם לכל <span>\( n \)</span> טבעי זה נכון שאם לכל <span>\( k&lt;n \)</span> מתקיים <span>\( P\left(k\right) \)</span> נובע מכך ש-<span>\( P\left(n\right) \)</span>, אז <span>\( P \)</span> נכון לכל הטבעיים”. הניסוח הזה נקרא <strong>אינדוקציה שלמה</strong> והוא שקול לאינדוקציה “רגילה” אבל לפעמים יותר נוח, כי כדי להוכיח ש-<span>\( P\left(n\right) \)</span> מתקיים אפשר להשתמש ישירות בכך ש-<span>\( P\left(k\right) \)</span> מתקיים לכל <span>\( k&lt;n \)</span> ולא רק למספר שבא מייד לפני <span>\( n \)</span>. לפעמים הניסוח הזה לא חוסך הרבה; עדיין צריך להוכיח בנפרד את המקרה עבור 0, וכשמוכיחים לאיבר כללי מספיק להסתמך על זה שהטענה מתקיימת לזה שלפניו.</p>

<p>מה שנחמד בניסוח של אינדוקציה שלמה זה שהוא עובד בדיוק באותה מידה עבור סודרים:</p>

<p><span>\( \forall\alpha\left(\forall\beta&lt;\alpha\left(P\left(\beta\right)\right)\to P\left(\alpha\right)\right)\to\forall\alpha P\left(\alpha\right) \)</span></p>

<p>כלומר, דרך להוכיח שטענה מתקיימת לכל הסודרים (כולם! אפילו שראינו שמחלקת כל הסודרים גדולה מכדי להיות קבוצה!) היא להוכיח שלכל סודר, אם הטענה מתקיימת לכל הסודרים הקטנים ממנו, היא מתקיימת גם עבורו.</p>

<p>איך מוכיחים שאינדוקציה כזו באמת עובדת? ובכן, נניח ש-<span>\( P \)</span> מקיימת את התכונה שתיארתי: לכל <span>\( \alpha \)</span>, אם <span>\( P\left(\beta\right) \)</span> לכל <span>\( \beta&lt;\alpha \)</span> נובע מכך ש-<span>\( P\left(\alpha\right) \)</span>, ועכשיו בואו נניח ש-<span>\( P \)</span> <strong>לא</strong> מתקיימת לכל הסודרים, אז קיים סודר מינימלי <span>\( \alpha \)</span> שעבורו היא לא מתקיימת, אבל המינימליות שלו פירושה שלכל <span>\( \beta&lt;\alpha \)</span> <strong>כן</strong> מתקיים <span>\( P\left(\beta\right) \)</span>, ומכאן שגם <span>\( P\left(\alpha\right) \)</span> עצמו מתקיים.</p>

<p>בהוכחה הזו השתמשתי די בחופשיות בכך שבכל מחלקה של סודרים (לאו דווקא קבוצה) יש איבר מינימלי. זה לא נראה מובן מאליו אבל זה די פשוט: ניקח סודר <strong>כלשהו</strong> ששייך למחלקה; אז אנחנו יודעים שא) הסודר הזה הוא <strong>כן</strong> קבוצה, וקבוצה סדורה היטב, כלומר בכל תת-קבוצה שלו יש איבר מינימלי; וב) הסודר הזה מכיל את כל הסודרים שקטנים ממנו, ובפרט את כל האיברים באוסף שקטנים ממנו. לכן או שהוא האיבר המינימלי, או שאפשר לשלוף מתוכו את האיבר המינימלי.</p>

<p>יופי, אז הוכחנו שאינדוקציה על-סופית “עובדת”, אבל אני עדיין רוצה לנסח אותה באופן שמזכיר אינדוקציה “רגילה” ולא אינדוקציה שלמה. בשביל זה אני צריך מושג חדש. השלב שבו אינדוקציה על מספרים טבעיים מפסיקה לעבוד הוא כשמגיעים אל <span>\( \omega \)</span>; זה סודר שהוא לא עוקב מיידי של אף מספר טבעי (כלומר, לא שווה <span>\( n+1 \)</span> לאף טבעי <span>\( n \)</span>) ולכן האינדוקציה לא “מגיעה” אליו. אנחנו צריכים חוק חדש שמדבר על <span>\( \omega \)</span> וסודרים שדומים לו.</p>

<p>אז אני מגדיר <strong>סודר גבולי</strong> בתור סודר שהוא לא עוקב מיידי של אף סודר אחר, כלומר הוא לא מהצורה <span>\( \alpha+1 \)</span> עבור אף סודר (כזכור, <span>\( \alpha+1\triangleq\alpha\cup\left\{ \alpha\right\}  \)</span>). הסודר הגבולי הראשון הוא 0, והשני הוא <span>\( \omega \)</span> וכן הלאה.</p>

<p>עכשיו אפשר לנסח אינדוקציה על-סופית בצורה יותר “קלאסית”. נניח שיש לנו טענה <span>\( P \)</span> על סודרים שמקיימת</p>

<ol> <li><span>\( P\left(0\right) \)</span></li>


<li>אם <span>\( P\left(\alpha\right) \)</span> אז <span>\( P\left(\alpha+1\right) \)</span></li>


<li>אם <span>\( \alpha\ne0 \)</span> הוא סודר גבולי ולכל <span>\( \beta&lt;\alpha \)</span> מתקיים <span>\( P\left(\beta\right) \)</span>, אז <span>\( P\left(\alpha\right) \)</span></li>

</ol>

<p>אז אפשר להסיק ש-<span>\( P \)</span> מתקיימת לכל <span>\( \alpha \)</span>.</p>

<p>עכשיו אפשר לעבור לדבר על רקורסיה, סוף סוף.</p>

<h2>רקורסיה על-סופית</h2>

<p>כמו עם אינדוקציה, גם כאן כדאי להתחיל עם דוגמא מעולם המספרים הטבעיים. איזו דוגמא מפורסמת יש למשהו שמוגדר ברקורסיה? זה קל: <strong>סדרת פיבונאצ'י</strong> היא ללא ספק הסדרה הרקורסיבית המפורסמת בעולם. בואו נזכיר מהי: זו סדרה <span>\( F_{0},F_{1},F_{2},\ldots \)</span> שמוגדרת על ידי הכללים:</p>

<ul> <li><span>\( F_{0}=0 \)</span></li>


<li><span>\( F_{1}=1 \)</span></li>


<li><span>\( F_{n}=F_{n-1}+F_{n-2} \)</span> לכל <span>\( n&gt;1 \)</span></li>

</ul>

<p>הכללים הללו בעצם נחלקים לשני סוגים: יש לנו <strong>תנאי התחלה</strong>, שהם ערכים מפורשים של <span>\( F \)</span> עבור איברים ספציפיים, במקרה שלנו <span>\( F_{0},F_{1} \)</span>, ויש לנו <strong>כלל רקורסיבי</strong> שמאפשר לקבל את <span>\( F_{n} \)</span> מתוך ערכים קודמים בסדרה. אנחנו רוצים להכליל את הרעיון הזה גם לסודרים, אבל בסודרים הסיטואציה קצת יותר מסובכת בגלל שיש לנו סודרים גבוליים שלא נוכל לכתוב <span>\( \alpha-1 \)</span> וכדומה עבורם. אז בואו נשתמש בניסוח קצת שונה, וקצת יותר מסורבל למראה במבט ראשון, גם עבור מספרים טבעיים.</p>

<p>הרעיון הוא כזה. מה זו בעצם “סדרה”? אנחנו חושבים עליה בתור פונקציה <span>\( F:\mathbb{N}\to A \)</span> עבור קבוצה <span>\( A \)</span> כלשהי; כלומר, דרך כלשהי להתאים לכל מספר טבעי איבר של <span>\( A \)</span>. בסדרה רקורסיבית, כל איבר נבנה בצורה כלשהי מהאיברים הקודמים; פורמלית, יש פונקציה <span>\( G \)</span> שמקבלת סדרה <span>\( G\left(a_{0},a_{1},\ldots,a_{n-1}\right) \)</span> ומוציאה כפלט את <span>\( a_{n} \)</span>, שהוא האיבר הבא שאמור להופיע בסדרה בתנאי שהאיברים הקודמים היו <span>\( a_{0},\ldots,a_{n} \)</span>. עכשיו, כשאנחנו בונים את הסדרה <span>\( F \)</span>, אנחנו עושים את זה על ידי הפעלות של <span>\( G \)</span> שמקבלת בכל פעם את האיברים של <span>\( F \)</span> שכבר נבנו; אפשר לסמן את זה <span>\( F|_{n} \)</span> - הצמצום של התחום של <span>\( F \)</span> מהקבוצה <span>\( \mathbb{N} \)</span> לקבוצה <span>\( n=\left\{ 0,1,2,\ldots,n-1\right\}  \)</span>, ואז מה שקורה הוא</p>

<p><span>\( F\left(n\right)=G\left(F|_{n}\right) \)</span></p>

<p>כלומר, הסדרה ה<strong>אינסופית</strong> <span>\( F \)</span> נבנית איכשהו מתוך פונקציה <span>\( G \)</span> שהקלטים שלה הן סדרות <strong>סופיות</strong>.</p>

<p>מסורבל? כן, אבל מה שנחמד פה הוא שזה עובד באותה מידה גם עבור הסודרים. אבל צריך להיזהר קצת. אם אנחנו רוצים ש-<span>\( F \)</span> תהיה סדרה על-סופית, כלומר פונקציה שתוכל לקבל כקלט כל סודר, זה אומר שהתחום של <span>\( F \)</span> הוא אוסף כל הסודרים - והאוסף הזה, כבר אמרתי, גדול מכדי להיות קבוצה. לכן <span>\( F \)</span> היא מחלקה. כבר ראינו שמחלקה יכולה לתאר פונקציה, אז אני מקווה שאנחנו בסדר עם זה; כל החלק הראשון של הפוסט היה מיועד כדי שלא נתקומם כאן.</p>

<p>אם כן, הרעיון הוא שאם נתונה לי פונקציה <span>\( G \)</span> (וגם זו “פונקציה” במובן של מחלקה) שמוגדרת על מחלקת כל הקבוצות <span>\( V \)</span>, אני יכול להשתמש בה כדי ליצור סדרה על-סופית אחת ויחידה <span>\( F \)</span>, שמקיימת</p>

<p><span>\( F\left(\alpha\right)=G\left(F|_{\alpha}\right) \)</span></p>

<p>לכל הסודרים, כאשר <span>\( F|_{\alpha} \)</span> הוא הצמצום של <span>\( F \)</span> לאיברי הסודר <span>\( \alpha \)</span>, דהיינו הסדרה <span>\( \left\{ F_{\beta}\right\} _{\beta&lt;\alpha} \)</span> (הסדרה הזו היא <strong>כן</strong> קבוצה בזכות אקסיומת ההחלפה, שמחליפה את אברי הסודר <span>\( \alpha \)</span> בזוגות <span>\( \left(\beta,F_{\beta}\right) \)</span>, ולכן קלט לגיטימי של <span>\( G \)</span>).</p>

<p>את הטענה שבאמת קיימת סדרה אחת ויחידה <span>\( F \)</span> כזו צריך להוכיח; אז בונים את <span>\( F \)</span> בתור נוסחה לוגית <span>\( \varphi \)</span> עם שני משתנים, <span>\( \alpha,x \)</span>, כך ש-<span>\( \varphi\left(\alpha,x\right) \)</span> בודקת שקיימת סדרה <span>\( \left\{ a_{\beta}\right\} _{\beta&lt;\alpha} \)</span> כך שהדברים הללו מתקיימים</p>

<ol> <li>לכל <span>\( \beta&lt;\alpha \)</span> מתקיים <span>\( a_{\beta}=G\left(\left\{ a_{\gamma}\right\} _{\gamma&lt;\beta}\right) \)</span></li>


<li><span>\( x=G\left(\left\{ a_{\beta}\right\} _{\beta&lt;\alpha}\right) \)</span></li>

</ol>

<p>כדי להראות שזה עובד, משתמשים באינדוקציה על-סופית. ראשית, אנחנו רוצים להראות ש-<span>\( F \)</span> היא באמת פונקציה, כלומר שלכל <span>\( \alpha \)</span>, אם קיימים <span>\( x_{1},x_{2} \)</span> כך ש-<span>\( \varphi\left(\alpha,x_{1}\right) \)</span> וגם <span>\( \varphi\left(\alpha,x_{2}\right) \)</span> שניהם T אז <span>\( x_{1}=x_{2} \)</span>. מה אנחנו יודעים על <span>\( x_{1},x_{2} \)</span>? אנחנו יודעים שעבור <span>\( x_{1} \)</span> קיימת סדרה <span>\( \left\{ a_{\beta}\right\} _{\beta&lt;\alpha} \)</span> שמקיימת את תנאי 1, ובנוסף <span>\( x_{1}=G\left(\left\{ a_{\beta}\right\} _{\beta&lt;\alpha}\right) \)</span>; ואנחנו יודעים שעבור <span>\( x_{2} \)</span> קיימת סדרה <span>\( \left\{ b_{\beta}\right\} _{\beta&lt;\alpha} \)</span> שמקיימת את תנאי 1 ובנוסף <span>\( x_{2}=G\left(\left\{ a_{\beta}\right\} _{\beta&lt;\alpha}\right) \)</span>. אז מכיוון שאנחנו יודעים ש-<span>\( G \)</span> פונקציה, אם נראה ש-<span>\( \left\{ a_{\beta}\right\} _{\beta&lt;\alpha}=\left\{ b_{\beta}\right\} _{\beta&lt;\alpha} \)</span>, ינבע מכך <span>\( x_{1}=x_{2} \)</span>. ואיך נראה ששתי הסדרות הללו שוות? בעזרת תנאי 1, ובעזרת אינדוקציה.</p>

<p>אנחנו משתמשים באינדוקציה על <span>\( \beta \)</span> ומראים ש-<span>\( a_{\beta}=b_{\beta} \)</span> לכל <span>\( \beta&lt;\alpha \)</span>: הבסיס הוא <span>\( \beta=0 \)</span> ועבורו <span>\( a_{0}=G\left(\emptyset\right)=b_{0} \)</span> (כי במקרה זה לא קיים <span>\( \gamma&lt;\beta \)</span> ולכן הסדרה של תנאי 1 ריקה). לכל סודר אחר, גבולי או עוקב, אנחנו מניחים שלכל <span>\( \gamma&lt;\beta \)</span> כבר מתקיים <span>\( a_{\gamma}=b_{\gamma} \)</span>, ומכאן שהסדרות <span>\( \left\{ a_{\gamma}\right\} _{\gamma&lt;\beta},\left\{ b_{\gamma}\right\} _{\gamma&lt;\beta} \)</span> שוות, ולכן</p>

<p><span>\( a_{\beta}=G\left(\left\{ a_{\gamma}\right\} _{\gamma&lt;\beta}\right)=G\left(\left\{ b_{\gamma}\right\} _{\gamma&lt;\beta}\right)=b_{\beta} \)</span></p>

<p>וזה מסיים את ההוכחה באינדוקציה. די פשוט!</p>

<p>יפה, אז מה שהשגנו עד כה הוא להראות ש-<span>\( F \)</span> היא באמת פונקציה. אבל עדיין צריך להראות ש-<span>\( F \)</span> מוגדרת <strong>לכל</strong> סודר <span>\( \alpha \)</span>, כלומר שתמיד קיים <span>\( x \)</span> כך ש-<span>\( \varphi\left(\alpha,x\right) \)</span> היא בעלת ערך T; זה לא מתחייב ממה שראינו עד כה. גם את זה נוכיח, כמה מפתיע, באינדוקציה על <span>\( \alpha \)</span>.</p>

<p>עבור <span>\( \alpha=0 \)</span>, בוודאי ש-<span>\( x=G\left(\emptyset\right) \)</span> ישיג את המטרה ש-<span>\( \varphi\left(0,x\right) \)</span> תקבל T; הסדרה של ה”קיימת סדרה” במקרה הזה היא בהכרח ריקה (כי האינדקסים שלה הם <span>\( \beta&lt;0 \)</span> ואין כאלו) ולכן תנאי 1 מתקיים באופן ריק ותנאי 2 הוא בדיוק <span>\( x=G\left(\emptyset\right) \)</span>. אז זה הבסיס.</p>

<p>עבור <span>\( \alpha+1 \)</span>, אנו מניחים שהטענה נכונה עבור <span>\( \alpha \)</span>, כלומר קיים איבר שאסמן <span>\( a_{\alpha} \)</span> וקיימת סדרה <span>\( \left\{ a_{\beta}\right\} _{\beta&lt;\alpha} \)</span> שמקיימת את תנאי 1 ובנוסף <span>\( a_{\alpha}=G\left(\left\{ a_{\beta}\right\} _{\beta&lt;\alpha}\right) \)</span>. נרחיב את הסדרה הזו לסדרה <span>\( \left\{ a_{\beta}\right\} _{\beta&lt;\alpha+1} \)</span> על ידי הוספת <span>\( a_{\alpha} \)</span> בתור האיבר האחרון שלה. נסמן <span>\( x=G\left(\left\{ a_{\beta}\right\} _{\beta&lt;\alpha+1}\right) \)</span> (קיים <span>\( x \)</span> כזה כי <span>\( G \)</span> היא פונקציה) ועכשיו ברור ש-<span>\( \varphi\left(\alpha+1,x\right) \)</span> הוא T.</p>

<p>אם <span>\( \alpha \)</span> הוא סודר גבולי, אנחנו מניחים שהטענה נכונה לכל <span>\( \beta&lt;\alpha \)</span>. עכשיו מגיע החלק הטריקי והטכני ביותר בהוכחה: אני רוצה לבנות את הסדרה <span>\( \left\{ a_{\beta}\right\} _{\beta&lt;\alpha} \)</span>. אם אני אבנה אותה, אני אוכל להגדיר <span>\( x=G\left(\left\{ a_{\beta}\right\} _{\beta&lt;\alpha}\right) \)</span> ואז <span>\( \varphi\left(\alpha,x\right) \)</span> יתקיים וכולנו נשמח. אבל בשביל זה צריך להראות שהסדרה <span>\( \left\{ a_{\beta}\right\} _{\beta&lt;\alpha} \)</span> <strong>קיימת</strong>. לא קיימת במובן הנפנוף-ידיימי של מחלקות; קיימת בתור אובייקט מתמטי קונקרטי - קבוצה - ביקום שלנו.</p>

<p>אז ראשית כל, אינטואיציה. אם יש לנו <span>\( \beta_{1}&lt;\beta_{2}&lt;\alpha \)</span>, אנחנו יודעים שהסדרה עד <span>\( \beta_{1} \)</span> היא תת-סדרה של הסדרה עד <span>\( \beta_{2} \)</span>. פורמלית, מכיוון ש-<span>\( \beta_{1} \)</span> מקיימת את הנחת האינדוקציה קיימת עבורה סדרה, <span>\( \left\{ a_{\gamma}\right\} _{\gamma\le\beta_{1}} \)</span> שמקיימת את תכונות 1-2. בדומה עבור <span>\( \beta_{2} \)</span> קיימת סדרה <span>\( \left\{ b_{\gamma}\right\} _{\gamma\le\beta_{2}} \)</span> שכזו. אפשר להוכיח באינדוקציה, כמו שעשינו קודם, שעבור <span>\( \gamma\le\beta_{1} \)</span> מתקיים <span>\( a_{\gamma}=b_{\gamma} \)</span> - שתי הסדרות זהות עד שהסדרה הקצרה ביותר נגמרת. זה נכון לכל זוג <span>\( \beta_{1}&lt;\beta_{2}&lt;\alpha \)</span>, ולכן אם נחשוב לרגע על שתי הסדרות הללו בתור קבוצות של זוגות סדורים:</p>

<p><span>\( \left\{ \left(0,a_{0}\right),\left(1,a_{1}\right),\ldots,\left(\beta_{1},a_{\beta_{1}}\right)\right\}  \)</span></p>

<p><span>\( \left\{ \left(0,a_{0}\right),\left(1,a_{1}\right),\ldots,\left(\beta_{1},a_{\beta_{1}}\right),\ldots,\left(\beta_{2},a_{\beta_{2}}\right)\right\}  \)</span></p>

<p>אז אחרי שנאחד את שתי הקבוצות הללו נקבל את הגדולה יותר, בלי “איברים מיותרים” נוספים.</p>

<p>על פי אותו הגיון, אם תהיה לנו קבוצה שהאיברים שלה הן <strong>כל הסדרות</strong> שמתאימות לכל אחד מה-<span>\( \beta&lt;\alpha \)</span> האפשריים, איחוד של כל אברי הקבוצה הזו יתן לנו בדיוק את הסדרה <span>\( \left\{ a_{\beta}\right\} _{\beta&lt;\alpha} \)</span> המבוקשת: לכל <span>\( \beta&lt;\alpha \)</span> אכן יהיה בדיוק איבר אחד בסדרה, והסדרה תקיים את החוקיות של דרישה (1). רק צריך להראות שקיימת קבוצה שהאיברים שלה הן <strong>כל הסדרות</strong>. הקבוצה הזו מתקבלת <strong>מאקסיומת ההחלפה</strong> כשמפעילים אותה על <span>\( \alpha \)</span> ומחליפים כל <span>\( \beta \)</span> בסדרה <span>\( \left\{ a_{\gamma}\right\} _{\gamma\le\beta_{1}} \)</span> . השימוש הזה באקסיומת ההחלפה דורש בעצמו עבודה טכנית - להראות שיש פסוק שמקבל זוג של <span>\( \beta \)</span> וסדרה <span>\( \left\{ a_{\gamma}\right\} _{\gamma\le\beta} \)</span> ומוודא שהסדרה <span>\( \left\{ a_{\gamma}\right\} _{\gamma\le\beta} \)</span> מקיימת את תנאים 1-2 ושהיא כוללת את כל הסודרים עד וכולל <span>\( \beta \)</span>, וש-<span>\( \beta \)</span> הוא בכלל סודר… הבנו את הרעיון, זה הזמן להתחיל לחפף.</p>

<p>לסיום, בואו נוכיח יחידות: נניח ש-<span>\( F,F^{\prime} \)</span> הן שתי פונקציות שמקיימות שתיהן <span>\( F\left(\alpha\right)=G\left(F|_{\alpha}\right) \)</span> ו-<span>\( F^{\prime}\left(\alpha\right)=G\left(F^{\prime}|_{\alpha}\right) \)</span> ונוכיח ש-<span>\( F\left(\alpha\right)=F^{\prime}\left(\alpha\right) \)</span> לכל סודר <span>\( \alpha \)</span> (כאן אנחנו נעזרים בכך שאנחנו כבר יודעים ש-<span>\( F,F^{\prime} \)</span> מוגדרות לכל סודר). איך? באינדוקציה, כמובן! ההוכחה טריוויאלית, כי <span>\( F|_{\alpha}=F^{\prime}|_{\alpha} \)</span> אם אנחנו מניחים את נכונות הטענה לכל <span>\( \beta&lt;\alpha \)</span> (כי צמצמנו את שתי הפונקציות הללו אל תחום שבו הן שוות) ולכן <span>\( F\left(\alpha\right)=G\left(F|_{\alpha}\right)=G\left(F^{\prime}|_{\alpha}\right)=F^{\prime}\left(\alpha\right) \)</span>, מה שמסיים את ההוכחה.</p>

<h2>דוגמא מועילה במיוחד: ההיררכייה המצטברת</h2>

<p>אינדוקציה ורקורסיה על-סופיות הן דבר מועיל, ואנחנו מתעסקים בקבוצות, אז מה יותר מועיל מלהוכיח דברים באינדוקציה על-סופית על קבוצות, ולהגדיר קבוצות בעזרת רקורסיה על-סופית? הבעיה היא ששתיהן דורשת <strong>סדרה</strong>, וקבוצות לא מסודרות בסדרה, הן… בלאגן אחד גדול. אבל יש טריק פשוט שמאפשר לנו לעבור מרמת הקבוצה לרמת הסדרה - מה שנקרא <strong>ההיררכייה המצטברת</strong>, שהוא דרך להתאים לכל קבוצה “דרגה” שהיא מספר סודר כלשהו, כך שלכל קבוצה - הדרגות של כל האיברים שלה קטנות יותר. זה מאפשר לנו להוכיח באינדוקציה דברים על קבוצות: מוכיחים באינדוקציה על-סופית על הדרגות, ואז בכל פעם שיש לנו קבוצה שצריך להוכיח עליה משהו, אפשר להניח שאותו משהו כבר מתקיים לכל איבריה.</p>

<p>אם כן, הרעיון הוא שקיימת סדרה על-סופית <span>\( V_{0},V_{1},V_{2},\ldots \)</span> של קבוצות כך שלכל קבוצה קיימת <span>\( V_{\alpha} \)</span> בהיררכייה שהיא שייכת אליה. דרך אפשרית אחת להגדיר את ההיררכייה היא בתור <span>\( V_{\alpha}=\mathcal{P}\left(\bigcup_{\beta&lt;\alpha}V_{\beta}\right) \)</span>, מה שנותן</p>

<p><span>\( V_{0}=\mathcal{P}\left(\emptyset\right)=\left\{ \emptyset\right\}  \)</span></p>

<p><span>\( V_{1}=\mathcal{P}\left(\left\{ \emptyset\right\} \right)=\left\{ \emptyset,\left\{ \emptyset\right\} \right\}  \)</span></p>

<p><span>\( V_{2}=\mathcal{P}\left(\left\{ \emptyset,\left\{ \emptyset\right\} \right\} \right)=\left\{ \emptyset,\left\{ \emptyset\right\} ,\left\{ \left\{ \emptyset\right\} \right\} \left\{ \emptyset,\left\{ \emptyset\right\} \right\} \right\}  \)</span></p>

<p>וכן הלאה וכן הלאה. אז הדרגה של <span>\( \emptyset \)</span> היא 0 ושל <span>\( \left\{ \emptyset,\left\{ \emptyset\right\} \right\}  \)</span> היא 2 וכן הלאה.</p>

<p>למה כל קבוצה שייכת לדרגה כלשהי בהיררכייה? ובכן, זה לא לגמרי מובן מאליו - כדי להוכיח את זה אני אשתמש באחת מהאקסיומות של ZFC שאני לא בטוח אם הצגתי עד כה - <strong>אקסיומת היסוד</strong>. אדבר עליה בפירוט בהמשך; לעת עתה מה שצריך לדעת הוא שהיא באה למנוע סיטואציות הזויות כמו קבוצות <span>\( A \)</span> שמקיימות <span>\( A\in A \)</span>, ופורמלית אני מגדיר אותה באופן הבא: לכל קבוצה לא ריקה <span>\( A \)</span>, קיים ב-<span>\( A \)</span> איבר מינימלי ביחס ל-<span>\( \in \)</span> (כלומר קיים <span>\( x\in A \)</span> כך שלכל <span>\( y\in A \)</span> מתקיים <span>\( y\notin x \)</span>).</p>

<p>בואו ניקח קבוצה <span>\( A \)</span> כלשהי ונניח שלכל <span>\( x\in A \)</span>, קיים סודר <span>\( \alpha_{x} \)</span> כך ש-<span>\( x\in V_{\alpha_{x}} \)</span>. אז נגדיר סודר חדש, <span>\( \overline{\alpha}=\bigcup\left\{ \alpha_{x}+1\ |\ x\in A\right\}  \)</span>. קיבלנו סודר כך ש-<span>\( \alpha_{x}&lt;\overline{\alpha} \)</span> לכל <span>\( x\in A \)</span>, אז <span>\( \bigcup_{\beta&lt;\overline{\alpha}}V_{\beta} \)</span> כוללת את כל ה-<span>\( x\in A \)</span>-ים, ולכן <span>\( A\in V_{\overline{\alpha}}=\mathcal{P}\left(\bigcup_{\beta&lt;\overline{\alpha}}V_{\beta}\right) \)</span>. אז זה מסביר למה, באופן לא מפתיע, אם כל האיברים של קבוצה שייכים להיררכייה אז היא עצמה שייכת להיררכייה; אבל למה אפשר תמיד להניח שכל האיברים של קבוצה יהיו שייכים להיררכייה?</p>

<p>בבירור מסתתר כאן טיעון כלשהו שמדבר לא רק על קבוצה והאיברים שלה אלא גם על האיברים של האיברים שלה והאיברים-של-האיברים-של-האיברים שלה וכן הלאה. צריך לפרמל את זה איכשהו, אז אפשר לדבר על <strong>הסגור הטרנזיטיבי</strong> של קבוצה שהוא מה שמכיל את כל הדברים הללו. בשביל הגדרה פורמלית, נגדיר <span>\( A^{\prime}=\bigcup_{x\in A}x \)</span>: זו הקבוצה שאבריה הם כל האיברים-של-איברים של <span>\( A \)</span>. עכשיו אפשר להגדיר סגור טרנזיטיבי על ידי <span>\( A^{*}=A\cup A^{\prime}\cup A^{\prime\prime}\cup\ldots \)</span>. נשאר להוכיח את הטענה שבהינתן <span>\( A \)</span>, לכל <span>\( x\in A^{*} \)</span> מתקיים ש-<span>\( x \)</span> שייך להיררכייה המצטברת. זו טענה חזקה יותר מהטענה הקודמת, כי <span>\( A\subseteq A^{*} \)</span> ולכן אם הטענה נכונה עבור <span>\( A^{*} \)</span> היא בוודאי נכונה עבור <span>\( A \)</span>; אבל היתרון בכך שהיא חזקה יותר הוא שעכשיו יש לנו גם יותר לעבוד איתו ב”צעד האינדוקציה” (במרכאות, כי אנחנו לא באמת מבצעים פה אינדוקציה).</p>

<p>בואו נניח עכשיו בשלילה שב-<span>\( A^{*} \)</span> יש איברים ש<strong>אינם</strong> שייכים להיררכייה המצטברת. אז בזכות אקסיומת היסוד, אני יכול להניח שיש ביניהם איבר מינימלי <span>\( x \)</span>. אם כל האיברים של <span>\( x \)</span> כן שייכים להיררכייה המצטברת, כבר ראינו שמכך ינבע שגם <span>\( x \)</span> שייך. אם כן, יהי <span>\( y\in x \)</span> כלשהו. אם <span>\( x\in A^{\left(n\right)} \)</span> אז <span>\( y\in A^{\left(n+1\right)} \)</span>, ולכן <span>\( y\in A^{*} \)</span> בעצמו. המינימליות של <span>\( x \)</span> והעובדה ש-<span>\( y\in x \)</span> אומרת לנו שלא ייתכן שגם <span>\( y \)</span> לא שייך להיררכייה המצטברת, ולכן כל האיברים של <span>\( x \)</span> שייכים להיררכייה המצטברת, ולכן גם <span>\( x \)</span> עצמו, וסיימנו.</p>

<p>מכאן ואילך נוכל להשתמש בחופשיות בהיררכייה המצטברת בהוכחות. פורמלית, לכל קבוצה <span>\( A \)</span> נתאים סודר <span>\( \text{rank}\left(A\right) \)</span> כך ש-<span>\( \text{rank}\left(A\right)=\min\left\{ \alpha\ |\ A\in V_{\alpha}\right\}  \)</span> ונקרא לזה <strong>הדרגה</strong> של <span>\( A \)</span>, ואז האינדוקציה/רקורסיה שלנו תהיה על הדרגה. אנחנו רוצים להיות מסוגלים להניח שלכל <span>\( A \)</span>, הדרגה של כל האיברים של <span>\( A \)</span> קטנה מהדרגה של <span>\( A \)</span> עצמה (ולכן אפשר להניח באינדוקציה שהטענה נכונה עבורם/להניח שערכם כבר הוגדר ברקורסיה). למה זה נכון? כי אם <span>\( A\in V_{\alpha} \)</span>, כש-<span>\( \alpha \)</span> הוא המינימלי בעל תכונה זו, אז <span>\( A\in\mathcal{P}\left(\bigcup_{\beta&lt;\alpha}V_{\beta}\right) \)</span>, מה שאומר שכל אברי <span>\( A \)</span> שייכים ל-<span>\( V_{\beta} \)</span> עם <span>\( \beta&lt;\alpha \)</span>.</p>

<p>זהו, סיימנו עם ההירכייה המצטברת, ולכן עם הפוסט הזה. מה עכשיו? סיימנו את הדברים הבסיסיים שאפשר לומר על סודרים, ואפשר לעבור אל המושג הכי מלהיב שאנחנו יכולים להגדיר בעזרתם בשלב הזה: <strong>עוצמות</strong>. זה מה שיקרה בפוסט הבא.</p>

  </div>

  <hr />
  <p>
    נהניתם? התעניינתם? אם תרצו, אתם מוזמנים לתת טיפ:
  </p>
  <a href='https://ko-fi.com/H2H5XFBQ' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://az743702.vo.msecnd.net/cdn/kofi2.png?v=2' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a><div class="PageNavigation">
    
      <a class="prev" href="/2023/01/14/ordinal_arithmetic/">&laquo; תורת הקבוצות - אריתמטיקה של סודרים</a>
    
    
      <a class="next" href="/2023/01/24/cardinals/">תורת הקבוצות - עוצמות &raquo;</a>
    
  </div><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://gadial.net/2023/01/18/classes_and_transfinite/';
      this.page.identifier = 'http://gadial.net/2023/01/18/classes_and_transfinite/';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://not-precise.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/2023/01/18/classes_and_transfinite/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">לא מדויק</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">לא מדויק</li><li><a class="u-email" href="mailto:gadial@gmail.com">gadial@gmail.com</a></li><li>&copy; כל הזכויות שמורות לגדי אלכסנדרוביץ'</li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/%D7%9C%D7%90-%D7%9E%D7%93%D7%95%D7%99%D7%A7-163347110378474"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">לא מדויק</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>RSS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>בלוג על מתמטיקה ומדעי המחשב</p>
      </div>
    </div>

  </div>

</footer><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script>

<!-- Default Statcounter code for New blog
http://www.gadial.net/ -->
<script type="text/javascript">
  var sc_project=5444342; 
  var sc_invisible=1; 
  var sc_security="4a89cbe4"; 
  </script>
  <script type="text/javascript"
  src="https://www.statcounter.com/counter/counter.js"
  async></script>
  <noscript><div class="statcounter"><a title="Web Analytics"
  href="https://statcounter.com/" target="_blank"><img
  class="statcounter"
  src="https://c.statcounter.com/5444342/0/4a89cbe4/1/"
  alt="Web Analytics"></a></div></noscript>
  <!-- End of Statcounter Code --></body>

</html>
