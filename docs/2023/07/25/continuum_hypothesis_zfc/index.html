<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>בעקבות השערת הרצף, חלק ב&#39;: האקסיומות של צרמלו-פרנקל - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2023/07/25/continuum_hypothesis_zfc/">
    <meta property="og:title" content="בעקבות השערת הרצף, חלק ב&#39;: האקסיומות של צרמלו-פרנקל">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="https://gadial.net/assets/img/main/forcing.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary_large_image">


    <meta name="twitter:url" content="https://gadial.net/2023/07/25/continuum_hypothesis_zfc/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="בעקבות השערת הרצף, חלק ב&#39;: האקסיומות של צרמלו-פרנקל">
    

<meta property="twitter:image" content="https://gadial.net/assets/img/main/forcing.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2023/07/25/continuum_hypothesis_overview/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">בעקבות השערת הרצף, חלק א&#39;: מבוא</span>
            </a>
            

            
            <a href="/2023/07/26/continuum_hypothesis_relativization/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">בעקבות השערת הרצף, חלק ג&#39;: רלטיביזציה ועקרון הרפלקציה</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>בעקבות השערת הרצף, חלק ב&#39;: האקסיומות של צרמלו-פרנקל</h1>
            <div class="post-meta">
                <span class="date">2023-07-25</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הקבוצות.html">תורת הקבוצות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/השערת הרצף.html">השערת הרצף</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>המטרה שלנו בסדרת הפוסטים הנוכחית היא להוכיח שהשערת הרצף היא בלתי תלויה במערכת האקסיומות ZFC, אז כדאי שנתחיל עם הצגה מסודרת של ZFC. אני מניח שהמוטיבציה כבר ברורה כי דיברתי עליה מספיק, אז בואו ניגש לפורמליזם.</p>
<p>ראשית כל, ZFC היא מה שנקרא <strong>תורה מסדר ראשון</strong>. הסברתי את זה לא מזמן <a href="https://gadial.net/2023/01/18/classes_and_transfinite/">כשדיברתי על מחלקות</a>, אבל הנה עוד תזכורת זריזה, פורמלית יותר: באופן כללי, שפה מסדר ראשון נבנית כוללת אוסף של סימנים עבור <strong>יחסים</strong> <span class="math">\(R_{1},R_{2},\ldots,R_{n}\)</span>, עבור <strong>פונקציות</strong> ועבור <strong>קבועים</strong>, אבל במקרה של ZFC אין שימוש בסימני פונקציה או <strong>קבועים</strong> וזה מפשט משמעותית עניינים מסויימים, כך שלא אכנס להגדרות הנוספות שקשורות ליצורים הללו (<a href="https://gadial.net/2012/06/17/first_order_logic/">הנה פוסט שלי</a> על לוגיקה מסדר ראשון כללית, לסקרניות).</p>
<p>אל סימני היחסים אנחנו מצרפים עוד דברים: קבוצה אינסופית בת מניה של סימנים עבור <strong>משתנים</strong>, וסימנים של <strong>קשרים לוגיים</strong> <span class="math">\(\neg,\wedge,\vee,\to,\leftrightarrow\)</span> <strong>וכמתים לוגיים</strong> <span class="math">\(\forall,\exists\)</span> וסימנים לסוגריים. מכל אלו בונים <strong>נוסחאות</strong> על פי ההגדרה הרקורסיבית הבאה:</p>
<ul> <li>אם <span class="math">\(R\)</span> הוא סימן יחס עם <span class="math">\(n\)</span> מקומות ו-<span class="math">\(x_{1},\ldots,x_{n}\)</span> הם משתנים כלשהם (לאו דווקא <span class="math">\(n\)</span> המשתנים הראשונים בקבוצת המשתנים שלנו; כל אוסף של <span class="math">\(n\)</span> משתנים), אז <span class="math">\(R\left(x_{1},\ldots,x_{n}\right)\)</span> היא נוסחה. נוסחאות שנבנות כך נקראות <strong>נוסחאות אטומיות</strong> כי הן הסוג הבסיסי ביותר של נוסחה - זה שלא ניתן לחלק אותו עוד ועדיין לקבל נוסחה.</li>


<li>אם <span class="math">\(\varphi,\psi\)</span> הן נוסחאות אז <span class="math">\(\left(\neg\varphi\right),\left(\varphi\wedge\psi\right),\left(\varphi\vee\psi\right),\left(\varphi\to\psi\right),\left(\varphi\leftrightarrow\psi\right)\)</span> הן נוסחאות.</li>


<li>אם <span class="math">\(\varphi\)</span> היא נוסחה ו-<span class="math">\(x\)</span> הוא משתנה אז <span class="math">\(\left(\forall x\varphi\right)\)</span> ו-<span class="math">\(\left(\exists x\varphi\right)\)</span> הן נוסחאות.</li>

</ul>

<p>אני כותב פה סוגריים כי הן הכרחיות לצורך זה שתהיה דרך אחת ויחידה לקרוא נוסחה, אבל לרוב אני אשמיט אותן אם אין בהן צורך.</p>
<p>בשפה של ZFC יש שני סימני יחס: <span class="math">\(\in\)</span> ו-<span class="math">\(=\)</span>. הסימן <span class="math">\(=\)</span> באופן כללי בשפות מסדר ראשון הוא מיוחד; אסביר את זה כשנדבר על הסמנטיקה של נוסחאות, מה שיקרה בהמשך. עוד דבר שיהיה ברור יותר בהמשך הוא למה קוראים לשפה כזו "מסדר ראשון" ומה זה סדר גבוה יותר; הכוונה היא שהכמתים <span class="math">\(\forall,\exists\)</span> מתייחסים לאיברים ספציפיים, לא <strong>לאוספים</strong> של איברים (זה מבלבל במיוחד בהקשר שלנו כי "איבר" הוא קבוצה, וגם "אוסף של איברים" הוא קבוצה, אז אני אתן דוגמא שאני מקווה שתקל על העניין).</p>
<p>הגדרה אחת אחרונה היא של משתנה חופשי ומשתנה קשור. לא פורמלית, משתנה הוא <strong>חופשי</strong> בתוך נוסחה מסויימת אם הוא לא נופל תחת כמת עבורו בתוך הנוסחה, ו<strong>קשור</strong> אם הוא לא חופשי. למשל בנוסחה <span class="math">\(\forall x\left(x=y\right)\)</span> המשתנה <span class="math">\(y\)</span> הוא חופשי (כי הוא נופל רק תחת הכמת <span class="math">\(\forall x\)</span> שמיועד עבור <span class="math">\(x\)</span> ולא עבורו והמשתנה <span class="math">\(x\)</span> הוא קשור.</p>
<p>אם <span class="math">\(\varphi\)</span> היא נוסחה אטומית, המשתנים שמופיעים בה כולם חופשיים. המשתנים החופשיים בנוסחאות כמו <span class="math">\(\left(\neg\varphi\right),\left(\varphi\wedge\psi\right),\left(\varphi\vee\psi\right),\left(\varphi\to\psi\right),\left(\varphi\leftrightarrow\psi\right)\)</span> הם המשתנים החופשיים של <span class="math">\(\varphi,\psi\)</span>. לעומת זאת, המשתנים החופשיים של <span class="math">\(\left(\forall x\varphi\right)\)</span> ושל <span class="math">\(\left(\exists x\varphi\right)\)</span> הם המשתנים החופשיים של <span class="math">\(\varphi\)</span> למעט <span class="math">\(x\)</span> אם הוא הופיע במשתנים החופשיים הללו.</p>
<p>לבסוף, אנחנו אומרים על נוסחה שהיא <strong>פסוק</strong> אם אין בה משתנים חופשיים. הסיבה שזו סיטואציה מעניינת היא שערך האמת של פסוק לא תלוי בהשמה ספציפית למשתנים שלו; מרגע שקבענו מה הקונטקסט (מה ה"יקום" שממנו נלקחים איברים ומה המשמעות של סימן היחס <span class="math">\(\in\)</span>) ערך האמת של הפסוק נקבע באופן יחיד. כל האקסיומות שאנחנו הולכים לנסח יהיו פסוקים, כי הרעיון הוא שמרגע שקבענו יקום מתמטי אנחנו יכולים להגיד האם הוא מקיים את ZFC או לא מקיים את ZFC; זה לא משהו שאמור להיות תלוי בהשמה מסויימת למשתנים.</p>
<p>עכשיו אפשר לנסח את אקסיומות ZFC. כולן, עד לאחרונה שבהן. אני קודם אתן לכל אחת תיאור מילולי, ואחר כך אציג את כולן ברמה הפורמלית. הדבר היחיד שקריטי לזכור הוא שב-ZFC <strong>כל האיברים הם קבוצות</strong>. לכן אם אני אומר "קבוצה <span class="math">\(X\)</span>" אין לי צורך לומר "קבוצה <span class="math">\(X\)</span> שכל אבריה הן קבוצות". בהמשך נבין באיזה מובן האקסיומות אכן גורמות לכך שכל האיברים יהיו קבוצות.</p>
<ul> <li>(היקפיות): אם לשתי קבוצות יש את אותם איברים, הן שוות.</li>


<li>(זיווג) לכל שתי קבוצות <span class="math">\(x,y\)</span> קיימת הקבוצה <span class="math">\(\left\{ x,y\right\} \)</span>.</li>


<li>(איחוד) לכל קבוצה <span class="math">\(X\)</span> קיימת הקבוצה <span class="math">\(\bigcup X\)</span>.</li>


<li>(קבוצת החזקה): לכל קבוצה <span class="math">\(x\)</span>, הקבוצה <span class="math">\(\mathcal{P}\left(x\right)\)</span> של כל תתי הקבוצות של <span class="math">\(x\)</span> קיימת.</li>


<li>(יסוד): לכל קבוצה לא ריקה קיים איבר מינימלי ביחס ל-<span class="math">\(\in\)</span>.</li>


<li>(אינסוף): קיימת קבוצה <span class="math">\(x\)</span> כך ש-<span class="math">\(\emptyset\in x\)</span> ואם <span class="math">\(y\in x\)</span> אז גם <span class="math">\(y\cup\left\{ y\right\} \in x\)</span>.</li>


<li>(סכמת ההפרדה): לכל קבוצה <span class="math">\(x\)</span> תת-הקבוצה של האיברים <span class="math">\(u\in x\)</span> שעבורם <span class="math">\(\varphi\)</span> מתקיים קיימת.</li>


<li>(סכמת ההחלפה): לכל <span class="math">\(x\)</span>, אם <span class="math">\(\varphi\left(u,v\right)\)</span> שמצומצמת ל-<span class="math">\(x\)</span> היא פונקציה <span class="math">\(x\)</span> אז הקבוצה <span class="math">\(\varphi\left(x\right)\)</span> קיימת.</li>


<li>(בחירה): לכל אוסף <span class="math">\(X\)</span> של קבוצות לא ריקות קיימת פונקציית בחירה: <span class="math">\(f:X\to\bigcup X\)</span> כך ש-<span class="math">\(f\left(a\right)\in a\)</span> לכל <span class="math">\(a\in X\)</span>.</li>

</ul>

<p>נקודה אחת שצריך לשים לב אליה כבר עכשיו: סכמת ההפרדה וסכמת ההחלפה הן לא אקסיומות בודדות; הן <strong>סכמות</strong>, כלומר הן אוסף אינסופי של אקסיומות, אחת לכל נוסחה <span class="math">\(\varphi\)</span> אפשרית. בסכמת ההפרדה אנחנו מניחים שב-<span class="math">\(\varphi\)</span> יש משתנה חופשי יחיד ובסכמת ההחלפה אנחנו מניחים שב-<span class="math">\(\varphi\)</span> יש שני משתנים חופשיים, אבל זהו; לכל נוסחה שמתאימה כך לאחת מהסכמות קיימת אקסיומה ב-ZFC.</p>
<p>עכשיו אפשר לראות את הניסוח הפורמלי עד הסוף. כדי לעשות אותו קצת קל יותר לקריאה אני אשתמש במשתנים <span class="math">\(A,B\)</span> כדי לתאר קבוצות, <span class="math">\(x,y,z\)</span> כדי לתאר "איברים של קבוצות" (שהם בעצמם קבוצות כמובן) ו-<span class="math">\(\mathcal{F}\)</span> כדי לתאר "משפחה של קבוצות" (שגם היא קבוצה, כמובן).</p>
<ul> <li>(היקפיות): <span class="math">\(\forall A\forall B\left(\forall x\left(x\in A\leftrightarrow x\in B\right)\to A=B\right)\)</span></li>


<li>(זיווג): <span class="math">\(\forall x\forall y\exists A\left(x\in A\wedge y\in A\right)\)</span></li>


<li>(איחוד): <span class="math">\(\forall\mathcal{F}\exists X\left(\forall A\forall x\left(\left(A\in\mathcal{F}\wedge x\in A\right)\to x\in X\right)\right)\)</span></li>


<li>(קבוצת החזקה): <span class="math">\(\forall A\exists X\forall B\left(\forall x\left(x\in B\to x\in A\right)\to B\in X\right)\)</span></li>

</ul>

<p>עד עכשיו הפורמליזציה הייתה די פשוטה, אבל כבר בקבוצת החזקה אפשר להרגיש שהסימונים מתחילים להסתרבל לנו. דרך מקוצרת לכתוב את אקסיומת קבוצת החזקה היא על ידי</p>
<p><span class="math">\(\forall A\exists X\forall B\left(B\subseteq A\to B\in X\right)\)</span></p>
<p>כאשר <span class="math">\(B\subseteq A\)</span> הוא <strong>סימון לא פורמלי</strong>, כלומר, הסימן <span class="math">\(\subseteq\)</span> הוא לא סימן יחס, הוא פשוט כתיב מקוצר; אנחנו כותבים <span class="math">\(B\subseteq A\)</span> במקום לכתוב את הנוסחה <span class="math">\(\forall x\left(x\in B\to x\in A\right)\)</span> שהופיעה קודם. נזדקק לגישה המקוצרת הזו אם לא נרצה להשתגע כשיגיע הזמן לנסח את אקסיומת האינסוף, למשל.</p>
<p>נקודה אחרת שצריך לשים לב אליה הוא שאקסיומות הזיווג, האיחוד וקבוצת החזקה, בהגדרה הפורמלית שלהן, <strong>לא</strong> אומרות שהקבוצות שהן מיועדות להבטיח את קיומן אכן קיימות. הן רק מראות שקיימת קבוצה <strong>שמכילה</strong> אותן. למשל, אקסיומת הזיווג אומרת שקיימת <span class="math">\(A\)</span> שמכילה גם את <span class="math">\(x\)</span> וגם את <span class="math">\(y\)</span>; היא לא אומרת ש-<span class="math">\(A=\left\{ x,y\right\} \)</span>, ולא שוללת את האפשרות שיש ב-<span class="math">\(A\)</span> עוד איברים. זה מכוון, כי עכשיו אפשר להכניס לתמונה את סכמת אקסיומת ההפרדה.</p>
<p>בואו ננסח את אקסיומת ההפרדה הכי פורמלי שאפשר. ניקח נוסחה <span class="math">\(\varphi\left(u,p_{1},\ldots,p_{n}\right)\)</span> <strong>כלשהי</strong> כך שהמשתנים החופשיים שלה שייכים לקבוצה <span class="math">\(\left\{ x,p_{1},\ldots,p_{n}\right\} \)</span>. קונספטואלית אנחנו חושבים על <span class="math">\(p_{1},\ldots,p_{n}\)</span> בתור משתנים שמגדירים <strong>פרמטרים</strong> ועל <span class="math">\(x\)</span> בתור המשתנה שמקבל את האיברים שבודקים את שייכותם לתת-הקבוצה שאקסיומת ההפרדה בונה. עכשיו אפשר לעבור לאקסיומה עצמה:</p>
<ul> <li>(סכמת אקסיומת ההפרדה): <span class="math">\(\forall A\forall p_{1}\ldots\forall p_{n}\exists B\forall x\left(x\in B\leftrightarrow x\in A\wedge\varphi\right)\)</span></li>

</ul>

<p>כלומר, בהינתן קבוצה <span class="math">\(A\)</span> והשמה כלשהי של ערכים לפרמטרים, קיימת קבוצה <span class="math">\(B\)</span> שכל איבריה הם בדיוק האיברים של <span class="math">\(A\)</span> שעל הדרך גם מספקים את <span class="math">\(\varphi\)</span> עם הפרמטרים הנתונים.</p>
<p>בואו נשתמש בזה כדי לייצר את הקבוצות של אקסיומות הזיווג/איחוד/קבוצת החזקה. עבור הזיווג, נשתמש בנוסחה <span class="math">\(z=x\vee z=y\)</span> (כאשר כאן <span class="math">\(z\)</span> הוא המשתנה שמייצג את האיבר שאנחנו "מסננים" מתוך <span class="math">\(A\)</span>) - הנוסחה הזו מבטיחה שהאיבר שאנחנו מסננים יהיה או <span class="math">\(x\)</span> או <span class="math">\(y\)</span> ושום דבר פרט אליהם.</p>
<p>עבור איחוד הקבוצות ששייכות ל-<span class="math">\(X\)</span>, נשתמש בנוסחה <span class="math">\(\exists A\left(A\in X\wedge z\in A\right)\)</span> שמבטיחה שנסנן רק איברים שנמצאים באחת מהקבוצות ב-<span class="math">\(X\)</span>. ועבור קבוצת החזקה, נשתמש בנוסחה <span class="math">\(\exists B\left(B\subseteq A\wedge z\in B\right)\)</span> (כאן השתמשנו שוב ב-<span class="math">\(\subseteq\)</span> בתור קיצור לנוסחה מורכבת יותר).</p>
<p>אם כבר הצגתי סכמת אקסיומות אחת, למה לא להציג את השניה, סכמת אקסיומת ההחלפה? כזכור, אקסיומת ההחלפה מניחה שאנחנו עובדים עם נוסחה <span class="math">\(\varphi\)</span> שמייצגת <strong>פונקציה</strong>: זה אומר שהיא מקבלת שני קלטים, ואולי פרמטרים נוספים: <span class="math">\(\varphi\left(x,y,p_{1},\ldots,p_{n}\right)\)</span>. הדרישה היא שלכל <span class="math">\(x\)</span> יהיה קיים <span class="math">\(y\)</span> <strong>יחיד</strong> שעבורו <span class="math">\(\varphi\left(x,y,p_{1},\ldots,p_{n}\right)\)</span> מתקיים. אפשר לנסח את זה יחסית בקלות כנוסחה:</p>
<p><span class="math">\(\exists y\varphi\left(x,y,p_{1},\ldots,p_{n}\right)\wedge\left(\forall z\varphi\left(x,z,p_{1},\ldots,p_{n}\right)\to z=y\right)\)</span></p>
<p>את הנוסחה הזו אני אסמן בצורה מקוצרת בתור <span class="math">\(\exists!y\varphi\left(x,y,p_{1},\ldots,p_{n}\right)\)</span>.</p>
<p>עוד דבר ששווה לכתוב בצורה מקוצרת הוא הגבלה של כמת כך שירוץ רק על אברי קבוצה מסוימת. אני ארצה לכתוב דבר כזה בתור <span class="math">\(\forall x\in A\left(\psi\right)\)</span> או <span class="math">\(\exists x\in A\left(\psi\right)\)</span>. הראשון הוא סימון מקוצר עבור <span class="math">\(\forall x\left(x\in A\to\psi\right)\)</span> והשני עבור <span class="math">\(\exists x\left(x\in A\wedge\psi\right)\)</span>.</p>
<p>כל אלו יקלו עלינו לכתוב את סכמת אקסיומת ההחלפה:</p>
<ul> <li>(סכמת אקסיומת ההחלפה): <span class="math">\(\forall A\forall p_{1}\ldots\forall p_{n}\left(\forall x\in A\exists!y\varphi\to\exists B\forall x\in A\exists y\in B\varphi\right)\)</span></li>

</ul>

<p>גם כאן, שימו לב שזה לא מוכיח באופן ישיר שהקבוצה <span class="math">\(\varphi\left(A\right)\)</span> קיימת; רק שקיימת קבוצה שמכילה את <span class="math">\(\varphi\left(A\right)\)</span> ואפשר לקבל אותה בעזרת אקסיומת ההפרדה.</p>
<p>נשארנו עם שלוש אקסיומות, המורכבות ביותר לניסוח פורמלי: יסוד, אינסוף, ובחירה.</p>
<p>בואו נתחיל מאקסיומת היסוד. באופן לא פורמלי היא אומרת "לכל קבוצה לא ריקה קיים איבר מינימלי ביחס ל-<span class="math">\(\in\)</span>". כלומר, לכל קבוצה <span class="math">\(A\)</span>, אם <span class="math">\(A\ne\emptyset\)</span>, אז קיימת <span class="math">\(B\in A\)</span> כך ש... מה? איך מנסחים את "<span class="math">\(B\)</span> מינימלית ביחס ל-<span class="math">\(\in\)</span>"? זה נראה לי מפחיד בהתחלה אבל זה בעצם די פשוט: אם <span class="math">\(B\)</span> <strong>אינה</strong> מינימלית ביחס ל-<span class="math">\(\in\)</span> זה אומר שקיימת ב-<span class="math">\(A\)</span> קבוצה נוספת, <span class="math">\(C\in A\)</span>, כך ש-<span class="math">\(C\in B\)</span>; הרי המשמעות של "<span class="math">\(b\)</span> הוא איבר מינימלי" בהקשר של יחס סדר <span class="math">\(\le\)</span> היא שאין <span class="math">\(c\)</span> כך ש-<span class="math">\(c\le b\)</span>; זה בדיוק מה שמדובר עליו פה. עכשיו, אם הייתה קיימת <span class="math">\(C\)</span> כזו כך ש-<span class="math">\(C\in A\)</span> וגם <span class="math">\(C\in B\)</span>, אז היה מתקיים <span class="math">\(C\in B\cap A\)</span>; זה מה שאני הולך להשתמש בו.</p>
<p>אם כן, בכתיב פורמלי, אפשר לתאר את האקסיומה כך:</p>
<ul> <li>(אקסיומת היסוד): <span class="math">\(\forall A\left(A\ne\emptyset\to\exists B\left(B\in A\wedge B\cap A=\emptyset\right)\right)\)</span></li>

</ul>

<p>זה כתיב פורמלי, אבל עם סימונים מקוצרים שצריך להסביר איך כותבים בצורה מלאה. ראשית, <span class="math">\(A\ne\emptyset\)</span> זו הנוסחה <span class="math">\(\exists x\left(x\in A\right)\)</span>. שנית, <span class="math">\(B\cap A=\emptyset\)</span> זו הנוסחה <span class="math">\(\neg\exists x\left(x\in B\wedge x\in A\right)\)</span>.</p>
<p>את אקסיומת האינסוף כבר ניסחנו בצורה המפורשת שלה - במקום לומר "קיימת קבוצה אינסופית", אמרנו "קיימת קבוצה <span class="math">\(x\)</span> כך ש-<span class="math">\(\emptyset\in x\)</span> ואם <span class="math">\(y\in x\)</span> אז גם <span class="math">\(y\cup\left\{ y\right\} \in x\)</span>". מכאן הפורמליזציה מגיעה מעצמה:</p>
<ul> <li>(אקסיומת האינסוף): <span class="math">\(\exists A\left(\emptyset\in A\wedge\forall x\left(x\in A\to x\cup\left\{ x\right\} \in A\right)\right)\)</span></li>

</ul>

<p>גם כאן השתמשתי בקיצורים. ראשית, <span class="math">\(\emptyset\in A\)</span> הוא קיצור ל-<span class="math">\(\exists y\left(\forall z\neg\left(z\in y\right)\wedge y\in A\right)\)</span>. שנית, <span class="math">\(x\cup\left\{ x\right\} \in A\)</span> זה קיצור ל-<span class="math">\(\exists y\left(y\in A\wedge\forall z\left(z\in y\leftrightarrow\left(z=x\vee z\in x\right)\right)\right)\)</span>.</p>
<p>נשארה רק אקסיומת הבחירה, שאותה אני <strong>באמת</strong> מפחד מלכתוב פורמלי; אולי אפשר פשוט להגיד שקיים לה כתיב פורמלי וזהו? למה הכל חייב להיות קונסטרוקטיבי?</p>
<p>טוב, האמת היא שלא באמת צריך לכתוב את זה פורמלי - תפתחו ספר אקראי בתורת הקבוצות האקסיומטית ותראו שהם לא טורחים לעשות את זה. אפשר גם אולי לנסות לנסח את אקסיומת הבחירה בעזרת ניסוח של עקרון הסדר הטוב או הלמה של צורן ששקולות אליה. אבל אפשר גם פשוט לכתוב את זה:</p>
<ul> <li>(אקסיומת הבחירה): <span class="math">\(\forall A\left(\emptyset\notin A\to\exists f:A\to\bigcup A\forall a\in A\left(f\left(a\right)\in a\right)\right)\)</span></li>

</ul>

<p>כאן הקיצורים באמת קשים לניסוח פורמלי. ב-<span class="math">\(\emptyset\notin A\)</span> קל לטפל, כי זה בסך הכל <span class="math">\(a\in A\to\exists b\left(b\in a\right)\)</span>. אבל קיום של פונקציה <span class="math">\(f\)</span>? פונקציה היא קבוצה של זוגות סדורים שמקיימת כל מני תנאים. צריך קיצורים בתוך הקיצורים. בואו נפרוט את זה צעד-צעד.</p>
<p>ראשית, מופיע שם <span class="math">\(\bigcup A\)</span> וזה מסבך אותי. אז נוסיף לפסוק את <span class="math">\(\exists X\left(\forall B\forall b\left(B\in A\wedge b\in B\right)\to b\in X\right)\)</span> - די דומה לאקסיומת האיחוד שכבר ראינו. אחרי שהוספנו את הנוסחה הזו לפסוק, במקום לכתוב <span class="math">\(\bigcup A\)</span> אפשר לכתוב את <span class="math">\(X\)</span> וזהו. אז כשאני בא לכתוב את <span class="math">\(\exists f:A\to\bigcup A\)</span> אני אראה איך במקום זה כותבים פסוק עבור <span class="math">\(\exists f:A\to B\)</span> עם <span class="math">\(A,B\)</span> כלליים.</p>
<p>ה-<span class="math">\(f:A\to B\)</span> אומר בעצם שלושה דברים:</p>
<ul> <li><span class="math">\(f\)</span> היא קבוצה של זוגות סדורים <span class="math">\(\left(a,b\right)\)</span> כך ש-<span class="math">\(a\in A\)</span> ו-<span class="math">\(b\in B\)</span>.</li>


<li>לכל <span class="math">\(a\in A\)</span> קיים <span class="math">\(b\in B\)</span> כך ש-<span class="math">\(\left(a,b\right)\in f\)</span>.</li>


<li>לכל <span class="math">\(a\in A\)</span> ולכל <span class="math">\(b_{1},b_{2}\in B\)</span>, אם מתקיים <span class="math">\(\left(a,b_{1}\right)\in f\)</span> וגם <span class="math">\(\left(a,b_{2}\right)\in f\)</span> אז <span class="math">\(b_{1}=b_{2}\)</span>.</li>

</ul>

<p>התנאים הללו הם קלים יחסית לניסוח פורמלי, בהינתן שאנחנו יודעים לתאר זוגות סדורים:</p>
<ul> <li><span class="math">\(\forall a\forall b\left(\left(a,b\right)\in f\to\left(a\in A\wedge b\in B\right)\right)\)</span></li>


<li><span class="math">\(\forall a\left(a\in A\to\exists b\left(b\in B\wedge\left(a,b\right)\in f\right)\right)\)</span></li>


<li><span class="math">\(\forall a\forall b_{1}\forall b_{2}\left(\left(\left(a,b_{1}\right)\in f\wedge\left(a,b_{2}\right)\in f\right)\to b_{1}=b_{2}\right)\)</span></li>

</ul>

<p>וגם קל לתאר את <span class="math">\(f\left(a\right)\in a\)</span> בהינתן שאנחנו יודעים לתאר זוגות סדורים:</p>
<ul> <li><span class="math">\(\exists b\left(\left(a,b\right)\in f\wedge b\in a\right)\)</span></li>

</ul>

<p>אז מה שנשאר לי לעשות הוא להסביר איך לתאר משהו כמו <span class="math">\(\left(a,b\right)\in f\)</span>. זה תלוי באופן שבו אנחנו בונים זוגות סדורים מלכתחילה; הבניה הסטנדרטית, <a href="https://gadial.net/2019/10/19/what_is_set_theory/">שהראיתי כבר כאן</a>, היא <span class="math">\(\left(a,b\right)\triangleq\left\{ \left\{ a\right\} ,\left\{ a,b\right\} \right\} \)</span>. אז בתור <span class="math">\(\left(a,b\right)\in f\)</span> אפשר לכתוב</p>
<ul> <li><span class="math">\(\exists A\left(A\in f\wedge A=\left\{ \left\{ a\right\} ,\left\{ a,b\right\} \right\} \right)\)</span></li>

</ul>

<p>אבל איך אני כותב ביטוי כמו <span class="math">\(A=\left\{ \left\{ a\right\} ,\left\{ a,b\right\} \right\} \)</span> פורמלית? הנה בעיה קצת יותר כללית: איך אני כותב <span class="math">\(A=\left\{ a_{1},\ldots,a_{n}\right\} \)</span>, עבור קבוצה סופית <span class="math">\(A\)</span> כלשהי? פשוט מאוד:</p>
<ul> <li><span class="math">\(a_{1}\in A\wedge\ldots\wedge a_{n}\in A\wedge\forall b\left(b\in A\to\left(b=a_{1}\vee\ldots\vee b=a_{n}\right)\right)\)</span></li>

</ul>

<p>כלומר: <span class="math">\(A\)</span> מכילה את כל האיברים <span class="math">\(a_{1},\ldots,a_{n}\)</span> ואם היא מכילה איבר כלשהו, הוא אחד מהם. השתמשתי בשלוש נקודות בתור קיצור כאן, כי פסוקים שונים נכתבים שונה בהתאם למספר האיברים של <span class="math">\(A\)</span>, אבל כל עוד <span class="math">\(A\)</span> סופית אפשר לכתוב פסוק כזה במפורש.</p>
<p>בהינתן שאנחנו יודעים לכתוב פסוק כזה, ברור איך לממש את <span class="math">\(A=\left\{ \left\{ a\right\} ,\left\{ a,b\right\} \right\} \)</span>:</p>
<ul> <li><span class="math">\(\exists B\exists C\left(B=\left\{ a\right\} \wedge C=\left\{ a,b\right\} \wedge A=\left\{ B,C\right\} \right)\)</span></li>

</ul>

<p>שמשתמש בבניה הזו שלוש פעמים. אם ננסה לכתוב במפורש את הנוסחה של אקסיומת הבחירה היא תהיה ארוכה להחריד, אבל למרבה המזל אנחנו לא צריכים את זה.</p>
<p>אם כן - זהו, סיימנו! הצגנו בצורה הכי פורמלית שאפשר את ZFC, מה שייתן לנו תירוץ מעכשיו קצת לחפף בפורמליזם כי אנחנו מבינים איך עושים אותו ושזה אפשרי, וגם שאם מנסים לעשות את זה עד הסוף זה כואב ממש.</p>
<p>לאן הולכים עכשיו? השלב הראשון יהיה להציג באופן פורמלי את הרעיון של צמצום היקום של תורת הקבוצות לכדי "תת-יקום" כלשהו <span class="math">\(\mathcal{M}\)</span> ש-ZFC מתקיימת גם בו במובן מסוים - רעיון שנקרא <strong>רלטיביזציה</strong>. את זה נראה בפוסט הבא.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>