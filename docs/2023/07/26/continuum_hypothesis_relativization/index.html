<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>בעקבות השערת הרצף, חלק ג&#39;: רלטיביזציה ועקרון הרפלקציה - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/new_blog/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/new_blog/">דף הבית</a>
                <a href="/new_blog/random.html">פוסט אקראי</a>
                <a href="/new_blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_blog/2023/07/25/continuum_hypothesis_zfc/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">בעקבות השערת הרצף, חלק ב&#39;: האקסיומות של צרמלו-פרנקל</span>
            </a>
            

            
            <a href="/new_blog/2023/07/26/continuum_hypothesis_relativization_usage/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">בעקבות השערת הרצף, חלק ד&#39;: התמונה הגדולה של ההוכחה</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>בעקבות השערת הרצף, חלק ג&#39;: רלטיביזציה ועקרון הרפלקציה</h1>
            <div class="post-meta">
                <span class="date">2023-07-26</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הקבוצות.html">תורת הקבוצות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/השערת הרצף.html">השערת הרצף</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <h2>מבוא</h2>

<p>המטרה שלנו בסדרת הפוסטים הזו היא להוכיח שהשערת הרצף בלתי תלויה במערכת האקסיומות ZFC, שהצגתי בפוסט הקודם. אסטרטגיית ההוכחה הכללית היא זו: מתוך היקום הגדול של תורת הקבוצות אנחנו הולכים לבנות שני "יקומים זעירים", כך שבשני היקומים הזעירים הללו ZFC מתקיימת במובן מסוים, אבל באחד מהם השערת הרצף היא נכונה בזמן שביקום השני השערת הרצף אינה נכונה. זה יסיים את ההוכחה של אי-תלות השערת הרצף, כי אם היה אפשר להוכיח את השערת הרצף מתוך ZFC המשמעות של כך הייתה ש<strong>בכל</strong> יקום שבו ZFC מתקיימת, גם השערת הרצף מתקיימת (ובדומה גם עבור הפרכה).</p>
<p>זו אסטרטגיה פשוטה אבל בניסוח הפשטני והלא פורמלי שלה היא גם מבלבלת. מה זה בכלל אומר, "יקום זעיר"? זה נשמע ממש מטופש. אז הנה הסבר קצת יותר מפורט.</p>
<p>בפוסט שלי על <a href="https://gadial.net/2012/06/17/first_order_logic/">לוגיקה מסדר ראשון</a> דיברתי על מושג שנקרא "מודל" עבור קבוצת אקסיומות. אני אחזור על זה בקצרה. תורה מסדר ראשון, כמו ZFC מתחילה עם קבוצה של סימני יחס, סימני פונקציה וסימני קבועים, ואז בונים בעזרת הסימונים הללו פסוקים, ולבסוף אוספים חלק מהפסוקים יחד לקבוצה של <strong>אקסיומות</strong> עבור התורה. דווקא ZFC היא לא הדוגמא הכי אינפורמטיבית לנושא, כי יש בה רק שני סימני יחס: <span class="math">\(\in\)</span> ו-<span class="math">\(=\)</span> ואין בה בכלל סימני פונקציה וסימני קבועים. יותר מכך - עם ZFC יש לנו איזו הנחה אינטואיטיבית שיש "יקום יחיד" ש-ZFC אמורה לתאר. אז בואו ניקח דוגמא שונה, מהעולם של <strong>תורת החבורות</strong> (שלא חייבים להכיר בשביל הפוסט הזה).</p>
<p>בשפה של תורת החבורות סימן היחס היחיד הוא <span class="math">\(=\)</span>, אבל יש לנו סימן פונקציה, <span class="math">\(f\)</span> ("כפל") וסימן קבוע <span class="math">\(e\)</span> ("יחידה") והאקסיומות הן</p>
<ol> <li><span class="math">\(\forall a\forall b\forall c\left(f\left(a,f\left(b,c\right)\right)=f\left(f\left(a,b\right),c\right)\right)\)</span></li>


<li><span class="math">\(\forall a\left(f\left(a,e\right)=a\wedge f\left(e,a\right)=a\right)\)</span></li>


<li><span class="math">\(\forall a\exists b\left(f\left(a,b\right)=e\right)\)</span></li>

</ol>

<p>בתור קיצור, במקום לכתוב <span class="math">\(f\left(a,b\right)\)</span> אנחנו כותבים <span class="math">\(a\cdot b\)</span> או אפילו סתם <span class="math">\(ab\)</span>, מה שמפשט את האקסיומות שהופכות להיות </p>
<ol> <li>לכל <span class="math">\(a,b,c\)</span>: <span class="math">\(\left(ab\right)c=a\left(bc\right)\)</span> .</li>


<li>לכל <span class="math">\(a\)</span>: <span class="math">\(a\cdot e=e\cdot a=a\)</span>.</li>


<li>לכל <span class="math">\(a\)</span> קיים <span class="math">\(b\)</span> כך ש-<span class="math">\(ab=e\)</span>.</li>

</ol>

<p>מה שעושים עכשיו הוא להתחיל להסתכל על <strong>מבנים</strong>: מבנה הוא קבוצה <span class="math">\(\mathcal{M}\)</span> של איברים, ובנוסף "פרשנות" שמתאימה לכל סימן יחס בשפה יחס מעל <span class="math">\(\mathcal{M}\)</span> (חוץ מאשר סימן היחס <span class="math">\(=\)</span> שתמיד מייצג שוויון), לכל סימן פונקציה מתאים פונקציה מעל <span class="math">\(\mathcal{M}\)</span> ולכל סימן קבוע מתאים קבוע מתוך <span class="math">\(\mathcal{M}\)</span>. למשל, עבור תורת החבורות, אפשר לקחת <span class="math">\(\mathcal{M}=\mathbb{Z}\)</span> ולהתאים ל-<span class="math">\(f\)</span> את הפונקציה <span class="math">\(+\)</span> (חיבור רגיל) ול-<span class="math">\(e\)</span> להתאים את האיבר <span class="math">\(0\)</span>.</p>
<p>אם נעשה את זה, ונסתכל על שלוש האקסיומות שכתבתי קודם, נראה שהן כולן מתקיימות (כלומר ערך האמת שלהן הוא T) כאשר מפרשים את הסימנים באופן שתיארתי, והכמתים שבפסוקים רצים על האיברים של <span class="math">\(\mathcal{M}\)</span> (כלומר, כשכתוב <span class="math">\(\forall a\)</span> הכוונה היא "לכל <span class="math">\(a\in\mathbb{Z}\)</span>"). במקרה כזה אומרים ש-<span class="math">\(\mathcal{M}\)</span> הוא <strong>מודל</strong> של קבוצת האקסיומות.</p>
<p>עוד מודלים עבור אותן אקסיומות: <span class="math">\(\mathbb{R}\)</span> עם פעולת החיבור הרגילה ו-<span class="math">\(e=0\)</span>; <span class="math">\(\mathbb{Q}\backslash\left\{ 0\right\} \)</span> עם פעולת הכפל הרגיל ו-<span class="math">\(e=1\)</span>; מרחב המטריצות ההפיכות מסדר <span class="math">\(2\times2\)</span> מעל הממשיים, <span class="math">\(Gl_{2}\left(\mathbb{R}\right)\)</span> עם פעולת כפל המטריצות הרגילה ו-<span class="math">\(e=I\)</span>, וכן הלאה. אפשר כמובן גם להציע מבנים שלא יעברו את המחסום של האקסיומות: למשל <span class="math">\(\mathbb{N}\)</span> עם פעולת החיבור הרגילה לא יקיים את האקסיומה השלישית; <span class="math">\(\mathbb{Z}\)</span> עם פעולת החיבור הרגילה ו-<span class="math">\(e=1\)</span> לא יקיים את האקסיומה השניה; ו-<span class="math">\(\mathbb{Z}\)</span> עם פעולת החיסור במקום חיבור לא יקיים את 1. בכל המקרים הללו יש לנו מבנה לגיטימי שפשוט אינו מודל של קבוצת האקסיומות.</p>
<p>עכשיו, הבה ונתבונן על הפסוק הבא:</p>
<ul> <li><span class="math">\(\forall a\forall b\left(f\left(a,b\right)=f\left(b,a\right)\right)\)</span></li>

</ul>

<p>כלומר, לכל <span class="math">\(a,b\)</span> מתקיים <span class="math">\(ab=ba\)</span>. זה פסוק שמתקיים על ידי <span class="math">\(\mathbb{Z}\)</span> ופעולת החיבור הרגילה, אבל לא מתקיים על ידי <span class="math">\(Gl_{2}\left(\mathbb{R}\right)\)</span>. משני אלו אנו מקבלים שמערכת ההוכחה הרגילה שלנו לא יכולה להוכיח את הפסוק הזה מתוך האקסיומות. הסיבה לכך היא שמערכת ההוכחה הרגילה שלנו מקיימת משהו שנקרא <strong>משפט הנאותות</strong>; הוא אומר שאם קבוצת אקסיומות מוכיחה טענה כלשהי, אז נובע מכך שהיא <strong>גוררת אותה לוגית</strong>: כלומר, שכל מודל של האקסיומות הוא גם מודל של הטענה. גם את זה <a href="https://gadial.net/2013/02/23/first_order_logic_proof_system/">תיארתי פה כבר</a> בעבר.</p>
<p>אם כן, בהקשר של תורת החבורות נראה לנו די טבעי שיש לאותה מערכת אקסיומות כמה מודלים שונים - כל מודל הוא חבורה אחרת, וברור לנו שיש המון חבורות בעולם. אבל כשזה מגיע ל-ZFC אולי קצת יותר קשה לעכל את זה כי אנחנו חושבים על ZFC בתור המערכת שבאה לתאר את "כל המתמטיקה" ולכן לכאורה צריך להיות לה רק מודל יחיד, שהוא "כל המתמטיקה". מילת המפתח כאן היא "לכאורה", לא צריך להניח את זה.</p>
<p>בעיה אחרת היא שעד עכשיו התייחסתי אל מבנה בתור <strong>קבוצה</strong>, אבל מלכתחילה העולם המתמטי שעליו אנחנו מדברים בתורת הקבוצות הוא גדול מכדי להיות קבוצה - הוא מה שקראנו לו <strong>מחלקה</strong>. אז הדבר הראשון שאני רוצה לעשות הוא לעזוב את העולם הגדול והמסובך הזה ולבסס את ההוכחה שלנו על מודלים <strong>זעירים</strong> - מודלים שהם קבוצות, וקבוצות קטנות ככל שרק אפשר: אקסיומת האינסוף מחייבת אותן להיות אינסופיות, אבל הן הולכות להיות <strong>בנות מניה</strong>, כלומר האינסוף הקטן ביותר. אני נזהר מאוד לא לומר שהקבוצות הללו יהיו מודלים של ZFC; כפי שנראה בהמשך, זה יהיה <strong>טיפה</strong> יותר מסובך מזה. אבל אני מקווה שזה לפחות מסביר את הבחירה שלי, כשאני מדבר באופן לא פורמלי, לדבר על "יקום זעיר" שבו ZFC מתקיימת.</p>
<p>בואו נעבור לדבר מתמטיקה בצורה יותר קונקרטית.</p>
<h2>רלטיביזציה ורפלקציה</h2>

<p>הכלי הטכני הבסיסי שאנחנו מסתמכים עליו נקרא <strong>רלטיביזציה</strong> של נוסחאות. הרעיון הוא לקחת נוסחה כללית <span class="math">\(\phi\)</span> בשפה של ZFC ולקחת משתנה <span class="math">\(M\)</span> (משתנה שבא לתאר קבוצה) ולשנות את <span class="math">\(\phi\)</span> כך שבכל פעם שבה מופיע כמת, הטווח של הכמת הזה יהיה רק אברי הקבוצה <span class="math">\(M\)</span>. בצורה הזו הנוסחה הכללית <span class="math">\(\phi\)</span> הופכת לנוסחה <span class="math">\(\phi|_{M}\)</span> שהיא <strong>יחסית</strong> ל-<span class="math">\(M\)</span>.</p>
<p>פורמלית:</p>
<ul> <li>אם <span class="math">\(\phi=\forall x\varphi\)</span> אז <span class="math">\(\phi|_{M}=\forall x\left(x\in M\to\varphi\right)\)</span> </li>


<li>אם <span class="math">\(\phi=\exists x\varphi\)</span> אז <span class="math">\(\phi|_{M}=\exists x\left(x\in M\wedge\varphi\right)\)</span> </li>

</ul>

<p>כלומר, במקרה של <span class="math">\(\forall\)</span> אנחנו מצמצמים את הדרישות שלנו מ-<span class="math">\(\varphi\)</span>: במקום ש-<span class="math">\(\varphi\)</span> יתקיים לכל איבר, הוא צריך להתקיים רק לאיברים של <span class="math">\(M\)</span>. עבור <span class="math">\(\exists\)</span> אנחנו מחמירים את הדרישות שלנו: במקום שהוא סתם יתקיים ל-<span class="math">\(x\)</span> כלשהו, אנחנו מוסיפים את הדרישה ש-<span class="math">\(x\in M\)</span>.</p>
<p>בואו נראה דוגמא. אחת מהאקסיומות הפשוטות ביותר של ZFC היא אקסיומת הזיווג:</p>
<p><span class="math">\(\phi=\forall x\forall y\exists A\left(x\in A\wedge y\in A\right)\)</span></p>
<p>ממנה נקבל את האקסיומה היחסית ל-<span class="math">\(M\)</span>:</p>
<p><span class="math">\(\phi|_{M}=\forall x\left(x\in M\to\forall y\left(y\in M\to\exists A\left(A\in M\wedge x\in A\wedge y\in A\right)\right)\right)\)</span></p>
<p>עכשיו הטרמינולוגיה שדיברתי עליה קודם עושה קאמבק: אם <span class="math">\(\phi|_{M}\)</span> מקבלת ערך T אז אומרים על זה ש-<span class="math">\(M\)</span> הוא "מודל" של <span class="math">\(\phi\)</span>, אבל שימו לב שזו סיטואציה שונה ממה שדיברנו עליה קודם: קודם היה לנו פסוק <span class="math">\(\phi\)</span> ואז הבאנו ממקור חיצוני מבנה <span class="math">\(\mathcal{M}\)</span> שיהיה מודל שלו; הפעם <span class="math">\(M\)</span> הוא <strong>משתנה</strong> ולכן הערך שלו נקבע כשאנחנו מסתכלים על השמה כלשהי למשתנים של הפסוק. זה לא משהו שבא "מבחוץ". אבל אפשר לנקוט בגישה שמשלבת את הטוב שבשני העולמות: אם יש לנו קבוצה קונקרטית <span class="math">\(M\)</span> ופסוק <span class="math">\(\phi\)</span> נהוג לסמן <span class="math">\(M\models\phi\)</span> אם <span class="math">\(M\)</span> היא מודל של <span class="math">\(\phi\)</span> (כלומר, הפסוק <span class="math">\(\phi\)</span> מסתפק כאשר הכמתים שמופיעים בו רצים על אברי <span class="math">\(M\)</span>); זה אותו דבר כמו לומר שהנוסחה <span class="math">\(\phi|_{M}\)</span> מסתפקת כאשר אנו מציבים את הקבוצה <span class="math">\(M\)</span> בתוך המשתנה <span class="math">\(M\)</span> שמופיע ב-<span class="math">\(\phi|_{M}\)</span>. יש כאן כפל משמעות מזעזע בסימון: <span class="math">\(M\)</span> מייצג גם קבוצה, וגם את "המשתנה שבו מציבים את הקבוצה". אני לא חושש שזה יגרום לבלבול, כי אפשר להבין מהי <span class="math">\(M\)</span> מתוך ההקשר: האם היא קבוצה, או סימבול שמופיע בתוך נוסחה.</p>
<p>עכשיו יש לנו מספיק טרמינולוגיה כדי שאוכל להציג את "מטרת העל" שלנו בפוסט הזה: אני רוצה שנוכיח שלכל פסוק <span class="math">\(\phi\)</span> קיימת קבוצה <span class="math">\(M\)</span> שהיא פשוטה במיוחד: היא <strong>בת מניה</strong> והיא <strong>טרנזיטיבית</strong>, כך שמתקיים <span class="math">\(\phi\leftrightarrow\phi|_{M}\)</span>. כאן "מתקיים" פירושו שהנוסחה <span class="math">\(\phi\leftrightarrow\phi|_{M}\)</span>, כאשר מציבים את <span class="math">\(M\)</span> בתוך המשתנה <span class="math">\(M\)</span> שבה, היא בעלת ערך T (המשתנה החופשי היחיד בה היה <span class="math">\(M\)</span> ולכן מרגע שהצבנו ערך בתוכו קיבלנו פסוק שערך האמת שלו נקבע באופן יחיד). ה-<span class="math">\(M\)</span> הזו היא מה שכיניתי קודם "יקום זעיר". שימו לב שזה יקום זעיר קונקרטי שמתאים לפסוק אחד ויחיד <span class="math">\(\phi\)</span>; זה לא יקום שמתאים בו זמנית לכל ZFC (וכפי שנראה בהמשך, גם לא נבנה יקום שמתאים בו זמנית <strong>לכל</strong> ZFC, אבל לא נצטרך).</p>
<p>הקיום של <span class="math">\(M\)</span> הזו לכל <span class="math">\(\phi\)</span> נקרא <strong>עקרון השיקוף</strong>; האינטואיציה היא שהתכונות של יקום הקבוצות הגדול משתקפות איכשהו באופן חלקי ביקום הקבוצות הזעיר <span class="math">\(M\)</span>. מרגע שיהיה לנו את היכולת לבנות <span class="math">\(M\)</span>-ים שכאלו, האתגר הנוסף, והמרכזי, יהיה <strong>להרחיב</strong> את ה-<span class="math">\(M\)</span>-ים הללו בצורה שבה מובטח שהשערת הרצף מתקיימת או מובטח שהיא לא מתקיימת, אבל לא נעסוק בזה בפוסט הזה.</p>
<p>בואו ניגש לעיקר העבודה הטכנית. האזהרה שלי היא שמדובר <strong>בהרבה</strong> עבודה טכנית; אני אוכיח סדרה של טענות עד שאוכיח את עקרון השיקוף. אף טענה לא חשובה בפני עצמה ולא אשתמש בהן בהמשך, וההוכחות שלהן הן אמנם נחמדות אבל לא מאירות עיניים - הן משהו שבספרים בעיקר מחפפים כי הקורא יכול להשלים את הפרטים בעצמו (ואני אולי מטרחן אותן בהמשך שלא לצורך). אז בהחלט אפשר לדלג על ההמשך הישר אל הפוסט הבא אם לא רוצים את הפרטים הטכניים; בפוסט הבא אני אחזור על כל מה שרלוונטי.</p>
<h2>רלטיביזציה ואיזומורפיזם</h2>

<p>בואו ניקח נוסחה <span class="math">\(\phi\left(x_{1},\ldots,x_{n}\right)\)</span> כלשהי. ההבדל בין "נוסחה כלשהי" ובין "פסוק" הוא שפסוק הוא מקרה פרטי של נוסחה שאין לה משתנים חופשיים; כשאני כותב את ה-<span class="math">\(x_{i}\)</span>-ים הללו בסוגריים אני מתכוון שהמשתנים החופשיים של <span class="math">\(\phi\)</span> נמנים על <span class="math">\(x_{1},\ldots,x_{n}\)</span> (לאו דווקא שכל אחד מה-<span class="math">\(x_{i}\)</span>-ים הזה הוא משתנה חופשי של <span class="math">\(\phi\)</span>, רק שכל המשתנים החופשיים של <span class="math">\(\phi\)</span> נמנים איתם).</p>
<p>המטרה שלי היא להבין מתי הרלטיביזציה של <span class="math">\(\phi\)</span> לשתי קבוצות שונות <span class="math">\(M,N\)</span> היא "אותו דבר", כחלק מהמאמץ שלי למצוא קבוצה "קנונית נחמדה" (בת מניה וטרנזיטיבית) שאליה נעשה רלטיביזציה. הכלי הסטנדרטי בלוגיקה בהקשר הזה הוא מה שנקרא <strong>איזומורפיזם של מבנים</strong>, שזו פונקציה <span class="math">\(f:M\to N\)</span> שהיא חח"ע ועל ומשמרת את פרשנות יחסי הסדר/קבועים/פונקציות. בשפה שלנו יש רק את יחס הסדר <span class="math">\(\in\)</span> אז הדרישה מ-<span class="math">\(f\)</span>, בנוסף לזה שהיא חח"ע ועל, היא רק שיתקיים <span class="math">\(x\in y\iff f\left(x\right)\in f\left(y\right)\)</span>.</p>
<p>בהינתן <span class="math">\(f\)</span> כזו, הטענה שאנחנו רוצים להוכיח היא זו: לכל <span class="math">\(a_{1},\ldots,a_{n}\in M\)</span>, מתקיים</p>
<p><span class="math">\(\phi|_{M}\left(a_{1},\ldots,a_{n}\right)\leftrightarrow\phi|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span></p>
<p>במילים (שיוצאות הרבה יותר מסורבלות): אם נסתכל על הנוסחה שמתקבלת מכך שלוקחים את <span class="math">\(\phi\)</span>, יוצרים שני עותקים שלו, מבצעים רלטיביזציה לשני העותקים, פעם עם המשתנה <span class="math">\(M\)</span> ופעם עם המשתנה <span class="math">\(N\)</span>, מציבים את הקבוצה <span class="math">\(M\)</span> במשתנה הראשון ואת הקבוצה <span class="math">\(N\)</span> במשתנה השני, ואז ניגשים אל המשתנים החופשיים של העותק הראשון ומציבים בהם <span class="math">\(a_{1},\ldots,a_{n}\)</span> ובמשתנים החופשיים של העותק השני מציבים <span class="math">\(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\)</span> ובסוף לוקחים את שני העותקים ומחברים אותם עם הקשר <span class="math">\(\leftrightarrow\)</span> - אחרי כל המהומה הזו מתקבלת נוסחה אחת עם הצבה עבורה, וערך האמת של הנוסחה בהצבה הזו הוא T.</p>
<p>כדי להוכיח טענות כאלו משתמשים בכלי ההוכחה האהוב עלינו מלוגיקה מתמטית: אינדוקציה על <strong>המבנה</strong> של הנוסחה. כזכור, נוסחה היא או <strong>אטומית</strong> מהצורה <span class="math">\(x_{1}=x_{2}\)</span> או <span class="math">\(x_{1}\in x_{2}\)</span>, או שהיא מהצורה <span class="math">\(\neg\psi\)</span>, או <span class="math">\(\psi_{1}\to\psi_{2}\)</span>, או <span class="math">\(\forall\psi_{1}\)</span>, או... או שום דבר נוסף, בעצם; אפשר להראות שכל קשר וכל כמת אחר ניתן להחלפה באלו הקיימים לקבל נוסחה שקולה, ומספיק להוכיח את הטענה עבור הנוסחה השקולה הזו (אבל איך אומרים? זה <strong>תרגיל טוב</strong> להוכיח גם עבור הקשרים והכמתים האחרים).</p>
<p>אם <span class="math">\(\phi\)</span> היא מהצורה <span class="math">\(x_{1}=x_{2}\)</span> הטענה מאוד פשוטה: רלטיביזציה במקרה הזה לא עושה כלום (כי אין כמתים) ולכן אנחנו רוצים להוכיח שלכל <span class="math">\(a_{1},a_{2}\in M\)</span> מתקיים <span class="math">\(\left(a_{1}=a_{2}\right)\iff\left(f\left(a_{1}\right)=f\left(a_{2}\right)\right)\)</span> , וזה נובע מיידית מכך ש-<span class="math">\(f\)</span> פונקציה חח"ע.</p>
<p>אם <span class="math">\(\phi\)</span> היא מהצורה <span class="math">\(x_{1}\in x_{2}\)</span> אז באופן דומה צריך לראות ש-<span class="math">\(\left(a_{1}\in a_{2}\right)\iff\left(f\left(a_{1}\right)\in f\left(a_{2}\right)\right)\)</span> וזה נובע ישירות מהדרישה ש-<span class="math">\(f\)</span> היא איזומורפיזם (מכאן הדרישה הזו הגיעה, כמובן). אז לטפל במקרי הבסיס סיימנו.</p>
<p>עכשיו, נניח ש-<span class="math">\(\phi=\left(\neg\psi\right)\)</span>, אז</p>
<p><span class="math">\(\phi|_{M}=\left(\neg\psi\right)|_{M}=\neg\left(\psi|_{M}\right)\)</span></p>
<p>כי כאשר מבצעים רלטיביזציה לנוסחה, זה משפיע רק על המקומות שבהם מופיע כמת, לא על הקשר הלוגי החיצוני. עכשיו, אנחנו מניחים באופן אינדוקטיבי שהטענה כבר הוכחה עבור <span class="math">\(\psi\)</span>, כלומר</p>
<p><span class="math">\(\psi|_{M}\left(a_{1},\ldots,a_{n}\right)\leftrightarrow\psi|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span></p>
<p>בגלל השקילות בין שני האגפים (שמשמעותה שבהצבה שעליה אנו מסתכלים שניהם מקבלים את אותו ערך אמת), אם נוסיף <span class="math">\(\neg\)</span> בהתחלה של כל אחד מהם נהפוך את ערך האמת שהוא מקבל, אבל שניהם עדיין יקבלו את אותו ערך אמת ולכן הנוסחה כולה עדיין תהיה T.</p>
<p>עבור <span class="math">\(\phi=\left(\psi_{1}\to\psi_{2}\right)\)</span> קורה משהו דומה - רלטיביזציה משפיעה רק על תתי-הפסוקים, כלומר</p>
<p><span class="math">\(\phi|_{M}=\left(\psi_{1}\to\psi_{2}\right)|_{M}=\left(\psi_{1}|_{M}\to\psi_{2}|_{M}\right)\)</span></p>
<p>נאחד את קבוצות המשתנים החופשיים שמופיעים ב-<span class="math">\(\psi_{1}\)</span> וב-<span class="math">\(\psi_{2}\)</span> ונסמן את קבוצת המשתנים שקיבלנו ב-<span class="math">\(x_{1},\ldots,x_{n}\)</span> (הנה מקום שבו אנחנו משתמשים בזה שהמשתנים שנכתבים בסוגריים עשויים להיות יותר מאשר המשתנים החופשיים של הנוסחה), ניקח ערכים <span class="math">\(a_{1},\ldots,a_{n}\in M\)</span> ונקבל מהנחת האינדוקציה</p>
<p><span class="math">\(\psi_{1}|_{M}\left(a_{1},\ldots,a_{n}\right)\leftrightarrow\psi_{1}|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span></p>
<p><span class="math">\(\psi_{2}|_{M}\left(a_{1},\ldots,a_{n}\right)\leftrightarrow\psi_{2}|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span></p>
<p>משני אלו אנחנו רוצים להסיק ש-</p>
<p><span class="math">\(\left(\psi_{1}\to\psi_{2}\right)|_{M}\left(a_{1},\ldots,a_{n}\right)\leftrightarrow\left(\psi_{1}\to\psi_{2}\right)|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span></p>
<p>כדי להראות את זה צריך להראות ששני האגפים מקבלים את אותו ערך אמת. הדרך היחידה שבה אגף שמאל יכול לקבל F היא אם <span class="math">\(\psi_{1}|_{M}\left(a_{1},\ldots,a_{n}\right)\)</span> מקבל T וגם <span class="math">\(\psi_{2}|_{M}\left(a_{1},\ldots,a_{n}\right)\)</span> מקבל F, והשקילויות שקיבלנו מהנחת האינדוקציה מראות שבמקרה הזה <span class="math">\(\psi_{1}|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span> מקבל T ו-<span class="math">\(\psi_{2}|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span> מקבל F ולכן גם אגף ימין מקבל F בסך הכל והשקילות נשמרת; אותו הדבר אפשר לעשות גם בכיוון השני, אם מניחים שאגף ימין מקבל F.</p>
<p>כל זה הוא בעצם דרך לומר בהרבה מלל משהו שנראה טריוויאלי לגמרי. איפה החלק המסובך של ההוכחה? כמובן, כשמכניסים כמתים לתמונה.</p>
<p>אם כן, נסתכל על <span class="math">\(\phi=\forall x_{i}\psi\left(x_{1},\ldots,x_{n}\right)\)</span>. הוספת הכמת ל-<span class="math">\(\phi\)</span> עלולה לגרום לאחד מהמשתנים החופשיים של <span class="math">\(\psi\)</span> להיעלם - להפוך למשתנה קשור, וכזה שכבר לא מציבים בו <span class="math">\(a_{i}\)</span>. בנוסף, רלטיביזציה של <span class="math">\(\phi\)</span> הולכת לשנות אותו: נקבל את</p>
<p><span class="math">\(\phi|_{M}=\forall x_{i}\left(x_{i}\in M\to\psi\left(x_{1},\ldots,x_{n}\right)\right)\)</span></p>
<p>עכשיו, מה הנחת האינדוקציה נותנת לנו כאן? אנחנו יודעים שלכל <span class="math">\(a_{1},\ldots,a_{n}\in M\)</span> מתקיים</p>
<p><span class="math">\(\psi|_{M}\left(a_{1},\ldots,a_{n}\right)\leftrightarrow\psi|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span></p>
<p>ומה שאנחנו צריכים לעשות הוא להראות שלכל <span class="math">\(a_{1},\ldots,a_{i-1},a_{i+1},\ldots,a_{n}\in M\)</span> מתקיים</p>
<p><span class="math">\(\phi|_{M}\left(a_{1},\ldots,a_{n}\right)\leftrightarrow\phi|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span></p>
<p>נניח שתחת ההשמה שמציבה את הערכים הללו במשתנים (ואת <span class="math">\(M,N\)</span> במשתנים המתאימים שלהם) אגף שמאל מקבל T. אנחנו צריכים להוכיח שגם אגף ימין מקבל T. בשלב הזה אגף ימין הוא</p>
<p><span class="math">\(\phi|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span></p>
<p>או, אם נפתח את ההגדרה של <span class="math">\(\phi|_{N}\)</span>, אגף ימין הוא</p>
<p><span class="math">\(\forall x_{i}\left(x_{i}\in N\to\psi|_{N}\left(f\left(a_{1}\right),\ldots,x_{i},\ldots,f\left(a_{1}\right)\right)\right)\)</span></p>
<p>זה אומר שכדי להראות שהאגף הזה הוא T, צריך להראות שלכל הצבה של ערך <span class="math">\(b\)</span> ב-<span class="math">\(x_{i}\)</span>, <strong>אם</strong> <span class="math">\(b\in N\)</span> <strong>אז</strong> <span class="math">\(\psi|_{N}\left(f\left(a_{1}\right),\ldots,b,\ldots,f\left(a_{1}\right)\right)=\text{T}\)</span>.</p>
<p>האתגר התקבל! בואו ניקח ערך <span class="math">\(b\)</span> כזה ונניח ש-<span class="math">\(b\in N\)</span> אחרת אין לנו מה לעשות. עכשיו אנחנו סוף כל סוף משתמשים בתכונה של <span class="math">\(f\)</span> שטרם השתמשנו בה: <span class="math">\(f:M\to N\)</span> היא <strong>פונקציה על</strong> ולכן קיים <span class="math">\(a\in M\)</span> כך ש-<span class="math">\(f\left(a\right)=b\)</span>. מכאן שמה שצריך להראות הוא</p>
<p><span class="math">\(\psi|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a\right),\ldots,f\left(a_{1}\right)\right)=\text{T}\)</span></p>
<p>עכשיו, בואו ניזכר מה הנחת האינדוקציה נתנה לנו; היא נתנה את </p>
<p><span class="math">\(\psi|_{M}\left(a_{1},\ldots,a_{n}\right)\leftrightarrow\psi|_{N}\left(f\left(a_{1}\right),\ldots,f\left(a_{n}\right)\right)\)</span></p>
<p>אז מספיק אם נוכיח שעבור <span class="math">\(a_{1},\ldots,a_{i-1},a,a_{i+1},\ldots,a_{n}\)</span> מתקיים</p>
<p><span class="math">\(\psi|_{M}\left(a_{1},\ldots,a_{n}\right)=\text{T}\)</span></p>
<p>לצורך כך, בואו ניזכר בהנחה שהתחלנו איתה את השלב הזה בהוכחה, איפה שכתבתי "אגף שמאל מקבל T". אותו אגף שמאל היה</p>
<p><span class="math">\(\phi|_{M}\left(a_{1},\ldots,a_{n}\right)\)</span></p>
<p>וכשפותחים את ההגדרה, מקבלים</p>
<p><span class="math">\(\forall x_{i}\left(x_{i}\in M\to\psi|_{M}\left(a_{1},\ldots,x_{i},\ldots,a_{n}\right)\right)\)</span></p>
<p>ולכן, אם הנוסחה הזו מקבלת ערך T תחת ההשמה הנתונה, היא בפרט מקבלת ערך T אם מציבים ב-<span class="math">\(x_{i}\)</span> את <span class="math">\(a\)</span>. מכיוון ש-<span class="math">\(a\in M\)</span> אז נובע מכך</p>
<p><span class="math">\(\psi|_{M}\left(a_{1},\ldots,a,\ldots,a_{n}\right)=\text{T}\)</span></p>
<p>וזה בדיוק מה שרצינו. זה מסיים את הכיוון הזה של ההוכחה; צריך גם להתחיל עם ההנחה שאגף ימין הוא T ולהוכיח שאגף שמאל הוא T אבל זה אותו רעיון, רק קצת קל יותר כי לא צריך להשתמש בכך ש-<span class="math">\(f\)</span> היא על (אלא רק בכך שהיא פונקציה, כלומר מוגדרת לכל <span class="math">\(M\)</span>).</p>
<h2>שובן של הקבוצות הטרנזיטיביות</h2>

<p>עכשיו, כשיש לנו את הכלי החדש של איזומורפיזם, בואו נשתמש בו! הרעיון הוא למצוא לכל מבנה <span class="math">\(M\)</span> מבנה איזומורפי <span class="math">\(N\)</span> שהוא "נחמד". כרגע "נחמד" עבורי יהיה <strong>טרנזיטיבי</strong>. כזכור, קבוצה היא טרנזיטיבית אם כל איבר שלה הוא תת-קבוצה שלה; זו התכונה הבסיסית שמאחורי סודרים, למשל (אבל יש קבוצות טרנזיטיביות שאינן סודרים; סודר צריך להיות גם טרנזיטיבי וגם סדור בסדר טוב).</p>
<p>לא נוכל למצוא דבר כזה עבור <strong>כל</strong> קבוצה <span class="math">\(M\)</span>; בהוכחה נראה מה שהכרחי הוא ש<strong>אקסיומת ההיקפיות</strong> תהיה ניתנת לרלטיביזציה אל <span class="math">\(M\)</span>. מה זה אומר? כזכור, אקסיומת ההיקפיות היא "שתי קבוצות הן שוות אם ורק אם יש להן אותם איברים":</p>
<p><span class="math">\(\forall A\forall B\left(\forall x\left(x\in A\leftrightarrow x\in B\right)\to A=B\right)\)</span></p>
<p>אז הרלטיביזציה של זה אומרת "לכל <span class="math">\(A,B\in M\)</span> , אם <span class="math">\(A\cap M=B\cap M\)</span> אז <span class="math">\(A=B\)</span>": אין שתי קבוצות שונות ב-<span class="math">\(M\)</span> ש"החלק שלהן שמוכל ב-<span class="math">\(M\)</span>" נראה אותו דבר. או בניסוח אחר: כדי להראות ש-<span class="math">\(A\ne B\)</span> צריך להציג איבר ששייך לאחת הקבוצות אבל לא לשנייה; מובטח לנו שאחד מהאיברים הללו יהיה שייך ל-<span class="math">\(M\)</span>.</p>
<p>לקבוצה <span class="math">\(M\)</span> שמקיימת את התכונה הזו נקרא <strong>היקפית</strong> והטענה היא שלכל קבוצה היקפית קיימת ויחידה קבוצה טרנזיטבית <span class="math">\(N\)</span> כך ש-<span class="math">\(M\cong N\)</span> על פי הגדרת האיזומורפיזם שראינו קודם. ההוכחה לא תהיה קלה, אבל למרבה השמחה היא תהיה כולה "תורת-קבוצתית" באופיה ולא "לוגיקה מסדר ראשון-ית" באופיה כמו הקודמת.</p>
<p>הוכחת היחידות היא קלה יותר, אז נתחיל ממנה. נניח שקיימות <span class="math">\(N_{1}\ne N_{2}\)</span> כך ש-<span class="math">\(N_{1}\cong M\cong N_{2}\)</span>. מטרנזיטיביות האיזומורפיזם נקבל <span class="math">\(N_{1}\cong N_{2}\)</span>; נסמן את האיזומורפיזם הזה ב-<span class="math">\(g\)</span>. מכיוון ש-<span class="math">\(N_{1}\ne N_{2}\)</span> אז <span class="math">\(g\)</span> הוא לא הזהות, כלומר קיים <span class="math">\(a\in N_{1}\)</span> כך ש-<span class="math">\(g\left(a\right)\ne a\)</span>, ובעזרת אקסיומת היסוד אפשר לבחור את <span class="math">\(a\)</span> להיות האיבר המינימלי של <span class="math">\(N_{1}\)</span> ביחס ל-<span class="math">\(\in\)</span> שמקיים את התכונה הזו.</p>
<p>עכשיו משתמשים בטריק די סטנדרטי עבור קבוצות טרנזיטיביות: מכיוון ש-<span class="math">\(N_{1},N_{2}\)</span> טרנזיטיביות, אז <span class="math">\(a\subseteq N_{1}\)</span> ו-<span class="math">\(g\left(a\right)\subseteq N_{2}\)</span>. בפרט, לכל <span class="math">\(x\in a\)</span> מתקיים <span class="math">\(a\in N_{1}\)</span> ולכן <span class="math">\(g\)</span> מוגדר על <span class="math">\(x\)</span>, ומכיוון ש-<span class="math">\(g\)</span> היא איזומורפיזם אז <span class="math">\(x\in a\iff g\left(x\right)\in g\left(a\right)\)</span>, כלומר <span class="math">\(g\)</span> היא פונקציה חח"ע ועל בין הקבוצות <span class="math">\(a,g\left(a\right)\)</span>. עכשיו, בגלל המינימליות של <span class="math">\(a\)</span>, אנחנו יודעים שלכל <span class="math">\(x\in a\)</span> מתקיים <span class="math">\(g\left(x\right)=x\)</span>, ולכן מסיקים ש-<span class="math">\(a=g\left(a\right)\)</span>, וזו סתירה לכך שבחרנו את <span class="math">\(a\)</span> להיות איבר שמקיים <span class="math">\(g\left(a\right)\ne a\)</span>, מה שמסיים את החלק הזה של ההוכחה.</p>
<p>גם חלק ה"קיום" הולך להיות דומה לדברים שראינו כשהתעסקנו עם קבוצות טרנזיטיביות, אבל זה עדיין ידרוש מאיתנו עבודה. הרעיון הוא שבהינתן קבוצה היקפית כלשהי <span class="math">\(M\)</span>, אנחנו יכולים להסתכל על תת-קבוצות של <span class="math">\(M\)</span> שאיזומורפיות לקבוצה טרנזיטיבית, ואז להרכיב מכל האיזומורפיזמים הללו איזומורפיזם אחד גדול של <span class="math">\(M\)</span> עם קבוצה טרנזיטיבית. זו גישה סטנדרטית, אבל היא מצריכה זהירות.</p>
<p>ראשית, בואו נסתכל על אותן תת-קבוצות של <span class="math">\(M\)</span> ש"ביחס אל <span class="math">\(M\)</span> נראות טרנזיטיביות". אם טרנזיטיביות של <span class="math">\(A\in M\)</span> פירושה שלכל <span class="math">\(a\in A\)</span> מתקיים <span class="math">\(a\subseteq A\)</span>, כאן אנו רוצים שיתקיים <span class="math">\(a\cap M\subseteq A\)</span>. מבין הקבוצות ה"נראות טרנזיטיביות" הללו אנחנו מתעניינים רק באלו שאיזומורפיות לקבוצה טרנזיטיבית - אני אקרא לקבוצות הללו "קבוצות נחמדות". אני כמובן רוצה להראות ש-<span class="math">\(M\)</span> עצמה היא נחמדה; הטריק יהיה להסתכל על איחוד כל הקבוצות הנחמדות ב-<span class="math">\(M\)</span>, שאסמן <span class="math">\(Z\)</span>, ולהוכיח שני דברים:</p>
<ul> <li><span class="math">\(Z\)</span> היא בעצמה קבוצה נחמדה.</li>


<li><span class="math">\(Z=M\)</span>.</li>

</ul>

<p>דווקא את החלק השני קל להראות. אם <span class="math">\(Z\)</span> נחמדה, אז יש איזומורפיזם <span class="math">\(f:Z\to N\)</span> עבור קבוצה טרנזיטיבית <span class="math">\(N\)</span> כלשהי. עכשיו, אם <span class="math">\(M\ne Z\)</span>, ומכיוון שמלכתחילה <span class="math">\(Z\)</span> היא איחוד של תת-קבוצות של <span class="math">\(M\)</span> ולכן <span class="math">\(Z\subseteq M\)</span>, אנו מקבלים ש- <span class="math">\(M\backslash Z\ne\emptyset\)</span>; ניקח <span class="math">\(a\in M\backslash Z\)</span> מינימלי (ביחס ל-<span class="math">\(\in\)</span>) שמקיים זאת (אפשר, על פי אקסיומת היסוד).</p>
<p>עכשיו נרחיב את האיזומורפיזם <span class="math">\(f\)</span> על ידי ההגדרה <span class="math">\(f\left(a\right)=\left\{ f\left(x\right)\ |\ x\in a\right\} \)</span>; כלומר, הוספנו את <span class="math">\(a\)</span> אל <span class="math">\(Z\)</span>, והוספנו את <span class="math">\(\left\{ f\left(x\right)\ |\ x\in a\right\} \)</span> אל <span class="math">\(N\)</span>. האיבר החדש הזה ב-<span class="math">\(N\)</span> כולל רק איברים של <span class="math">\(N\)</span> ולכן מוכל ב-<span class="math">\(N\)</span> כך שהוספתו לא פוגמת בטרנזיטיביות; את <span class="math">\(f\)</span> הרחבנו על ידי איבר חדש שעובר לאיבר חדש, כך שהפונקציה המתקבלת היא עדיין חח"ע ועל; וכדי להראות שעדיין יש שימור סדר ראשית נשים לב לכך שלא ייתכן ש-<span class="math">\(a\in x\)</span> עבור <span class="math">\(x\in Z\)</span>, כי מכיוון ש-<span class="math">\(Z\)</span> היא קבוצה נחמדה אז <span class="math">\(a\in x\)</span> היה גורר <span class="math">\(a\in Z\)</span>. לכן הדבר היחיד שאפשרי הוא <span class="math">\(x\in a\)</span> עבור <span class="math">\(x\in Z\)</span>, ובסיטואציה כזו <span class="math">\(f\left(x\right)\in f\left(a\right)\)</span> על פי ההגדרה, כך שגם יחס הסדר נשמר.</p>
<p>המסקנה היא שההרחבה הזו של <span class="math">\(Z\)</span> היא עדיין קבוצה נחמדה בעצמה, אבל אם <span class="math">\(Z\)</span> היא איחוד כל הקבוצות הנחמדות, היא לא יכולה להיות מוכלת ממש בקבוצה נחמדה; אנו מקבלים, אם כן, ש-<span class="math">\(Z=M\)</span>.</p>
<p>אבל עדיין לא הוכחנו שאיחוד כל הקבוצות הנחמדות הוא קבוצה נחמדה. התוכנית היא כזו: לכל קבוצה נחמדה <span class="math">\(A\subseteq M\)</span> קיימת קבוצה טרנזיטיבית <span class="math">\(N_{A}\)</span> ואיזומורפיזם <span class="math">\(f_{A}:A\to N_{A}\)</span>. עכשיו נבנה את האיחוד <span class="math">\(\bigcup A\)</span>; אני רוצה לומר שהוא איזומרפי אל <span class="math">\(\bigcup N_{A}\)</span> עם האיזומורפיזם <span class="math">\(\bigcup f_{A}\)</span>. עיקר הקושי הוא להראות שהקבוצה <span class="math">\(\bigcup f_{A}\)</span> היא אכן פונקציה, ולא סתם פונקציה אלא איזומורפיזם; אם יש לנו את זה, צריך להראות ש-<span class="math">\(\bigcup N_{A}\)</span> היא קבוצה טרנזיטיבית אבל זה קל - איחוד של קבוצות טרנזיטיביות הוא טרנזיטיבי ישירות מההגדרה.</p>
<p>אז אנחנו מתמקדים ב-<span class="math">\(f=\bigcup f_{A}\)</span>. הקבוצה הזו נוצרת מכך ש"מדביקים ביחד" את כל ה-<span class="math">\(f_{A}\)</span>-ים השונים. החשש הראשון הוא ש-<span class="math">\(f\)</span> לא תהיה בכלל פונקציה; כלומר, שבקבוצה <span class="math">\(\bigcup f_{A}\)</span> יהיו שני איברים <span class="math">\(\left(a,n_{1}\right),\left(a,n_{2}\right)\)</span> שהורסים את תכונת ה"יחידות" שמגדירה פונקציה (לכל קלט קיים פלט יחיד). עכשיו, אם יש שני איברים כאלו, הם חייבים להגיע משני <span class="math">\(A\)</span>-ים שונים (כי אם הם היו נובעים מאותו <span class="math">\(A\)</span>, כבר <span class="math">\(f_{A}\)</span> לא הייתה פונקציה). אז ניקח קבוצות <span class="math">\(A_{1},A_{2}\)</span> כלשהן עם איזומורפיזמים <span class="math">\(f_{A_{1}}:A_{1}\to N_{1}\)</span> ו-<span class="math">\(f_{A_{2}}:A_{2}\to N_{2}\)</span> ונוכיח שלכל איבר משותף להן, <span class="math">\(a\in A_{1}\cap A_{2}\)</span>, מתקיים <span class="math">\(f_{A_{1}}\left(a\right)=f_{A_{2}}\left(a\right)\)</span>.</p>
<p>בשביל לראות את זה, הנה טענה כללית: אם <span class="math">\(g:A\to N\)</span> הוא איזומורפיזם של קבוצה <span class="math">\(A\subseteq M\)</span> וקבוצה טרנזיטיבית <span class="math">\(N\)</span>, ואם <span class="math">\(B\subseteq A\)</span>, ואם בנוסף לכך <span class="math">\(B\)</span> היא מה שקראתי לו קודם "טרנזיטיבית ביחס ל-<span class="math">\(M\)</span>", אז גם <span class="math">\(g\left(B\right)\)</span> הוא קבוצה טרנזיטיבית (תת-קבוצה של <span class="math">\(N\)</span>). כדי לראות את זה, ניקח <span class="math">\(y\in x\in g\left(B\right)\)</span> ונוכיח ש-<span class="math">\(y\in g\left(B\right)\)</span>: מכיוון ש-<span class="math">\(x\in g\left(B\right)\)</span> קיים <span class="math">\(b_{x}\in B\)</span> כך ש-<span class="math">\(g\left(b_{x}\right)=x\)</span>. עכשיו בגלל ש-<span class="math">\(N\)</span> טרנזיטיבית ו-<span class="math">\(y\in x\in N\)</span> אז <span class="math">\(y\in N\)</span> ומכך ש-<span class="math">\(g\)</span> על נקבל שקיים <span class="math">\(b_{y}\in A\)</span> כך ש-<span class="math">\(g\left(b_{y}\right)=y\)</span>. אבל מכיוון ש-<span class="math">\(g\)</span> איזומורפיזם, <span class="math">\(b_{y}\in b_{x}\iff g\left(b_{y}\right)\in g\left(b_{x}\right)\)</span>, וקיבלנו שיש שרשרת <span class="math">\(b_{y}\in b_{x}\in B\)</span>. מכיוון ש-<span class="math">\(b_{y}\in A\subseteq M\)</span> ומכיוון ש-<span class="math">\(B\)</span> היא טרנזיטיבית ביחס ל-<span class="math">\(M\)</span>, נובע מכך ש-<span class="math">\(b_{y}\in B\)</span> ולכן <span class="math">\(y=g\left(b_{y}\right)\in g\left(B\right)\)</span>, שזה מה שרצינו.</p>
<p>עכשיו אני משתמש במה שהראיתי בפסקה הקודמת זה על החיתוך <span class="math">\(A_{1}\cap A_{2}\)</span>. בשביל זה צריך להראות טרנזיטיביות שלו ביחס ל-<span class="math">\(M\)</span>, וזה נובע מכך שאם <span class="math">\(a\in A_{1}\cap A_{2}\)</span> אז <span class="math">\(a\in A_{1}\)</span> וגם <span class="math">\(a\in A_{2}\)</span> ולכן <span class="math">\(a\cap M\subseteq A_{1}\)</span> וגם <span class="math">\(a\cap M\subseteq A_{2}\)</span> ולכן <span class="math">\(a\cap M\subseteq A_{1}\cap A_{2}\)</span>. מכל זה קיבלנו ש-<span class="math">\(A_{1}\cap A_{2}\)</span> היא אכן קבוצה נחמדה.</p>
<p>איך זה עוזר לנו? בקלות: אני מסתכל על התמונות <span class="math">\(f_{A_{1}}\left(A_{1}\cap A_{2}\right)\cong A_{1}\cap A_{2}\cong f_{A_{2}}\left(A_{1}\cap A_{2}\right)\)</span>. קיבלתי ששתי התמונות הללו הן קבוצות טרנזיטיביות שאיזומורפיות זו לזו, ולכן הוכחת היחידות שממנה התחלתי עובדת עבורן - אני מקבל שזו אותה קבוצה, והאיזומורפיזמים, כשמצמצמים אותם ל-<span class="math">\(A_{1}\cap A_{2}\)</span>, הם אותו איזומורפיזם. זה בדיוק מה שרציתי להראות.</p>
<p>כל זה הוכיח רק ש-<span class="math">\(f=\bigcup f_{A}\)</span> היא פונקציה. למה היא חח"ע ועל, ולמה היא משמרת את היחס <span class="math">\(\in\)</span>?</p>
<p>זה ש-<span class="math">\(f\)</span> היא על זה מובן מאליו: הטווח של <span class="math">\(f\)</span> הוא <span class="math">\(\bigcup N_{A}\)</span>, שהיא איחוד של קבוצות שהתקבלו בתור תמונות של <span class="math">\(A\)</span>-ים; התחום של <span class="math">\(f\)</span> הוא איחוד ה-<span class="math">\(A\)</span>-ים הללו, אז לכל איבר ב-<span class="math">\(\bigcup N_{A}\)</span>, המקור שלו נמצא באחד ה-<span class="math">\(A\)</span>-ים הללו וכשאנחנו מפעילים את <span class="math">\(f\)</span> על המקור אנחנו מקבלים את האיבר הזה.</p>
<p>למה <span class="math">\(f\)</span> חח"ע? זה טיפה יותר טריקי. אני צריך להראות שעבור שני <span class="math">\(a_{1},a_{2}\in\bigcup A\)</span> ששונים זה מזה, אם <span class="math">\(f\left(a_{1}\right)=f\left(a_{2}\right)\)</span> אז <span class="math">\(a_{1}=a_{2}\)</span>. עכשיו, אם <span class="math">\(a_{1},a_{2}\in A\)</span> עבור קבוצה <span class="math">\(A\)</span> כלשהי זה ברור - ה-<span class="math">\(f_{A}\)</span> על אותה קבוצה היא חח"ע ולכן מקבלים את מה שרוצים. אבל מה אם <span class="math">\(a_{1}\in A_{1}\)</span> ו-<span class="math">\(a_{2}\in A_{2}\)</span> עבור קבוצות שונות?</p>
<p>זה הזמן להחזיר הנחה שלא השתמשתי בה בכלל עד עכשיו - ש-<span class="math">\(M\)</span> היא <strong>היקפית</strong>. כלומר, שאם <span class="math">\(a_{1},a_{2}\in M\)</span> (כמו במקרה שלנו) אז מספיק להראות <span class="math">\(a_{1}\cap M=a_{2}\cap M\)</span> כדי להסיק <span class="math">\(a_{1}=a_{2}\)</span>. במילים אחרות, מספיק להראות שלכל <span class="math">\(x\in M\)</span> מתקיים <span class="math">\(x\in a_{1}\iff x\in a_{2}\)</span>.</p>
<p>כעת, <span class="math">\(A_{1},A_{2}\)</span> הן קבוצות "נחמדות", ובפרט טרנזיטיביות ביחס ל-<span class="math">\(M\)</span>. כלומר, אם למשל <span class="math">\(x\in a_{1}\in A_{1}\)</span> אז <span class="math">\(x\in A_{1}\)</span>. זה אומר ש-<span class="math">\(f\)</span> מוגדר על <span class="math">\(x\)</span>, ומכך ש-<span class="math">\(f\)</span> איזומורפיזם אנחנו מקבלים <span class="math">\(f\left(x\right)\in f\left(a_{1}\right)=f\left(a_{2}\right)\)</span>, ועכשיו מ-<span class="math">\(f\left(x\right)\in f\left(a_{2}\right)\)</span> אנחנו מקבלים <span class="math">\(x\in a_{2}\)</span>, וזה מה שרצינו; הכיוון השני (<span class="math">\(x\in a_{2}\)</span> גורר <span class="math">\(x\in a_{1}\)</span>) זהה. זה מוכיח ש-<span class="math">\(a_{1}=a_{2}\)</span> ומסביר למה הייתי צריך להניח ש-<span class="math">\(M\)</span> היקפית.</p>
<p>הוכחנו ש-<span class="math">\(f\)</span> היא פונקציה חח"ע ועל; רק נשאר לטפל בשימור הסדר, כלומר להראות שאם <span class="math">\(x,a\in\bigcup A\)</span> וגם <span class="math">\(x\in a\)</span> אז <span class="math">\(f\left(x\right)\in f\left(a\right)\)</span>. זה נראה כמו תכונה שהשתמשתי בה זה עתה! וזה נכון: זה ש-<span class="math">\(a\in\bigcup A\)</span> אומר ש-<span class="math">\(a\in A\)</span> עבור קבוצה נחמדה כלשהי <span class="math">\(A\)</span>; זה ש-<span class="math">\(A\)</span> נחמדה מאפשר להסיק מ-<span class="math">\(x\in a\)</span> את <span class="math">\(x\in A\)</span> <strong>בתנאי</strong> שאנחנו יודעים ש-<span class="math">\(x\in M\)</span>, אבל הרי התחלנו מכך שגם <span class="math">\(x\in\bigcup A\subseteq M\)</span>, כך שאנחנו יודעים את זה. קיבלנו ש-<span class="math">\(x,a\)</span> שייכים לאותה קבוצה ולכן <span class="math">\(x\in a\)</span> גורר <span class="math">\(f_{A}\left(x\right)\in f_{A}\left(a\right)\)</span> אבל כפי שכבר ראינו, <span class="math">\(f=f_{A}\)</span> עבור אברי <span class="math">\(A\)</span>. זה מסיים את ההוכחה!</p>
<h2>נעבור לרפלקציה</h2>

<p>בואו נעצור לרגע וניזכר מה אנחנו רוצים להוכיח, שנקרא "עקרון הרפלקציה": שלכל פסוק <span class="math">\(\phi\)</span> (פסוק הוא נוסחה ללא משתנים חופשיים, כלומר שערך האמת שלו קבוע ואינו תלוי בהשמה ספציפית) קיימת קבוצה טרנזיטיבית ובת מניה <span class="math">\(M\)</span> כך ש-<span class="math">\(\phi\leftrightarrow\phi|_{M}\)</span>.</p>
<p>את <span class="math">\(\phi\leftrightarrow\phi|_{M}\)</span> צריך להבין בתור נוסחה (לא פסוק) שיש בה משתנה חופשי <span class="math">\(M\)</span>, וכשאני אומר ש-<span class="math">\(\phi\leftrightarrow\phi|_{M}\)</span> "מתקיים" אני מתכוון שבהשמה שבה אני מציב את הקבוצה <span class="math">\(M\)</span> בתוך המשתנה <span class="math">\(M\)</span>, הנוסחה מקבלת ערך T.</p>
<p>את החלק של הטרנזיטיביות של <span class="math">\(M\)</span> עשינו קודם: הוכחנו שאם <span class="math">\(M\)</span> היא מה שכיניתי <strong>היקפית</strong> אז היא איזומורפית לקבוצה טרנזיטיבית. לכן מה שאני צריך לבנות הוא <span class="math">\(M\)</span> שתהיה בת מניה והיקפית. כפי שנראה, הבניה לא תתקשה "על הדרך" להבטיח ש-<span class="math">\(M\)</span> היקפית כך שהחלק של "בת מניה" הוא עיקר הסיפור פה.</p>
<p>לב הרעיון הוא זה: לא משנה כמה <span class="math">\(\phi\)</span> היא נוסחה גדולה ומורכבת ומסובכת, היא עדיין נוסחה. נוסחה היא משהו שנבנה מנוסחאות קודמות בעזרת כמה צעדי בניה פשוטים, ובמספר <strong>סופי</strong> של צעדים. מה שנעשה הוא לקחת את <span class="math">\(\phi\)</span> ולפרק אותה לגורמים - לכל אותם מרכיבים שבהם משתמשים בתהליך הבניה שלה, ואז לבנות את <span class="math">\(M\)</span> באופן סדרתי עבור המרכיבים הללו כך שנוכל אינדוקטיבית להראות ש-<span class="math">\(M\)</span> מקיימת רפלקציה גם עבורם. רפלקציה במובן הקצת יותר רחב, שבו יש לנוסחאות משתנים חופשיים ואנחנו מציבים בהם ערכים שמגיעים מתוך <span class="math">\(M\)</span>. כדי להבטיח ש-<span class="math">\(M\)</span> תהיה היקפית נזרוק פנימה לאוסף הנוסחאות הזה גם את הפירוק של אקסיומת ההיקפיות.</p>
<p>בואו נתחיל עם הבניה של <span class="math">\(M\)</span>. כאמור, מה שעומד לנגד העיניים שלנו כשאנחנו בונים את <span class="math">\(M\)</span> לא יהיה פסוק בודד אלא קבוצה <strong>סופית</strong> של נוסחאות, <span class="math">\(\phi_{1},\ldots,\phi_{n}\)</span>, כך שהמשתנים החופשיים של כל אחת מהנוסחאות הללו נופלים בתוך הקבוצה <span class="math">\(x_{1},\ldots,x_{m}\)</span>. אני אבנה את <span class="math">\(M\)</span> כך שמתקיים הדבר הבא: לכל <span class="math">\(1\le i\le n\)</span> ו-<span class="math">\(1\le j\le m\)</span> ולכל קבוצה של ערכים <span class="math">\(a_{1},\ldots,a_{j-1},a_{j+1},\ldots,a_{m}\in M\)</span>:</p>
<p><strong>אם</strong> <span class="math">\(\exists x_{j}\phi_{i}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבל את הערך T</p>
<p><strong>אז</strong> <span class="math">\(\exists x_{j}\left(x_{j}\in M\wedge\phi_{i}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\right)\)</span> מקבל את הערך T (כשמציבים את הקבוצה <span class="math">\(M\)</span> במשתנה <span class="math">\(M\)</span>).</p>
<p>הרעיון פה הוא שכדי לספק נוסחאות של "קיים" מספיק <strong>איבר אחד</strong>, ומכיוון שמלכתחילה יש לנו רק מספר סופי של נוסחאות, קבוצת כל האיברים שנזדקק להם היא לא גדולה. למה זה לא טריוויאלי לחלוטין? כי ברגע שהוספנו ל-<span class="math">\(M\)</span> משהו, גם הגדלנו את טווח הסיטואציות שלנו. "סיטואציה" כזו כוללת נוסחה <span class="math">\(\phi_{i}\)</span> ומשתנה <span class="math">\(x_{j}\)</span> ויש רק מספר סופי של זוגות כאלו, אבל היא כוללת גם את <strong>ההצבה</strong> שהצבנו בכל משתני <span class="math">\(\phi_{i}\)</span> למעט <span class="math">\(x_{j}\)</span>, וכשאני מגדיל את <span class="math">\(M\)</span> אני גם מוסיף הרבה הצבות חדשות שכאלו. </p>
<p>אז מצד אחד לכאורה אני נמצא בתוך תהליך אינסופי שרק הולך ומסתבך - ככל שאני מוסיף איברים ככה אני מגדיל את כמות הסיטואציות שאני צריך להתמודד איתן. זו אכן הסיבה שבגללה אני לא אוכל לבנות קבוצה <strong>סופית</strong> <span class="math">\(M\)</span> שכזו. אבל אז נכנס לתמונה הקסם הגדול של המתמטיקה, זה שעובד גם במלון של הילברט ובעצם בחצי מתורת הקבוצות - היכולת שלנו "לדחוק את השגיאה לאינסוף". לא לפתור את הבעיה, אלא כל הזמן לדחוף אותה עוד ועוד קדימה ואז להסתכל על התהליך כולו ולראות שאיזה פלא, התהליך פתר את הבעיה למרות שבשום שלב היא לא נפתרה (ואצלנו, כאמור, היא רק הולכת ומחמירה עם הזמן).</p>
<p>כמובן, זה לא היה נשמע מרשים או מעניין כל כך אם כל מה שהיה קיים בעולם שלנו הוא קבוצות בנות מניה. רק ההבנה שלנו שקבוצות בנות מניה הן למעשה מקרה פשוט וקליל יחסית היא שהופכת את הסיפור למעניין.</p>
<p>טוב, קשקשתי מספיק והגיע הזמן להוכחה. הטריק כאמור יהיה לבנות את <span class="math">\(M\)</span> בשלבים, <span class="math">\(M_{0},M_{1},M_{2},\ldots\)</span> כשבכל שלב נוסיף ל-<span class="math">\(M_{k}\)</span> איברים לקבלת <span class="math">\(M_{k+1}\)</span> ובסוף נגדיר <span class="math">\(M=\bigcup_{k=0}^{\infty}M_{k}\)</span>. הבניה עצמה פשוטה: נגדיר <span class="math">\(M_{0}=\left\{ \emptyset\right\} \)</span> ובהינתן <span class="math">\(M_{k}\)</span> נבנה מתוכה את <span class="math">\(M_{k+1}\)</span> על ידי כך שניקח את כל אברי <span class="math">\(M_{k}\)</span> ובנוסף לכל <span class="math">\(1\le i\le n\)</span> וכל <span class="math">\(1\le j\le m\)</span> וכל סדרת ערכים <span class="math">\(a_{1},\ldots,a_{j-1},a_{j+1},\ldots,a_{m}\in M_{k}\)</span>, <strong>אם</strong> קיים איבר (ביקום הגדול של תורת הקבוצות, לא ב-<span class="math">\(M_{k}\)</span> או משהו) שכשמציבים אותו ב-<span class="math">\(x_{j}\)</span> הנוסחה <span class="math">\(\phi_{i}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבלת T, אז נוסיף את האיבר הזה אל <span class="math">\(M_{k+1}\)</span>. בבניה הזו <span class="math">\(M_{0}\)</span> סופית ואם <span class="math">\(M_{k}\)</span> סופית גם <span class="math">\(M_{k+1}\)</span> סופית, ולכן קיבלנו בסך הכל אוסף סופי של קבוצות, ומכיוון ש-<span class="math">\(M\)</span> היא איחוד בן מניה של קבוצות סופיות קיבלנו ש-<span class="math">\(M\)</span> בת מניה.</p>
<p>עכשיו, בואו ניזכר מה צריך להוכיח ש-<span class="math">\(M\)</span> מקיימת:</p>
<p>לכל <span class="math">\(1\le i\le n\)</span> ו-<span class="math">\(1\le j\le m\)</span> ולכל קבוצה של ערכים <span class="math">\(a_{1},\ldots,a_{j-1},a_{j+1},\ldots,a_{m}\in M\)</span>:</p>
<p><strong>אם</strong> <span class="math">\(\exists x_{j}\phi_{i}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבל את הערך T</p>
<p><strong>אז</strong> <span class="math">\(\exists x_{j}\left(x_{j}\in M\wedge\phi_{i}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\right)\)</span> מקבל את הערך T</p>
<p>כל אחד מהערכים <span class="math">\(a_{1},\ldots,a_{m}\)</span> הללו התווסף אל <span class="math">\(M\)</span> בשלב כלשהו, אז אם ניקח את <span class="math">\(k\)</span> להיות השלב <strong>המקסימלי</strong> מביניהם אנחנו מקבלים שכל האיברים הללו שייכים אל <span class="math">\(M_{k}\)</span>, ולכן ב-<span class="math">\(M_{k+1}\)</span> יש לנו בדיוק איבר קונקרטי של <span class="math">\(M\)</span> שעבורו הנוסחה השניה מקבלת T, כי כך בנינו את <span class="math">\(M\)</span>. זה מסיים את הבניה.</p>
<p>עכשיו אנחנו רוצים לחזור אל המטרה שלנו: נתון פסוק <span class="math">\(\phi\)</span> ואנחנו רוצים לבנות <span class="math">\(M\)</span> כך ש-</p>
<p><span class="math">\(\phi\leftrightarrow\phi|_{M}\)</span></p>
<p>מה שנעשה הוא לקחת את <span class="math">\(\phi\)</span> וליצור ממנה רשימת נוסחאות באופן הבא:</p>
<ul> <li>אם <span class="math">\(\neg\psi\)</span> ברשימה, נוסיף לרשימה גם את <span class="math">\(\psi\)</span></li>


<li>אם <span class="math">\(\psi_{1}\to\psi_{2}\)</span> ברשימה, נוסיף לרשימה גם את <span class="math">\(\psi_{1},\psi_{2}\)</span></li>


<li>אם <span class="math">\(\forall x_{j}\psi\)</span> ברשימה, נוסיף לרשימה גם את <span class="math">\(\psi\)</span></li>

</ul>

<p>אנחנו מפעילים את הכללים הללו על רשימה שבהתחלה כוללת רק את <span class="math">\(\phi\)</span> ואת אקסיומת ההיקפיות (כזכור, צריך גם אותה), ומקבלים רשימה <strong>סופית</strong> של נוסחאות, <span class="math">\(\phi_{1},\ldots,\phi_{n}\)</span> שהמשתנים החופשיים שלהם נופלים בתוך הקבוצה <span class="math">\(x_{1},\ldots,x_{m}\)</span>. עד כאן, הכל מתקדם על פי התוכנית. שימו לב שגם פה השתמשתי בכך שמספיקים הקשרים <span class="math">\(\neg,\to\)</span> והכמת <span class="math">\(\forall\)</span> כדי לתאר את כל הנוסחאות, כי כל נוסחה שיש לה קשר או כמת אחרת ניתן להחליף בנוסחה שקולה בלעדיו. זה מרגיש לי קצת מוזר כי הרי לפני רגע ההוכחה שלי דיברה על נוסחאות שמופיע בהן הכמת <span class="math">\(\exists\)</span>, אבל זו לא בעיה כי אני הולך להשתמש בטריק: כזכור, <span class="math">\(\exists x_{j}\psi\)</span> שקול אל <span class="math">\(\neg\forall x_{j}\left(\neg\psi\right)\)</span>, ומה שאני אעשה, במקום לבנות <span class="math">\(M\)</span> עבור הנוסחאות <span class="math">\(\phi_{1},\ldots,\phi_{n}\)</span>, זה לבנות <span class="math">\(M\)</span> עבור <strong>השלילה</strong> שלהן, <span class="math">\(\neg\phi_{1},\ldots,\neg\phi_{n}\)</span>. עכשיו בואו נראה שזה עובד.</p>
<p>כרגיל, כשעובדים עם נוסחאות נוח להוכיח באינדוקציה על המבנה שלהן. בזכות האופן שבו בנינו את קבוצת הנוסחאות שלנו, כל נוסחה בקבוצה שלנו שאינה אטומית נבנית מנוסחאות פשוטות יותר שגם כן שייכות לקבוצה, ולכן הוכחה אינדוקטיבית תעבוד כאן. הטענה הכללית שאנחנו מוכיחים היא שלכל השמה של הערכים <span class="math">\(a_{1},\ldots,a_{m}\in M\)</span> למשתנים של <span class="math">\(\psi\)</span> מתקיים</p>
<p><span class="math">\(\psi\left(a_{1},\ldots,a_{m}\right)\leftrightarrow\psi|_{M}\left(a_{1},\ldots,a_{m}\right)\)</span></p>
<p>כבר ראינו הוכחה אינדוקטיבית אחת שמערבת רלטיביזציה, וכזכור רובה הייתה טריוויאלית: אם <span class="math">\(\psi\)</span> היא נוסחה אטומית אז רלטיביזציה שלה לא משנה אותה בכלל ולכן כמובן ש-<span class="math">\(\psi\leftrightarrow\psi|_{M}\)</span>. עבור <span class="math">\(\psi=\neg\psi^{\prime}\)</span> אנחנו יודעים ש-<span class="math">\(\psi|_{M}=\neg\left(\psi^{\prime}|_{M}\right)\)</span> ומהנחת האינדוקציה <span class="math">\(\psi^{\prime}|_{M}\leftrightarrow\psi^{\prime}\)</span> ולכן נקבל <span class="math">\(\psi|_{M}\leftrightarrow\psi\)</span> (הטיעון המובלע פה הוא שאם <span class="math">\(\psi_{1}\leftrightarrow\psi_{2}\)</span> אז <span class="math">\(\neg\psi_{1}\leftrightarrow\neg\psi_{2}\)</span>).</p>
<p>באופן דומה, אם <span class="math">\(\psi=\psi_{1}\to\psi_{2}\)</span> אז מכך ש-<span class="math">\(\psi|_{M}=\psi_{1}|_{M}\to\psi_{2}|_{M}\)</span> נקבל <span class="math">\(\psi|_{M}\leftrightarrow\psi\)</span>. החלק המאתגר היחיד מגיע כשהנוסחה היא מהצורה <span class="math">\(\forall x_{j}\psi\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span>.</p>
<p>עכשיו מגיעה הוכחה דו כיוונית שאני אעשה טיפה שונה מבדרך כלל. ראשית אני אניח ש-<span class="math">\(\forall x_{j}\psi\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבלת T ואוכיח שגם <span class="math">\(\forall x_{j}\psi|_{M}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבלת T . אחר כך אני אניח ש-<span class="math">\(\forall x_{j}\psi\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבלת F ואוכיח שגם <span class="math">\(\forall x_{j}\psi|_{M}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבלת F. יאללה לעבודה.</p>
<p>בואו נניח קודם כל שהנוסחה <span class="math">\(\forall x_{j}\psi\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבלת ערך T, ונוכיח מזה שהנוסחה <span class="math">\(\forall x_{j}\left(x_{j}\in M\to\psi|_{M}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\right)\)</span> מקבלת T. זה כמובן החלק הקל; לכל ערך שנציב ב-<span class="math">\(x_{j}\)</span>, ההנחה שלנו אומרת ש-<span class="math">\(\psi\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> תקבל T ולכן מהנחת האינדוקציה גם <span class="math">\(\psi|_{M}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> תקבל T.</p>
<p>שימו לב! אנחנו כפסע מסוף הההוכחה, ועדיין לא השתמשנו <strong>בכלל</strong> באופן שבו <span class="math">\(M\)</span> נבנתה! הגיע הרגע שלקראתו אנו בונים במשך פוסט שלם! איזו התרגשות! וכעת, בואו נצלול חזרה לדברים טכניים.</p>
<p>נניח עכשיו ש-<span class="math">\(\forall x_{j}\psi\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבלת F. בניסוח שקול: <span class="math">\(\neg\left(\forall x_{j}\psi\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\right)\)</span> מקבלת T, והרי הנוסחה הזו שקולה אל <span class="math">\(\exists x_{j}\neg\psi\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span>. והנה זה הגיע: בשביל זה כשבנינו את <span class="math">\(M\)</span> השתמשנו ב<strong>שלילה</strong> של ה-<span class="math">\(\psi\)</span>-ים שלנו.</p>
<p>בואו ניזכר שוב באופן שבו בנינו את <span class="math">\(M\)</span>. עשינו זאת כך שיתקיים</p>
<p><strong>אם</strong> <span class="math">\(\exists x_{j}\phi_{i}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\)</span> מקבל את הערך T</p>
<p><strong>אז</strong> <span class="math">\(\exists x_{j}\left(\phi_{i}|_{M}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\right)\)</span> מקבל את הערך T.</p>
<p>ראינו שהחלק העליון, שאינו תלוי ב-<span class="math">\(M\)</span>, מתקיים; זה אומר שעל פי בניית <span class="math">\(M\)</span>, יש בה איבר כלשהו שמאפשר גם לרלטיביזציה להיות T. כלומר, הנוסחה הבאה מקבלת T:</p>
<p><span class="math">\(\exists x_{j}\left(\left(\neg\psi\right)|_{M}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\right)\)</span></p>
<p>מכיוון שההשמה ל-<span class="math">\(x_{j}\)</span> שמראה שהנוסחה מקבלת T מציבה בו איבר מתוך <span class="math">\(M\)</span> (כלומר, כזה שמקיים את הנוסחה האטומית <span class="math">\(x_{j}\in M\)</span>) נקבל שגם הנוסחה הבאה מקבלת T:</p>
<p><span class="math">\(\exists x_{j}\left(x_{j}\in M\wedge\left(\neg\psi\right)|_{M}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\right)\)</span></p>
<p>מה שאומר שבאופן שקול, הנוסחה הבאה מקבלת F:</p>
<p><span class="math">\(\forall x_{j}\left(x_{j}\in M\to\psi|_{M}\left(a_{1},\ldots,x_{j},\ldots,a_{m}\right)\right)\)</span></p>
<p>וזה בדיוק מה שרצינו להגיע אליו, מה שמסיים את ההוכחה, ואת כל שרשרת ההוכחות שהייתה בפוסט הזה.</p>
<p>זה זמן טוב לעצור ולקחת הפסקה; מכיוון שכל החלק הזה של הפוסט היה טכני להחריד אין טעם להמשיך ולדבר על התמונה הגדולה ולאן הולכים מכאן; את זה אעשה בפוסט הבא.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>