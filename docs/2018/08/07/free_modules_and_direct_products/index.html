<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מודולים חופשיים ומכפלות ישרות של מודולים - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                text-align: center;
                margin-bottom: 10px;
            }
            
            .top-nav .nav-links {
                flex-direction: column;
                width: 100%;
            }
            
            .top-nav .nav-links a {
                text-align: center;
                padding: 8px;
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2018/08/05/intro_to_module_theory/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">אז מה זה בעצם מודולים ואלגבראות?</span>
            </a>
            

            
            <a href="/2018/08/11/noetherian_modules_and_rings/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">מודולים וחוגים נתריים</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מודולים חופשיים ומכפלות ישרות של מודולים</h1>
            <div class="post-meta">
                <span class="date">2018-08-07</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אלגברה מופשטת.html">אלגברה מופשטת</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/מודול חופשי.html">מודול חופשי</a>
                    
                    <a href="/tags/מכפלה ישרה.html">מכפלה ישרה</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסט הקודם הצגתי מודולים בתור "זה כמו מרחב וקטורי רק מעל חוג אבל בעצם זה ממש לא כמו מרחב וקטורי כי תשכחו מכל מה שידעתם על מושגים כמו בסיס ופרישה". המקבילה שלנו למרחב שנפרש על ידי וקטורים הייתה תת-מודול שנוצר על ידי איברים; וכאן היו לנו תופעות מוזרות כמו מודול שנוצר על ידי מספר סופי של איברים אבל יש לו תת-מודולים שאין להם קבוצה יוצרת סופית.</p>
<p>בפוסט הזה ננסה, בזהירות, להרים את השברים ולקחת מהם את מה שנזדקק לו בשביל <strong>משפט המבנה של מודולים נוצרים סופית מעל תחום ראשי</strong>.</p>
<p>הדבר הראשון שנעשה יהיה לנסות ולהציל את מושג ה<strong>בסיס</strong>. באלגברה לינארית, קבוצה <span class="math">\(B\)</span> היא בסיס למרחב וקטורי <span class="math">\(V\)</span> מעל שדה <span class="math">\(F\)</span> אם לכל <span class="math">\(v\in V\)</span> קיים צירוף לינארי <strong>יחיד</strong> של אברי הבסיס שנותן אותו. כלומר, קיימים <span class="math">\(b_{1},\dots,b_{n}\in B\)</span> ו-<span class="math">\(\lambda_{1},\dots,\lambda_{n}\in F\)</span> כך ש-<span class="math">\(v=\sum\lambda_{i}b_{i}\)</span>, ודרך הייצוג הזו היא יחידה עד כדי פרמוטציה של האינדקסים של ה-<span class="math">\(\lambda_{i}b_{i}\)</span>. בנוסף, סימנו בתור <span class="math">\(\dim V\)</span> את העוצמה של <span class="math">\(B\)</span> וקראנו לזה <strong>המימד</strong> של <span class="math">\(V\)</span>.</p>
<p>במודולים דבר כזה לא בהכרח קיים, אבל אפשר לדבר על המקרה שבו הוא קיים. אנחנו אומרים ש-<span class="math">\(R\)</span> מודול <span class="math">\(M\)</span> הוא <strong>חופשי</strong> מעל הקבוצה <span class="math">\(A\subseteq M\)</span> אם כל <span class="math">\(m\in M\)</span> ניתן לכתיבה <strong>באופן יחיד</strong> בתור <span class="math">\(m=\sum_{i=1}^{n}r_{i}a_{i}\)</span> עבור <span class="math">\(r_{1},\dots,r_{n}\in R\)</span> ו-<span class="math">\(a_{1},\dots,a_{n}\in A\)</span>. לא כל מודול הוא חופשי, אבל לא קשה להראות שבהינתן חוג <span class="math">\(R\)</span> וקבוצה <span class="math">\(A\)</span> אז <strong>קיים</strong> <span class="math">\(R\)</span>-מודול חופשי מעל <span class="math">\(A\)</span>: מגדירים את <span class="math">\(M\)</span> הזה להיות הקבוצה של כל הביטויים מהצורה <span class="math">\(\sum_{i=1}^{n}r_{i}a_{i}\)</span> (פורמלית: כל הפונקציות <span class="math">\(f:A\to R\)</span> כך ש-<span class="math">\(f\left(a\right)=0\)</span> לכל <span class="math">\(a\in A\)</span> למעט מספר סופי). לא קשה להראות שזה <span class="math">\(R\)</span>-מודול חופשי, ושהוא יחיד עד כדי איזומורפיזם. יותר מכך, הוא מקיים את מה שנקרא <strong>תכונה אוניברסלית</strong> (מושג שטרם הבהרתי עד הסוף, גם בסדרת הפוסטים הזו), שאפשר לתאר בדיאגרמה הקומוטטיבית הבאה:<br />
<img src="/img/2018/08/free_modules_diagram1.png" alt="\xymatrix{A\ar[r]\ar[dr]^{\varphi} & F\left(A\right)\ar[d]^{\Phi}\\  & M }"/></p>
<p>הדיאגרמה אומרת את הדבר הבא: לכל קבוצה <span class="math">\(A\)</span> קיים <span class="math">\(R\)</span>-מודול <span class="math">\(F\left(A\right)\)</span> (זהו המודול החופשי מעל <span class="math">\(A\)</span>) כך שאם <span class="math">\(M\)</span> הוא <span class="math">\(R\)</span>-מודול <strong>כלשהו</strong> וקיימת פונקציה <span class="math">\(\varphi:A\to M\)</span> שמתאימה לכל איבר של <span class="math">\(A\)</span> איבר ב-<span class="math">\(M\)</span>, אז קיים <strong>הומומורפיזם של מודולים</strong> <span class="math">\(\Phi:F\left(A\right)\to M\)</span> כך ש-<span class="math">\(\varphi\left(a\right)=\Phi\left(a\right)\)</span> (כאן אנחנו חושבים על <span class="math">\(a\)</span> גם בתור איבר של <span class="math">\(A\)</span> אבל גם בתור איבר של <span class="math">\(F\left(A\right)\)</span>; זו המשמעות של החץ מ-<span class="math">\(A\)</span> אל <span class="math">\(F\left(A\right)\)</span> שמסמל את העתקת הזהות). כלומר, אנחנו יכולים לחשוב על כל מודול ש"מערב" את <span class="math">\(A\)</span> בתור תמונה של <span class="math">\(F\left(A\right)\)</span>; זה המודול ה"כללי ביותר" שמייצג את <span class="math">\(A\)</span> כמודול.</p>
<p>עכשיו אני רוצה לחבר את הדבר הזה לשתי בניות אחרות שאנחנו מכירים מאלגברה לינארית (ומאלגברה בכלל): מכפלות ישרות וסכומים ישרים.</p>
<p><strong>מכפלה ישרה</strong> של <span class="math">\(R\)</span>-מודולים <span class="math">\(N_{1},N_{2},\dots,N_{k}\)</span> היא הדרך הטבעית להפוך את המכפלה הקרטזית <span class="math">\(N_{1}\times N_{2}\times\dots\times N_{k}\)</span> ל-<span class="math">\(R\)</span>-מודול; מגדירים חיבור וכפל "רכיב רכיב", כלומר <span class="math">\(\left(a_{1},\dots,a_{k}\right)+\left(b_{1},\dots,b_{k}\right)\triangleq\left(a_{1}+b_{1},\dots,a_{k}+b_{k}\right)\)</span> ו-<span class="math">\(r\left(a_{1},\dots,a_{k}\right)\triangleq\left(ra_{1},\dots,ra_{k}\right)\)</span>. זה אותו רעיון כמו הבניות הדומות שראינו עבור חבורות וחוגים. <strong>סכום ישר</strong> זה אותו דבר בדיוק כמו מכפלה ישרה כל עוד אנחנו מדברים על מכפלה של <strong>מספר סופי</strong> של מודולים, שזה מה שתיארתי למעלה; אם אנחנו לוקחים אינסוף מודולים אז המכפלה הישרה שלהם היא עדיין המכפלה הקרטזית עם חיבור וכפל נקודתיים, אבל סכום ישר לוקח מהמכפלה הקרטזית רק את האיברים שבהם כל הכניסות הן 0 למעט מספר סופי - קצת מזכיר את מה שראינו קודם עם הבניה של המודול החופשי. אני לא הולך לדבר על מכפלות אינסופיות הפעם כי אני לא צריך את זה, ולכן ההבדל בין מכפלה ישרה וסכום ישר יהיה שקוף עבורנו.</p>
<p>מה שכן לא אמרתי עד עכשיו הוא שאני מדבר על מה שנקרא <strong>מכפלה ישרה חיצונית</strong> ו<strong>סכום ישר חיצוני</strong>. במשהו "חיצוני" שכזה אנחנו לוקחים מודולים שלאו דווקא קשורים אחד לשני ו"מדביקים" אותם אחד לשני באופן מלאכותי משהו. אפשר לעשות דבר אחר: מתחילים עם מודול <span class="math">\(M\)</span>, לוקחים <strong>תת-מודולים</strong> שלו, ומסתכלים על מה שקורה כשמחברים אותם. אם התוצאה איזומורפית לסכום הישר החיצוני, הסיטואציה הזו נקראת גם <strong>סכום ישר</strong> ("פנימי", לפעמים). זה מה שלרוב נתקלים בו קודם כשלומדים אלגברה לינארית.</p>
<p>בואו ניזכר איך זה הולך באלגברה לינארית: נניח ש-<span class="math">\(V\)</span> הוא מרחב וקטורי ו-<span class="math">\(W,U\)</span> הם שני תת-מרחבים. אפשר תמיד להסתכל על תת-המרחב <span class="math">\(W+U\triangleq\left\{ w+u\ |\ w\in W,u\in U\right\} \)</span>. אם מתקיימת גם התכונה הנחמדה <span class="math">\(W\cap U=\left\{ 0\right\} \)</span>, אז נותנים לסכום הזה את הסימון המיוחד <span class="math">\(W\oplus U\)</span> וקוראים לו <strong>סכום ישר</strong>. כלומר: "סכום ישר" הוא לא <strong>בניה</strong> אלא הוא <strong>הצהרה</strong> שהבניה של "סכום רגיל של תתי-מרחבים" בנוסף לכך מקיים <strong>משהו</strong>. כמו ש"איחוד זר" זו הצהרה שאיחוד רגיל כלשהו הוא איחוד של שתי קבוצות שהן זרות.</p>
<p>הסיבה שסכום ישר שכזה הוא מעניין היא בגלל תכונת <strong>יחידות</strong> דומה לזו של בסיס. נניח ש-<span class="math">\(V=W\oplus U\)</span>, אז <strong>לכל</strong> <span class="math">\(v\in V\)</span> קיימים איברים <strong>יחידים</strong> <span class="math">\(w\in W,u\in U\)</span> כך ש-<span class="math">\(v=w+u\)</span>. איך יודעים שהוא יחיד? כי נניח ש-<span class="math">\(w_{1}+u_{1}=v=w_{2}+u_{2}\)</span> אז <span class="math">\(w_{1}-w_{2}=u_{2}-u_{1}\)</span>. אגף שמאל הוא ב-<span class="math">\(W\)</span> ואגף ימין הוא ב-<span class="math">\(U\)</span>, ולכן <span class="math">\(W\cap U=\left\{ 0\right\} \)</span> מסיים את הטיעון. אפשר בקלות גם להוכיח ש-<span class="math">\(W\times U\cong W\oplus U\)</span> כאשר <span class="math">\(W\times U\)</span> הוא המכפלה החיצונית של המרחבים; פשוט מגדירים <span class="math">\(T\left(\left(w,u\right)\right)=w+u\)</span> ומקבלים העתקה לינארית שהגרעין שלה הוא ה-<span class="math">\(\left(w,u\right)\)</span> שעבורם <span class="math">\(w=-u\)</span> ושוב יש לנו איברים ששייכים ל-<span class="math">\(W\cap U\)</span> ולכן <span class="math">\(\left(w,u\right)=\left(0,0\right)\)</span> וההעתקה היא חח"ע (וכמובן שהיא על).</p>
<p>את הרעיון הזה אפשר להכליל לסכום ישר של יותר משני תת-מרחבים; אני אעשה את זה כבר ישירות עבור מודולים, אבל מה שאעשה לא שונה ממה שעושים עבור מרחבים וקטוריים. הסיטואציה שלנו, כאמור, היא של <span class="math">\(R\)</span>-מודול <span class="math">\(M\)</span> עם תתי-מודולים <span class="math">\(N_{1},\dots,N_{k}\)</span>. נניח ש-<span class="math">\(M=N_{1}+\dots+N_{k}\)</span> (לא חייבים להניח את זה; אפשר לתת סימון אחר ל-<span class="math">\(N_{1}+\dots+N_{k}\)</span> במקרה שהוא לא שווה ל-<span class="math">\(M\)</span> ולהמשיך עם הסימון הזה). אני תוהה מה התנאי הנדרש על מנת שיתקיים שכל איבר ב-<span class="math">\(M\)</span> יהיה ניתן לכתיבה <strong>באופן יחיד</strong> בתור <span class="math">\(n_{1}+\dots+n_{k}\)</span> כך ש-<span class="math">\(n_{i}\in N_{i}\)</span>. אבל לפני שנגיע לתנאי הזה, הנה שאלה מכשילה: נניח שזה אכן מה שקורה וכל איבר ב-<span class="math">\(M\)</span> ניתן לכתיבה יחידה שכזו; האם זה אומר ש-<span class="math">\(M\)</span> הוא חופשי מעל <span class="math">\(N_{1}\cup N_{2}\cup\dots\cup N_{k}\)</span>? התשובה היא <strong>ממש לא</strong>. וזה שונה ממה שקורה במרחבים וקטוריים.</p>
<p>מה ההבדל? לפני שאתן דוגמא, דווקא עם ההגדרה הכללית קל לראות אותה לדעתי: <ul></p>
<li><span class="math">\(M\)</span> הוא <strong>חופשי</strong> מעל <span class="math">\(N_{1},\dots,N_{k}\)</span> אם לכל <span class="math">\(m\in M\)</span> קיימים ויחידים <span class="math">\(n_{1},\dots,n_{k}\)</span> <strong>וגם</strong> <span class="math">\(r_{1},\dots,r_{k}\in R\)</span> כך ש-<span class="math">\(m=\sum r_{i}n_{i}\)</span>.
</li>
<li><span class="math">\(M\)</span> הוא <strong>סכום ישר</strong> של <span class="math">\(N_{1},\dots,N_{k}\)</span> אם לכל <span class="math">\(m\in M\)</span> קיימים ויחידים <span class="math">\(n_{1},\dots,n_{k}\)</span> כך ש-<span class="math">\(m=\sum n_{i}\)</span>. </ul> כלומר, מודול חופשי הוא אפילו יותר מאשר סכום ישר - הוא דורש יחידות גם מה<strong>מקדמים</strong>. הנה דוגמא פשוטה לסיטואציה שבה זה לא קורה: <span class="math">\(R=\mathbb{Z}\)</span> ו-<span class="math">\(M=\mathbb{Z}_{2}\times\mathbb{Z}_{2}\)</span>. במקרה הזה <span class="math">\(M\)</span> הוא בוודאי סכום ישר של שני עותקים של <span class="math">\(\mathbb{Z}_{2}\)</span>, אבל <span class="math">\(\left(1,1\right)=\left(1,0\right)+\left(0,1\right)=3\left(1,0\right)+5\left(0,1\right)\)</span> מראה שיש יותר מייצוג אחד ל-<span class="math">\(\left(1,1\right)\)</span> אם מסתכלים גם על המקדמים. זה מתרחש במקרה הנוכחי פשוט כי <span class="math">\(3\left(1,0\right)=\left(1,0\right)\)</span>. בשדה משהו כזה לא יכול לקרות: בגלל שכל איבר שונה מ-0 הוא הפיך, כפל בסקלר הוא העתקה חח"ע - אין שני סקלרים שכפל בהם יחזיר את אותו איבר, ולכן ה"יחידות" באה מעצמה.

נעבור עכשיו לסיכום ביניים של הטענה שאני כן רוצה להוכיח. ראינו עד עכשיו שלוש דרכים להסתכל על עניין ה"סכום ישר פנימי" הזה, בואו נכתוב את כולן.

יש לנו <span class="math">\(R\)</span>-מודול <span class="math">\(M\)</span> עם תת-מודולים <span class="math">\(N_{1},\dots,N_{k}\)</span> כך ש-<span class="math">\(M=N_{1}+\dots+N_{k}\)</span>. אז שלושת התנאים הבאים שקולים: <ul></li>
<li><span class="math">\(N_{1}\times\dots\times N_{k}\cong M\)</span> עם האיזומורפיזם <span class="math">\(\varphi\left(n_{1},\dots,n_{k}\right)=n_{1}+\dots+n_{k}\)</span>
</li>
<li>לכל <span class="math">\(1\le i\le k\)</span> מתקיים ש-<span class="math">\(N_{i}\cap\left(N_{1}+\dots+N_{i-1}+N_{i+1}+\dots+N_{k}\right)=\left\{ 0\right\} \)</span>
</li>
<li>לכל <span class="math">\(m\in M\)</span> קיימים <strong>ויחידים</strong> <span class="math">\(n_{1},\dots,n_{k}\)</span> כך ש-<span class="math">\(n_{i}\in N_{i}\)</span> ו-<span class="math">\(m=n_{1}+\dots+n_{k}\)</span>
</li>
<p></ul> שימו לב במיוחד לתנאי האמצעי: שגיאה נפוצה (שגם אני עשיתי) היא להניח שההכללה של ה-<span class="math">\(W\cap U=\left\{ 0\right\} \)</span> מהמקרה של סכום ישר של שני מרחבים היא פשוט להגיד שצריך להתקיים <span class="math">\(N_{i}\cap N_{j}=\left\{ 0\right\} \)</span> לכל <span class="math">\(i\ne j\)</span>. אבל הדרישה הזו חלשה מדי ולא מספיקה (תרגיל נחמד: למצוא דוגמא נגדית) ולכן אני משתמש בדרישה הכללית יותר, שלכל תת-מודול <span class="math">\(N_{i}\)</span>, לא יהיה לו שום דבר לא טריוויאלי משותף עם מה שמתקבל מכל המרחבים האחרים ביחד.</p>
<p>הדרך האהובה ביותר להוכיח שכמה טענות הן שקולות היא "שרשרת גרירות" - נוכיח שהטענה הראשונה גוררת את השניה, השניה את השלישית, השלישית את הראשונה - וזהו, זה מוכיח שהכל גורר את הכל.</p>
<p>בשביל להוכיח את הטענה השניה בעזרת הראשונה, ניקח <span class="math">\(a\in N_{i}\cap\left(N_{1}+\dots+N_{i-1}+N_{i+1}+\dots+N_{k}\right)\)</span> ונוכיח ש-<span class="math">\(a=0\)</span>. אנחנו יודעים שמצד אחד <span class="math">\(a\in N_{i}\)</span> ומצד שני <span class="math">\(a=\sum_{j\ne i}a_{j}\)</span> עבור <span class="math">\(a_{j}\in N_{j}\)</span>. מכאן ש-<span class="math">\(\varphi\left(a_{1},a_{2},\dots,a_{i-1},-a,a_{i+1},\dots,a_{k}\right)=\sum_{j\ne i}a_{j}-a=0\)</span> ולכן <span class="math">\(\left(a_{1},\dots,a,\dots,a_{k}\right)\in\ker\varphi\)</span>. מכיוון ש-<span class="math">\(\varphi\)</span> איזומורפיזם ובפרט חח"ע, נקבל <span class="math">\(\left(a_{1},\dots,a,\dots,a_{k}\right)=\left(0,0,\dots,0\right)\)</span> ובפרט <span class="math">\(a=0\)</span>.</p>
<p>בשביל להוכיח את הטענה השלישית בעזרת השניה, נשים לב ראשית כל לכך שהנחנו מראש ש-<span class="math">\(M=N_{1}+\dots+N_{k}\)</span> וזה מראה מייד את ה"קיימים", האתגר הוא רק להראות את ה"יחידים". זו בעצם אותה הוכחה שכבר הראיתי קודם: נניח ש-<span class="math">\(m=a_{1}+\dots+a_{k}=b_{1}+\dots+b_{k}\)</span> כך ש-<span class="math">\(a_{i},b_{i}\in N_{i}\)</span>, אז <span class="math">\(\left(a_{1}-b_{1}\right)+\dots+\left(a_{k}-b_{k}\right)=0\)</span> ולכן, לכל <span class="math">\(i\)</span>, נקבל <span class="math">\(-\left(a_{i}-b_{i}\right)=\sum_{j\ne i}\left(a_{j}-b_{j}\right)\)</span>. אגף שמאל שייך ל-<span class="math">\(N_{i}\)</span> ואגף ימין ל-<span class="math">\(\sum_{j\ne i}N_{j}\)</span> ולכן המסקנה מהטענה השניה היא ש-<span class="math">\(a_{i}-b_{i}=0\)</span>, כלומר <span class="math">\(a_{i}=b_{i}\)</span>.</p>
<p>בשביל להוכיח את הטענה הראשונה בעזרת השלישית משתמשים בעוד טיעון שכבר פחות או יותר הראיתי. זה ש-<span class="math">\(\varphi\)</span> הוא הומומורפיזם זה קל לבדיקה; זה שהוא על <span class="math">\(M\)</span> נובע מ-<span class="math">\(M=N_{1}+\dots+N_{k}\)</span>; נשאר רק לראות ש-<span class="math">\(\varphi\)</span> חח"ע, כלומר ש-<span class="math">\(\ker\varphi=\left\{ \left(0,0,\dots,0\right)\right\} \)</span>. מכיוון ש-<span class="math">\(0\in M\)</span> ו-<span class="math">\(0=0+0+\dots+0\)</span> כאשר <span class="math">\(0\in N_{i}\)</span> לכל <span class="math">\(1\le i\le k\)</span>, זו ההצגה <strong>היחידה</strong> של 0 בתור <span class="math">\(n_{1}+\dots+n_{k}\)</span>, ולכן האיבר היחיד בגרעין של <span class="math">\(\varphi\)</span> הוא <span class="math">\(\left(0,0,\dots,0\right)\)</span>. זה מסיים את ההוכחה.</p>
<p>יש עוד דבר אחד שאני רוצה "להציל" מאלגברה לינארית, והוא ידרוש ממני להתחיל להתכנס אל היעד שלנו. כזכור, אני רוצה בסופו של דבר להוכיח משפט עבור מודולים <strong>נוצרים סופית</strong> מעל <strong>תחום ראשי</strong>. "תחום ראשי" הוא תחום שלמות (חוג <strong>קומוטטיבי</strong> ללא מחלקי אפס) שבנוסף לכך כל אידאל בו נוצר על ידי איבר בודד; אז במסגרת ההתכנסות, אני אניח כרגע ש-<span class="math">\(R\)</span> הוא תחום שלמות, ואני אדבר על מודול <strong>חופשי</strong> שהוא נוצר סופית. כלומר, <span class="math">\(M\)</span> יהיה <span class="math">\(R\)</span>-מודול חופשי מעל קבוצת יוצרים סופית <span class="math">\(A\)</span>. ניתן לזה שם: <span class="math">\(\text{rank}M=\left|A\right|\)</span> - <strong>הדרגה</strong> של המודול החופשי <span class="math">\(M\)</span>. זו המקבילה ל<strong>מימד</strong> עבור מרחבים וקטוריים. מה שאני רוצה להציל כרגע הוא משפט שימושי מאלגברה לינארית: אם <span class="math">\(V\)</span> מרחב וקטורי מעל <span class="math">\(F\)</span> ו-<span class="math">\(\dim V=n\)</span>, אז הקבוצה <span class="math">\(\left\{ v_{1},\dots,v_{n+1}\right\} \)</span> של <span class="math">\(n+1\)</span> וקטורים <strong>שונים</strong> מעל <span class="math">\(V\)</span> היא <strong>תלויה לינארית</strong>, כלומר קיימים <span class="math">\(\lambda_{1},\dots,\lambda_{n+1}\in F\)</span> שלא כולם אפס כך ש-<span class="math">\(\sum\lambda_{i}v_{i}=0\)</span>. עכשיו תחליפו את <span class="math">\(V\)</span> ב-<span class="math">\(M\)</span> ואת <span class="math">\(\dim V\)</span> ב-<span class="math">\(\text{rank}M\)</span> וקחו את הסקלרים מתוך <span class="math">\(R\)</span> וקיבלתם את הטענה שאני רוצה להוכיח.</p>
<p>האם אתם זוכרים איך מוכיחים את הטענה הזו באלגברה לינארית? כמו רוב הדברים באלגברה לינארית בסיסית היא ניתנת לרדוקציה זריזה אל משהו שמדבר על מטריצות, ואותו משהו הוא זוועת עולם טכנית. מה שעושים הוא להסתכל על בסיס <span class="math">\(B=\left\{ e_{1},\dots,e_{n}\right\} \)</span> של <span class="math">\(V\)</span> ולכתוב את ה-<span class="math">\(v_{i}\)</span>-ים באמצעותו: <span class="math">\(v_{i}=\sum_{j=1}^{n}a_{j,i}e_{j}\)</span>. זה מגדיר לנו מטריצה <span class="math">\(A=\left(a_{j,i}\right)\)</span> עם <span class="math">\(n\)</span> שורות ו-<span class="math">\(n+1\)</span> עמודות, כך שהעמודה ה-<span class="math">\(i\)</span> הוא וקטור הקואורדינטות של <span class="math">\(v_{i}\)</span> על פי הבסיס <span class="math">\(B\)</span>.</p>
<p>כעת, נסתכל על צירוף לינארי של ה-<span class="math">\(v_{i}\)</span>-ים שאיבריו הם <strong>משתנים</strong> ואנחנו רוצים שיהיה שווה ל-0: <span class="math">\(\sum_{i=1}^{n+1}x_{i}v_{i}=0\)</span>. אם נפתח את ההגדרה של כל <span class="math">\(v_{i}\)</span>, נקבל את המשוואה:</p>
<p><span class="math">\(\sum_{i=1}^{n+1}x_{i}\sum_{j=1}^{n}a_{j,i}e_{j}=0\)</span></p>
<p>אפשר לשנות את סדר הסכימה ולקבץ איברים לפי ה-<span class="math">\(e_{j}\)</span>-ים:</p>
<p><span class="math">\(\sum_{j=1}^{n}\left(\sum_{i=1}^{n+1}a_{j,i}x_{i}\right)e_{j}=0\)</span></p>
<p>מכיוון ש-<span class="math">\(B\)</span> הוא קבוצה בלתי תלויה לינארית, נסיק שהמקדמים של כל <span class="math">\(e_{j}\)</span> הם 0:</p>
<p><span class="math">\(\sum_{i=1}^{n+1}a_{j,i}x_{i}=0\)</span> לכל <span class="math">\(1\le j\le n\)</span></p>
<p>אם נסמן <span class="math">\(\overline{x}=\left[\begin{array}{c} x_{1}\\ \vdots\\ x_{n+1} \end{array}\right]\)</span> אז נקבל את המשוואה</p>
<p><span class="math">\(A\overline{x}=\overline{0}\)</span></p>
<p>זו מערכת משוואות עם יותר נעלמים (<span class="math">\(n+1\)</span>) מאשר משוואות (<span class="math">\(n\)</span>) ולכן קיים לה פתרון לא טריוויאלי. דרך אחרת לחשוב על זה: נרחיב את <span class="math">\(A\)</span> למטריצה מסדר <span class="math">\(\left(n+1\right)\times\left(n+1\right)\)</span> על ידי הוספת שורת אפסים. גם <span class="math">\(A\)</span> המורחבת תקיים את המשוואה <span class="math">\(A\overline{x}=\overline{0}\)</span>, ומכיוון שיש לה שורת אפסים אז <span class="math">\(\det A=0\)</span> ולכן <span class="math">\(A\)</span> לא הפיכה ולכן הגרעין של ההעתקה <span class="math">\(A\overline{x}\)</span> אינו טריוויאלי. איך שאני לא רוצה לנסח את זה, אתם רואים שאני נעצר מתישהו בהוכחה הזו בדיוק לפני השלב הטכני המזוויע שאני מדבר עליו.</p>
<p>ולמה טרחתי להזכיר מה קורה באלגברה לינארית, הרי אנחנו לא באלגברה לינארית יותר? ובכן, להוכיח את המשפט עבור מודולים במקרה שלנו הוא בסך הכל <strong>רדוקציה</strong> למקרה של מרחבים וקטוריים. זה היתרון הגדול שבעבודה עם <strong>תחום שלמות</strong> <span class="math">\(R\)</span>; כבר ראינו <a href="https://gadial.net/2018/01/30/rings_of_fractions/">בסדרת הפוסטים</a> הזו שכל תחום שלמות <span class="math">\(R\)</span> ניתן לשיכון בשדה <span class="math">\(F\)</span> ("שדה השברים" של <span class="math">\(R\)</span>). כעת, מכיוון ש-<span class="math">\(M\)</span> הוא <span class="math">\(R\)</span>-מודול חופשי מדרגה <span class="math">\(n\)</span> אז <span class="math">\(M\cong R^{n}\)</span>, ולכן <span class="math">\(M\subseteq F^{n}\)</span> (ההכלה הזו היא דרך מקוצרת לומר "<span class="math">\(M\)</span> איזומורפי לתת-מרחב של <span class="math">\(F^{n}\)</span>"). מכיוון ש-<span class="math">\(F\)</span> הוא שדה אז <span class="math">\(F^{n}\)</span> הוא מרחב וקטורי, כך שאם <span class="math">\(\left\{ a_{1},\dots,a_{n+1}\right\} \)</span> הם <span class="math">\(n+1\)</span> איברים שונים של <span class="math">\(M\)</span>, אנחנו יודעים שקיימים <span class="math">\(\lambda_{1},\dots,\lambda_{n+1}\in F\)</span> כך ש-<span class="math">\(\sum\lambda_{i}a_{i}=0\)</span>. האם סיימנו?</p>
<p>עדיין לא לגמרי סיימנו, כי אותם <span class="math">\(\lambda_{i}\in F\)</span> הם לא בהכרח איברים של <span class="math">\(R\)</span>. כאן נכנסת לתמונה באופן חזק העובדה ש-<span class="math">\(F\)</span> הוא שדה השברים של <span class="math">\(R\)</span>; מתקיים <span class="math">\(\lambda_{i}=\frac{r_{i}}{s_{i}}\)</span> עבור <span class="math">\(r_{i},s_{i}\in R\)</span>. אם נגדיר <span class="math">\(s=\prod s_{i}\)</span>, אז <span class="math">\(s\lambda_{i}\in R\)</span> לכל <span class="math">\(\lambda_{i}\)</span>, כך שנקבל <span class="math">\(\sum\left(s\lambda_{i}\right)a_{i}=0\)</span> ב-<span class="math">\(M\)</span> כאשר כאן המקדמים הם איברים של <span class="math">\(R\)</span> - וזה מה שרצינו.</p>
<p>זהו, הצלחנו להציל את כל האלגברה הלינארית שנזדקק לה בהמשך; השלב הבא הוא לדבר קצת על מה זה אומר שמודול הוא <strong>נוצר סופית</strong> ואחר כך נגיע הישר אל המשפט המרכזי שאנחנו רוצים להוכיח.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>