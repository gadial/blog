<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אז מה זה בעצם מודולים ואלגבראות? - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2018/08/05/intro_to_module_theory/">
    <meta property="og:title" content="אז מה זה בעצם מודולים ואלגבראות?">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2018/08/05/intro_to_module_theory/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="אז מה זה בעצם מודולים ואלגבראות?">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2018/07/26/casus_irreducibilis/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">ה-Casus irreducibilis, או: למה חייבים מספרים מרוכבים</span>
            </a>
            

            
            <a href="/2018/08/07/free_modules_and_direct_products/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">מודולים חופשיים ומכפלות ישרות של מודולים</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>אז מה זה בעצם מודולים ואלגבראות?</h1>
            <div class="post-meta">
                <span class="date">2018-08-05</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אלגברה מופשטת.html">אלגברה מופשטת</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אלגברה.html">אלגברה</a>
                    
                    <a href="/tags/מודול.html">מודול</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אני מגיע עכשיו אל<a href="https://gadial.net/2017/01/31/abstract_algebra_intro/"> החלק האחרון</a> בסדרת הפוסטים שלי על אלגברה מופשטת. עד עכשיו ראינו בה שלושה תחומים עיקריים: את תורת החבורות, את תורת החוגים ואת תורת השדות (שכללה את תורת גלואה). תורת השדות הייתה סוג של נקודת שיא - ההכנה המקדימה הארוכה של חבורות וחוגים השתלמה בה וראינו הרבה תוצאות מעניינות ויפות. אני רוצה לעבור עכשיו לדבר על <strong>תורת המודולים</strong>, שהיא סוג של מקבילה לתורת השדות; לא נשתמש בה בנושאים מתורת השדות, אבל כן נתבסס על דברים מחוגים וחבורות על מנת להגיע אל נקודת שיא אחרת.</p>
<p>למרות שמודולים זה מושג מעניין ובסיסי וחשוב, אני מייעד את סדרת הפוסטים הנוכחית רק לנקודת שיא אחת, אבל כזו רצינית במיוחד: <strong>משפט המבנה של מודולים נוצרים סופית מעל תחומים ראשיים</strong>. השם המסורבל הזה מחביא מאחוריו משפט שהוא הכללה של שני משפטים כבדים למדי - בתורת החבורות: משפט המבנה של חבורות אבליות נוצרות סופית; ובאלגברה לינארית:<strong> משפט הפירוק הפרימרי ומשפט הפירוק הציקלי</strong>, שבתורם מובילים ל<strong>צורת ז'ורדן</strong> ולצורה הרציונלית של טרנספורמציות לינאריות. שני המשפטים הללו היו קיימים עוד לפני שהיו מודולים, כמובן; המושג המופשט של מודול שאציג פה הוצג לראשונה על ידי אמי נתר במאמר מ-1921 (ויבוא יום ואכתוב פוסטים מסודרים על ההיסטוריה הארוכה והמעניינת של התחום).</p>
<h2>הגדרה</h2>
<p>מהו מודול? כפי שאפשר לנחש, זה מושג שמצליח להכליל איכשהו גם חבורות אבליות וגם מרחבים וקטוריים וגם עוד כל מני דברים. אני אניח שאתם כבר מכירים מרחבים וקטוריים ולכן אדבר עליהם בחופשיות; די סביר בעיני להכיר אלגברה לינארית לפני שנכנסים לעובי הקורה של האלגברה המופשטת. אז אתם מכירים כבר מרחבים וקטוריים, הנה הגדרת מחץ בשורה אחת למודול: מודול זה כמו מרחב וקטורי, רק מעל חוג שלא חייב להיות שדה.</p>
<p>ההבדל הקטן הזה - חוג ולאו דווקא שדה - הוא עצום. אתם זוכרים אלגברה לינארית? יופי, אז <strong>תשכחו ממנה</strong>. המון משפטים באלגברה לינארית הסתמכו על כך שמרחבים וקטוריים מוגדרים מעל שדה, ובלי זה הכל מתחיל להישבר. למשל, זוכרים את הקטע הזה שכל הבסיסים של מרחב וקטורים הם מאותו גודל? תשכחו מזה כשמדובר על מודולים. נכון שבמרחבים וקטוריים קבוצה בת איבר אחד לא יכולה להיות תלויה לינארית? במודולים היא כן. וזו רק ההתחלה. בקיצור, "מרחב וקטורי מעל חוג" זה אולי משפט מחץ נחמד, אבל בתור כלי עבודה שנותן לנו אינטואיציה עדיף לוותר עליו ולהיות מאוד זהירים ביחס לטענות שאנחנו טוענים.</p>
<p>אז הנה הגדרה יבשה, שהיא אכן בדיוק ההגדרה של מרחב וקטורי רק עם "חוג" במקום "שדה":</p>
<p>חבורה <strong>אבלית</strong> <span class="math">\(M\)</span> (עם פעולה בינארית שאסמן ב-<span class="math">\(+\)</span>) היא <span class="math">\(R\)</span>-מודול שמאלי עבור חוג <span class="math">\(R\)</span> (לאו דווקא קומוטטיבי, אבל אניח שיש לו יחידה) אם קיימת פונקציה <span class="math">\(R\times M\to M\)</span> שאסמן <span class="math">\(\left(r,m\right)\mapsto r\cdot m\)</span>, המקיימת:</p>
<ol>
    <li><span class="math">\(\left(r+s\right)m=rm+sm\)</span> לכל <span class="math">\(r,s\in R\)</span> ו-<span class="math">\(m\in M\)</span>.</li>
    <li><span class="math">\(r\left(m+n\right)=rm+rn\)</span> לכל <span class="math">\(r\in R\)</span> ו-<span class="math">\(m,n\in M\)</span>.</li>
    <li><span class="math">\(\left(rs\right)m=r\left(sm\right)\)</span> לכל <span class="math">\(r,s\in R\)</span> ו-<span class="math">\(m\in M\)</span></li>
    <li><span class="math">\(1\cdot m=m\)</span> לכל <span class="math">\(m\in M\)</span> (כאן <span class="math">\(1\)</span> הוא איבר היחידה של <span class="math">\(R\)</span>).</li>
</ol>
<p>כלומר, מודול הוא חבורה אבלית עם פעולה של "כפל בסקלר" כשהסקלר הוא איבר שנלקח מהחוג <span class="math">\(R\)</span>, עם אקסיומות שאומרות שהפעולה הזו מתנהגת יפה. הראשונה אומרת שחיבור בחוג <span class="math">\(R\)</span> מומר לחיבור במודול <span class="math">\(M\)</span>; השניה אומרת שכפל בסקלר הוא הומומורפיזם של <span class="math">\(M\)</span>; השלישית אומרת שכפל איברים ב-<span class="math">\(R\)</span> שקול ל<strong>הרכבה</strong> של ההומומורפיזמים שהמוכפלים מגדירים; והרביעית אומרת שהזהות של <span class="math">\(R\)</span> היא תמיד הומומורפיזם הזהות. שתי התכונות האחרונות מזכירות את מה שקורה ב<strong>פעולה של חבורה על קבוצה</strong>; רק שכאן ה"פעולה" היא של חוג, והקבוצה היא בעלת מבנה נוסף, של חבורה, שלא מתבטא בשתי האקסיומות האחרונות.</p>
<p>שימו לב שכתבתי "<span class="math">\(R\)</span>-מודול <strong>שמאלי</strong>", כי כאן יש חשיבות לכיוונים. אפשר היה לדבר גם על <span class="math">\(R\)</span>-מודול <strong>ימני</strong> כאשר הפעולה מוגדרת כך: <span class="math">\(\left(m,r\right)\mapsto m\cdot r\)</span>. על פניו זה נראה ריק מתוכן - מה בדיוק משתנה אם מגדירים את זה ככה? <span class="math">\(r\cdot m\)</span> ו-<span class="math">\(m\cdot r\)</span> הם סתם סימונים. אבל באקסיומה 3 יש לעניין הכיוון חשיבות. מילולית, אקסיומה 3 אומרת "הפעולה של האיבר <span class="math">\(rs\)</span> על <span class="math">\(m\)</span> היא כמו הפעלה של <span class="math">\(s\)</span> <strong>ואחר כך</strong> הפעלה של <span class="math">\(r\)</span>". אם היינו משתמשים בסימון ה"ימני", האקסיומה הייתה נכתבת כך:</p>
<ul>
    <li><span class="math">\(m\left(rs\right)=\left(ms\right)r\)</span></li>
</ul>
<p>שימו לב מה קרה - הסדר הפנימי בין <span class="math">\(r,s\)</span> חייב להתהפך כדי שהאקסיומה תשמור את הסמנטיקה שלה. אנחנו לא רוצים לעשות את זה, ולכן כשמגדירים <span class="math">\(R\)</span>-מודול ימני, האקסיומה השלישית שונה, ונראית כך:</p>
<ul>
    <li><span class="math">\(m\left(sr\right)=\left(ms\right)r\)</span></li>
</ul>
<p>אם אני אקח <span class="math">\(R,M\)</span> <strong>כלשהם</strong> ופונקציה שלוקחת זוגות של איבר מ-<span class="math">\(M\)</span> ואיבר מ-<span class="math">\(R\)</span> ומחזירה איבר ב-<span class="math">\(M\)</span>, אז <strong>אותה פונקציה בדיוק</strong> לאו דווקא תקיים גם את אקסיומה 3 וגם את האקסיומה החדשה בו זמנית. רק אם <span class="math">\(R\)</span> <strong>קומוטטיבי</strong> (ולכן <span class="math">\(rs=sr\)</span>) מובטח לי שזה יקרה. מבלבל? הו, בוודאי, זו המחשה פשוטה לבלבולים שמתלווים לעובדה שמודול מוגדר מעל חוג ולא שדה; הרי באלגברה לינארית הכל מוגדר מעל שדה <span class="math">\(F\)</span> שהוא תמיד קומוטטיבי ולכן הדיון הזה נחסך מאיתנו.</p>
<p>שימו לב שבעוד <span class="math">\(R\)</span> לא חייב להיות חוג קומוטטיבי, <span class="math">\(M\)</span> חייבת להיות <strong>חבורה אבלית</strong>. זה מזכיר את האופן שבו חוג <span class="math">\(R\)</span> הוא תמיד חבורה אבלית <strong>ביחס לפעולת החיבור</strong>. בלי זה הכל היה פשוט מסובך מדי; בהמשך (למשל, כשנדבר על מודולי מנה) נראה שדרישת האבליות הזו ממודולים הופכת אותם ליחסית פשוטים ונחמדים, בהתחשב בנסיבות.</p>
<h2>הדוגמאות המרכזיות שלנו</h2>
<p>אני רוצה להתחיל את הדוגמאות למודולים דווקא משתי הדוגמאות ה"כבדות" יותר - אלו שנשתמש בהן אחר כך כדי להסיק ממשפט הפירוק של מודולים על משפט הפירוק של חבורות אבליות, ואת צורת ז'ורדן.</p>
<p>הדוגמא הראשונה היא פשוט <strong>חבורות אבליות</strong>. אמרנו שכל מודול <span class="math">\(M\)</span> הוא מראש חבורה אבלית, אבל בנוסף לכך היינו רוצים שהפעולה של כפל בסקלר מ-<span class="math">\(R\)</span> תשקף איכשהו את המבנה של החבורה האבלית, ואת זה אפשר לעשות בצורה טבעית מאוד. בואו ניזכר שיש לנו שתי דרכי סימון מקובלות לחבורות. בדרך כלל, אנחנו מתארים את הפעולה בתוך חבורה באמצעות סימונים דמויי כפל: <span class="math">\(ab\)</span> היא המכפלה של <span class="math">\(a\)</span> ב-<span class="math">\(b\)</span>, ו-<span class="math">\(a^{n}\)</span> היא המכפלה של <span class="math">\(a\)</span> בעצמו <span class="math">\(n\)</span> פעמים וכדומה. אבל כאשר החבורה שלנו אבלית, מקובלת גם שיטת סימון אלטרנטיבית, שבה הפעולה של החבורה מתוארת עם חיבור. כך ש-<span class="math">\(a+b\)</span> היא ה"מכפלה" של <span class="math">\(a\)</span> ב-<span class="math">\(b\)</span> (כלומר, <span class="math">\(a+b\)</span> זה פשוט סימון שונה ל-<span class="math">\(ab\)</span>), ה"הופכי" של <span class="math">\(a\)</span>, מה שבדרך כלל מסומן בתור <span class="math">\(a^{-1}\)</span>, נקרא כעת "הנגדי" של <span class="math">\(a\)</span> ומסומן <span class="math">\(-a\)</span>; ואיבר היחידה של החבורה מסומן בתור <span class="math">\(0\)</span> (ולא בתור <span class="math">\(e\)</span> או 1 כמו שנהוג בחבורות שמתוארות בצורה כפלית). איך בשיטת הסימון הזו יתואר <span class="math">\(a^{n}\)</span>? זה הרי קיצור ל-<span class="math">\(a+a+\dots+a\)</span> בדיוק <span class="math">\(n\)</span> פעמים; הכתיב המקובל הוא פשוט <span class="math">\(na\)</span>, כלומר "כפל" של המספר הטבעי <span class="math">\(n\)</span> באיבר החבורה <span class="math">\(a\)</span>. אפשר להרחיב את הסימון הזה לכל המספרים השלמים (בדומה לאיך שעושים את זה עבור חזקות): <span class="math">\(0\cdot a=0\)</span> ו-<span class="math">\(-n\cdot a=n\left(-a\right)\)</span>.</p>
<p>כלומר, <strong>שיטת הסימון</strong> של חבורות אבליות כבר מחביאה בתוכה את החשיבה על החבורה האבלית בתור מודול מעל השלמים - מה שנקרא <span class="math">\(\mathbb{Z}\)</span>-מודול. במילים אחרות, כל חבורה אבלית היא אוטומטית <span class="math">\(\mathbb{Z}\)</span>-מודול (חבורות לא אבליות <strong>אינן</strong> <span class="math">\(\mathbb{Z}\)</span>-מודול כי הדרישה הבסיסית שלנו מהקבוצה <span class="math">\(M\)</span> שמגדירה מודול הוא שהיא תהיה חבורה <strong>אבלית</strong>).</p>
<p>זה עובד גם בכיוון ההפוך: אם <span class="math">\(M\)</span> הוא <span class="math">\(\mathbb{Z}\)</span>-מודול כלשהו, לא קשה להראות שפעולת הכפל בסקלר של <span class="math">\(M\)</span> חייבת להתאים למושג ה"חיבור שוב ושוב" של חבורה. כי תראו מה קורה משילוב אקסיומות 1 ו-2 ו-4 של מודול:</p>
<p><span class="math">\(m+m=1\cdot m+1\cdot m=\left(1+1\right)\cdot m=2\cdot m\)</span></p>
<p>וכך זה יעבוד למספר סופי כלשהו של מחוברים. השוויון הזה לא טריוויאלי: בקצה השמאלי שלו אין זכר לחוג <span class="math">\(R\)</span>, ובקצה הימני שלו יש לנו כפל בסקלר מתוך <span class="math">\(R\)</span>.</p>
<p>באופן דומה: <span class="math">\(0\cdot m=\left(0+0\right)\cdot m=0\cdot m+0\cdot m\)</span> ולכן נקבל <span class="math">\(0\cdot m=0\)</span> (לא ממש שונה מאיך שזה קורה בחוגים)</p>
<p>ובאופן דומה: <span class="math">\(-1\cdot m+1\cdot m=\left(-1+1\right)\cdot m=0\cdot m=0\)</span> ולכן <span class="math">\(-1\cdot m=-m\)</span> (שוב, בצד שמאל יש לנו כפל בסקלר, בצד ימין אין כפל בסקלר, כך שזה לא שוויון טריוויאלי).</p>
<p>המסקנה היא ש-<span class="math">\(\mathbb{Z}\)</span> מודול וחבורה אבלית שמתוארת בצורה חיבורית <strong>הם בדיוק אותו דבר</strong>.</p>
<p>כעת, <span class="math">\(\mathbb{Z}\)</span> הוא חוג נחמד מאוד: הוא קומוטטיבי, והוא אפילו חוג אוקלידי, מה שגרר את זה שהוא תחום ראשי. משפט המבנה של מודולים שנוכיח בהמשך מדבר על מודולים נוצרים סופית <strong>מעל תחום ראשי</strong>, כך שהוא יחול בקלות על <span class="math">\(\mathbb{Z}\)</span>-מודולים נוצרים סופית, כלומר על חבורות אבליות נוצרות סופית.</p>
<p>כעת, אם תזכרו, ל-<span class="math">\(\mathbb{Z}\)</span> היה מעין בן דוד, גם הוא חוג אוקלידי, שהיה מאוד דומה ל-<span class="math">\(\mathbb{Z}\)</span> ומאוד נחמד בפני עצמו - <strong>חוג הפולינומים במשתנה יחיד מעל שדה</strong>, מה שאסמן כאן <span class="math">\(F\left[x\right]\)</span>. גם <span class="math">\(F\left[x\right]\)</span>-מודול נכנס תחת מה שמשפט המבנה של מודולים מדבר עליו - אבל מה זה <span class="math">\(F\left[x\right]\)</span>-מודול? ובכן, זה מתאים בול ל"מרחב וקטורי עם טרנספורמציה לינארית שאנחנו רוצים לז'רדן".</p>
<p>מה זה <span class="math">\(F\)</span>-מודול, כאשר <span class="math">\(F\)</span> הוא שדה? כאמור, זה בדיוק מרחב וקטורי. <strong>כל</strong> מרחב וקטורי <span class="math">\(V\)</span> הוא <span class="math">\(F\)</span>-מודול עבור <span class="math">\(F\)</span> מתאים. לפעולה של <span class="math">\(F\)</span> על <span class="math">\(V\)</span> אנחנו קוראים "כפל בסקלר" ולרוב מסמנים את זה כך: <span class="math">\(\lambda v\)</span> כאשר <span class="math">\(\lambda\in F\)</span> ו-<span class="math">\(v\in V\)</span>. חוץ מהאותיות ה"לא סטנדרטיות" זה אותו הדבר.</p>
<p>עכשיו בואו ניקח טרנספורמציה לינארית <span class="math">\(T:V\to V\)</span> ונגדיר "כפל בפולינום" בצורה שתלויה ב-<span class="math">\(T\)</span> הזה:</p>
<p><span class="math">\(\left(a_{n}x^{n}+\dots+a_{1}x+a_{0}\right)v\triangleq a_{n}T^{n}\left(v\right)+\dots+a_{1}T\left(v\right)+a_{0}v\)</span></p>
<p>מה הולך כאן? אינטואיטיבית, אנחנו מציבים את <span class="math">\(T\)</span> בפולינום, מקבלים טרנספורמציה לינארית חדשה, מפעילים אותה על <span class="math">\(v\)</span> ומחזירים את התוצאה. דרך אחרת לחשוב על זה: אנחנו מגדירים שהפעולה של <span class="math">\(x\)</span> על <span class="math">\(v\)</span> היא פשוט הפעלת <span class="math">\(T\)</span>: <span class="math">\(x\cdot v=T\left(v\right)\)</span>; כעת אנחנו מרחיבים בצורה לינארית את הפעולה הזו. כל אלו הן אינטואיציות; בסופו של דבר המשוואה שכתבתי לעיל היא ההגדרה המפורשת ומה שקורה בפועל.</p>
<p>ההגדרה תלויה מאוד ב-<span class="math">\(T\)</span>; עבור כל <span class="math">\(T\)</span> שונה מעל <span class="math">\(V\)</span> אנחנו נקבל <span class="math">\(F\left[x\right]\)</span>-מודול שונה. כמו כן, אם ניקח <span class="math">\(F\left[x\right]\)</span>-מודול <strong>כלשהו</strong>, נשתמש בהגדרה של הכפל עם הפולינומים הקבועים כדי להגדיר "כפל בסקלר" מתוך <span class="math">\(F\)</span> נקבל שהמודול הוא מרחב וקטורי מעל <span class="math">\(F\)</span>; עכשיו נוכל להגדיר טרנספורמציה לינארית <span class="math">\(T:V\to V\)</span> על ידי <span class="math">\(T\left(v\right)=x\cdot v\)</span>; תכונות המודול מראות שהיא אכן טרנספורמציה לינארית. זה מראה שעל כל <span class="math">\(F\left[x\right]\)</span>-מודול אפשר לחשוב בתור מרחב וקטורי עם טרנספורמציה לינארית <span class="math">\(T\)</span> שכפל בפולינום הוא כמו הפעלת הפולינום הזה על <span class="math">\(T\)</span> והפעלת התוצאה על איבר מ-<span class="math">\(V\)</span>.</p>
<p>אני מקווה שהדוגמא הזו היא בעלת אפקט עליכם שדומה לזה שהיה עלי. כשראיתי אותה הייתי בהלם של "אוקיי, ממש לא ראיתי <strong>את זה</strong> בא" והעולם פתאום הפך לפשוט והגיוני קצת יותר. אבל אולי זה רק אני.</p>
<p>כמובן, צריך לבדוק שהפעולה הזו אכן מגדירה מודול; אני אשאיר לכם את התענוג הזה.</p>
<p>אני רוצה לדבר עכשיו על עוד כמה מקרים של מודולים שהם יותר כלליים ופחות ישר ולעניין כמו הדוגמאות שכבר הצגתי. נתחיל מהדוגמא הפשוטה ביותר: אם <span class="math">\(R\)</span> הוא חוג כלשהו אז <span class="math">\(M=R\)</span> הוא <span class="math">\(R\)</span>-מודול שמאלי, כשפעולת ה"כפל בסקלר" היא פשוט פעולת הכפל הרגילה ב-<span class="math">\(R\)</span>. זה מזכיר את האופן שבו שדה הוא מרחב וקטורי מעל עצמו והאופן שבו חבורה יודעת לפעול על עצמה. זה אולי נראה טריוויאלי, אבל זה אומר שכל מני דברים שאנחנו מוכיחים על מודולים יכולים לעבור לחוגים "כמעט כמות שהם", ועוד נראה דוגמאות לכך.</p>
<p>עוד בניה בסיסית של מודול מתוך כל חוג <span class="math">\(R\)</span> מזכירה באופיה את מה שקורה באלגברה לינארית. שם מוכיחים בסופו של דבר שכל מרחב ממימד <span class="math">\(n\)</span> איזומורפי למרחב הוקטורי <span class="math">\(F^{n}\)</span>. במודולים אין תוצאה כזו, אבל עדיין אפשר לדבר על המרחב <span class="math">\(R^{n}\triangleq\left\{ \left(r_{1},\dots,r_{n}\right)\ |\ r_{1},\dots,r_{n}\in R\right\} \)</span>. המרחב הזה הוא חבורה אבלית עם חיבור "רכיב-רכיב" (<span class="math">\(\left(r_{1},\dots,r_{n}\right)+\left(s_{1},\dots,s_{n}\right)\triangleq\left(r_{1}+s_{1},\dots,r_{n}+s_{n}\right)\)</span>) ואפשר להפוך אותו ל-<span class="math">\(R\)</span>-מודול על ידי הכפל הטבעי בסקלר: <span class="math">\(\alpha\left(r_{1},\dots,r_{n}\right)\triangleq\left(\alpha r_{1},\dots,\alpha r_{n}\right)\)</span>.</p>
<p>עוד דוגמא חשובה היא לאופן שבו אפשר לצמצם את חוג הסקלרים של מודול - וזה משהו שפשוט לא יכול לקרות במרחבים וקטוריים. נניח ש-<span class="math">\(M\)</span> הוא <span class="math">\(R\)</span>-מודול, וש-<span class="math">\(I\)</span> הוא אידאל דו-צדדי ב-<span class="math">\(R\)</span>. אז חוג המנה <span class="math">\(R/I\)</span> מוגדר היטב, אבל האם אפשר להגדיר כפל בסקלר מתוך <span class="math">\(R/I\)</span>? איבר כללי של <span class="math">\(R/I\)</span> הוא מהצורה <span class="math">\(r+I\)</span>. אי אפשר סתם לומר ש-<span class="math">\(\left(r+I\right)m\triangleq rm+Im\)</span> כי הסימון <span class="math">\(Im\)</span> לא מוגדר בכלל, ואין סיבה להניח שהוא יהיה איבר בודד. אבל אפשר <strong>להניח</strong> שהוא יהיה איבר בודד. במקרה הזה, מכיוון ש-<span class="math">\(0\in I\)</span>, בהכרח צריך להתקיים <span class="math">\(Im=0\)</span>, וזאת לכל <span class="math">\(M\)</span>. לסיטואציה הזו יש שם: אומרים שהאידאל <span class="math">\(I\)</span> ב-<span class="math">\(R\)</span> <strong>מאפס</strong> את <span class="math">\(M\)</span>. במקרה הזה, ההגדרה <span class="math">\(\left(r+I\right)m\triangleq rm\)</span> אכן מגדירה לנו <span class="math">\(R/I\)</span>-מודול מתוך <span class="math">\(M\)</span>.</p>
<h2>למה שלא נדבר על אלגבראות אם כבר אנחנו פה</h2>
<p>עד כה ראינו כמה מבנים אלגבריים מהותיים - חבורות, חוגים, שדות ועכשיו גם מודולים. אני רוצה לנצל את ההזדמנות כדי להציג מבנה נוסף שקשור אליהם, למרות שאני לא בטוח עד כמה אזדקק לו בהמשך - <strong>אלגברה</strong> (כן, למבנה האלגברי עצמו קוראים "אלגברה". פשוט נגמרו להם הרעיונות לשמות, מה?). אפשר לחשוב על אלגברה בתור שילוב של מודול (או מרחב וקטורי) עם חוג - בנוסף לפעולות החיבור והכפל בסקלר, יש לנו גם פעולה של כפל בין האיברים של האלגברה, והכפל הזה "משחק יפה" עם החיבור והכפל בסקלר של המודול, מה שבאחת ההגדרות של אלגברה נדרש במפורש. אני הולך להציג את הגדרה טיפה שונה, שבמבט ראשון היא אולי מבלבלת יותר אבל עם המוטיבציה הנכונה אני מקווה שהיא תהיה ברורה יותר דווקא.</p>
<p>המוטיבציה שאנסה לתת היא <strong>מטריצות</strong>. מטריצות הן דבר נפלא כי הן המוטיבציה לכל דבר בערך. חבורות? <strong>מטריצות</strong> הפיכות הן חבורה ביחס לכפל מטריצות! וחבורה מעניינת כי היא יכולה להיות לא אבלית! חוגים? <strong>מטריצות</strong> הן חוג ביחס לחיבור וכפל מטריצות! וחוג מעניין כי יש בו מחלקי אפס! מודולים? <strong>מטריצות</strong> הן מודול ביחס לחיבור מטריצות וכפל בסקלר! ומודול מעניין כי... כי... כי... ובכן, כי <strong>כפל מטריצות</strong> הוא משהו שאנחנו מכירים ממש טוב וממש תוהים איך הוא יכול להיכנס לכל הסיפור הזה של מודול.</p>
<p>הנה דרך שבה הוא יכול להיכנס פנימה. מטריצות פשוטות במיוחד הן <strong>המטריצות הסקלריות</strong>. אלו מטריצות שהן 0 בכל מקום למעט האלכסון הראשי, שכל הכניסות בו הן <span class="math">\(\lambda\)</span> עבור סקלר כלשהו מהחוג שמעליו המטריצות מוגדרות. למשל <span class="math">\(\left(\begin{array}{ccc} 7 & 0 & 0\\ 0 & 7 & 0\\ 0 & 0 & 7 \end{array}\right)\)</span> היא המטריצה הסקלרית מסדר <span class="math">\(3\times3\)</span> עבור הערך "7". אנחנו יודעים שכפל של מטריצה <span class="math">\(A\)</span> כלשהי במטריצה סקלרית שמתאימה לסקלר <span class="math">\(\lambda\)</span> זה <strong>אותו הדבר בדיוק</strong> כמו לכפול את <span class="math">\(A\)</span> בסקלר <span class="math">\(\lambda\)</span>. ההבדל? כפל מטריצות הוא כפל של <strong>איברים בתוך המודול</strong> בעוד שלכפול את <span class="math">\(A\)</span> בסקלר זה <strong>כפל איבר במודול באיבר מתוך החוג</strong>.</p>
<p>מה שאנחנו עושים באלגברה לינארית לפעמים הוא לחשוב על סקלרים בתור משהו ש<strong>משוכן</strong> בתוך חוג המטריצות - סקלר משוכן בתוך המטריצה הסקלרית המתאימה לו. בגישה הזו, אפשר לשכוח מהחוג שמעליו אנחנו מוגדרים ולהתעסק רק עם פעולת כפל המטריצות; כפל באיבר מהחוג מתורגם לכפל מטריצות. כפל שתי מטריצות שמתאימות לאיברים מהחוג זה כמו כפל האיברים מהחוג עצמם. בניסוחים הרגילים שלנו, יש לנו <strong>הומומורפיזם</strong> מחוג הסקלרים אל חוג המטריצות.</p>
<p>עוד נקודה שצריך לקחת מדוגמת המטריצות - מטריצות סקלריות מפורסמות בכך שהן <strong>מתחלפות בכפל</strong> עם כל מטריצה. כלומר, אם <span class="math">\(A\)</span> מטריצה כלשהי ו-<span class="math">\(B\)</span> מטריצה סקלרית, אז <span class="math">\(AB=BA\)</span>. אומרים על זה ש-<span class="math">\(B\)</span> שייכת ל<strong>מרכז</strong> של חוג המטריצות (מרכז של חוג, כמו מרכז של חבורה, הוא אוסף האיברים שמתחלפים עם <strong>כל</strong> אברי המבנה האלגברי בכפל). זה מנחה את ההגדרה הבאה של אלגברה:</p>
<ul>
    <li>חוג <span class="math">\(M\)</span> הוא <span class="math">\(R\)</span>-<strong>אלגברה</strong> עבור חוג <strong>קומוטטיבי </strong><span class="math">\(R\)</span> אם קיים הומומורפיזם <span class="math">\(\varphi:R\to M\)</span> כך ש-<span class="math">\(\varphi\left(R\right)\)</span> מוכל במרכז של <span class="math">\(M\)</span> ו-<span class="math">\(\varphi\left(1_{R}\right)=1_{M}\)</span>.</li>
</ul>
<p>תחשבו על <span class="math">\(M\)</span> בתור "חוג מטריצות", על <span class="math">\(R\)</span> בתור "חוג סקלרים" ועל <span class="math">\(\varphi\)</span> בתור ההעתקה שלוקחת סקלר ומחזירה את המטריצה הסקלרית המתאימה; זה האבטיפוס של מה שהולך פה.</p>
<p>שימו לב שההגדרה שלי <strong>לא</strong> הניחה ש-<span class="math">\(M\)</span> הוא מודול. היא לוקחת את <span class="math">\(M\)</span> להיות חוג, ומייצרת קשר בינו ובין חוג <span class="math">\(R\)</span> על ידי שיכון. הנקודה היא שעכשיו אפשר לנצל את פעולת הכפל שקיימת על <span class="math">\(M\)</span> כדי להגדיר פעולת <strong>כפל בסקלר</strong> של <span class="math">\(R\)</span> על <span class="math">\(M\)</span>: פשוט מגדירים <span class="math">\(r\cdot m\triangleq\varphi\left(r\right)\cdot m\)</span>. באגף ימין יש פעולת כפל מבוססת היטב - הכפל בתוך <span class="math">\(M\)</span> עצמו. תכונות הכפל בחוג והעובדה ש-<span class="math">\(\varphi\)</span> הוא הומומורפיזם גוררות חיש קל את זה שפעולת הכפל החדשה הזו הופכת את <span class="math">\(M\)</span> להיות <span class="math">\(R\)</span>-מודול.</p>
<h2>החשודים המיידיים - תתי-מודולים, מודולי מנה והומומורפיזמים</h2>
<p>בשלב הזה של ההיכרות שלנו עם מבנים אלגבריים, הנוהל כבר הפך להיות סטנדרטי - הגדרנו מבנה אלגברי חדש? יאללה, להגדיר לו תת-מבנים, ומבני מנה, והומומורפיזמים והיי תראו כתבתי מחדש את כל מה שכתבתי בכותרת. זה לא מפתיע; אם אדבר יום אחד על <strong>תורת הקטגוריות</strong> גם יהיה ברור שזה מה ש"נכון" לעשות, אבל זה שהנוהל כבר שחוק אומר שאני לא אפרט על המוטיבציות אליו כפי שעשיתי עבור חבורות אלא אגש אל הישר ולעניין.</p>
<p>תת-מודול של <span class="math">\(R\)</span>-מודול <span class="math">\(M\)</span> הוא תת-קבוצה של <span class="math">\(M\)</span> שהיא בעצמה <span class="math">\(R\)</span>-מודול (בפרט, היא <strong>סגורה</strong> ביחס לכפל באיבר של <span class="math">\(R\)</span>). איך בודקים את זה? כמו שעושים עם תתי-מרחבים וקטוריים: אם <span class="math">\(N\subseteq M\)</span> אז בודקים שמתקיים <span class="math">\(rm+sn\in N\)</span> עבור <span class="math">\(m,n\in M\)</span> ו-<span class="math">\(r,s\in R\)</span>.</p>
<p>עבור <span class="math">\(\mathbb{Z}\)</span>-מודולים (חבורות אבליות - זוכרים?) תתי-המודולים הם פשוט תתי-חבורות (וקריטריון השייכות מצטמצם לצורך לבדוק ש-<span class="math">\(m-n\in N\)</span>, שזה מה שהצגנו בשעתו כשדיברנו על תת-חבורות). עבור חוג <span class="math">\(R\)</span> שהוא מודול מעל עצמו, תתי-המודולים הם פשוט האידאלים של <span class="math">\(R\)</span>. עבור <span class="math">\(F\left[x\right]\)</span>-מודולים הסיפור יותר מעניין. תתי-המודולים הם לא "סתם" תתי-מרחבים; הרי צריך איכשהו שהמבנה של הכפל בסקלר יבוא לידי ביטוי. בפרט, אם <span class="math">\(v\in U\)</span> עבור תת-מודול פוטנציאלי <span class="math">\(U\)</span> אז צריך לבדוק שגם <span class="math">\(x\cdot v\in U\)</span>, כלומר ש-<span class="math">\(T\left(v\right)\in U\)</span>. במילים אחרות, צריך לבדוק שיתקיים <span class="math">\(T\left(U\right)\subseteq U\)</span>. תתי-מרחבים שמקיימים את התכונה הזו נקראים <span class="math">\(T\)</span>-אינוריאנטיים; כשדיברתי בבלוג על אלגברה לינארית וצורות קנוניות תתי-מרחבים כאלו מילאו תפקיד חשוב ביותר, וכך יהיה גם כאן.</p>
<p>ההגדרה של הומומורפיזם גם היא סטנדרטית, ומזכירה כמובן את ההגדרה של טרנספורמציה לינארית: אם <span class="math">\(M,N\)</span> הם שני <span class="math">\(R\)</span>-מודולים, אז <span class="math">\(\varphi:M\to N\)</span> הוא הומומורפיזם של <span class="math">\(R\)</span>-מודולים אם</p>
<ul>
    <li><span class="math">\(\varphi\left(x+y\right)=\varphi\left(x\right)+\varphi\left(y\right)\)</span> לכל <span class="math">\(x,y\in M\)</span></li>
    <li><span class="math">\(\varphi\left(rx\right)=r\varphi\left(x\right)\)</span> לכל <span class="math">\(x\in M\)</span> ו-<span class="math">\(r\in R\)</span></li>
</ul>
<p>הומומורפיזם חח"ע ועל הוא <strong>איזומורפיזם</strong> ומסמנים <span class="math">\(M\cong N\)</span> אם קיים ביניהם איזומורפיזם. מגדירים את הגרעין והתמונה של <span class="math">\(\varphi\)</span> בדרך הרגילה:</p>
<ul>
    <li><span class="math">\(\ker\varphi\triangleq\left\{ m\in M\ |\ \varphi\left(m\right)=0\right\} \)</span></li>
    <li><span class="math">\(\varphi\left(M\right)\triangleq\left\{ \varphi\left(m\right)\ |\ m\in M\right\} \)</span></li>
</ul>
<p>קל לבדוק ש-<span class="math">\(\ker\varphi\)</span> הוא תת-מודול של <span class="math">\(M\)</span> ו-<span class="math">\(\varphi\left(M\right)\)</span> הוא תת-מודול של <span class="math">\(N\)</span>.</p>
<p>סימון סטנדרטי שמופיע באלגברה לינארית אבל לא ראינו עד כה בהקשר של אלגברה מופשטת הוא הסימון למרחב כל ההומומורפיזמים מ-<span class="math">\(M\)</span> ל-<span class="math">\(N\)</span>, שמסומן <span class="math">\(\text{Hom}_{R}\left(M,N\right)\)</span>. באלגברה לינארית, המרחב הזה הוא בעצמו תמיד מרחב וקטורי. אצלנו... אצלנו המצב קצת יותר מסובך, ונדבר על זה בהמשך.</p>
<p>עכשיו בואו נדבר על מודולי מנה. עד כה, מנה של מבנה אלגברי התקבלה מכך שלקחנו תת-מבנה שלו ובדקנו אילו תכונות נוספות הוא צריך לקיים כדי שמרחב המנה יירש את המבנה האלגברי מהמרחב המקורי. במקרה של חבורות ראינו שתת-החבורה צריכה להיות <strong>נורמלית</strong> ובמקרה של חוג ראינו שתת-החוג צריך להיות <strong>אידאל</strong>. במקרה של מודולים <strong>אין שום דרישה נוספת</strong>. אפשר לחלק בכל תת-מודול ולקבל קבוצת מנה שהיא מודול ביחס לפעולה שנורשת מהמודול המקורי. מה הקסם פה? אין שום קסם: כזכור, מודול <span class="math">\(M\)</span> הוא בראש ובראשונה חבורה <strong>אבלית</strong>. זה מראש מטפל באספקט הבעייתי של החלוקה - הצורך שהפעולה בין איברים בתוך מרחב המנה תתנהג יפה. שנית, ראינו כבר שתתי-מודולים זו דרישה שמקפלת בתוכה את תכונת ה"בליעה" שדרשנו במפורש עבור תת-חוגים; תת-מודול פירושו מראש שאם <span class="math">\(m\)</span> שייך לתת-המודול ו-<span class="math">\(r\in R\)</span> אז גם <span class="math">\(rm\)</span> יהיה שייך לתת- המודול - זו בדיוק המהות של "בליעה".</p>
<p>בקיצור, הסיבה שאפשר לחלק בכל תת-מודול מצביעה בעיקר על כך שמודולים הם מבנים קצת יותר "מגבילים" מאשר חוגים או חבורות. אבל היי, עדיין מגניב.</p>
<p>בואו נזכיר קונקרטית מה זה אומר "לחלק": אם <span class="math">\(M\)</span> הוא <span class="math">\(R\)</span>-מודול ו-<span class="math">\(N\)</span> הוא תת-מודול של <span class="math">\(M\)</span>, אז אפשר להסתכל על הקבוצה <span class="math">\(M/N\triangleq\left\{ m+N\ |\ m\in M\right\} \)</span> של כל <strong>הקוסטים</strong> של <span class="math">\(N\)</span> בתוך <span class="math">\(M\)</span> (קוסט הוא קבוצה <span class="math">\(m+N\triangleq\left\{ m+n\ |\ n\in N\right\} \)</span> שאפשר לחשוב עליה בתור "הזזה" של כל <span class="math">\(N\)</span>). על הקבוצה <span class="math">\(M/N\)</span> הזו מגדירים פעולות של חיבור וכפל בסקלר מתוך <span class="math">\(R\)</span>, ובכך הופכים אותה ל-<span class="math">\(R\)</span>-מודול בעצמה:</p>
<ul>
    <li><span class="math">\(\left(x+N\right)+\left(y+N\right)\triangleq\left(x+y\right)+N\)</span></li>
    <li><span class="math">\(r\left(x+N\right)\triangleq xr+N\)</span></li>
</ul>
<p>כלומר, הפעולות של החיבור והכפל ב-<span class="math">\(M/N\)</span> לא באו משום מקום; הן מתבססות על הפעולות בתוך <span class="math">\(M\)</span> (זה מה שקורה באגף ימין של המשוואות). מכיוון שיש דרכים שונות לכתוב את אותו קוסט (אם <span class="math">\(x-y\in N\)</span> אז <span class="math">\(x+N=y+N\)</span>) צריך להוכיח שההגדרות לעיל <strong>מוגדרות היטב</strong>; שבחירה שונה של נציגים לאותו קוסט לא מניבה תוצאות שונות. עבור חיבור זה נובע מכך ש-<span class="math">\(M\)</span> היא חבורה אבלית; בואו נרגיע את עצמנו שזה עובד גם עבור כפל.</p>
<p>נניח אם כן ש-<span class="math">\(x+N=y+N\)</span> - לקחנו שני נציגים שונים לאותו קוסט. זה אומר, כאמור, ש-<span class="math">\(x-y\in N\)</span>. כעת, <span class="math">\(N\)</span> הוא תת-מודול ולכן סגור לפעולה של כפל בסקלר מ-<span class="math">\(R\)</span>, כלומר <span class="math">\(r\left(x-y\right)\in N\)</span>. על פי אקסיומה 2 של מודולים נקבל <span class="math">\(rx-ry\in N\)</span>, כלומר <span class="math">\(rx+N=ry+N\)</span>, מה שמסיים את ההוכחה. פשוט! בשלב הזה כל מה שאנחנו עושים הוא פשוט.</p>
<p>בחבורות וחוגים היה עניין כזה שבו תת-החבורות הנורמליות והאידאלים (תתי-המבנים שבהם "מותר" לחלק) היו בדיוק הגרעינים של הומומורפיזמים מהמבנה המקורי. על פי אותו הגיון, אצלנו <strong>כל</strong> תת-מודול אמור להיות גרעין שכזה, אז מה ההומומורפיזם? כמו שהיה אז, קוראים לו "ההטלה הטבעית", מסמנים אותו ב-<span class="math">\(\pi\)</span> והוא מוגדר כך:</p>
<p><span class="math">\(\pi:M\to M/N\)</span></p>
<p><span class="math">\(\pi\left(x\right)\triangleq x+N\)</span></p>
<p>העובדה שזה הומומורפיזם נובעת מיידית מכך ש-<span class="math">\(M/N\)</span> הוא אכן מודול, וברור ש-<span class="math">\(\ker\pi=N\)</span>.</p>
<p>עוד דבר שעשינו בחבורות וחוגים היה <strong>משפטי האיזומורפיזם</strong> - משפטים שהם כלי עבודה בסיסי עבורנו כשמתחילים להשתגע עם בניות והומומורפיזמים מסובכים. הם עוברים ככתבם וכלשונם גם למודולים, אז אני אסתפק בלצטט אותם. הניסוח שלהם <strong>פשוט יותר</strong> מאשר במקרה של חבורות, למשל, כי לא צריך לדבר על מתי משהו נורמלי ומתי לא.</p>
<ul>
    <li>(משפט האיזומורפיזם הראשון): אם <span class="math">\(M,N\)</span> הם <span class="math">\(R\)</span>-מודולים ו-<span class="math">\(\varphi:M\to N\)</span>ֳ הומומורפיזם, אז <span class="math">\(M/\ker\varphi\cong\varphi\left(M\right)\)</span>.</li>
    <li>(משפט האיזומורפיזם השני): אם <span class="math">\(M\)</span> הוא <span class="math">\(R\)</span>-מודול ו-<span class="math">\(A,B\)</span> תת-מודולים שלו אז <span class="math">\(\left(A+B\right)/B\cong A/\left(A\cap B\right)\)</span>.</li>
    <li>(משפט האיזומורפיזם השלישי): אם <span class="math">\(M\)</span> הוא <span class="math">\(R\)</span>-מודול ו-<span class="math">\(A\subseteq B\)</span> שני תת-מודולים שלו, אז <span class="math">\(\left(M/A\right)/\left(B/A\right)\cong M/B\)</span>.</li>
    <li>(משפט האיזומורפיזם הרביעי): אם <span class="math">\(M\)</span> הוא <span class="math">\(R\)</span>-מודול עם תת-מודול <span class="math">\(N\)</span> אז יש התאמה חח"ע ועל בין תתי-המודולים של <span class="math">\(M\)</span> שמכילים את <span class="math">\(N\)</span> ובין תתי-המודולים של <span class="math">\(M/N\)</span>. ההתאמה נתונה על ידי <span class="math">\(A\leftrightarrow A/N\)</span>.</li>
</ul>
<p>השתמשתי במשפט השני בסימון <span class="math">\(A+B\)</span> שהמשמעות שלו סטנדרטית אבל אולי כדאי להזכיר אותה: <span class="math">\(A+B\triangleq\left\{ a+b\ |\ a\in A,b\in B\right\} \)</span>. זו בעצם דרך אחת לבנות תת-מודול חדש מתוך תת-מודולים קיימים. בואו נראה את ההכללות המתבקשות שלה.</p>
<h2>יוצרים של מודולים</h2>
<p>אחד מהמושגים החשובים ביותר באלגברה לינארית הוא זה של <strong>בסיס</strong> למרחב וקטורי - קבוצה של איברים שצירופים לינאריים שלה (כלומר, סכומים סופיים של איברים מתוכה עם מקדמים שנלקחים מתוך השדה) יוצרים את כל האיברים במרחב, וכל איבר נוצר בדרך ייחודית. במודולים המושג הנחמד הזה כבר לא בדיוק קיים ותכף נראה למה, אבל עדיין אפשר לדבר על קבוצה ש<strong>יוצרת</strong> מודול מסויים באמצעות צירופים לינאריים (באלגברה לינארית דבר כזה נקרא <span class="math">\(\text{span}\)</span>).</p>
<p>בואו ניקח מודול <span class="math">\(M\)</span>. ראשית, אם <span class="math">\(N_{1},\dots,N_{k}\)</span> הם תת-מודולים שלו, אז אפשר להגדיר את הסכום שלהם: <span class="math">\(N_{1}+N_{2}+\dots+N_{k}\triangleq\left\{ n_{1}+\dots+n_{k}\ |\ n_{i}\in N_{i}\right\} \)</span>.</p>
<p>שנית, אם <span class="math">\(A\subseteq M\)</span> היא <strong>קבוצה כלשהי</strong> (לאו דווקא תת-מודול) אז אפשר לדבר על תת-המודול שהיא יוצרת: <span class="math">\(RA\triangleq\left\{ r_{1}a_{1}+\dots+r_{n}a_{n}\ |\ r_{i}\in R,a_{i}\in A,n\ge1\right\} \)</span>. צריך להבין מה בדיוק <span class="math">\(RA\)</span> מסמל פה: זה אוסף כל הצירופים הלינאריים של איברים מתוך <span class="math">\(A\)</span> עם מקדמים מתוך <span class="math">\(R\)</span> <strong>מאורך סופי כלשהו</strong>. כלומר, <span class="math">\(RA\)</span> כולל את כל הצירופים מאורך 1, ואת כל הצירופים מאורך 2 וכן הלאה. במקרה שבו <span class="math">\(A\)</span> סופית קל יותר לכתוב את זה: אם <span class="math">\(A=\left\{ a_{1},\dots,a_{n}\right\} \)</span> אז פשוט מתקיים <span class="math">\(RA=\left\{ r_{1}a_{1}+\dots+r_{n}a_{n}\ |\ r_{i}\in R\right\} \)</span> ואפשר אפילו לכתוב <span class="math">\(RA=Ra_{1}+Ra_{2}+\dots+Ra_{n}\)</span> תוך התבססות על הגדרת החיבור של תת-מודולים שנתתי קודם.</p>
<p>לא קשה לראות ש-<span class="math">\(RA\)</span> הוא תת-מודול, ושזה תת-המודול הקטן ביותר של <span class="math">\(M\)</span> שמכיל את <span class="math">\(A\)</span>. כאן מתחבאת עוד הדגמה לכמה מודולים עלולים להיות מבלבלים: אם לא הייתי מניח ש-<span class="math">\(R\)</span> הוא חוג עם יחידה (ובהחלט מדברים לפעמים על מודולים מעל חוגים ללא יחידה) אז הקטע הזה של "מכיל את <span class="math">\(A\)</span>" בכלל לא היה נכון בהכרח.</p>
<p>על <span class="math">\(A\)</span> אומרים שהיא <strong>יוצרת</strong> את תת-המודול <span class="math">\(RA\)</span>. לאותו תת-מודול יכולות להיות קבוצות רבות ושונות של יוצרים. אם לפחות אחת מקבוצות היוצרים של תת-המודול היא סופית, אז אומרים שהוא <strong>נוצר סופית</strong>. מודולים נוצרים סופית הולכים לשחק תפקיד מכריע במה שנעשה בהמשך.</p>
<p>עכשיו, בואו נראה כמה דוגמאות כדי לראות כמה העסק הזה דומה וגם לא דומה לאלגברה לינארית. נתחיל עם המודול <span class="math">\(M=\mathbb{Z}\)</span> מעל החוג <span class="math">\(\mathbb{Z}\)</span>. מהי הקבוצה <span class="math">\(\mathbb{Z}n\)</span> בחוג הזה? ובכן, היא מה שבדרך כלל היינו מסמנים בתור <span class="math">\(n\mathbb{Z}=\left\{ nk\ |\ k\in\mathbb{Z}\right\} \)</span>; כמובן ששני הסימונים מתארים בדיוק את אותו דבר כי <span class="math">\(\mathbb{Z}\)</span> קומוטטיבי. כעת, המסקנה היא ש-<span class="math">\(\mathbb{Z}1=M\)</span>, כלומר יש לנו קבוצה בת איבר בודד שיוצרת את החוג. הקבוצה הזו היא בבירור בלתי תלויה לינארית במובן הרגיל של אלגברה לינארית (אם צירוף לינארי של אבריה שווה לאפס אז כל המקדמים הם אפס). לכן באלגברה לינארית היינו אומרים שהמימד של <span class="math">\(\mathbb{Z}\)</span> הוא 1.</p>
<p>בינתיים נראה דומה לאלגברה לינארית, אבל מה קורה אם <span class="math">\(M=n\mathbb{Z}\)</span>? גם זו חבורה אבלית לגיטימית ו-<span class="math">\(1\)</span> יוצר את המודול המתאים מעל <span class="math">\(\mathbb{Z}\)</span>. אבל <span class="math">\(n\cdot1=0\)</span>, כך שקיבלנו צירוף לינארי של אברי הקבוצה <span class="math">\(\left\{ 1\right\} \)</span> כך שלא כל מקדמי הצירוף הם 0 (כי <span class="math">\(n\in\mathbb{Z}\)</span> אינו אפס בחוג <span class="math">\(\mathbb{Z}\)</span> שמעליו המודול הוגדר). האם <span class="math">\(\left\{ 1\right\} \)</span> היא "תלויה לינארית"? בהגדרות הרגילות של אלגברה לינארית, כן; אבל באלגברה לינארית מעולם לא נתקלנו בקבוצה מגודל 1 שהיא תלויה לינארית.</p>
<p>מה קורה אם <span class="math">\(M=\mathbb{Z}_{2}\times\mathbb{Z}_{2}\)</span>? גם זו חבורה אבלית לגיטימית. מי יוצר אותה? איבר בודד לא יצליח: <span class="math">\(\left(1,0\right)\)</span> למשל מקיים <span class="math">\(2\cdot\left(1,0\right)=\left(0,0\right)\)</span>. לכן קבוצת יוצרים צריכה להיות מגודל 2 לפחות, למשל <span class="math">\(\left\{ \left(1,0\right),\left(0,1\right)\right\} \)</span>. מצד שני, <strong>כל</strong> קבוצה של איברים מ-<span class="math">\(M\)</span> היא "תלויה לינארית" כי כפל ב-2 של כל איבר מחזיר 0. אם כן, כאן הקבוצה הפורשת המינימלית היא <strong>גדולה יותר</strong> מקבוצות תלויות לינארית. זה הבדל מהותי ממה שקרה באלגברה לינארית, שם הבסיס היה בו זמנית הקבוצה הפורשת המינימלית, והקבוצה הבלתי תלויה המקסימלית. כל התכונה היפה הזו פשוט לא קיימת במודולים.</p>
<p>עוד אסון לאינטואיציה שלנו הוא מה שקורה עם פרישה של תת-מודולים. באלגברה לינארית, הכלל פשוט: אם <span class="math">\(W\)</span> הוא תת-מרחב של <span class="math">\(V\)</span>, אז <span class="math">\(\dim W\le\dim V\)</span>. במודולים זה ממש לא קורה: אפשר אפילו לתת דוגמא למודול <span class="math">\(M\)</span> שהוא נוצר סופית, אבל יש לו תת-מודול <span class="math">\(N\subseteq M\)</span> שאיננו נוצר סופית.</p>
<p>הנה דוגמא שכזו: ניקח את החוג <span class="math">\(R=\mathbb{R}\left[x_{1},x_{2},\dots\right]\)</span> - חוג הפולינומים באינסוף (בן מניה) של משתנים <span class="math">\(x_{1},x_{2},\dots\)</span> מעל השדה <span class="math">\(\mathbb{R}\)</span> של הממשיים. נגדיר <span class="math">\(M=R\)</span>, כלומר המודול הוא החוג מעל עצמו. כמובן שהמודול הזה נוצר סופית על ידי הקבוצה <span class="math">\(\left\{ 1\right\} \)</span>, אבל בואו נתבונן כעת בתת-הקבוצה של <span class="math">\(M\)</span> שכוללת את כל הפולינומים עם מקדם חופשי 0; הקבוצה הזו מן הסתם סגורה לחיבור וכפל בסקלר, ולכן היא תת-מודול, והיא בוודאי נוצרת על ידי <span class="math">\(\left\{ x_{1},x_{2},\dots\right\} \)</span> ולכן היא "נוצרת אינסופית". אבל האם ייתכן שיש לה קבוצת יוצרים סופית? נניח לרגע שיש לה. מכיוון שקבוצת היוצרים שלה סופית, וכל איבר בקבוצה הוא פולינום ולכן הוא סופי, אז רק מספר סופי של משתנים משתתפים בקבוצה הזו - יהא <span class="math">\(x_{n}\)</span> משתנה <strong>שאינו</strong> שייך לקבוצת היוצרים. אז איך נוצר האיבר <span class="math">\(x_{n}\in M\)</span> על ידי קבוצת היוצרים? קל להשתכנע שזה בלתי אפשרי.</p>
<p>ההבדלים הללו בין מודולים ומרחבים וקטוריים נותנים לנו סיבה טובה לשמוח על <strong>הטרמינולוגיה השונה</strong> שיש בין שני היקומים הללו, למרות שהם מדברים לכאורה על אותו דבר. כך למשל באלגברה לינארית אומרים שוקטורים פורשים תת-מרחב, ואילו במודולים אומרים שאיברים יוצרים תת-מודול. בשני המקרים הרעיון הוא אותו רעיון, אבל טוב שבמודולים אנחנו לא משתמשים באותה טרמינולוגיה, ולו כדי לזכור שדברים שעובדים מאליהם באלגברה לינארית לא עובדים כאן. בפוסט הבא אני אדבר על מה כן עובד, ועד איזו רמה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>