<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אוף, כל הקטע עם השורש הריבועי באמת יוצא מסובך - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2007/11/10/modular_square_roots_hardness/">
    <meta property="og:title" content="אוף, כל הקטע עם השורש הריבועי באמת יוצא מסובך">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2007/11/10/modular_square_roots_hardness/">
    <meta name="twitter:title" content="אוף, כל הקטע עם השורש הריבועי באמת יוצא מסובך">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2007/11/05/modular_square_roots/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">ועכשיו למשהו מסובך יותר - הוצאת שורש ריבועי!</span>
            </a>
            

            
            <a href="/2007/11/17/cryptography_intro/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">עולמם המופלא של אליס ובוב</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>אוף, כל הקטע עם השורש הריבועי באמת יוצא מסובך</h1>
            <div class="post-meta">
                <span class="date">2007-11-10</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת המספרים.html">תורת המספרים</a>
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
            </div>
        </header>
        
        <article>
            <p>סיימתי את <a href="http://www.gadial.net/2007/11/05/modular_square_roots/">הפוסט הקודם</a> עם "סגירת" הבעיה של הוצאת שורש מודולו מספר ראשוני. בקצרה - הבעיה הזו אינה קשה יותר, מבחינה עקרונית, מאשר הוצאת שורש "רגילה", במספרים הממשיים. אם כן, מה כן קשה בהוצאת שורש מודולרית? התשובה פשוטה - הוצאת שורש מודולו מספר שאינו ראשוני. בפרט, מספיק לדבר על n שהוא מכפלה של שני ראשוניים, p,q. הטענה שלי היא שבעיית הוצאת שורש מודולו n הזה היא קשה "בדיוק כמו" הבעיה של פירוק n לגורמיו הראשוניים.</p>
<p>לפני שאמשיך, כדאי לסקור קצת את עניין ה"קשה" הזה. בצורה פשטנית למדי, אפשר לומר שב<a href="http://he.wikipedia.org/wiki/%D7%A1%D7%99%D7%91%D7%95%D7%9B%D7%99%D7%95%D7%AA">תורת הסיבוכיות</a> מבדילים בין ארבע מחלקות שונות של בעיות. בעיות ש"אפשר" לפתור בזמן סביר - מחלקה שמכונה <a href="http://he.wikipedia.org/wiki/P_%28%D7%9E%D7%93%D7%A2%D7%99_%D7%94%D7%9E%D7%97%D7%A9%D7%91%29">P</a>. בעיות ש"אולי אפשר" לפתור בזמן סביר, בעיות ש"כנראה אי אפשר" לפתור בזמן סביר, ובעיות שידוע בוודאות שאי אפשר לפתור בזמן סביר (או לפתור בכלל). המחלקה המעניינת ביותר היא זו של הבעיות ש"אולי אפשר" לפתור בזמן סביר. למחלקת הבעיות שכוללות את הבעיות הללו ואת הבעיות שכבר ידוע שאפשר לפתור בזמן סביר קוראים <a href="http://he.wikipedia.org/wiki/NP">NP</a>. אני מקווה בעתיד לפרט יותר על המחלקה החשובה הזו, אבל בינתיים אסתפק בתיאור לא מדוייק לחלוטין שלה: אפשר לחשוב עליה בתור אוסף כל הבעיות ש<strong>קל לבדוק פתרון עבורן</strong>. אחת מהשאלות המרכזיות במדעי המחשב היא האם התכונה הזו היא מספיקה כדי להקל על <strong>מציאת</strong> פתרון - זו שאלת P=NP, לאלו מכם שנתקלו בה כבר. נכון לעכשיו לא ידוע האם התשובה לשאלה הזו היא חיובית או שלילית, ולמיטב ידיעתי הקונצנזוס במדעי המחשב נוטה לאמונה שהתשובה שלילית.</p>
<p>בעיית הפירוק לגורמים שייכת ל-NP, מן הסתם: אולי לא קל לנו לפרק את n, אבל אם בא מישהו ונותן לנו שני ראשוניים p,q ואומר "אלו הגורמים של n", קל לבדוק אותו - מכפילים אותם, ורואים אם קיבלנו n. זה מספיק כדי לזכות את שאלת הפירוק לגורמים בתואר "אולי אפשר לפתור ביעילות, אבל לא יודעים איך". יתר על כן, ב-NP יש אוסף של בעיות שנחשבות "הקשות ביותר ב-NP", מהטעם הפשוט שפתרון יעיל שלהן ייספק דרך יעילה לפתור כל בעיה ב-NP (ולכן P=NP). לבעיות הללו קוראים "<a href="http://he.wikipedia.org/wiki/NP-%D7%A9%D7%9C%D7%9E%D7%94">בעיות NP-שלמות</a>". בעיית הפירוק לגורמים <strong>אינה</strong> מוכרת כבעיה NP שלמה; כלומר, גם אם נפתור אותה ביעילות, השמיים לא יפלו ושום בעיה מרכזית במדעי המחשב לא תוכרע באופן שנראה כרגע לא סביר.</p>
<p>כאילו שזה לא מספיק, מודל "<a href="http://he.wikipedia.org/wiki/%D7%9E%D7%97%D7%A9%D7%91_%D7%A7%D7%95%D7%95%D7%A0%D7%98%D7%99">המחשב הקוונטי</a>" המדובר כל כך יהיה מסוגל, אם ייבנה יום אחד, לפתור את בעיית הפירוק לגורמים בצורה יעילה (ועם זאת, יש בעיות ב-NP שלא ידוע איך הוא יוכל להתגבר עליהן בצורה יעילה - כלומר, גם במודל שלו כנראה שלא יתקיים P=NP). מכל זה נובע שה"קושי" של בעיית הפירוק לגורמים צריך להילקח בעירבון מוגבל. מצד שני, העובדות בשטח הן שלמרות שזו בעיה כל כך חשובה, ולמרות המחקר האדיר שנערך סביבה, ולמרות שפתרון יעיל שלה יזכה את הפותר בכבוד והדר עצומים - למרות כל זה היא טרם נפתרה באופן מעשי, ככל הידוע לנו. זה המדד האמפירי של "קשה" שבו אנו משתמשים כאן.</p>
<p>חזרה לענייננו. במה עוזר לי הפירוק לגורמים של מספר כדי להוציא שורש? כאן נכנס לתמונה <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%A4%D7%98_%D7%94%D7%A9%D7%90%D7%A8%D7%99%D7%95%D7%AA_%D7%94%D7%A1%D7%99%D7%A0%D7%99"><strong>משפט השאריות הסיני</strong></a>. לפני שאציג אותו, אראה איך הוא עוזר לנו, ועוד לפני כן, אציג סימון חשוב.</p>
<p>הסימון הוא זה: <span class="math">\(a\equiv b(mod n)\)</span> (קרי: "a שקול ל-b מודולו n"). הגדרתו המתמטית היא ש-n מחלק את a-b. הגדרתו הטיפה-פחות-מתמטית היא שגם a וגם b נותנים את אותה השארית כשמחלקים אותם ב-n. לכן, כשאני מחפש ל-x שורש מודולו n, אני בעצם מחפש איזה y שיקיים <span class="math">\(y^2\equiv x(mod n)\)</span></p>
<p>אז יש לי איזה שהוא x שאני רוצה להוציא לו שורש ריבועי מודולו n. לא בטוח בכלל שקיים לו שורש שכזה, אבל בואו נעסוק במקרה שבו קיים (אם יודעים את הפירוק של n קל לבדוק אם קיים ל-x שורש). נניח שפתרתי את הבעיות הקלות יותר של הוצאת שורש ל-x מודולו p ומודולו q, כלומר - מצאתי <span class="math">\(y_p,y_q\)</span> כך שמתקיים:</p>
<p><span class="math">\(y_p^2\equiv x (mod p)\)</span></p>
<p><span class="math">\(y_q^2\equiv x (mod q)\)</span></p>
<p>עכשיו, נניח שבדרך קסם כלשהי אני מוצא y שמודולו p שקול ל-<span class="math">\(y_p\)</span>, ומודולו q שקול ל-<span class="math">\(y_q\)</span>. מה קורה? אני אקבל ש:</p>
<p><span class="math">\(y^2\equiv y_p^2\equiv x (mod p)\)</span></p>
<p><span class="math">\(y^2\equiv y_q^2\equiv x (mod q)\)</span></p>
<p>ומזה נובע ש:</p>
<p><span class="math">\(y^2\equiv x (mod n)\)</span></p>
<p>המעבר האחרון בפירוש אינו מובן מאליו. כדי להבין אותו, צריך לשוב להגדרות הבסיסיות: <span class="math">\(a\equiv b(mod p)\)</span> פירושו ש-p מחלק את <span class="math">\(a-b\)</span>. באופן דומה, אם גם <span class="math">\(a\equiv b(mod q)\)</span>, נובע מכך שגם q מחלק את <span class="math">\(a-b\)</span>. כעת מגיעה טענה לא טריוויאלית (אך גם לא קשה מדי): אם שני מספרים שזרים זה לזה (אין להם מחלק משותף גדול מ-1) מחלקים שניהם גם יחד מספר כלשהו, אז גם <strong>מכפלתם</strong> מחלקת אותו.</p>
<p>כלומר, בהקשר שלנו, פירוש הדבר הוא ש-pq מחלק את <span class="math">\(a-b\)</span>, אבל הרי pq=n. לכן, כמו שראינו, שורש של x שהוא אותו הדבר הן מודולו p והן מודולו q נותן לנו שורש מודולו n של x.</p>
<p>נשאר רק להבין איך מתרחש ה"קסם"; איך לוקחים שני שורשים <strong>שונים</strong> של x מודולו מספרים שונים, ומאחדים אותם לפתרון בודד.</p>
<p>משפט השאריות הסיני הוא זה שעושה את הקסם הזה. מכיוון שיש למשפט הזה ניסוחים רבים ושונים, אסתפק באחד מהפשוטים והפרטיים שבהם - בדיוק זה שאני זקוק לו כעת. הרעיון הבסיסי הוא זה. נניח שנתונים לנו שני מספרים שלמים, <span class="math">\(a,n\)</span> ואנחנו רוצים לפתור את המשוואה <span class="math">\(x\equiv a(mod n)\)</span>. האם אפשר לעשות זאת? כמובן, די בקלות; למשל, <span class="math">\(x=a\)</span> הוא פתרון. אם כן, מה הלאה? מה אם יהיו לנו <strong>שתי</strong> משוואות, שאת שתיהן נרצה לפתור <strong>בו זמנית</strong>? כלומר, אם יש לנו <span class="math">\(n,m\)</span> שלמים, ו-<span class="math">\(a,b\)</span> שלמים, האם אפשר למצוא פתרון לשתי המשוואות הבאות:</p>
<p><span class="math">\(x\equiv a(mod n)\)</span></p>
<p><span class="math">\(x\equiv b(mod m)\)</span></p>
<p>התשובה היא שכלל לא בטוח שאפשר. נניח ש-<span class="math">\(n=2,m=4, a=1, b=0\)</span>, אז פתרון לשתי המשוואות הוא מספר שמצד אחד מתחלק ללא שארית ב-4, ומצד שני משאיר שארית 1 בחלוקה ב-2, כלומר הוא אי זוגי - והרי כל מספר שמתחלק ב-4 הוא בפרט זוגי. לכן אין כאן פתרון למערכת.</p>
<p>משפט השאריות הסיני אומר במקרה הזה את הדבר הבא: <strong>אם</strong> שני המספרים <span class="math">\(m,n\)</span> זרים זה לזה (אף מספר גדול מ-1 לא מחלק את שניהם גם יחד), אז קיים פתרון למשוואה (והוא יחיד מודולו <span class="math">\(mn\)</span>, אבל זה פחות קריטי). ההוכחה של המשפט היא קונסטרוקטיבית ומראה בדיוק כיצד ניתן לחשב (ביעילות) את הפתרון הזה. אסביר כאן את ההוכחה, אך ייתכן מאוד שההסבר לא יהיה ברור למי שלא עסקו מעולם בנושאים הללו קודם.</p>
<p>הרעיון המרכזי בהוכחה הוא למצוא מספר <span class="math">\(x_n\)</span> בעל שתי התכונות הנאות הבאות:</p>
<p><span class="math">\(x_n\equiv a(mod n)\)</span></p>
<p><span class="math">\(x_n\equiv 0(mod m)\)</span></p>
<p>ולמצוא <span class="math">\(x_m\)</span> דומה, רק הפוך (שקול ל-<span class="math">\(b\)</span> מודולו <span class="math">\(m\)</span> ושקול לאפס מודולו <span class="math">\(n\)</span>). אם מצאנו כאלו, הפתרון הסימולטני למשוואות הוא <span class="math">\(x_n+x_m\)</span> (למה?)</p>
<p>איך מוצאים <span class="math">\(x_n\)</span> שכזה? כאן נכנס החלק החישובי לסיפור. מכיוון ש-<span class="math">\(m,n\)</span> זרים, אפשר להשתמש ב<a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">אלגוריתם האוקלידי המורחב</a> (שראוי לפוסט משל עצמו) כדי למצוא מספרים שלמים <span class="math">\(\alpha,\beta\)</span> כך ש- <span class="math">\(\alpha n+\beta m=1\)</span> (אם המחלק הגדול ביותר של <span class="math">\(m,n\)</span> היה גדול מ-1, אפשר היה עדיין לכתוב סכום דומה כשבאגף ימין של השוויון יש את המחלק הזה; נסו לחשוב איזו הכללה של המשפט נובעת בשל כך למקרה שבו <span class="math">\(m,n\)</span> לא זרים).</p>
<p>כעת, על ידי כפל שני האגפים ב-<span class="math">\(a\)</span> והעברת אגף, מקבלים את המשוואה <span class="math">\(a\beta m=a-a\alpha n\)</span>. אם לוקחים את כל זה מודולו <span class="math">\(m\)</span> ברור שמקבלים אפס (בגלל אגף שמאל), ואם לוקחים אותו מודולו <span class="math">\(n\)</span> ברור שמקבלים <span class="math">\(a\)</span> (בגלל אגף ימין), ולכן זה ה-<span class="math">\(x_n\)</span> המבוקש.</p>
<p>זה סוגר את ההוכחה מלבד החור של האלגוריתם האוקלידי המורחב.</p>
<p>מה נשאר? הכיוון השני של השקילות בין הוצאת שורש ופירוק לגורמים - כלומר, נותר לשכנע למה אם אני יודע להוציא שורשים מודולו מספר כלשהו, אני יכול גם לפרק אותו לגורמים (ולכן פירוק לגורמים אינו "יותר קשה" מאשר הוצאת שורשים).</p>
<p>אז שוב, בואו נניח שיש לנו איזה <span class="math">\(n=pq\)</span> ואנחנו יודעים באופן קסום להוציא שורשים. האבחנה הראשונית החשובה היא שאם יש למספר (שונה מאפס) שורש מודולו <span class="math">\(n\)</span>, אז יש לו <strong>ארבעה</strong> שורשים. הסיבה לכך היא שלמספר שיש לו שורש מודולו <span class="math">\(p\)</span> יש בדיוק שני שורשים כאלו (השורש המקורי, ומינוס השורש המקורי), וכך גם עבור <span class="math">\(q\)</span>, כך שיש לנו ארבעה זוגות אפשריים של "מספר שהוא שורש מודולו <span class="math">\(p\)</span> ומספר שהוא שורש מודולו <span class="math">\(q\)</span>", וכל זוג שכזה נותן, באמצעות משפט השאריות הסיני, שורש אחר מודולו <span class="math">\(n\)</span>.</p>
<p>לב האלגוריתם נעוץ בכך שאם ניקח שני שורשים שהתקבלו <strong>מאותו שורש</strong> מודולו <span class="math">\(p\)</span> ונחסר אותם, נקבל מספר ששקול לאפס מודולו <span class="math">\(p\)</span> - כלומר, <span class="math">\(p\)</span> מחלק אותו. את הטענה הזו אשאיר גם כן כתרגיל, כדי לחסוך עוד כתיבה מסורבלת (אם יש צורך, אנסה לפרט בתגובות). מכיוון שההפרש הזה לא שווה ל-<span class="math">\(n\)</span> (למה?), הרי שקיבלנו מספר ששונה מ-<span class="math">\(n\)</span> אבל מתחלק ב-<span class="math">\(p\)</span>, כלומר המחלק המשותף הגדול ביותר שלו ושל <span class="math">\(n\)</span> הוא בדיוק <span class="math">\(p\)</span>. מחלק משותף קל למצוא בעזרת האלגוריתם האוקלידי, ולכן זה סוף הסיפור - מפעילים אותו, ומקבלים את <span class="math">\(p\)</span> (ולכן גם את <span class="math">\(q\)</span> - פשוט מחלקים את <span class="math">\(n\)</span> ב-<span class="math">\(p\)</span>).</p>
<p>בקיצור, מה שאנחנו רוצים הוא למצוא  עבור מספר כלשהו את <strong>כל</strong> השורשים שלו מודולו <span class="math">\(n\)</span>. מכיוון שלא מניחים שהאלגוריתם שלנו יודע לעשות את זה (מניחים רק שהוא יודע למצוא שורש אחד), מסתפקים בגישה הסתברותית: מגרילים מספר, מעלים אותו בריבוע מודולו <span class="math">\(n\)</span> (כדי להבטיח שנקבל מספר שיש לו שורשים), ומוציאים לו שורש. אם קיבלנו משהו ששונה בערכו המוחלט מהמספר שהגרלנו, נהדר - מצאנו שני שורשים שונים וההפרש שלהם יתחלק ב-<span class="math">\(p\)</span> או ב-<span class="math">\(q\)</span>. אחרת, מנסים שוב. ושוב, ושוב. בסוף זה עובד.</p>
<p>רק חוב אחד נשאר לי: הדבר שבשבילו בכלל עושים את כל המהומה הזו - השימוש שלה בקריפטוגרפיה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>