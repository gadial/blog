<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>שורש, ההוכחה (חלק ב’) - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/blog/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/blog/">דף הבית</a>
                <a href="/blog/random.html">פוסט אקראי</a>
                <a href="/blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/blog/2007/07/31/fiat_shamir_intro/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">שורש, ההוכחה (חלק א’)</span>
            </a>
            

            
            <a href="/blog/2007/08/14/chomp/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">צ’ומפ צ’ומפ</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>שורש, ההוכחה (חלק ב’)</h1>
            <div class="post-meta">
                <span class="date">2007-08-07</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/קריפטולוגיה.html">קריפטולוגיה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/הוכחות לא קונסטרוקטיביות.html">הוכחות לא קונסטרוקטיביות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>פרוטוקול הוכחת אפס-הידע שאני עומד להציג נקרא "פרוטוקול פיאט-שמיר", על שם שני ממציאיו הישראליים - עמוס פיאט ועדי שמיר (את עדי שמיר הזכרתי כבר במובלע לפחות פעמיים בפוסטים קודמים - הוא זה שהוכיח שהוכחות אינטראקטיביות שקולות למחלקה PSPACE, והוא ה-S שבשמו של אלגוריתם ההצפנה RSA). המערכת שאני מציג הנה פרימיטיבית למדי, במונחים של ביצוע מעשי; לא אתעכב על הבעייתיות הטכנית שבה אלא רק אציין שהיא שופרה בידי אוריאל פייגה, שתיקן את הבעיה הטכנית ועשה עוד משהו נוסף, שגם אליו אתייחס בהמשך.</p>
<p>הבסיס של הוכחת אפס הידע הוא במספר גדול <span class="math">\(n\)</span> שהוא מכפלה של שני מספרים ראשוניים גדולים. המושג "גדול" אינו מוגדר היטב, ותלוי בכוח החישוב הנוכחי של מחשבים, אבל בימינו פירוש הדבר מספר בן כמה מאות ספרות (400? 600?). הרעיון העקרוני שעומד מאחורי זה הוא שקל <strong>לייצג</strong> מספרים גדולים ולעבוד איתם (בניסוח נאיבי, צריך רק "400 בייטים" כדי לייצג מספר בן 400 ספרות, והרי בזכרונות המחשב של ימינו זוהי כמות זניחה ביותר. בפועל, צריך הרבה פחות מ-400 בייטים), אבל לא קשה לנסח בעיות שהקושי שלהן תלוי ב<strong>גודל</strong> המספר (ערכו המספרי), ולא ב<strong>גודל הייצוג</strong> שלו (מספר הבייטים שנדרשים לצורך כתיבתו). כדי להבין את ההבדל אעיר שמספר האטומים ביקום מוערך כמספר שאינו גדול מגוגול (<span class="math">\(10^{100}\)</span>, ובמילים אחרות - 1 עם מאה אפסים אחריו) וגוגול הוא יצור פיצי ומסכן לעומת מספר בן 400 ספרות.</p>
<p>הנה המחשה לבעייתיות שבדבר: בדיקת ראשוניות. הדרך שבה יוצרים את <span class="math">\(n\)</span> היא על ידי הגרלה של שני ראשוניים גדולים (אם אנחנו רוצים ש-<span class="math">\(n\)</span> יהיה בגודל 600 ספרות, נגריל ראשוניים בני 300 ספרות) והכפלתם (פעולה שכאמור - קל לבצע גם עבור מספרים גדולים שכאלו, בגלל שגודל הייצוג שלהם סביר). הבעיה היא רק כיצד להגריל שני ראשוניים דווקא, הרי ראשוניים הם לא מספרים נפוצים עד כדי כך.</p>
<p>דרך נאיבית היא פשוט להגריל מספרים גדולים שוב ושוב עד שיצאו ראשוניים ולקוות שזה יקרה מהר. אפשר לחשוב על כל מני אופטימיזציות טריוויאליות - למשל, להימנע מהגרלת מספריים זוגיים, אבל צוואר הבקבוק של האלגוריתם יהיה נעוץ בשאלה איך ניתן לדעת, בהינתן מספר שהגרלנו, האם הוא ראשוני או לא?</p>
<p>הדרך הסטנדרטית לבדיקת ראשוניות היא לעבור על כל המספרים הקטנים מהמספר שאנו בודקים ולבדוק האם הם מחלקים אותו (והמהדרין יגידו - כל המספרים הקטנים או שווים לשורש המספר שאנו בודקים). השיטה הזו, שהיא קלה מאוד לתכנות ונוחה לשימוש עבור מספרים קטנים, היא חסרת ערך עבור מספרים גדולים. גם אם המספר שלנו מיוצג עם 300 ספרות בלבד, הרי שלעבור על כל המספרים עד לשורש שלו ידרוש מאיתנו פרק זמן הגדול בהרבה מזה שחלף מאז המפץ הגדול. על כן נדרשות שיטות אחרות - וכאלו אכן יש, וייתכן שאציג אותן בעתיד.</p>
<p>אם כן, ייצרנו שני מספרים ראשוניים גדולים <span class="math">\(p,q\)</span> כפלנו אותם וקיבלנו <span class="math">\(n=pq\)</span>. כעת זורקים את הראשוניים לכל הרוחות (אם מישהו ידע מה הם, הוא ידע את הפירוק של <span class="math">\(n\)</span> ולכן יוכל להוציא שורש מודולו <span class="math">\(n\)</span> והמערכת חסרת ערך) ומפרסמים את <span class="math">\(n\)</span> לכל דורש. כעת המערכת מסוגלת להתחיל לתפקד.</p>
<p>אני, בתור המוכיח, רוצה להראות למערכת שאני מכיר שורש של מספר כלשהו. אם כן, אני בוחר באקראי מספר מודולו <span class="math">\(n\)</span> שנכנה <span class="math">\(x\)</span> (צריך לוודא גם שהוא זר ל-<span class="math">\(n\)</span> כדי שיהיה איבר בחבורה הכפלית - אבל הסיכוי שניפול על איבר שאינו זר שווה לסיכוי שנצליח לפרק את <span class="math">\(n\)</span> לגורמים "בטעות" - למה?), מעלה אותו בריבוע מודולו <span class="math">\(n\)</span> ומקבל מספר חדש, <span class="math">\(y=x^2(mod n)\)</span>. מן הסתם אני צריך לבחור את <span class="math">\(y\)</span> כך שהריבוע שלו יהיה גדול מ-<span class="math">\(n\)</span>, אחרת יהיה קל להוציא ל-<span class="math">\(x\)</span> שורש (למה?)</p>
<p>אני מפרסם את <span class="math">\(y\)</span> לכל דורש, ובפרט למערכת שרוצה לזהות אותי. יש כאן בעיה לוגיסטית כלשהי - צריך שהיא <strong>תשתכנע</strong> ש-<span class="math">\(y\)</span> באמת מייצג אותי ולא איזה מתחזה, וזו יכולה להיות בעיה רצינית - אולם הפתרונות לבעיה הם לרוב לא קריפטוגרפיים, והבעיה עצמה אינה חמורה כל כך מכיוון שהיא "חד פעמית" - אחרי שפעם אחת אני "אירשם" במערכת כבעליו של המספר <span class="math">\(y\)</span>, לא יידרשו עוד שכנועים עתידיים. כל מה שיידרש ממני להוכיח בפני המערכת כדי להזדהות הוא שאני יודע את השורש של <span class="math">\(y\)</span> - סוד שרק אני אמור לדעת, מכיוון שהוצאת שורש היא קשה.</p>
<p>ההוכחה הטריוויאלית של "שלח את <span class="math">\(x\)</span>, תן למוודא להעלות אותו בריבוע ולוודא שהוא קיבל <span class="math">\(y\)</span>" לא טוב לנו מכיוון שכך <span class="math">\(x\)</span> נחשף לכל מי שרוצה לצותת. ה"תיקון" שיש לבצע להוכחה הנאיבית אינו גדול, במפתיע; מה שנעשה יהיה לכפול את <span class="math">\(x\)</span> במספר אקראי כלשהו, ואז לשלוח את המכפלה. מכיוון שכפלנו את <span class="math">\(x\)</span> במספר אקראי ואנחנו עובדים בחבורה הכפלית מודולו <span class="math">\(n\)</span> (ולכן <strong>כל</strong> מספר מודולו <span class="math">\(n\)</span> ששייך לחבורה הזו הוא תוצאה אפשרית של המכפלה, תלוי מה המספר האקראי) הרי שאין במכפלה הזו שום מידע על זהותו של <span class="math">\(x\)</span>.</p>
<p>אם כן, נסכם: אנו מגרילים <span class="math">\(r\)</span> אקראי מודלו <span class="math">\(n\)</span>, ושולחים למוודא את <span class="math">\(xr\)</span>. כיצד המוודא יכול לוודא שאנחנו יודעים את שורש <span class="math">\(y\)</span>? אם הוא יעלה את המספר ששלחנו לו בריבוע הוא יקבל את <span class="math">\((xr)^2=x^2r^2=yr^2\)</span>, ולכן הוא צריך מידע נוסף - מהו <span class="math">\(r^2\)</span>. אם כן, נשלח לו גם את המספר הזה (בלי חשש שאפשר יהיה לגלות ממנו את <span class="math">\(r\)</span>, שהרי הוצאת שורש היא קשה), וכעת המוודא אכן יכול לוודא שהכל בסדר: ש-<span class="math">\(y\)</span> כפול המספר השני ששלחנו לו שווה למספר הראשון בריבוע. עשינו זאת מבלי לחשוף שום מידע על <span class="math">\(x\)</span> (שלחנו רק מספרים שנראים אקראיים) ולכן תם ונשלם הפרוטוקול.</p>
<p>האמנם?</p>
<p>שלמות יש ואפס ידע יש בפרוטוקול שלהלן, אבל נאותות אין בכלל. הנה הדגמה כיצד ניתן להונות את המוודא: נניח שאנחנו אמנם מכירים את <span class="math">\(y\)</span> אבל אין לנו מושג מה השורש שלו. איך נבצע הונאה?</p>
<p>אנחנו יודעים שהמוודא מצפה לקבל שני מספרים <span class="math">\(a,b\)</span> (בכוונה עברתי לאותיות אחרות) כך שמתקיים <span class="math">\(yb=a^2\)</span>. במילים אחרות, הוא מצפה שיתקיים <span class="math">\(b=\frac{a^2}{y}\)</span>. קשה לנו להוציא שורש, אולם לחלק קל, ולכן מה שנעשה יהיה להגריל את <span class="math">\(a\)</span> (שכזכור, אם היינו מוכיחים "הגונים" היה המספר <span class="math">\(xr\)</span>, שאינו "סתם" אקראי אלא מהווה פונקציה של <span class="math">\(x\)</span>), להעלות אותו בריבוע, לחלק ב-<span class="math">\(y\)</span> ולחשב ממנו את <span class="math">\(b\)</span> (שכזכור, אם היינו הגונים היה בכלל <span class="math">\(r^2\)</span>). הצלחנו לענות בכך על כל הדרישות של המוודא, ועם זאת אין לנו שמץ של מושג מה השורש של <span class="math">\(y\)</span>. בעיה.</p>
<p>הפתרון הוא הוספת שאלה נוספת למוודא: אם שלחנו לו <span class="math">\(a,b\)</span>, הוא יכול לתפוס את הרמאות הזו על ידי דרישת השורש של <span class="math">\(b\)</span>. אם היינו הגונים, אז <span class="math">\(b=r^2\)</span> ולכן כל מה שצריך הוא לשלוח את <span class="math">\(r\)</span>; אם רימינו ולא יצרנו את <span class="math">\(b\)</span> על ידי העלאה בריבוע של מספר אקראי אלא על ידי חישוב מהסוג שהוצג לעיל - אז אין סיכוי שנדע את השורש של <span class="math">\(b\)</span> (אם היינו יודעים, היינו יכולים לדעת גם את <span class="math">\(x\)</span> - למה?).</p>
<p>מה הבעיה עכשיו? איבדנו את אפס הידע. מדוע? מכיוון שאם אנחנו הוגנים, ושלחנו למוודא את <span class="math">\(r^2, xr\)</span> ועכשיו הוא דרש מאיתנו גם את <span class="math">\(r\)</span>, הרי שהוא מסוגל לחלק את <span class="math">\(xr\)</span> ב-<span class="math">\(r\)</span> ולקבל את <span class="math">\(x\)</span> ישירות - וכך גם כל מי שמצותת לרשת.</p>
<p>הפתרון הוא לבצע פשרה. האבחנה היא שאת <span class="math">\(r^2\)</span> תמיד אפשר לשלוח, אבל שתי פיסות המידע האחרות, <span class="math">\(r\)</span> ו-<span class="math">\(xr\)</span> לא מתיישבות זו עם זו, ושתיהן גם ממלאות פונקציות שונות: <span class="math">\(xr\)</span> מראה למוודא שאנחנו אכן יודעים את <span class="math">\(x\)</span>, ואילו <span class="math">\(r\)</span> מראה למוודא שאנחנו הגונים ובאמת יצרנו את ה-<span class="math">\(b\)</span> באופן אקראי. לכן, מספיק לבחון כל אחת משתי פיסות המידע הללו <strong>לסירוגין</strong>.</p>
<p>הנה הפרוטוקול השלם והאמיתי: הפרוטוקול שלנו יחולק לסיבובים. בכל סיבוב, המוכיח יגריל <span class="math">\(r\)</span> אקראי וישלח למוודא את <span class="math">\(r^2\)</span>. בשלב הזה המוודא יבצע "הטלת מטבע" ועל פיה יודיע למוכיח אם הוא רוצה לקבל את <span class="math">\(xr\)</span> או את <span class="math">\(r\)</span>. אם הוא ביקש את <span class="math">\(xr\)</span>, הוא מעלה בריבוע את מה שקיבל, מחלק במספר הראשון שקיבל ובודק אם יצא <span class="math">\(y\)</span>. אם הוא ביקש את <span class="math">\(r\)</span>, הוא מעלה בריבוע את מה שקיבל ובודק האם זה שווה למספר הראשון שקיבל. אם הבדיקה נכשלה, הוא יודע שהמוכיח שקרן ומעיף אותו. אחרת, ממשיכים לסיבוב הבא.</p>
<p>אם המוכיח דובר אמת הוא תמיד יצליח - כלומר, יש לנו שלמות. אם המוכיח שקרן, לעומת זאת, הוא אף פעם לא יידע בו זמנית את התשובה לשתי השאלות שהמוודא עשוי לשאול - זה תלוי בצורה שבה הוא יצר את המספר הראשון ששלח למוודא. לכן הוא צריך "לנחש" מה המוודא ישאל, וההסתברות לכך היא 50:50. לכן, ההסתברות שלו לעבור את הסיבוב הראשון בשלום היא חצי, אבל ההסתברות לעבור את השני בשלום היא כבר רבע (כי גם בראשון וגם בשני הוא צריך להצליח), בשלישי שמינית וכן הלאה וכן הלאה - מהר מאוד ההסתברות של מוכיח לשקר הופכת לאפסית, ולכן יש כאן גם נאותות.</p>
<p>כדי להוכיח פורמלית שזו הוכחת אפס ידע יש צורך בהדגמת סימולטור. במקרה שלנו זה "סימולטור עם נבוט" - הוא מזמין מוודא "אמיתי" להשתתף בסימולציה, ואז מנסה לרמות אותו באותה צורה שבה מוכיח רמאי היה פועל - מנחש מה תהיה השאלה של המוודא, ובוחר את המספר הראשון שישלח לו בהתאם לה. אם המוודא אכן בחר את השאלה שהמוכיח ניחש - מה טוב, מצלמים את התנהלות הסיבוב הזה (מוסיפים ל"תעתיק" של הפרוטוקול שהסימולטור יוצר) וכולם שמחים. אם לעומת זאת המוודא בחר את השאלה "הלא נכונה", הסימולטור מרביץ לו עם נבוט בראש (מאפס אותו כך שלא יזכור את הסיבוב הכושל הנוכחי), שורף את סרט הצילום (לא מוסיף את הסיבוב הכושל לפרוטוקול) ומתחיל סיבוב חדש. צריך להוכיח פורמלית שזה עובד - אבל זה עובד. בממוצע חצי מהסיבובים שהסימולטור מנסה לייצר ייכשלו, אבל זה לא כל כך הרבה, ולכן הסימולטור עדיין יעבוד בפרק זמן סביר, ויצליח לשכנע שהפרוטוקול שהוא ייצר "אותנטי" (ה"אותנטיות" נובעת מכך שהמוודא שהשתתף ביצירת הפרוטוקול היה אמיתי).</p>
<p>נשאר רק מה שהבטחתי קודם - השיפור של פייגה. כאמור, לסוגייה הטכנית אני לא הולך להיכנס אלא רק להפיכה שלו את הפרוטוקול למה שמכונה Proof of Knowledge. כפי שהוא כרגע, הפרוטוקול כן מעביר למוודא מידע כלשהו - הוא אומר לו של-<span class="math">\(y\)</span> יש שורש מודולו <span class="math">\(n\)</span> (דבר שאינו נכון בהכרח לכל המספרים מודולו <span class="math">\(n\)</span>). לכאורה זה לא בעייתי כי ממילא ההנחה המוקדמת של כל הפרוטוקול היא שקיים למספר הזה שורש (אחרת איך אפשר להוכיח שיודעים את השורש שלו?).</p>
<p>השיפור מחסל גם את הדבר הזה. עדיין יש מספר <span class="math">\(y\)</span>, אבל מה שהמוכיח מוכיח הוא ש<strong>אם</strong> קיים לו שורש, המוכיח יודע אותו; ואם לא קיים לו שורש, המוכיח יודע גם את העובדה הזו (שגם אותה קשה לבדוק), אבל הוא לא מגלה למוודא איזה משתי העובדות הללו נכונות. זוהי הצורה הקיצונית ביותר של הוכחות אפס-ידע; כאן אפילו לא ברור אם מה שהמוכיח מנסה להוכיח הוא נכון או לא, והדבר היחיד שידוע בסיום הפרוטוקול הוא שהמוכיח יודע.</p>
<p>וזוהי, לטעמי, אחת מהדוגמאות הנאות ביותר להוכחה לא קונסטרוקטיבית.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>