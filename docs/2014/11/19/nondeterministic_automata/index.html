<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אוטומטים אי דטרמיניסטיים ושאר מריעין בישין - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/blog/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/blog/">דף הבית</a>
                <a href="/blog/random.html">פוסט אקראי</a>
                <a href="/blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/blog/2014/11/11/automata_intro/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">אוטומטים ושפות רגולריות - מבוא</span>
            </a>
            

            
            <a href="/blog/2014/12/15/regular_languages_closure_1/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">שפות רגולריות - תכונות סגור (חלק א&#39;)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>אוטומטים אי דטרמיניסטיים ושאר מריעין בישין</h1>
            <div class="post-meta">
                <span class="date">2014-11-19</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אוטומטים.html">אוטומטים</a>
                    
                    <a href="/tags/אוטומטים אי דטרמיניסטיים.html">אוטומטים אי דטרמיניסטיים</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסט הקודם הצגתי את המושג של אוטומט סופי דטרמיניסטי והגדרתי אותו בצורה פורמלית. בשביל מתמטיקאים, הגדרה פורמלית היא סדין אדום. מייד מתעוררות שאלות - למה להגדיר כך ולא אחרת? האם כל ההנחות שהשתמשנו בהן נחוצות? מה קורה אם משנים קצת את כללי המשחק? אם מקלים על הנחות מסויימות? וכן הלאה. ובכן, בואו ננסה לחשוב על ההנחות שלנו ועל אילו מהן אפשר לוותר.</p>
<p>הנחה אחת הייתה שאני מראש מדבר רק על פתרון בעיות "כן/לא". לא ניגע בה, למרות שאפשר. הנחה אחרת הייתה שהגודל של קלטים ופלטים הוא סופי. גם בה לא ניגע, למרות שאפשר. ההנחות הללו <strong>משנות לנו את סוג הבעיות</strong> שאנחנו רוצים לעסוק בהן, ולכן שינוי שלהן יעביר אותנו לדיבור על דברים שאינם קשורים ישירות לנושא של שפות רגולריות.</p>
<p>הנחה אחרת הייתה הנחת הסופיות של האוטומט - קבוצת המצבים שלו יכולה להיות גדולה, אבל היא חייבת להיות סופית. זו הנחה שהיא בבירור הכרחית - זה תרגיל נחמד להוכיח שאם אנחנו מרשים לקבוצת המצבים להיות אינסופית, אז ה"אוטומט" המתקבל יכול לקבל כל שפה שהיא. אבל אי אפשר לממש אותו בפועל או אפילו לתת לו תיאור מפורש סופי (למשל, אלגוריתם שמחשב את הפונקציה <span class="math">\(\delta\left(q,\sigma\right)\)</span> של האוטומט), אז מה הטעם.</p>
<p>עוד הנחה הייתה שהאוטומט קורא את הקלט שלו רק בכיוון אחד - כלומר, אנחנו הולכים על הקלט משמאל לימין, וברגע שקראנו אות מהקלט היא אבודה לנצח ולא נוכל לחזור אליה. זו הנחה <strong>מאוד</strong> כבדה ולא טריוויאלית ונראה שיהיה קשה מאוד להצדיק אותה. אני הולך להצדיק אותה בעתיד על ידי האבחנה שמודל שבו אפשר לעשות את זה הוא שקול בכוחו החישובי למודל הפשוט שלנו, אבל זה ידרוש עוד כלי מרכזי (משפט נרוד) שטרם הצגתי, ולכן לא ניגע בהנחה הזו כרגע.</p>
<p>אבל היו שתי הנחות שהרבה פחות קל להצדיק ואנחנו הולכים להעיף אותן לכל הרוחות הפעם: ראשית, שהאוטומט פועל בצורה מוזרה שבה הוא קורא אות אחת מהקלט <strong>בכל צעד חישוב</strong> שלו. למה שלא נאפשר לו לעשות צעדי חישוב "על ריק"? ובכן, אנחנו הולכים להרשות לו. אבל עצרו רגע ותחשבו על זה - תראו שאם זה כל מה שאנחנו משנים במודל שלנו, לא הרווחנו כמעט שום דבר - המודל החדש שנקבל יהיה אפילו <strong>יותר מסורבל</strong> מהמודל הנוכחי, כי צעד חישוב "על ריק" כזה בעצם לא עושה כלום. אתם תתחילו להגיד לעצמכם "נו, אם אתה רוצה לעבור אל <strong><span class="math">\(p\)</span> </strong>על ריק, למה לא הלכת לשם מלכתחילה?". אז בפני עצמה ההנחה שאנחנו קוראים אות בכל צעד חישוב היא סבירה. אלא אם האוטומט יהיה מסוגל <strong>לבחור</strong> בין קריאת אות קלט ובין ביצוע צעד חישוב על ריק.</p>
<p>אלא שכרגע המודל שלנו הוא <strong>דטרמיניסטי</strong>, מה שאומר שיש לו <strong>פונקציית מעברים</strong>. בואו ניזכר מה זה אומר, פונקציה: פונקציה <span class="math">\(f:A\to B\)</span> מתאימה לכל איבר ב-<span class="math">\(A\)</span> איבר <strong>אחד ויחיד</strong> ב-<span class="math">\(B\)</span>. זה אומר שאין לנו "בחירה" בין שני פלטים אפשריים של הפונקציה בהינתן קלט מסויים, וגם אין לנו את האפשרות להגיד "לא רוצים להוציא פלט, מה תעשו לנו". באוטומט, ה-<span class="math">\(A\)</span> של פונקציית המעברים הוא אוסף כל הזוגות של מצב ואות קלט, ואילו <span class="math">\(B\)</span> הוא המצבים. מה שאנחנו רוצים לעשות הוא לזרוק לפח את הדרישה שפונקציית המעברים <span class="math">\(\delta:Q\times\Sigma\to\Sigma\)</span> היא פונקציה - כלומר, בהינתן הזוג של המצב הנוכחי ואות הקלט הנוכחית, אנחנו רוצים להרשות לאוטומט כמה אפשרויות בחירה - כמה מצבים שונים שהוא יכול לעבור אליהם. או אפילו להרשות לו לא לעבור לשום מצב בכלל אלא "להיתקע", מה שיסיים את החישוב מייד בלי לקבל את מילת הקלט. אוטומט כזה נקרא <strong>אי דטרמיניסטי</strong> (שימו לב שאני עדיין לא מרשה מעברים "על ריק"; אל זה נגיע אחר כך).</p>
<p>כשמציירים את האוטומט בתור גרף, קל להדגים אי דטרמיניזם - בסך הכל מדובר על מצבים שמהם לא יוצא חץ עבור אות מסויימת, או שיוצא יותר מחץ אחד עבור אות מסויימת:</p>
<p><strong><a href="/blog/img/2014/11/diagram0011.png"><img class="aligncenter size-full wp-image-3196" alt="diagram001" src="/blog/img/2014/11/diagram0011.png" width="433" height="114" /></a></strong></p>
<p>אבל איך מתארים אוטומט כזה בצורה פורמלית? דרך אחת היא להגיד שאין לנו יותר פונקציית מעברים אלא <strong>יחס</strong> מעברים - אוסף של שלשות מהצורה <span class="math">\(\left(q,\sigma,p\right)\)</span> שבא לומר שהאוטומט יכול, אם הוא במצב <span class="math">\(q\)</span> וקורא <span class="math">\(\sigma\)</span>, לעבור למצב <span class="math">\(p\)</span> (מבחינה פורמלית פונקציה היא פשוט מקרה פרטי של יחס, עם דרישות נוספות שמבטיחות שלכל קלט יהיה פלט אחד ויחיד). עם זאת, אני מעדיף דווקא לנקוט בגישה השניה, שאומרת שעדיין יכולה להיות לנו פונקציית מעברים, אם רק נשנה את הטווח שלה. דרך הפתרון שאני מציג כאן היא די סטנדרטית כאשר רוצים להגדיר פונקציות "רב ערכיות" בצורה פורמלית.</p>
<p>מה שאני אומר הוא שהפונקציה שלי, לכל קלט של <span class="math">\(\left(q,\sigma\right)\)</span>, תחזיר <strong>קבוצה</strong> - את קבוצת המצבים שאפשר לעבור אליהם כשהאוטומט במצב <span class="math">\(q\)</span> וקורא <span class="math">\(\sigma\)</span>. הקבוצה הזו יכולה להכיל איבר בודד (קבוצה כזו נקראת "סינגלטון") כמו שקורה באוטומט דטרמיניסטי; יכולה להיות ריקה; ויכולה להכיל שניים או יותר מצבים. כך שההגדרה הזו תופסת בו זמנית את הרעיון של "היתקעות" ושל "בחירה בין אפשרויות" מבלי להשליך לפח את האפשרות של דטרמיניזם. כלומר, הרחבנו את המודל של אוטומט סופי דטרמיניסטי; עם קצת שינויים סינטקטיים, אפשר לחשוב על כל אוטומט דטרמיניסטי כמקרה פרטי של אוטומט אי דטרמיניסטי. פורמלית כותבים את פונקציית המעברים כך: <span class="math">\(\delta:Q\times\Sigma\to2^{Q}\)</span> (הסימון <span class="math">\(2^{Q}\)</span> פירושו "כל-תתי הקבוצות של <span class="math">\(Q\)</span>"; קרוב לודאי שהוא נראה מוזר ושרירותי עבור מי שלא מכיר את תורת הקבוצות, אבל סמכו עלי שיש בו הגיון יפה).</p>
<p>התיאור הפורמלי של האוטומט שבציור, אם כן, הוא זה: <span class="math">\(Q=\left\{ q_{0},q_{1},q_{2}\right\} \)</span> ו-<span class="math">\(F=\left\{ q_{2}\right\} \)</span> ופונקציית המעברים הבאה:</p>
<p><span class="math">\(\delta\left(q_{0},a\right)=\left\{ q_{0},q_{1}\right\} ,\delta\left(q_{0},b\right)=\left\{ q_{0}\right\} \)</span></p>
<p><span class="math">\(\delta\left(q_{1},\sigma\right)=\left\{ q_{2}\right\} \)</span></p>
<p><span class="math">\(\delta\left(q_{2},\sigma\right)=\emptyset\)</span></p>
<p>מה שעדיין חסר לי הוא הסבר של מה זה אומר שאוטומט אי דטרמיניסטי כזה <strong>רץ</strong> על מילה, ומתי הוא <strong>מקבל</strong> אותה. המושג של ריצה נותר זהה - ריצה של אוטומט על מילה <span class="math">\(w\)</span> היא סדרה של מצבים שכל אחד מהם מתקבל מקודמו על ידי פונקציית המעברים, בהתאם לקלט שהאוטומט קורא. אם קודם אמרנו ש-<span class="math">\(p\)</span> נובע מ-<span class="math">\(q\)</span> כאשר האוטומט קורא <span class="math">\(\sigma\)</span> אם התקיים <span class="math">\(\delta\left(q,\sigma\right)=p\)</span>, עכשיו אנחנו אומרים את זה אם מתקיים <span class="math">\(p\in\delta\left(q,\sigma\right)\)</span>, כלומר אם <span class="math">\(p\)</span> הוא אחד המצבים שהאוטומט <strong>עשוי</strong> לעבור אליהם.</p>
<p>זה אומר שלאוטומט אי דטרמיניסטי יכולות להיות <strong>הרבה ריצות שונות</strong> על אותה מילת קלט. חלק מהריצות הללו עשויות להסתיים במצב מקבל וחלק לא - כלומר, האוטומט לכאורה "מקבל ודוחה בו זמנית" את המילה. מכאן שכשאנחנו באים לענות על השאלה האם <span class="math">\(w\in L\left(A\right)\)</span>, אנחנו בעצם שואלים שאלה על מה קורה בכל הריצות של <span class="math">\(A\)</span> על <span class="math">\(w\)</span>. תשובה סבירה אחת היא שנאמר ש-<span class="math">\(A\)</span> מקבלת את <span class="math">\(w\)</span> רק אם <strong>כל</strong> ריצה של <span class="math">\(A\)</span> על <span class="math">\(w\)</span> מסתיימת בקבלה, אבל אז נקבל מודל חדש שלא נוח לעבוד איתו (כי מה עוזר לנו שיש הרבה מסלולי חישוב אפשריים אם אנחנו צריכים לעבוד כדי להבטיח שבכולם האוטומט יקבל את המילים הנכונות?). לכן אנחנו מעדיפים את ההגדרה השניה: <span class="math">\(w\in L\left(A\right)\)</span> אם <strong>קיים</strong> מסלול חישוב כלשהו של <span class="math">\(A\)</span> על <span class="math">\(w\)</span> שהוא מקבל. אפילו אם יש מיליארד מסלולי חישוב דוחים, ורק אחד שמקבל - המילה עדיין תהיה בשפה של האוטומט.</p>
<p>בואו נסתכל לרגע באוטומט שציירתי למעלה. מה הוא מקבל? אפשר לראות שבהתחלה הוא יכול לקרוא אותיות באופן חופשי ולהישאר במצב ההתחלתי, וכך זה יכול להימשך לנצח בעיקרון (ואז האוטומט לא יגיע למצב מקבל אף פעם). אלא שהוא יכול גם לעבור ל-<span class="math">\(q_{1}\)</span> אחרי קריאה של <span class="math">\(a\)</span>. אם הוא יעשה את זה, בצעד הבא הוא יעבור ל-<span class="math">\(q_{2}\)</span>, ואז הוא "ייתקע" כי אין לו לאן ללכת. אז מתי הוא יקבל? רק אם שני צעדי החישוב האחרונים שלו (המעבר ל-<span class="math">\(q_{1}\)</span> ואחריו המעבר ל-<span class="math">\(q_{2}\)</span>) הם בדיוק הצעדים שבהם קוראים את שתי האותיות האחרונות במילה. צעד החישוב האחרון מתבצע תמיד, בלי תלות בשאלה מה האות האחרונה במילה, אבל הצעד שלפניו יכול להתבצע רק אם האות היא <span class="math">\(a\)</span>. המסקנה: האוטומט מקבל בדיוק את המילים שבהן <span class="math">\(a\)</span> היא האות הלפני-אחרונה.</p>
<p>העניין הזה, ש-<span class="math">\(A\)</span> מקבל מילה אם ורק אם קיים ל-<span class="math">\(A\)</span> מסלול חישוב מקבל על המילה, יכול להיות מבלבל למדי. זה הופך את <span class="math">\(A\)</span> למשהו לא מציאותי; כדי לדעת אם הוא מקבל מילה, אי אפשר סתם "להריץ אותו ולראות מה קורה", כי אם ההרצה תסתיים בדחייה של המילה, זה עדיין לא אומר שהאוטומט לא מקבל את המילה - אולי יש מסלול חישוב אחר שבו הוא כן יקבל אותה. דרך נחמדה לתת אינטואיציה היא לחשוב על <span class="math">\(A\)</span> כאילו הוא מצויד ב"מטבע קסם" - בכל פעם שבה הוא צריך לבצע בחירה אי דטרמיניסטית בין כמה אפשרויות הוא מטיל את המטבע, והמטבע יגריל את האפשרות "הטובה ביותר" במובן זה שאם יש ל-<span class="math">\(A\)</span> מסלול חישוב מקבל כלשהו על המילה, מטבע הקסם יוודא ש-<span class="math">\(A\)</span> ילך במסלול החישוב הזה (או, אם יש כמה, באחד מהם).</p>
<p>זה קצת מזכיר חישוב הסתברותי, אבל זה לא - אנחנו לא דורשים ש-<span class="math">\(A\)</span> תקבל בהסתברות גבוהה או משהו דומה; אין לנו חישובי הסתברויות בכלל. ייתכן שזה גם מזכיר חישוב קוונטי - כאילו <span class="math">\(A\)</span> נמצאת בסופרפוזיציה של הרבה ריצות אפשריות - אבל אם עקבתם אחרי סדרת הפוסטים שלי על חישוב קוונטי (או, יותר סביר, סתם מכירים חישוב קוונטי וכנראה יותר טוב ממני) אתם יודעים שחישוב קוונטי לא ממש עובד ככה ושאנחנו מתעלמים מההיבטים המורכבים שלו (איך לגלות את התוצאה, למשל). אז אני מעדיף לא ללכת יותר מדי לכיוון של אינטואיציות ולקוות שההגדרה המדויקת מספיק טובה כדי להבין מה הולך פה.</p>
<p>פורמלית, אנחנו רוצים להגדיר הרחבה של <span class="math">\(\delta\)</span>, <span class="math">\(\hat{\delta}:Q\times\Sigma^{*}\to2^{Q}\)</span>, באופן דומה לאיך שעשינו את זה עם אוטומט דטרמיניסטי - באינדוקציה. אז נגדיר <span class="math">\(\hat{\delta}\left(q,\varepsilon\right)=\left\{ q\right\} \)</span> ו-<span class="math">\(\hat{\delta}\left(q,w\sigma\right)=\bigcup_{p\in\hat{\delta}\left(q,w\right)}\delta\left(p,\sigma\right)\)</span>. במילים - קבוצת המצבים שאליהם ניתן להגיע מ-<span class="math">\(q\)</span> על ידי קריאת <span class="math">\(w\sigma\)</span> היא קבוצת המצבים שאליהם ניתן להגיע על ידי קריאת <span class="math">\(\sigma\)</span> מתוך אחד מהמצבים שאליהם ניתן להגיע מ-<span class="math">\(q\)</span> על ידי קריאת <span class="math">\(w\)</span>. מכיוון ש-<span class="math">\(\hat{\delta}\)</span> מקבלת מצב יחיד ופולטת קבוצה של מצבים כבר אי אפשר להרכיב אותה על עצמה ובשל כך יש את האיחוד הזה בחוץ. אפשר גם להתחכם מבחינת הסימון ולהגדיר <span class="math">\(\hat{\delta}:2^{Q}\times\Sigma^{*}\to2^{Q}\)</span> באופן הבא: <span class="math">\(\hat{\delta}\left(\left\{ q\right\} ,w\right)\)</span> יהיה שווה ל-<span class="math">\(\hat{\delta}\left(q,w\right)\)</span> שכבר הגדרנו, ועבור קבוצות <span class="math">\(P\subseteq Q\)</span> כלליות נגדיר <span class="math">\(\hat{\delta}\left(P,w\right)=\bigcup_{p\in P}\hat{\delta}\left(p,w\right)\)</span> (כאן הכתיב של <span class="math">\(\hat{\delta}\left(p,w\right)\)</span> הוא בעצם דרך מקוצרת לכתוב <span class="math">\(\hat{\delta}\left(\left\{ p\right\} ,w\right)\)</span> - ל"רמאות" כזו יש אפילו שם מקובל - Abuse of Notation. עכשיו אפשר לכתוב <span class="math">\(\hat{\delta}\left(q,w\sigma\right)=\hat{\delta}\left(\hat{\delta}\left(q,w\right),\sigma\right)\)</span> מבלי שתהיה עם זה בעיה.</p>
<p>עכשיו מתעוררות שתי שאלות, שקשורות אחת לשניה בקשר הדוק. הראשונה - נניח שנותנים לנו אוטומט אי דטרמיניסטי <span class="math">\(A\)</span> ומילה <span class="math">\(w\)</span> ושואלים אותנו אם <span class="math">\(w\in L\left(A\right)\)</span> - מה אנחנו עושים? אנחנו כבר יודעים שאי אפשר סתם להריץ את <span class="math">\(A\)</span> על <span class="math">\(w\)</span> ולבחור שרירותית בחירות אי דטרמיניסטיות כי אם הריצה לא תסתיים בקבלה זה לא אומר לנו עדיין כלום. השאלה השניה - האם המודל האי דטרמיניסטי שקול בכוחו למודל הדטרמיניסטי? דהיינו, האם בהינתן <span class="math">\(A\)</span> אי דטרמיניסטי קיים אוטומט <span class="math">\(A^{\prime}\)</span> דטרמיניסטי כך ש-<span class="math">\(L\left(A\right)=L\left(A^{\prime}\right)\)</span>?</p>
<p>השאלה הראשונה בעצם מבקשת מאיתנו למצוא אלגוריתם כלשהו להכרעת שאלת השייכות של מילה לשפה של אוטומט אי דטרמיניסטי; השאלה השניה מבקשת את אותו דבר בדיוק אבל תוך הדרישה הנוספת שכמות הזכרון שהאלגוריתם הזה צריך תהיה <strong>חסומה.</strong> כמו כן, תשובה לשאלה הראשונה אפשר לתת בנפנוף ידיים, אבל תשובה לשאלה השניה אתן על ידי בניה מפורשת ומדויקת.</p>
<p>פתרון כוח גס לשאלה הראשונה זה קל. בהינתן מילה <span class="math">\(w\)</span> מאורך <span class="math">\(m\)</span>, יש רק מספר סופי של מסלולי חישוב אפשריים של <span class="math">\(A\)</span> על <span class="math">\(w\)</span>. הנה חסם טיפשי: אם דרגת היציאה המקסימלית של צומת ב-<span class="math">\(A\)</span> היא <span class="math">\(k\)</span>, אז יש לכל היותר <span class="math">\(k^{m}\)</span> מסלולי חישוב אפשריים (למה?) אז אפשר לעבור על כולם. אבל סיבוכיות הזכרון של האלגוריתם הזה ככל הנראה תהיה גבוהה, כי צריך לזכור איכשהו באילו מסלולים כבר עברנו. זה לא אלגוריתם שנוח לממש בפועל במחשב. ודאי יש דרך קלה יותר. עצרו רגע וחשבו מהי.</p>
<p>ועכשיו, במקום לגלות לכם את הפתרון, אני הולך לעצור לרגע ולפתור בעיה שהיא לכאורה שונה לגמרי, אבל כמובן שתתקשר למה שאנחנו רוצים לעשות. הבעיה היא זו: נתונות לנו שתי שפות רגולריות <span class="math">\(L_{1},L_{2}\)</span>; אנחנו רוצים להוכיח שגם החיתוך שלהן, <span class="math">\(L_{1}\cap L_{2}\)</span>, שפת כל המילים שנמצאות גם ב-<span class="math">\(L_{1}\)</span> וגם ב-<span class="math">\(L_{2}\)</span> - היא שפה רגולרית. כלומר, אם <span class="math">\(A_{1}=\left(\Sigma,Q_{1},q_{0}^{1},\delta_{1},F_{1}\right)\)</span> ו-<span class="math">\(A_{2}=\left(\Sigma,Q_{2},q_{0}^{2},\delta_{2},F_{2}\right)\)</span> הם אוטומטים עבור השפות, אנחנו רוצים לבנות מהם אוטומט <span class="math">\(A=\left(\Sigma,Q,q_{0},\delta,F\right)\)</span> כך ש-<span class="math">\(L\left(A\right)=L_{1}\cap L_{2}\)</span>.</p>
<p>אלגוריתם נאיבי שעושה דבר כזה יפעל כך: בהינתן <span class="math">\(w\)</span>, קודם כל יריץ את <span class="math">\(A_{1}\)</span> על <span class="math">\(w\)</span>, ואם <span class="math">\(A_{1}\)</span> קיבלה, יריץ את <span class="math">\(A_{2}\)</span> על <span class="math">\(w\)</span> ויענה כמוה. הבעיה היא שאנחנו רוצים לבנות אוטומט עבור שפת החיתוך, ואוטומט לא יכול לבצע שתי הרצות בזו-אחר-זו של אותה מילה, בגלל הגישה המוגבלת שיש לו למילה - הוא יכול לקרוא אותה רק פעם אחת. לכן הפתרון הוא שהאוטומט יבצע סימולציה של <span class="math">\(A_{1},A_{2}\)</span> <strong>בו זמנית</strong>. בכל רגע נתון, המצב של האוטומט שלנו יהיה זוג <span class="math">\(\left(p,q\right)\)</span> שאומר "הסימולציה של <span class="math">\(A_{1}\)</span> נמצאת כרגע במצב <span class="math">\(p\)</span> והסימולציה של <span class="math">\(A_{2}\)</span> נמצאת כרגע במצב <span class="math">\(q\)</span>". כל אות שאנחנו קוראים מהקלט תגרום לנו לקדם את שני המצבים בזוג בו זמנית, בהתאם למעברים באוטומטים שלהם.</p>
<p>פורמלית, ההגדרה של <span class="math">\(A\)</span> היא זו: <span class="math">\(Q=Q_{1}\times Q_{2}\)</span>, <span class="math">\(F=F_{1}\times F_{2}\)</span> (כי מצב מקבל הוא זוג <span class="math">\(\left(p,q\right)\)</span> שבו שני המצבים הם מקבלים, כל אחד באוטומט שלו), <span class="math">\(q_{0}=\left(q_{0}^{1},q_{0}^{2}\right)\)</span>, ופונקציית המעברים מוגדרת לכל <span class="math">\(p\in Q_{1},q\in Q_{2},\sigma\in\Sigma\)</span> באופן הבא: <span class="math">\(\delta\left(\left(p,q\right),\sigma\right)=\left(\delta_{1}\left(p,\sigma\right),\delta_{2}\left(q,\sigma\right)\right)\)</span>. לא קשה להוכיח באינדוקציה שהבניה הזו אכן עובדת ו-<span class="math">\(A\)</span> מקבל את שפת החיתוך. האוטומט הזה נקרא <strong>אוטומט מכפלה</strong> כי קבוצת המצבים שלו היא מכפלה של קבוצות המצבים של האוטומטים שאנחנו מסמלצים.</p>
<p>נחזור כעת אל סילוק האי-דטרמיניזם שלנו. כאן אנחנו רוצים לעשות משהו דומה - לבצע סימולציה של כמה חישובים במקביל. כל החישובים הולכים להתבצע <strong>על אותו אוטומט</strong>, ולכן נשאלת השאלה - מה מבדיל חישובים שונים זה מזה? ובכן, כמובן, הבחירות האי דטרמיניסטיות שבוצעו במהלך החישוב, שאומרות שה"היסטוריה" של החישוב - כל המצבים שהיינו בהם עד כה, עד וכולל המצב הנוכחי - תהיה שונה בין חישובים שונים. וכאן מגיע הפאנץ': <strong>לא אכפת לנו מההיסטוריה</strong>. הדבר היחיד שמעניין אותנו בחישוב כלשהו הוא <strong>איפה אנחנו נמצאים כרגע</strong>. שני חישובים אי דטרמיניסטיים שונים, שאחרי קריאת כך-וכך אותיות הגיעו שניהם לאותו מצב, הם מבחינתנו מרגע זה והלאה אותו דבר בדיוק - זה שהם הגיעו לאותו מצב בשתי דרכים שונות לא משפיע בשום צורה על מה שיקרה מכאן והלאה. למי מכם שמכיר <a href="http://www.gadial.net/2012/01/19/markov_chains_and_linear_algebra/">שרשראות מרקוב</a>, זו בדיוק תכונת "חוסר הזכרון" של שרשראות מרקוב.</p>
<p>אם <span class="math">\(\left|Q\right|=n\)</span>, המשמעות היא שאנחנו צריכים בכל עת לתחזק עד <span class="math">\(n\)</span> "ריצות במקביל" של האוטומט. בפועל מה שנעשה יהיה פשוט יותר - הסימולציה שלנו תתבצע על ידי כך שנזכור בכל שלב את <strong>קבוצת המצבים</strong> שבהם האוטומט שאנחנו מסמלצים נמצא ב<strong>לפחות אחד</strong> ממסלולי החישוב שלו. אלגוריתמית, אפשר לחשוב על זה בתור מערך באורך <span class="math">\(n\)</span> של ערכים בוליאניים ("כן/לא") שאנחנו מעדכנים בכל צעד. זה כל הזכרון שנזדקק לו, ומכיוון שהוא לא תלוי בגודל מילת הקלט <span class="math">\(w\)</span> זהו זכרון חסום. כאשר נבנה אוטומט דטרמיניסטי עבור האלגוריתם הזה, האוטומט יכיל מצב אחד לכל סדרת ערכים אפשרית של המערך - דהיינו, יהיו לו <span class="math">\(2^{n}\)</span> מצבים. זה מספר <strong>קבוע</strong> ו<strong>סופי</strong>, אבל הוא אקספוננציאלי במספר המצבים של האוטומט שאנחנו מסמלצים. מסתבר שזה בלתי נמנע - לכל <span class="math">\(n\)</span> טבעי אפשר למצוא שפה שיש אוטומט אי-דטרמיניסטי עם <span class="math">\(O\left(n\right)\)</span> מצבים עבורה, אבל כל אוטומט סופי דטרמיניסטי עבורה יהיה עם <span class="math">\(\Omega\left(2^{n}\right)\)</span> מצבים. השפות הללו הן הכללה של השפה שנתתי בתור דוגמה - עבור <span class="math">\(n\)</span>, זו תהיה השפה של כל המילים הבינאריות שיש בהן 1 בדיוק <span class="math">\(n\)</span> צעדים מהסוף. כמובן, עוד לא הסברתי איך מוכיחים ש<strong>כל</strong> אוטומט סופי דטרמיניסטי עבור השפה יהיה בעל לפחות כך-וכך מצבים; זה משהו שיינתן לנו על ידי <strong>משפט נרוד</strong> שכבר הזכרתי בפוסט.</p>
<p>נעבור לבניה הפורמלית. נניח ש-<span class="math">\(A_{ND}=\left(\Sigma,Q_{ND},q_{0}^{ND},\delta_{ND},F_{ND}\right)\)</span> הוא אוטומט אי דטרמיניסטי כלשהו, אז נבנה אוטומט דטרמיניסטי <span class="math">\(A_{D}=\left(\Sigma,Q_{D},q_{0}^{D},\delta_{D},F_{D}\right)\)</span> כך ש-<span class="math">\(L\left(A_{ND}\right)=L\left(A_{D}\right)\)</span>.</p>
<p>הבסיס של הבניה הוא זה: <span class="math">\(Q_{D}=2^{Q_{ND}}\)</span>. כלומר, כל מצב של האוטומט הדטרמיניסטי הוא, מבחינה פורמלית, <strong>קבוצה</strong> - קבוצה של מצבים מתוך <span class="math">\(Q_{ND}\)</span>. זה די מבלבל, כי התרגלנו אולי לחשוב על מצבים של אוטומט בתור מין "אטומים" - אובייקטים שאנחנו מסמנים ב-<span class="math">\(q_{t}\)</span> ואין להם מבנה מתמטי מורכב יותר. אבל מבחינה פורמלית, זה לא הכרחי; כל מה שאנחנו דורשים על אוטומט הוא שקבוצת המצבים שלו תהיה קבוצה סופית כלשהי, והאיברים של אותה קבוצה יכולים להיות כל דבר - מספרים טבעיים, מחרוזות, סימבולים, או אפילו קבוצות. בבניה הנוכחית, נוח לנו שהאיברים הללו יהיו קבוצות. מכאן מגיע שם הבניה: האוטומט <span class="math">\(A_{D}\)</span> שבנינו נקרא <strong>אוטומט חזקה</strong>, כי קבוצת המצבים שלו היא קבוצת החזקה של קבוצת המצבים של האוטומט <span class="math">\(A_{ND}\)</span>.</p>
<p>כעת, <span class="math">\(q_{0}^{D}=\left\{ q_{0}^{ND}\right\} \)</span>. כלומר, המצב ההתחלתי של האוטומט הדטרמיניסטי הוא קבוצה (הרי אמרנו שכל מצב של האוטומט הוא קבוצה...) שהאיבר היחיד שלה הוא המצב ההתחלתי של האוטומט האי-דטרמיניסטי. כלומר, הסימולציה שלנו מתחילה עם חישוב יחיד, שמתחיל ב-<span class="math">\(q_{0}^{ND}\)</span>. למעשה, אפשר היה להרחיב עוד קצת את המודל האי-דטרמיניסטי ולהרשות כמה מצבים התחלתיים שונים, ואז הסימולציה הייתה מתחילה עם קבוצת כל המצבים הללו וזה היה כל ההבדל.</p>
<p>כמו כן, <span class="math">\(F_{D}=\left\{ P\subseteq Q_{ND}\ |\ P\cap F_{ND}\ne\emptyset\right\} \)</span>, כלומר המצבים המקבלים שלנו הם אלו שבהם <strong>לפחות אחת</strong> מהסימולציות נמצאת באותו הרגע במצב מקבל.</p>
<p>נשאר רק לתאר את פונקציית המעברים, לכל <span class="math">\(P\in Q_{D}\)</span> ו-<span class="math">\(\sigma\in\Sigma\)</span>: <span class="math">\(\delta_{D}\left(P,\sigma\right)=\hat{\delta}_{ND}\left(P,\sigma\right)\)</span>. דהיינו, האוטומט הדטרמיניסטי הולך מהמצב <span class="math">\(P\)</span> שלנו על ידי קריאת <span class="math">\(\sigma\)</span> אל קבוצת כל המצבים באוטומט האי דטרמיניסטי שניתן להגיע אליהם בצעד אחד ממצב כלשהו ב-<span class="math">\(P\)</span> על ידי קריאת <span class="math">\(\sigma\)</span>. מתבקש. קל להוכיח שמתקיים <span class="math">\(\hat{\delta}_{D}\left(P,w\right)=\hat{\delta}_{ND}\left(P,w\right)\)</span> לכל מילה <span class="math">\(w\)</span> ומכאן הוכחת השקילות של שני האוטומטים כבר נובעת מאליה.</p>
<p>זה מסיים את הטיפול במודל האי דטרמיניסטי, אבל עדיין לא סיימנו - אני עדיין צריך לטפל בהקלה השניה על כללי המשחק ולהסתכל על המודל שבו אפשר לבצע מעבר בין מצבים בלי לקרוא אות. למעבר כזה אני אקרא "מעבר-<span class="math">\(\varepsilon\)</span>". ונתחיל בדוגמא לאוטומט שמשתמש במעברים כאלו:</p>
<p><a href="/blog/img/2014/11/diagram002.png"><img class="aligncenter size-full wp-image-3197" alt="diagram002" src="/blog/img/2014/11/diagram002.png" width="419" height="119" /></a></p>
<p>האוטומט הזה מקבל את כל המילים שבנויות מרצף של 0 או יותר <span class="math">\(a\)</span>-ים, אחריו רצף של 0 או יותר <span class="math">\(b\)</span>-ים ואחריו רצף של 0 או יותר <span class="math">\(c\)</span>-ים. בהמשך נראה איך ייראה אוטומט בלי מעברי-<span class="math">\(\varepsilon\)</span> שעושה את זה ועד כמה מעברי ה-<span class="math">\(\varepsilon\)</span> מפשטים את דרך ההצגה שלנו, אבל בינתיים אני ממליץ לכם לנסות ולבנות אוטומט כזה (אי דטרמיניסטי!) בעצמכם ולראות כמה אתם מסתבכים כדי שתוכלו להעריך את הפשטות היחסית של האוטומט הזה. מה שהוא עושה הוא זה: כל עוד יש <span class="math">\(a\)</span>-ים לקרוא, קורא אותם. אחר כך קופץ למצב הבא על ידי מעבר <span class="math">\(\varepsilon\)</span>, קורא שם <span class="math">\(b\)</span>-ים כל עוד יש, ואז קופץ למצב האחרון וקורא שם <span class="math">\(c\)</span>-ים כל עוד יש, עד (בתקווה) סוף המילה. כמובן, שימו לב שאני מייחס לאוטומט מעין חוכמה שאין לו (לדעת מתי ה-<span class="math">\(a\)</span>-ים "נגמרו") - בפועל מה שקורה הוא שיש לאוטומט המון מסלולי חישוב אפשריים שרובם פשוט "נתקעים" (למשל, אם האות הראשונה במילה היא <span class="math">\(a\)</span> אבל האוטומט בחר לבצע את מסע ה-<span class="math">\(\varepsilon\)</span> אל <span class="math">\(q_{1}\)</span> במקום לקרוא אותה) ואני פשוט מתאר את הריצה המקבלת. שימו לב איך אני נעזר בכך שהאוטומט הוא אי-דטרמיניסטי, ולא "רק" יכול לבצע מסעי-<span class="math">\(\varepsilon\)</span>.</p>
<p>אתם כבר יודעים מה סדר הפעולות כשמציעים מודל מורחב שכזה. ראשית, תוהים איך להגדיר אותו פורמלית; שנית, תוהים איך להגדיר פורמלית "ריצה" במודל ומה זה אומר שהמודל "מקבל" מילה; ולבסוף, תוהים איך להוכיח שהוא שקול למודל פשוט יותר.</p>
<p>ובכן, ההגדרה פורמלית זהה לגמרי לזו של אוטומט אי דטרמיניסטי רגיל, פרט להגדרת פונקציית המעברים - <span class="math">\(\delta:Q\times\left(\Sigma\cup\left\{ \varepsilon\right\} \right)\to2^{Q}\)</span>. כלומר, "הרחבנו" את הא"ב <span class="math">\(\Sigma\)</span> על ידי הוספת הסימבול <span class="math">\(\varepsilon\)</span> ו-<span class="math">\(\delta\left(q,\varepsilon\right)\)</span> מחזיר את כל המצבים שאליהם ניתן להגיע מ-<span class="math">\(q\)</span> על ידי מסע-<span class="math">\(\varepsilon\)</span> יחיד. לרוע המזל, לסימבול <span class="math">\(\varepsilon\)</span> כבר יש משמעות מאוד קונקרטית עבורנו - המילה הריקה. Hilarity ensues.</p>
<p>כדי להבין את הבעיה, בואו ננסה להגדיר את פונקציית המעברים המורחבת <span class="math">\(\hat{\delta}\)</span>, שתתאר מה האוטומט עושה על מילים. כרגיל, מתחילים בלהגדיר אותה על המילה הריקה. עבור אוטומט אי דטרמיניסטי רגיל הגדרנו <span class="math">\(\hat{\delta}\left(q,\varepsilon\right)=\left\{ q\right\} \)</span>; אבל מה נגדיר עבור אוטומט עם מסעי-<span class="math">\(\varepsilon\)</span>? ובכן, העובדה שאנחנו משתמשים באותו סימון כדי לתאר מסע-<span class="math">\(\varepsilon\)</span> וגם את המילה הריקה נותנת לנו אינטואיציה חזקה שצריך להגדיר <span class="math">\(\hat{\delta}\left(q,\varepsilon\right)=\delta\left(q,\varepsilon\right)\)</span>. אבל זה <strong>לגמרי לא נכון</strong>! הנקודה הזו מבלבלת אנשים למוות. ממשלות כבר נפלו בגללה. טיסות חלל התרסקו, וקת'ולהו התעורר (אבל כשהוא ניסה להבין את הבעיה הוא גם נרדם שוב). בואו ננסה להבין מה הולך כאן.</p>
<p>כדי לעשות סדר בבלאגן, אני רוצה לשנות לרגע את השם של מסעי-<span class="math">\(\varepsilon\)</span> ולקרוא להם מסעי-<span class="math">\(\spadesuit\)</span>. כלומר, אני מגדיר את פונקציית המעברים <span class="math">\(\delta:Q\times\left(\Sigma\cup\left\{ \spadesuit\right\} \right)\to2^{Q}\)</span>, ועכשיו אני רוצה להסביר לכם למה השוויון <span class="math">\(\hat{\delta}\left(q,\varepsilon\right)=\delta\left(q,\spadesuit\right)\)</span> הוא לא נכון (קחו שניה כדי לוודא שאתם מבינים למה לא הפכתי את ה-<span class="math">\(\varepsilon\)</span> באגף שמאל ל-<span class="math">\(\spadesuit\)</span>). הסיבה פשוטה: <span class="math">\(\delta\left(q,\spadesuit\right)\)</span> היא קבוצת כל המצבים שאפשר להגיע אליה מ-<span class="math">\(q\)</span> על ידי ביצוע של <strong>מסע-<span class="math">\(\spadesuit\)</span> אחד בדיוק</strong> בזמן ש-<span class="math">\(\hat{\delta}\left(q,\varepsilon\right)\)</span> היא קבוצת כל המצבים שאפשר להגיע אליהם על ידי ביצוע של 0 או יותר מסעים שלא קוראים אות. באוטומט שבאיור מתקיים ש-<span class="math">\(\delta\left(q_{0},\spadesuit\right)=\left\{ q_{1}\right\} \)</span> אבל <span class="math">\(\hat{\delta}\left(q_{0},\varepsilon\right)=\left\{ q_{0},q_{1},q_{2}\right\} \)</span>.</p>
<p>עכשיו, נניח לרגע שפתרנו איכשהו את הבעיה של ההגדרה של <span class="math">\(\hat{\delta}\)</span> עבור <span class="math">\(\varepsilon\)</span>. מה יקרה כשננסה להמשיך את ההגדרה האינדוקטיבית, כלומר להגדיר את <span class="math">\(\hat{\delta}\left(q,w\sigma\right)\)</span>? צריך להכניס לתמונה איכשהו את מסעי-<span class="math">\(\varepsilon\)</span>. האינטואיציה הראשונה (שלי, לפחות) היא להרשות ל-<span class="math">\(\sigma\)</span> להיות לא רק איבר של <span class="math">\(\Sigma\)</span> אלא גם <span class="math">\(\varepsilon\)</span>, המילה הריקה, ולהגדיר באותו האופן בדיוק גם במקרה הזה: <span class="math">\(\hat{\delta}\left(q,w\sigma\right)=\delta\left(\hat{\delta}\left(q,w\right),\sigma\right)\)</span>. אבל בואו נציב שניה <span class="math">\(\sigma=\varepsilon\)</span> - אנחנו מקבלים את המשוואה <span class="math">\(\hat{\delta}\left(q,w\right)=\delta\left(\hat{\delta}\left(q,w\right),\varepsilon\right)\)</span> שמגדירה את <span class="math">\(\hat{\delta}\left(q,w\right)\)</span> באמצעות <span class="math">\(\hat{\delta}\left(q,w\right)\)</span> - הגדרה מעגלית. ברור שמשהו כאן לא עובד כל כך טוב וצריך איכשהו לתקן ועדיף מבלי להתייחס אל <span class="math">\(\sigma\)</span> בתור משהו שיכול לייצג גם את <span class="math">\(\varepsilon\)</span>. כלומר - צריך להתייחס למעברי-<span class="math">\(\varepsilon\)</span> בצורה שונה מיתר המעברים.</p>
<p>זו הסיבה שבגללה אני לא אוהב את השימוש הכפול בסימבול <span class="math">\(\varepsilon\)</span> כדי לתאר גם את המילה הריקה, וגם את המעברים שאינם קוראים אות. אבל אין מה לעשות - זה הסימון המקובל בספרות ובפרט בספרי הלימוד הרלוונטיים לטעמי (זה של הופקרופט ואולמן; זה של סיפסר; וזה של האוניברסיטה הפתוחה בישראל). לכן גם אני אשתמש בו, אבל בזהירות.</p>
<p>אז איך נגדיר את <span class="math">\(\hat{\delta}\left(q,\varepsilon\right)\)</span>? ובכן, אנחנו צריכים כתיב פורמלי עבור "כל המצבים שישיגים מ-<span class="math">\(q\)</span> על ידי 0 או יותר מסעי-<span class="math">\(\varepsilon\)</span>". נסמן את הקבוצה הזו ב-<span class="math">\(\text{Cl}^{\varepsilon}\left(q\right)\)</span> - <strong>סגור-<span class="math">\(\varepsilon\)</span></strong> של <span class="math">\(q\)</span> (Cl הוא קיצור של Closure - סגור, שמבוטא בחולם). לטעמי הדרך הנחמדה ביותר להגדיר את הקבוצה הזו היא בתור הקבוצה הקטנה ביותר של מצבים שמכילה את <span class="math">\(q\)</span> וסגורה ביחס למעברי <span class="math">\(\varepsilon\)</span>. פורמלית, <span class="math">\(q\in\text{Cl}^{\varepsilon}\left(q\right)\)</span> וכמו כן אם <span class="math">\(p\in\text{Cl}^{\varepsilon}\left(q\right)\)</span> ו-<span class="math">\(p^{\prime}\in\delta\left(p,\varepsilon\right)\)</span> אז גם <span class="math">\(p^{\prime}\in\text{Cl}^{\varepsilon}\left(q\right)\)</span>.</p>
<p>כעת נגדיר:</p>
<p><span class="math">\(\hat{\delta}\left(q,\varepsilon\right)=\text{Cl}^{\varepsilon}\left(q\right)\)</span></p>
<p><span class="math">\(\hat{\delta}\left(q,w\sigma\right)=\text{Cl}^{\varepsilon}\left(\delta\left(\hat{\delta}\left(q,w\right),\sigma\right)\right)\)</span></p>
<p>גם כאן אני מניח באופן מובלע ש-<span class="math">\(\delta\)</span> מוגדרת על קבוצות של מצבים ולא רק על מצבים בודדים.</p>
<p>מה שההגדרה שלי בעצם אומרת היא זו: ראשית, כל עוד לא קראתם אף אות, המצבים שישיגים מ-<span class="math">\(q\)</span> הם בדיוק אלו שניתן להגיע אליהם על ידי 0 או יותר מסעי-<span class="math">\(\varepsilon\)</span> מ-<span class="math">\(q\)</span>. כעת, המצבים שישיגים מ-<span class="math">\(q\)</span> על ידי קריאת <span class="math">\(w\sigma\)</span> (כאשר <span class="math">\(\sigma\in\Sigma\)</span>) הם בדיוק המצבים שניתן להגיע אליהם מאחד המצבים ב-<span class="math">\(\hat{\delta}\left(q,w\right)\)</span> על ידי כך שקודם כל מבצעים מסע תוך קריאת <span class="math">\(\sigma\)</span> ולאחר מכן מבצעים כמה מסעי-<span class="math">\(\varepsilon\)</span> שרוצים.</p>
<p>זה מסיים את שלב ההגדרות - וקצת מדכא לראות כמה מתוסבכת ההגדרה של רעיון יחסית פשוט כמו מסעי-<span class="math">\(\varepsilon\)</span>. נשאר להוכיח שאוטומט אי דטרמיניסטי עם מסעי-<span class="math">\(\varepsilon\)</span> שקול לאוטומט אי דטרמיניסטי בלי מסעים כאלו - להראות איך אפשר "לסלק" מסעי <span class="math">\(\varepsilon\)</span>. מספיק לעבור למודל אי דטרמיניסטי בלי מסעי-<span class="math">\(\varepsilon\)</span> כדי להוכיח שקילות למודל הדטרמיניסטי הרגיל, כי כבר ראינו שהמודל האי-דטרמיניסטי שקול למודל הדטרמיניסטי. בסילוק אי-דטרמיניזם ניפחנו אקספוננציאלית את מספר המצבים; בסילוק מסעי-<span class="math">\(\varepsilon\)</span> מספר המצבים כלל לא ישתנה, רק נוסיף עוד קשתות לגרף של האוטומט.</p>
<p>הרעיון הוא פשוט: אנחנו רוצים להגדיר את <span class="math">\(\delta\left(q,\sigma\right)\)</span> עבור האוטומט <strong>בלי</strong> מסעי-<span class="math">\(\varepsilon\)</span>, בצורה ש"תסמלץ" את מה שהאוטומט עם מסעי ה-<span class="math">\(\varepsilon\)</span> יכול לעשות. זה אומר ש-<span class="math">\(\delta\left(q,\sigma\right)\)</span> תכלול את כל המצבים שאפשר להגיע אליהם מ-<span class="math">\(q\)</span> באופן הבא: ביצוע של 0 או יותר מסעי-<span class="math">\(\varepsilon\)</span> מ-<span class="math">\(q\)</span>; ביצוע צעד תוך קריאת <span class="math">\(\sigma\)</span>; ביצוע 0 או יותר מסעי-<span class="math">\(\varepsilon\)</span> מהמצב שאליו הגענו. למרבה המזל, יש לנו כבר כעת דרך קומפקטית מאוד לכתוב את כל המהומה הזו: <span class="math">\(\hat{\delta}\)</span>! ההגדרה של <span class="math">\(\hat{\delta}\)</span> עבור אוטומט עם מסעי <span class="math">\(\varepsilon\)</span> הייתה מסובכת, אבל עכשיו אפשר להשתמש בה בצורה חופשית ולקבל בניה מאוד פשוטה.</p>
<p>פורמלית, נניח ש-<span class="math">\(A_{EM}=\left(\Sigma,Q,q_{0},\delta_{EM},F_{EM}\right)\)</span> הוא אוטומט עם מסעי-<span class="math">\(\varepsilon\)</span>. אז נבנה אוטומט בלי מסעים כאלו, <span class="math">\(A_{ND}=\left(\Sigma,Q,q_{0},\delta_{ND},F_{ND}\right)\)</span> שקול. קבוצת המצבים והמצב ההתחלתי של שניהם יהיו זהים, ולב הבניה טמון בהגדרת פונקציית המעברים, שהיא פשוטה כל כך לניסוח פורמלי שזה מרגיש כמו רמאות:</p>
<p><span class="math">\(\delta_{ND}\left(q,\sigma\right)=\hat{\delta}_{EM}\left(q,\sigma\right)\)</span></p>
<p>נשאר רק לטפל במצבים המקבלים. מן הסתם נרצה שכל מצב מקבל של <span class="math">\(A_{EM}\)</span> יהיה מצב מקבל של <span class="math">\(A_{ND}\)</span>, אבל למרבה הצער - זה לא מספיק. יש לנו מקרה קצה מעצבן שצריך לטפל בו - המילה הריקה. כי מה קורה? הבניה שלנו של פונקציית המעברים מבטיחה שהאוטומטים יתנהגו בצורה מאוד דומה - שיתקיים <span class="math">\(\hat{\delta}_{ND}\left(q,w\right)=\hat{\delta}_{EM}\left(q,w\right)\)</span> כמעט לכל מילה. אבל עבור <span class="math">\(w=\varepsilon\)</span> השוויון הזה פשוט לא נכון. למה? כי באוטומט עם מסעי-<span class="math">\(\varepsilon\)</span>, אפשר להגיע לקבוצה לא קטנה של מצבים תוך קריאת המילה הריקה - <span class="math">\(\text{Cl}^{\varepsilon}\left(q_{0}\right)\)</span>, אם להיות פורמליים - אבל באוטומט בלי מסעי <span class="math">\(\varepsilon\)</span> המצב <strong>היחיד</strong> שאפשר להגיע אליו בלי לקרוא אף אות הוא <span class="math">\(q_{0}\)</span>.</p>
<p>אם <span class="math">\(\varepsilon\notin L\left(A_{EM}\right)\)</span> כל זה לא רלוונטי. אבל אם <span class="math">\(\varepsilon\in L\left(A_{EM}\right)\)</span> אז אין לנו ברירה; אנחנו <strong>חייבים</strong> שיתקיים <span class="math">\(q_{0}\in F_{ND}\)</span> אחרת פשוט לא יתקיים <span class="math">\(\varepsilon\in L\left(A_{ND}\right)\)</span>. מכאן אנחנו מקבלים את ההגדרה הבאה:</p>
<p><span class="math">\(F_{ND}=\begin{cases}F_{EM} & \varepsilon\notin L\left(A_{EM}\right)\\F_{EM}\cup\left\{ q_{0}\right\} & \varepsilon\in L\left(A_{EM}\right)\end{cases}\)</span></p>
<p>השאלה היא האם ה"תיקון" הזה לא עשוי לקלקל לנו איכשהו את יתר השפה שהאוטומט מקבל. קל לראות שזה לא יכול לקרות, והנה הסבר בנפנוף ידיים: הדבר היחיד שיכול להשתבש הוא שבמקרה בו <span class="math">\(\varepsilon\in L\left(A_{EM}\right)\)</span> תהיה מילה לא ריקה <span class="math">\(w\)</span> כך ש-<span class="math">\(w\notin L\left(A_{EM}\right)\)</span> אבל <span class="math">\(q_{0}\in\hat{\delta}_{ND}\left(q_{0},w\right)\)</span> . עצרו רגע להסביר לעצמכם למה זה המקרה הבעייתי היחיד.</p>
<p>אני רוצה לשכנע אתכם שזה לא יכול לקרות. ספציפית, שאם <span class="math">\(q_{0}\in\hat{\delta}_{ND}\left(q_{0},w\right)\)</span> אז <span class="math">\(w\in L\left(A_{EM}\right)\)</span>. ההסבר פשוט מאוד: מכיוון ש-<span class="math">\(q_{0}\in\hat{\delta}_{ND}\left(q_{0},w\right)\)</span>, הרי ש-<span class="math">\(q_{0}\in\hat{\delta}_{EM}\left(q_{0},w\right)\)</span>, כלומר באוטומט עם מסעי ה-<span class="math">\(\varepsilon\)</span> אפשר להגיע אל <span class="math">\(q_{0}\)</span> על ידי קריאת <span class="math">\(w\)</span>. כעת, מכיוון ש-<span class="math">\(\varepsilon\in L\left(A_{EM}\right)\)</span> המשמעות של זה היא שבאותו אוטומט, קיימת סדרה של מסעי-<span class="math">\(\varepsilon\)</span> שמובילה מ-<span class="math">\(q_{0}\)</span> אל מצב מקבל כלשהו. לכן כדי לקבל את <span class="math">\(w\)</span> באוטומט הזה קודם כל נקרא אותו בצורה שמעבירה אותנו ל-<span class="math">\(q_{0}\)</span> בסוף הקריאה של אותיות <span class="math">\(w\)</span>, ואז מבצעת עוד סדרה של מסעי-<span class="math">\(\varepsilon\)</span> אל מצב מקבל.</p>
<p>זה מסיים את ההוכחה, והחל מהפוסט הבא נוכל להשתמש בחופשיות באוטומטים אי-דטרמיניסטיים עם מסעי-<span class="math">\(\varepsilon\)</span> כדי לעשות דברים. רק תרגול אחד לסיום - נסו לקחת את האוטומט שמצויר לעיל ולסלק לו את מסעי ה-<span class="math">\(\varepsilon\)</span>. הנה מה שאמור להתקבל:</p>
<p><a href="/blog/img/2014/11/diagram003.png"><img class="aligncenter size-full wp-image-3195" alt="diagram003" src="/blog/img/2014/11/diagram003.png" width="460" height="192" /></a></p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>