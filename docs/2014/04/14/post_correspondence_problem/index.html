<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>פוסט של בעיית ההתאמה של פוסט - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2014/04/08/limsup_and_liminf/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">על גבולות עליונים ותחתונים של קבוצות וממשיים</span>
            </a>
            

            
            <a href="/2014/04/28/fourier_series_intro/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">טורי פורייה - מה זה בכלל?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>פוסט של בעיית ההתאמה של פוסט</h1>
            <div class="post-meta">
                <span class="date">2014-04-14</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/חישוביות.html">חישוביות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/בעיית ההתאמה של פוסט.html">בעיית ההתאמה של פוסט</a>
                    
                    <a href="/tags/דקדוקים.html">דקדוקים</a>
                    
                    <a href="/tags/רדוקציות.html">רדוקציות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>"בעיית ההתאמה של פוסט" - Post Correspondence Problem, ובקיצור PCP - היא בעיה נחמדה במדעי המחשב שנקראת על שם אמיל פוסט, אחד מחלוצי מדעי המחשב (ואינה קשורה לדואר, כמו שחשבתי הרבה זמן) שתיאר אותה ב-1946. מה שנחמד בבעיה הזו הוא שהיא <strong>בלתי פתירה</strong>, דהיינו לא קיים אלגוריתם שיודע לפתור אותה; זה נשמע כמו חסרון, אבל למי שמעוניינים להוכיח שעוד בעיות במדעי המחשב הן לא פתירות זה דווקא יתרון: כדי להראות שבעיה במדעי המחשב אינה פתירה, מספיק להראות טיעון מהצורה "אם הבעיה שלי הייתה פתירה, אז היינו יכולים לפתור בעזרתה את בעיית ההתאמה של פוסט". מה שטוב בבעיית ההתאמה של פוסט הוא שמצד אחד היא לא פתירה, אבל מצד שני היא מאוד פשוטה לניסוח, ולכן הוכחות של "כך אני פותר את פוסט, בהינתן פתרון לבעיה המוזרה שלי" הן קלות יחסית.</p>
<p>איך מוגדרת הבעיה? ההגדרה קצת מוזרה, אז נתחיל עם דוגמה. בואו נסתכל על שלושה זוגות של מילים מעל <span class="math">\(\left\{ 0,1\right\} \)</span> (כלומר, סדרות של 0 ו-1):</p>
<p><span class="math">\(\left(00,0\right),\left(1,00\right),\left(0,10\right)\)</span></p>
<p>שתי מילים אפשר <strong>לשרשר</strong> - לכתוב אותן אחת אחרי השניה. השרשור של 00 עם 01 הוא המילה 0001. אז גם זוגות נשרשר "רכיב רכיב", כלומר <span class="math">\(\left(00,0\right)\cdot\left(1,00\right)=\left(001,000\right)\)</span>. עכשיו, הבה ונסתכל על סדרת השרשורים הבאים:</p>
<p><span class="math">\(\left(00,0\right)\cdot\left(00,0\right)\cdot\left(1,00\right)\cdot\left(0,10\right)=\left(000010,000010\right)\)</span></p>
<p>שימו לב מה קיבלתי - זוג שבו המילה בצד ימין והמילה בצד שמאל הן<strong> זהות</strong>, למרות שבכל הזוגות שמהם בניתי אותו המילים הללו תמיד שונות.</p>
<p>בואו נתאר את זה בצורה טיפה יותר פורמלית. נסמן את הזוגות בתור <span class="math">\(\left(a_{1},b_{1}\right),\left(a_{2},b_{2}\right),\left(a_{3},b_{3}\right)\)</span>. למשל, <span class="math">\(b_{3}=10\)</span> ו-<span class="math">\(a_{2}=1\)</span>. אז האבחנה שלעיל היא בעצם האבחנה ש-<span class="math">\(a_{1}a_{1}a_{2}a_{3}=b_{1}b_{1}b_{2}b_{3}\)</span>. עוד יותר פורמלית: מצאנו <strong>סדרת אינדקסים </strong><span class="math">\(j_{1},j_{2},\dots,j_{k}\)</span> כך ש-<span class="math">\(a_{j_{1}}a_{j_{2}}\cdots a_{j_{k}}=b_{j_{1}}b_{j_{2}}\cdots b_{j_{k}}\)</span>.</p>
<p>אצלנו <span class="math">\(n=4\)</span> ו-<span class="math">\(j_{1}=j_{2}=1\)</span>, <span class="math">\(j_{3}=2\)</span> ו-<span class="math">\(j_{4}=3\)</span>.</p>
<p>הדוגמה הזו בעצם מתארת כמעט לגמרי מה קורה באופן כללי: הקלט לבעיה הוא סדרה <strong>סופית</strong> של זוגות, <span class="math">\(\left(a_{1},b_{1}\right),\dots,\left(a_{n},b_{n}\right)\)</span>, שכולן מעל אותו א"ב (הוא יכול להיות שונה מ-<span class="math">\(\left\{ 0,1\right\} \)</span> ובהמשך אשתמש בזה, אבל זה לצורך נוחות בלבד; אפשר היה בתיאוריה לעשות את הכל גם עם 0,1). השאלה היא האם קיימת סדרת אינדקסים <strong>סופית</strong> <span class="math">\(j_{1},\dots,j_{k}\)</span> כך ש-<span class="math">\(a_{j_{1}}a_{j_{2}}\cdots a_{j_{k}}=b_{j_{1}}b_{j_{2}}\cdots b_{j_{k}}\)</span>. כן או לא. זה הכל. והבעיה האלגוריתמית הזו - אינה כריעה.</p>
<p>המטרה העיקרית שלי בפוסט היא להציג את הוכחת אי הכריעות של הבעיה, שהיא נפלאה לטעמי, אבל לפני כן אני רוצה להראות את היישום הסטנדרטי של הבעיה להוכחת אי הכריעות של בעיה אחרת - ובעיה טבעית ומעניינת למדי: בדיקה האם דקדוק חופשי-הקשר הוא דו-משמעי. זה מצריך ממני להציג בזריזות את ההגדרה של דקדוק חופשי-הקשר, שעדיין לא הצגתי בבלוג בכללת אבל אפשר גם לראות אותה ב<a href="http://he.wikipedia.org/wiki/%D7%93%D7%A7%D7%93%D7%95%D7%A7_%D7%97%D7%95%D7%A4%D7%A9%D7%99-%D7%94%D7%A7%D7%A9%D7%A8">ויקיפדיה</a>. אני חושב על דקדוק בתור מעין מכונה ליצירת מילים: מתחילים מאיזה <strong>משתנה</strong> התחלתי <span class="math">\(S\)</span>, ומבצעים סדרה של <strong>גזירות</strong>, כאשר כל גזירה מחליפה משתנה במילה שיש לנו כרגע בתת-מילה חדשה, שמכילה משתנים חדשים וסימבולים (<strong>טרמינלים</strong>) שאי אפשר לגזור. דקדוק <span class="math">\(G=\left(V,T,S,P\right)\)</span> כולל קבוצה סופית <span class="math">\(V\)</span> של משתנים, קבוצה סופית <span class="math">\(T\)</span> של טרמינלים, משתנה התחלתי <span class="math">\(S\in V\)</span> וקבוצה סופית <span class="math">\(P\)</span> של כללי גזירה שמסומנים <span class="math">\(A\to\beta\)</span> כאשר <span class="math">\(A\)</span> הוא המשתנה שגוזרים ו-<span class="math">\(\beta\)</span> היא מילה שיכולה לכלול משתנים וטרמינלים.</p>
<p>בואו נסתכל לדוגמה על דקדוק טיפשי לגזירת ביטויים חשבוניים. הטרמינלים שלנו יהיו <span class="math">\(0,1,2,\dots,9,+,\times\)</span>. יהיה לנו רק משתנה אחד: <span class="math">\(S\)</span> עצמו. ויהיו לנו כללי גזירה מהצורה <span class="math">\(S\to0,S\to1,\dots,S\to9\)</span> וכמו כן את <span class="math">\(S\to S+S\)</span> ואת <span class="math">\(S\to S\times S\)</span>. עכשיו בואו ונראה שתי גזירות למילה <span class="math">\(1+2\times3\)</span>:</p>
<p><span class="math">\(S\Rightarrow S+S\Rightarrow1+S\Rightarrow1+S\times S\Rightarrow1+2\times S\Rightarrow1+2\times3\)</span></p>
<p><span class="math">\(S\Rightarrow S\times S\Rightarrow S\times3\Rightarrow S+S\times3\Rightarrow S+2\times3\Rightarrow1+2\times3\)</span></p>
<p>שתי הגזירות הללו שונות זו מזו באופן מהותי. ההסבר הפורמלי הוא שיש להן עצי גזירה שונים אבל אני לא אגדיר את המושג הזה בפוסט, אז הנה אינטואיציה: בגזירה הראשונה, הצעד הראשון מפרק את הביטוי לשני חלקים - מה שמשמאל לפלוס ומה שלימינו. אם אנחנו מנסים לחשב את ערכו של הביטוי החשבוני, אפשר לחשוב שמעכשיו אנחנו מחשבים כל חלק בנפרד ובסוף נבצע חיבור שלהם. אגף שמאל יהיה שווה 1, ואגף ימין יהיה שווה <span class="math">\(2\times3=6\)</span>, ולכן הסכום ייתן 7. עד כאן, הגיוני; אבל אם נעשה את זה גם לגזירה השניה נראה שאחרי הצעד הראשון אנחנו מפרקים את הביטוי לאגף שמאל כפול אגף ימין, כאשר אגף ימין שווה ל-3 אבל אגף שמאל שווה ל-<span class="math">\(1+2=3\)</span> ולכן המכפלה צריכה לתת... תשע? לא הגיוני, כמובן - לנו זה נראה מובן מאליו שהביטוי שווה 7 כי אנחנו מניחים במובלע <strong>סדר קדימויות</strong> בין כפל וחיבור, אבל מבחינת הדקדוק זה לא קיים.</p>
<p>הסיטואציה הזו, שבה דקדוק יכול לגזור את אותה מילה בשתי דרכים שונות מהותית, היא בעייתית; לרוב משתמשים בנתונים על <strong>סדרת הגזירה</strong> של מילה בדקדוק מסויים כדי להבין את ה<strong>סמנטיקה</strong> שלו - מה הוא אומר בפועל (למשל, במקרה של ביטוי חשבוני, מה ערכו; אבל לעתים קרובות יותר, במקרה של תוכנית מחשב, מה היא עושה). שתי סדרות גזירה שונות פירושן שיש שתי דרכים שונות לפרש את המילה - בעיה. דקדוק שיש לו את הבעיה הזו - מילה אחת לפחות עם שתי סדרות גזירה שונות מהותית - נקרא דקדוק <strong>רב-משמעי</strong>. היינו שמחים, בהינתן הגדרה של דקדוק, לומר אם הוא רב משמעי - אבל באופן די מפתיע, גם זו בעיה לא כריעה אלגוריתמית, כי קל לראות שאם היא הייתה כריעה, גם PCP הייתה כריעה.</p>
<p>מה הרעיון? פשוט מאוד: נניח שיש לנו קלט לבעיית PCP, כלומר <span class="math">\(\left(a_{1},b_{1}\right),\dots,\left(a_{n},b_{n}\right)\)</span>. אנחנו רוצים לבנות דקדוק שבו יש מילה שניתן לגזור בשתי דרכים שונות אם ורק אם אפשר להרכיב גם מה-<span class="math">\(a\)</span>-ים וגם מה-<span class="math">\(b\)</span>-ים את אותה מילה... די ברור מה צריך לעשות. פשוט נגדיר דקדוק שמשתניו הם <span class="math">\(S,A,B\)</span> עם כללי הגזירה <span class="math">\(S\to A|B\)</span> (הקו המפריד הזה אומר "או" - בעצם אני מתאר כאן שני כללי גזירה בו זמנית) וכמו כן <span class="math">\(A\to a_{i}A|a_{i}\)</span> ו-<span class="math">\(B\to b_{i}B|b_{i}\)</span> לכל <span class="math">\(1\le i\le n\)</span>.</p>
<p>למשל, עבור בעיית ה-PCP שהבאתי כדוגמה בתחילת הפוסט, עם הזוגות <span class="math">\(\left(00,0\right),\left(1,00\right),\left(0,10\right)\)</span>, אקבל כללי גזירה כמו <span class="math">\(A\to00A\)</span> ו-<span class="math">\(A\to00\)</span> ו-<span class="math">\(B\to10\)</span> וכדומה. והנה שתי גזירות שונות של אותה מילה:</p>
<p><span class="math">\(S\Rightarrow A\Rightarrow00A\Rightarrow0000A\Rightarrow00001A\Rightarrow000010\)</span></p>
<p><span class="math">\(S\Rightarrow B\Rightarrow0B\Rightarrow00B\Rightarrow0000B\Rightarrow000010\)</span></p>
<p>זו בניה נחמדה מאוד, רק חבל שהיא לא עובדת. למה לא עובדת? מאותה סיבה שרוב הבניות הכושלות ברדוקציות בין בעיות חישוביות נכשלות - חשבנו רק על כיוון אחד של הבניה. מה שעשינו הוא לבדוק דקדוק שהוא על בטוח דו-משמעי אם בעיית ה-PCP המקורית פתירה; אבל ייתכן שהוא יהיה דו משמעי גם אם הבעיה המקורית אינה פתירה. למשל, תראו את הגזירות הללו עבור אותו דקדוק כמו קודם:</p>
<p><span class="math">\(S\Rightarrow A\Rightarrow00\)</span></p>
<p><span class="math">\(S\Rightarrow B\Rightarrow00\)</span></p>
<p>קל לבדוק ולוודא שאלו גזירות חוקיות בדקדוק, אבל 00 היא לא באמת מילה שיכולה להיווצר בבעיית ה-PCP בתור מילה משותפת, שכן היא מצריכה שימוש באינדקסים <strong>שונים</strong> עבור סדרות ה-<span class="math">\(a\)</span> וה-<span class="math">\(b\)</span> (<span class="math">\(a_{1}=00\)</span> אבל <span class="math">\(b_{2}=00\)</span>). לכן הדקדוק שלנו יצטרך בצורה כלשהי גם לציין מה היו האינדקסים שבהם הוא השתמש ביצירת המילה. התעלול הוא לפלוט אותם <strong>בסוף</strong> המילה. אז הנה מה שנעשה: נוסיף לטרמינלים שלנו סימבולים <span class="math">\(t_{1},\dots,t_{n}\)</span> ואת הסימבול <span class="math">\(\#\)</span> (שהוא מיותר אבל יעשה את מה שאעשה בהמשך טיפה יותר קריא) וכעת נבנה את הדקדוק הבא:</p>
<p><span class="math">\(S\to A|B\)</span></p>
<p><span class="math">\(A\to a_{i}At_{i}|\#\)</span> לכל <span class="math">\(1\le i\le n\)</span></p>
<p><span class="math">\(B\to b_{i}Bt_{i}|\#\)</span>לכל <span class="math">\(1\le i\le n\)</span></p>
<p>כעת אדגים שוב את הגזירות שנותנות את אותו הדבר:</p>
<p><span class="math">\(S\Rightarrow A\Rightarrow00At_{1}\Rightarrow0000At_{1}t_{1}\Rightarrow00001At_{2}t_{1}t_{1}\Rightarrow000010At_{3}t_{2}t_{1}t_{1}\Rightarrow000010\#t_{3}t_{2}t_{1}t_{2}\)</span></p>
<p><span class="math">\(S\Rightarrow B\Rightarrow0Bt_{1}\Rightarrow00Bt_{1}t_{1}\Rightarrow0000Bt_{2}t_{1}t_{1}\Rightarrow000010Bt_{3}t_{2}t_{1}t_{1}\Rightarrow000010\#t_{3}t_{2}t_{1}t_{1}\)</span></p>
<p>שימו לב שהאינדקסים מסודרים מהאחרון לראשון - קצת מחשבה תראה שלא יכלתי לעשות זאת בשום דרך אחרת. פרט לכך שזה נראה לנו, הקוראים, קצת מוזר, זה לא באמת מקלקל את ההוכחה.</p>
<p>עכשיו קל לראות שהגזירה השגויה שהצגתי למעלה, של 00, לא תעבוד:</p>
<p><span class="math">\(S\Rightarrow A\Rightarrow00At_{1}\Rightarrow00\#t_{1}\)</span></p>
<p><span class="math">\(S\Rightarrow B\Rightarrow00Bt_{2}\Rightarrow00\#t_{2}\)</span></p>
<p>כלומר, לא קיבלנו את אותה המילה כי <span class="math">\(t_{1}\ne t_{2}\)</span>. צריך עדיין לשבת ולהוכיח פורמלית שהרדוקציה עובדת, אבל היא עובדת. מסקנה: אם היינו יכולים לבדוק שדקדוק הוא רב משמעי, היינו יכולים לפתור את PCP, ולכן לא ניתן לבדוק את זה.</p>
<p>כמעט אותה בניה מראה לנו שעוד בעיה נפוצה עבור דקדוקים היא לא פתירה - נניח שיש לנו שני דקדוקים <span class="math">\(G_{1},G_{2}\)</span>, ואנחנו רוצים לבדוק שיש מילה ששניהם יודעים לייצר - כלומר, שהחיתוך של השפות שהם מייצרים הוא לא ריק. איך הבעיה הזו פותרת לנו את PCP? פשוט מאוד. במקום כללי הגזירה <span class="math">\(S\to A,S\to B\)</span> בדקדוק הקודם, פשוט נייצג שני דקדוקים ש-<span class="math">\(A\)</span> הוא המשתנה ההתחלתי של אחד מהם, ו-<span class="math">\(B\)</span> הוא המשתנה ההתחלתי של השני. באנג! עוד בעיה לא כריעה.</p>
<p>מספיק עם השימושים, בואו נעבור להוכחה ש-PCP לא כריעה. אבל לפני כן, אני אצטרך לעשות עוד תעלול טכני אחד ולעבור מ-PCP לבעיה כמעט זהה אבל עם מגבלה נוספת, שתקל עלי מאוד בהוכחה. המגבלה היא זו: עד כה, פתרון קביל ל-PCP יכל להשתמש בכל זוג מתי שבא לו. עכשיו אני רוצה להגביל את זה טיפ-טיפה: להגיד שהזוג <strong>הראשון</strong> שבו משתמשים יהיה זוג מיוחד, שמופיע רק פעם אחת - בהתחלה. במילים אחרות, הקלט לבעיה יהיה <span class="math">\(\left(a_{1},b_{1}\right),\dots,\left(a_{n},b_{n}\right)\)</span> ובנוסף לכך עוד זוג <span class="math">\(\left(x,y\right)\)</span>, והשאלה תהיה אם קיימת סדרת אינדקסים <span class="math">\(j,\dots,j_{k}\)</span> כך ש-<span class="math">\(xa_{j_{1}}a_{j_{2}}\cdots a_{j_{k}}=yb_{j_{1}}b_{j_{2}}\cdots b_{j_{k}}\)</span>. על הבעיה <strong>הזו</strong> יהיה לי הרבה יותר קל להראות שהיא לא כריעה; ולכן כדי להראות ש-PCP אינה כריעה, אני צריך קודם כל להסביר איך אני פותר את הבעיה החדשה בעזרת PCP.</p>
<p>התשובה היא שנעשה תעלול טכני. מתוך הקלט <span class="math">\(\left(x,y\right),\left(a_{1},b_{1}\right),\dots,\left(a_{n},b_{n}\right)\)</span> אני הולך ליצור סדרה חדשה של זוגות, שמהונדסים בצורה ש"תכריח" את הזוג שמתאים ל-<span class="math">\(\left(x,y\right)\)</span> להיות ראשון, למרות שחוקי המשחק לא מאפשרים לי להגדיר במפורש שאיבר כלשהו יהיה ראשון.</p>
<p>כרגיל, יהיה הכי נוח להסביר עם דוגמה, אז הנה קלט לדוגמה - וקלט ממש טיפשי, רק כדי שהמניפולציות שאעשה בהמשך יהיו ברורות. <span class="math">\(\left(x,y\right)=\left(11,1\right)\)</span> ו-<span class="math">\(\left(a_{1},b_{1}\right)=\left(11,11\right)\)</span>. ברור ש<strong>אין</strong> מילה משותפת, כי האורך של מילה שמתחילה ב-<span class="math">\(x\)</span> יהיה זוגי והאורך של מילה שמתחילה ב-<span class="math">\(y\)</span> יהיה אי זוגי, אבל אני לא יכול סתם לקחת את הזוגות הללו ולהתייחס אליהן כאל בעיית PCP רגילה, כי <span class="math">\(a_{1}=b_{1}\)</span> הוא פתרון לבעיית ה-PCP הרגילה (פשוט מתעלמים מה-<span class="math">\(\left(x,y\right)\)</span>). אני חייב איכשהו להכריח את <span class="math">\(\left(x,y\right)\)</span> להיות הזוג הראשון אם בכלל תהיה תקווה <strong>כלשהי</strong> לכך שנקבל מילה משותפת.</p>
<p>הרעיון הוא לדחוף סימן מיוחד - שוב פעם אשתמש ב-<span class="math">\(\#\)</span> - בין כל שתי אותיות, של כל מילה שמופיעה בכל זוג, אבל בצורה כזו שהמילה <strong>השמאלית</strong> בכל זוג <strong>תסתיים</strong> ב-<span class="math">\(\#\)</span>, ואילו המילה <strong>הימנית</strong> בכל זוג <strong>תתחיל</strong> ב-<span class="math">\(\#\)</span>. כלומר, אני אהפוך את הזוג <span class="math">\(\left(11,11\right)\)</span> לזוג <span class="math">\(\left(1\#1\#,\#1\#1\right)\)</span>. שימו לב לחוסר ההתאמה הזה במיקומי ה-<span class="math">\(\#\)</span>-ים; הוא מכוון.</p>
<p>כעת, גם ל-<span class="math">\(\left(x,y\right)\)</span> אעניק טיפול דומה במובן זה שאדחוף להם <span class="math">\(\#\)</span> בין כל שתי אותיות, אבל <strong>אף אחד מהם </strong>לא יתחיל ב-<span class="math">\(\#\)</span>, ורק השמאלי יסתיים ב-<span class="math">\(\#\)</span>, כלומר, אני הופך את <span class="math">\(\left(11,1\right)\)</span> ל-<span class="math">\(\left(1\#1\#,1\right)\)</span>.</p>
<p>עכשיו, מה קורה פה? המילה <span class="math">\(xa_{1}\)</span>, שקודם הייתה <span class="math">\(1111\)</span>, הפכה עכשיו ל-<span class="math">\(1\#1\#1\#1\#\)</span>. המילה <span class="math">\(yb_{1}\)</span> הפכה ל-<span class="math">\(1\#1\#1\)</span>. כלומר - כל מילה שמורכבת מהמילים <strong>השמאליות</strong> בכל זוג הולכת להסתיים ב-<span class="math">\(\#\)</span>, וכל מילה שמורכבת מהמילים ה<strong>ימניות</strong> בכל זוג תסתיים בלי ה-<span class="math">\(\#\)</span> הזה. הדרך היחידה לקבל מילה זהה היא "לסגור" את הסיפור באמצעות עוד זוג מיוחד - הזוג <span class="math">\(\left(@,\#@\right)\)</span> כאשר גם <span class="math">\(@\)</span> הוא תו מיוחד חדש שבו אני משתמש ולא מופיע במילים האחרות.</p>
<p>בואו נתאר פורמלית את מה שעשיתי. נגדיר אופרטור <span class="math">\(\Phi\)</span> שלוקח מילה <span class="math">\(w=\sigma_{1}\dots\sigma_{k}\)</span> ודוחף לה <span class="math">\(\#\)</span> בין כל האותיות, כלומר <span class="math">\(\Phi\left(w\right)=\sigma_{1}\#\sigma_{2}\dots\#\sigma_{k}\)</span>. כעת, אם קיבלנו בעיית PCP-עם-זוג-התחלתי <span class="math">\(\left(x,y\right),\left(a_{1},b_{1}\right),\dots,\left(a_{n},b_{n}\right)\)</span> נייצר בעיית PCP "רגילה" עם הזוגות הבאים: לכל <span class="math">\(\left(a_{i},b_{i}\right)\)</span> יהיה לנו את הזוג <span class="math">\(\left(\Phi\left(a_{i}\right)\#,\#\Phi\left(b_{i}\right)\right)\)</span>. כמו כן, במקום <span class="math">\(\left(x,y\right)\)</span> יהיה לנו <span class="math">\(\left(\Phi\left(x\right)\#,\Phi\left(y\right)\right)\)</span>, וכמו כן יהיה לנו את הזוג הנוסף <span class="math">\(\left(@,\#@\right)\)</span>. זה תרגיל מצויין לשבת ולהוכיח שזה עובד - שלבעיה המקורית היה פתרון אם ורק אם לבעיה החדשה עם ה-<span class="math">\(\#\)</span>-ים יש.</p>
<p>עכשיו אפשר להגיע סוף סוף לחלק המרכזי בפוסט - הוכחה שבעיית ה-PCP-עם-זוג-התחלתי היא לא כריעה. האופן שבו נעשה את זה הוא על ידי רדוקציה מהבעיה הלא כריעה הידועה ביותר במדעי המחשב - בעיית העצירה של מכונות טיורינג. לשם כך אזכיר בזריזות את מה שנצטרך לדעת על מכונות טיורינג (ו<a href="http://www.gadial.net/2007/09/23/turing_machine/">יש לי פוסט</a> על הנושא למי שמעוניין). אני הולך להציג כאן גרסה <strong>מפושטת</strong> של מכונות טיורינג ושל בעיית העצירה כי לא אצטרך יותר מכך - אל תסתכלו על מה שאכתוב עכשיו בתור ההגדרה האולטימטיבית!</p>
<p>מכונת טיורינג <span class="math">\(M\)</span> היא מעין מחשב קטן, עם קבוצת <strong>מצבים</strong> פנימיים סופית וסרט אינסופי בכיוון אחד (ימין) שמחולק לתאים שבכל אחד מהם כתובה אות כלשהי. יש למכונה ראש קורא/כותב שמתרוצץ על הסרט, קורא את תוכן התא שמעליו הוא נמצא כרגע, בודק באיזה מצב פנימי המכונה נמצאת, ועל פי הזוג הזה (המצב הפנימי והאות שקראנו) מחליט מה לעשות עכשיו - האם לשנות את תוכן התא, האם לשנות את המצב הפנימי של המכונה, והאם להזיז את הראש.</p>
<p>פורמלית מכונת טיורינג <span class="math">\(M\)</span> בנויה מקבוצת מצבים סופית <span class="math">\(Q\)</span>, מא"ב סופי כלשהו <span class="math">\(\Sigma\)</span> ומפונקציית מעברים <span class="math">\(\delta:Q\times\Sigma\to Q\times\Sigma\times\left\{ R,L,S\right\} \)</span>. <span class="math">\(\delta\left(q,\sigma\right)=\left(p,\tau,X\right)\)</span> פירושו "אם היית במצב <span class="math">\(q\)</span> וקראת <span class="math">\(\sigma\)</span> עבור למצב <span class="math">\(p\)</span>, שנה את תוכן התא ל-<span class="math">\(\tau\)</span> והזז את הראש <span class="math">\(X\)</span>" כאשר אם <span class="math">\(X\)</span> הוא <span class="math">\(L\)</span> מזיזים את הראש צעד אחד שמאלה, אם הוא <span class="math">\(R\)</span> מזיזים אותו צעד אחד ימינה ואם הוא <span class="math">\(S\)</span> לא זזים. כמו כן למכונה יש מצב מיוחד <span class="math">\(q_{f}\in Q\)</span> שאם המכונה נכנסה אליו, אומרים שהיא "עצרה" ומפסיקים את החישוב שלה, ו-<span class="math">\(\delta\)</span> לא מוגדרת עליו (זה לא מתאים לכתיב הפורמלי שלי שבו <span class="math">\(\delta\)</span> מוגדרת על התחום <span class="math">\(Q\times\Sigma\)</span> אבל למי אכפת - אני מרשה לפונקציה הזו לא להיות מוגדרת על כל התחום שלה). יש גם סימן מיוחד <span class="math">\(\flat\in\Sigma\)</span> שמהווה את תוכן תאי הסרט כשהמכונה רק מתחילה לרוץ (חושבים עליו בתור "תא ריק") ומצב מיוחד <span class="math">\(q_{0}\in Q\)</span> שבו המכונה נמצאת כשהיא מתחילה לרוץ.</p>
<p>בעיה טכנית אחת שאולי שמתם לב אליה היא ש-<span class="math">\(M\)</span> עשויה להגיע אל הקצה השמאלי של הסרט, ואז לבצע עוד צעד שמאלה. לרוב מגדירים שבמקרה כזה, היא פשוט נשארת במקום; אבל זה יסבך את הבניה שאציג בהמשך. לכן אני הולך להניח שזה פשוט לא קורה. זה תרגיל נחמד - בהינתן מכונת טיורינג לבנות מכונה שקולה (עוצרת על אותם קלטים) שאף פעם לא "נופלת מקצה הסרט"; בפוסט הזה תאמינו לי שזה אפשרי.</p>
<p>כעת, בכל רגע נתון של הריצה שלה, הריצה של המכונה מאופיינת על ידי שלושה דברים: המצב הפנימי הנוכחי של המכונה; המיקום של הראש הקורא/כותב על גבי הסרט; ותוכן הסרט. שלושת אלו יחד נקראים <strong>הקונפיגורציה</strong> של המכונה. אפשר לכתוב קונפיגורציה בקיצור בצורה הבאה: סדרה של תווים שמתארת את תוכן תאי הסרט, כאשר התא שמעליו נמצא הראש הקורא/כותב אינו תו מתוך <span class="math">\(\Sigma\)</span> אלא תו מיוחד שהוא <strong>זוג</strong> של תו מתוך <span class="math">\(\Sigma\)</span> יחד עם תו שמתאר את המצב הפנימי הנוכחי של המכונה. למשל, <span class="math">\(ab\flat\left(q_{3},b\right)\flat a\flat\)</span> היא מחרוזת שמתארת את הקונפיגורציה הבאה: תוכן הסרט הוא <span class="math">\(ab\flat b\flat a\flat\flat\flat\dots\)</span>, המצב הפנימי הוא <span class="math">\(q_{3}\)</span> ומיקום הראש הוא מעל תא 4 (אם מתחילים את הספירה מ-1). שימו לב שקונפיגורציה מתוארת על ידי מחרוזת <strong>סופית</strong> למרות שהסרט הוא אינסופי - זאת מכיוון שאנחנו יודעים בודאות שכל תא שהמכונה טרם הגיעה אליו הוא ריק, ולכן אפשר להסכים שהמחרוזת מתארת רק את תוכן כל תאי הסרט שהמכונה הגיעה אליהם עד כה מתישהו במהלך ריצתה.</p>
<p>כעת, נניח שבמכונה שאת הקונפיגורציה שלה תיארתי לפני רגע יש את המעבר הבא: <span class="math">\(\delta\left(q_{3},b\right)=\left(q_{5},c,R\right)\)</span>. אז מהקונפיגורציה <span class="math">\(ab\flat\left(q_{3},b\right)\flat a\flat\)</span> המכונה הולכת לעבור לקונפיגורציה <span class="math">\(ab\flat c\left(q_{5},\flat\right)a\flat\)</span>. ודאו לעצכם שאתם מבינים למה - זה יהיה <strong>קריטי לחלוטין</strong> בשביל מה שנעשה בהמשך להבין את כל הקטע המעיק הזה של מעבר קונפיגורציות (מעיק? למה מעיק? לדעתי זה נפלא, צורת התיאור הזו; אבל כל עוד לא רואים איך עושים איתה דברים מגניבים - כמו רדוקציה ל-PCP - זה נראה כמו משהו טכני יבשושי).</p>
<p>אם מקונפיגורציה א' מגיעים לקונפיגורציה ב' תוך צעד אחד, אומרים שב' היא <strong>עוקבת</strong> של א'. כמו כן, למכונה יש קונפיגורציה <strong>התחלתית</strong> פשוטה במיוחד - <span class="math">\(\left(q_{0},\flat\right)\)</span> ("הסרט ריק, המצב הוא <span class="math">\(q_{0}\)</span>, הראש נמצא בתחילת הסרט"). קונפיגורציה <strong>סופית</strong> היא כל קונפיגורציה שבה המצב של המכונה הוא <span class="math">\(q_{f}\)</span>. בעיית העצירה היא בסך הכל השאלה הבאה - בהינתן מכונה <span class="math">\(M\)</span>, האם קיימת סדרת קונפיגורציות עוקבות שמתחילה בקונפיגורציה ההתחלתית ומסתיימת בקונפיגורציה סופית? והשאלה הזו, כאמור, אינה כריעה (לא ניכנס כעת להוכחה של הטענה הזו).</p>
<p>איך כל זה קשור ל-PCP? על פניו זה לא נראה כל כך קשור; אבל בואו ננסה לחשוב איך בכל זאת אפשר לקשר. ב-PCP השאלה היא האם קיימת "מילה משותפת" שאפשר לבנות בשתי דרכים שונות עם אותה סדרת אינדקסים; בבעיית העצירה השאלה היא האם קיימת "סדרת קונפיגורציות" שמתארת ריצה חוקית מקונפיגורציה התחלתית לקונפיגורציה סופית. אלו האובייקטים שעלינו לתרגם ביניהם - האם אפשר לתאר סדרת קונפיגורציות חוקית בתור מילה? בוודאי! כבר הראיתי איך לתאר קונפיגורציה בודדת בתור מילה, אז פשוט בואו נתקע איזה סימן <span class="math">\(\#\)</span> בין קונפיגורציות עוקבות! וכדי לפשט קצת יותר את העניינים, בואו ניפטר מהסוגריים המיותרים הללו שיש בתוך קונפיגורציה: במקום לכתוב <span class="math">\(ab\flat\left(q_{3},b\right)\flat a\flat\)</span> נכתוב <span class="math">\(ab\flat q_{3}b\flat a\flat\)</span> וכל עוד הסימבולים שמתארים מצבים והסימבולים שמתארים את הא"ב של המכונה הם שונים זה מזה לא תהיה בעיה של דו משמעות כאן.</p>
<p>הנה דוגמה לסדרת קונפיגורציות שכזו:</p>
<p><span class="math">\(q_{0}\flat\#aq_{1}\flat\#q_{2}aa\#q_{f}aa\)</span></p>
<p>אל תקראו רגע את ההמשך - שבו וכתבו במפורש אילו מעברים צריכים להיות במכונה כדי שתיתן את סדרת הקונפיגורציות הזו. רק כך נוכל להיות בטוחים שאתם מבינים את הפרטים הטכניים הרלוונטיים כאן - והפרטים הללו יהיו לב העניין אחר כך. כתבתם? יפה. המעברים הם <span class="math">\(\delta\left(q_{0},\flat\right)=\left(q_{1},a,R\right)\)</span> ו-<span class="math">\(\delta\left(q_{1},\flat\right)=\left(q_{2},a,L\right)\)</span> ו-<span class="math">\(\delta\left(q_{2},a\right)=\left(q_{f},a,S\right)\)</span>.</p>
<p>עכשיו משהסכמנו על כך שהמילה המשותפת שנייצר תהיה סדרת קונפיגורציות שמתארת ריצה חוקית שעוצרת, נשאלת רק השאלה איך "לכפות" על המילה שנוצרת באמת לתאר ריצה כזו. לשם כך נצטרך להתבסס בצורה חזקה על הדרישה שיש לנו מ-PCP: שאותה סדרה תיווצר <strong>בשתי דרכים שונות</strong>, על ידי <strong>אותם אינדקסים</strong>. מה שנעשה הוא שניצור את המילה בצורה כזו שצד שמאל "רודף" כל הזמן אחרי צד ימין ומפגר אחריו בקונפיגורציה אחת בדיוק, וההזדמנות היחידה שלו להשיג את צד ימין ולהשלים את המילה היא אם צד ימין הגיע למצב הסופי <span class="math">\(q_{f}\)</span>. כדי לעשות את זה יותר ברור אני לא אצייר את המילים בתור צד שמאל וצד ימין אלא בתור למעלה ולמטה. בהתחלה שתי המילים שנבנות ייראו כך:</p>
<p><span class="math">\(\begin{array}{cc}\#\\\# &amp; q_{0}\flat\#\end{array}\)</span></p>
<p>כעת, כדי שלמילה למעלה יהיה סיכוי "להדביק" את המילה שלמטה ועדיין להיות זהה לה, האותיות הבאות שחייבות להתווסף אליה הן <span class="math">\(q_{0}\flat\)</span>. עכשיו, נניח שלמכונה יש את הצעד הבא: <span class="math">\(\delta\left(q_{0},\flat\right)=\left(q_{1},a,R\right)\)</span>. אנחנו רוצים שאחרי הוספת הזוג הבא, המילים שאנחנו בונים ייראו כך:</p>
<p><span class="math">\(\begin{array}{ccc}\# &amp; q_{0}\flat\\\# &amp; q_{0}\flat &amp; \#aq_{1}\end{array}\)</span></p>
<p>כלומר, המילה שלמעלה "כיסתה" את החלק של <span class="math">\(q_{0}\flat\)</span> ואילצה את המילה שלמטה לבצע את המעבר שמקודד ב-<span class="math">\(\delta\left(q_{0},\flat\right)\)</span>. איך נעשה את זה? פשוט מאוד: לרשימת הזוגות שלנו נוסיף את הזוג <span class="math">\(\left(q_{0}\flat,aq_{1}\right)\)</span>. הוספת הזוג הזה למילה שנבנית יגרום בדיוק לתוצאה שאנחנו מעוניינים בה.</p>
<p>עכשיו צריך לטפל ב-<span class="math">\(\#\)</span> שמסמן סוף קונפיגורציה ומעבר לבאה בתור. אנחנו רוצים לסגור את הקונפיגורציה בו זמנית בשתי המילים, אז נשתמש בזוג <span class="math">\(\left(\#,\#\right)\)</span> ונקבל:</p>
<p><span class="math">\(\begin{array}{cccc}\# &amp; q_{0}\flat &amp; \#\\\# &amp; q_{0}\flat &amp; \# &amp; aq_{1}\#\end{array}\)</span></p>
<p>עכשיו, נניח שיש לנו את המעבר <span class="math">\(\delta\left(q_{1},\flat\right)=\left(q_{2},\flat,S\right)\)</span>. איך נטפל בו? אנחנו אמורים להוסיף את הזוג <span class="math">\(\left(q_{1}\flat,q_{2}\flat\right)\)</span> וזה בסדר גמור, אבל אם תשימו לב, במילה שלנו <span class="math">\(q_{1}\)</span> נמצא משמאל ל-<span class="math">\(\#\)</span> שמסמן את סוף הקונפיגורציה, ולא משמאל ל-<span class="math">\(\flat\)</span>. הרעיון הוא שהראש של המכונה הגיע אל הקצה של הסרט שכבר ראינו, ולכן במובלע נובע שיש שם <span class="math">\(\flat\)</span> אבל זה לא נכתב במפורש עדיין. איך נפתור את הבעיה הזו? פתרון מתבקש אחד הוא להוסיף מעבר מהצורה <span class="math">\(\left(q_{1}\#,q_{2}\flat\#\right)\)</span> - אבל זה קצת מסורבל. אפשר להיות יותר חכמים ולמנוע את הבעיה מראש, כבר בשלב סגירת הקונפיגורציה: במקום להשתמש בזוג <span class="math">\(\left(\#,\#\right)\)</span> אנחנו רוצים לאפשר גם להשתמש בזוג <span class="math">\(\left(\#,\flat\#\right)\)</span> שאומר לקונפיגורציה למטה להוסיף <span class="math">\(\flat\)</span> כי אולי נזדקק לו תכף. אם היינו משתמשים בזוג הזה, זוג המילים שאנחנו בונים היה מהצורה:</p>
<p><span class="math">\(\begin{array}{cccc}\# &amp; q_{0}\flat &amp; \#\\\# &amp; q_{0}\flat &amp; \# &amp; aq_{1}\flat\#\end{array}\)</span></p>
<p>וכעת אין בעיה; הזוג <span class="math">\(\left(q_{1}\flat,q_{2}\flat\right)\)</span> מטפל בסיטואציה הנוכחית. האם סיימנו? לא, כי שימו לב ל-<span class="math">\(a\)</span> בתחילת הקונפיגורציה - זו האות הבאה שהמילה למעלה צריכה להוסיף לעצמה, וגם במילה למטה היא צריכה להופיע כי המכונה לא נוגעת בה בצעד הזה. אז נוסיף לנו זוג <span class="math">\(\left(a,a\right)\)</span>, וכעת על ידי שימוש ב-<span class="math">\(\left(a,a\right)\)</span> ואחריו ב-<span class="math">\(\left(q_{1}\flat,q_{2}\flat\right)\)</span>, נקבל:</p>
<p><span class="math">\(\begin{array}{ccccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1} &amp; \# &amp; aq_{2}\flat\end{array}\)</span></p>
<p>לבסוף, נסגור את הקונפיגורציה בצורה "רגילה" עם <span class="math">\(\left(\#,\#\right)\)</span> ונקבל:</p>
<p><span class="math">\(\begin{array}{cccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\#\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}\flat\#\end{array}\)</span></p>
<p>בואו נדבר עכשיו על תזוזה שמאלה של הראש, כלומר נניח שיש לנו את המעבר <span class="math">\(\delta\left(q_{2},\flat\right)=\left(q_{3},b,L\right)\)</span>. מה קורה כאן? אנחנו רוצים לעבור לסיטואציה הבאה:</p>
<p><span class="math">\(\begin{array}{cccccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}b\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}\flat &amp; \# &amp; q_{3}ab\end{array}\)</span></p>
<p>כלומר, ב"מחיר" של הוספת <span class="math">\(aq_{2}b\)</span> למעלה אנחנו רוצים להוסיף <span class="math">\(q_{3}ab\)</span> למטה. לכן נוסיף את הזוג <span class="math">\(\left(aq_{2}b,q_{3}ab\right)\)</span> לרשימת הזוגות שלנו.</p>
<p>רק דבר אחד עוד נותר לנו להבין לפני שנעבור לתיאור פורמלי של הכל - איך מסיימים? איך מאפשרים למילה שלמעלה להדביק את המילה שלמטה?</p>
<p>ובכן, בואו ניתן למכונה הבדיונית המסכנה שלי להגיע אל המנוחה והנחלה - נניח שיש לנו את המעבר <span class="math">\(\delta\left(q_{3},a\right)=\left(q_{f},a,S\right)\)</span>. קודם כל, הוא יתבטא, כרגיל, בזוג <span class="math">\(\left(q_{3}a,q_{f}a\right)\)</span> ונגיע אל הסיטואציה הבאה:</p>
<p><span class="math">\(\begin{array}{ccccccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}b &amp; \# &amp; q_{3}a\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}\flat &amp; \# &amp; q_{3}a &amp; b\#q_{f}a\end{array}\)</span></p>
<p>המילה שלמעלה עדיין צריכה להדביק את ה-<span class="math">\(b\#\)</span> שלמטה עד שתגיע למצב שבו היא צריכה להשוות את ה-<span class="math">\(q_{f}\)</span> שלמטה; את זה היא תעשה עם הזוגות <span class="math">\(\left(b,b\right)\)</span> ו-<span class="math">\(\left(\#,\#\right)\)</span>, ואז נגיע למצב הבא:</p>
<p><span class="math">\(\begin{array}{cccccccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}b &amp; \# &amp; q_{3}a &amp; b\#\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}\flat &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}ab\#\end{array}\)</span></p>
<p>מה היינו <strong>רוצים</strong> שיקרה עכשיו? ובכן, היינו שמחים אם היה לנו את הזוג הבא: <span class="math">\(\left(q_{f}ab\#\#,\#\right)\)</span>, שהיה משלים אותנו למילה המשותפת הבאה:</p>
<p><span class="math">\(\begin{array}{cccccccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}b &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}ab\#\#\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}\flat &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}ab\#\#\end{array}\)</span></p>
<p>למה לא להוסיף זוג כזה, באמת? למה לא להוסיף זוגות מהצורה <span class="math">\(\left(q_{f}w\#,\#\right)\)</span> כאשר <span class="math">\(w\)</span> הוא המשך של קונפיגורציה עד ה-<span class="math">\(\#\)</span> שבסוף שלה, וזאת לכל <span class="math">\(w\)</span> אפשרית? תיאורטית, זה בדיוק מה שהיינו רוצים לעשות. מעשית, זה בלתי אפשרי כי יש <strong>אינסוף</strong> ערכים אפשריים של <span class="math">\(w\)</span>, אבל בעיית PCP תמיד מורכבת ממספר <strong>סופי</strong> של זוגות. אז יש לנו כאן מגבלה טכנית קלה, ולכן יהיה לה פתרון טכני קל. במקום "לאכול" את כל הקונפיגורציה בבת אחת, נאכל אותה תו תו.</p>
<p>מה זה אומר? זה אומר שנתחיל עם הזוג <span class="math">\(\left(q_{f}a,q_{f}\right)\)</span>, ואחרי שנשתמש בו נגיע לסיטואציה הבאה:</p>
<p><span class="math">\(\begin{array}{ccccccccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}b &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}a\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}\flat &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}a &amp; b\#q_{f}\end{array}\)</span></p>
<p>עכשיו נעתיק את שארית הקונפיגורציה עד לפעם הבאה שבה המילה שלמעלה תצטרך לכתוב <span class="math">\(q_{f}\)</span>, ונגיע לדבר הבא:</p>
<p><span class="math">\(\begin{array}{cccccccccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}b &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}a &amp; b\#\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}\flat &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}a &amp; b\# &amp; q_{f}b\#\end{array}\)</span></p>
<p>מה קרה פה? אם נקרא רק את המילה למטה, זה נראה כאילו עברנו מהקונפיגורציה <span class="math">\(q_{f}ab\)</span> לקונפיגורציה <span class="math">\(q_{f}b\)</span> - כאילו ה-<span class="math">\(a\)</span> "נאכל" על ידי <span class="math">\(q_{f}\)</span>. זה בדיוק מה שהולך לקרות - <span class="math">\(q_{f}\)</span> הרעבתן הולך לבלוס את כל המילה שנמצאת מימינו בקונפיגורציה, אות אחרי אות. ומתי נוכל לסיים? כשיגיע הזמן לבלוס את ה-<span class="math">\(\#\)</span> שבסוף. כלומר, כשנגיע למצב הבא:</p>
<p><span class="math">\(\begin{array}{cccccccccccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}b &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}a &amp; b\# &amp; q_{f}b &amp; \#\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}\flat &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}a &amp; b\# &amp; q_{f}b &amp; \# &amp; q_{f}\#\end{array}\)</span></p>
<p>את זה אפשר לסיים על ידי הזוג <span class="math">\(\left(q_{f}\#\#,\#\right)\)</span>, מה שיביא אותנו אל</p>
<p><span class="math">\(\begin{array}{cccccccccccccc}\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}b &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}a &amp; b\# &amp; q_{f}b &amp; \# &amp; q_{f}\#\#\\\# &amp; q_{0}\flat &amp; \# &amp; a &amp; q_{1}\# &amp; aq_{2}\flat &amp; \# &amp; q_{3}a &amp; b\# &amp; q_{f}a &amp; b\# &amp; q_{f}b &amp; \# &amp; q_{f}\#\#\end{array}\)</span></p>
<p>וסיימנו!</p>
<p>יש עוד נקודה עדינה שצריך להתייחס אליה - <span class="math">\(q_{f}\)</span> יצטרך לאכול גם סימנים שמשמאלו בקונפיגורציה אם יש כאלו. כדי לראות את זה, בואו נתחיל דוגמה חדשה:</p>
<p><span class="math">\(\begin{array}{cc}\#q_{0}\flat\#\\\#q_{0}\flat\# &amp; aq_{f}\#\end{array}\)</span></p>
<p>מה עכשיו? כדי להשוות את ה-<span class="math">\(a\)</span> שיש למטה, חייבים להשתמש בזוג <span class="math">\(\left(a,a\right)\)</span>, ואז נגיע לסיטואציה הבאה:</p>
<p><span class="math">\(\begin{array}{ccc}\#q_{0}\flat\# &amp; a\\\#q_{0}\flat\# &amp; a &amp; q_{f}\#a\end{array}\)</span></p>
<p>אבל עכשיו אם נשתמש בזוג <span class="math">\(\left(q_{f}\#\#,\#\right)\)</span>, מה שנגיע אליו יהיה</p>
<p><span class="math">\(\begin{array}{cccc}\#q_{0}\flat\# &amp; a &amp; q_{f}\#\#\\\#q_{0}\flat\# &amp; a &amp; q_{f}\#a &amp; \#\end{array}\)</span></p>
<p>ויש לנו כאן בבירור אי התאמה. לכן אין מנוס - נצטרך "לאכול" את ה-<span class="math">\(a\)</span> עם זוג מהצורה <span class="math">\(\left(aq_{f},q_{f}\right)\)</span>. יחד איתנו נגיע ישירות מהמצב הבא:</p>
<p><span class="math">\(\begin{array}{cc}\#q_{0}\flat\#\\\#q_{0}\flat\# &amp; aq_{f}\#\end{array}\)</span></p>
<p>אל המצב הזה:</p>
<p><span class="math">\(\begin{array}{ccc}\#q_{0}\flat\# &amp; aq_{f}\\\#q_{0}\flat\# &amp; aq_{f} &amp; \#q_{f}\end{array}\)</span></p>
<p>ומכאן נגיע אל</p>
<p><span class="math">\(\begin{array}{cccc}\#q_{0}\flat\# &amp; aq_{f} &amp; \#\\\#q_{0}\flat\# &amp; aq_{f} &amp; \# &amp; q_{f}\#\end{array}\)</span></p>
<p>ומפה כבר נסתדר. ועכשיו זה באמת מסיים את כל הפינות האפלות של הבניה (תוך שימוש מובלע בהנחות שציינתי קודם, למשל שהמכונה אף פעם לא מנסה לפנות שמאלה כשהיא בקצה השמאלי של הסרט).</p>
<p>כל זה היה הסבר אינטואיטיבי, אבל לדעתי זה העיקר כאן. אחרי שהבנו אותו, כל מה שנשאר הוא ההגדרה היבשה. בהינתן מ"ט <span class="math">\(M\)</span>, אנחנו בונים ממנה בעיית PCP עם זוג התחלתי באופן הבא:</p>
<ul>
    <li>הזוג ההתחלתי יהיה <span class="math">\(\left(\#,\#q_{0}\flat\#\right)\)</span>.</li>
    <li>לכל <span class="math">\(a\in\Sigma\)</span> יהיה לנו הזוג <span class="math">\(\left(a,a\right)\)</span></li>
    <li>יהיו לנו הזוגות <span class="math">\(\left(\#,\#\right)\)</span> ו-<span class="math">\(\left(\#,\flat\#\right)\)</span>.</li>
    <li>לכל מעבר <span class="math">\(\delta\left(q,\sigma\right)=\left(p,\tau,R\right)\)</span> יהיה לנו הזוג <span class="math">\(\left(q\sigma,\tau p\right)\)</span>.</li>
    <li>לכל מעבר <span class="math">\(\delta\left(q,\sigma\right)=\left(p,\tau,S\right)\)</span> יהיה לנו הזוג <span class="math">\(\left(q\sigma,p\tau\right)\)</span>.</li>
    <li>לכל מעבר <span class="math">\(\delta\left(q,\sigma\right)=\left(p,\tau,L\right)\)</span> ולכל <span class="math">\(a\in\Sigma\)</span> יהיה לנו הזוג <span class="math">\(\left(aq\sigma,pa\tau\right)\)</span>.</li>
    <li>לכל <span class="math">\(a\in\Sigma\)</span> יהיו לנו הזוגות <span class="math">\(\left(q_{f}a,q_{f}\right)\)</span> ו-<span class="math">\(\left(aq_{f},q_{f}\right)\)</span>.</li>
    <li>יהיה לנו הזוג <span class="math">\(\left(q_{f}\#\#,\#\right)\)</span>.</li>
</ul>
<p>וזו הבניה כולה! קלה, אחרי שמבינים את הרעיון. האם הצלחתי להסביר את הרעיון?</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>