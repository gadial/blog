<!DOCTYPE html>
<html lang="he" dir="rtl"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>חישוב קוונטי - האלגוריתם של שור | לא מדויק</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="חישוב קוונטי - האלגוריתם של שור" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
<meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
<link rel="canonical" href="http://gadial.net/2014/08/24/shor_algorithm/" />
<meta property="og:url" content="http://gadial.net/2014/08/24/shor_algorithm/" />
<meta property="og:site_name" content="לא מדויק" />
<meta property="og:image" content="http://gadial.net/assets/img/main/default-card.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-08-24T21:11:14+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="http://gadial.net/assets/img/main/default-card.png" />
<meta property="twitter:title" content="חישוב קוונטי - האלגוריתם של שור" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
{"url":"http://gadial.net/2014/08/24/shor_algorithm/","@type":"BlogPosting","description":"לא מדויק - בלוג על מתמטיקה ומדעי המחשב","headline":"חישוב קוונטי - האלגוריתם של שור","dateModified":"2014-08-24T21:11:14+00:00","datePublished":"2014-08-24T21:11:14+00:00","image":"http://gadial.net/assets/img/main/default-card.png","mainEntityOfPage":{"@type":"WebPage","@id":"http://gadial.net/2014/08/24/shor_algorithm/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/favicon.ico" type="image/x-icon"><link type="application/atom+xml" rel="alternate" href="http://gadial.net/feed.xml" title="לא מדויק" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-3924539-2', 'auto');
  ga('send', 'pageview');
}
</script>
  
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        processEscapes: true
      },
      TeX: {extensions: ["AMSmath.js","AMSsymbols.js"]},
      "HTML-CSS": { 
        linebreaks: { automatic: true }
      },
      SVG: { 
        linebreaks: { automatic: true } 
      }
    });
  </script>
  <!-- "https://www.gadial.net/wp-includes/js/xypic.js" -->

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

</head>
<body><header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <a class="navbar-brand" href="/">לא מדויק</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarCollapse">
      <ul class="navbar-nav mr-auto">
        
            
            <li class="nav-item">
                <a class="nav-link" href="/">דף הבית</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/post_list">רשימת הפוסטים</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/categories">קטגוריות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/random">פוסטים אקראיים</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/lecture_notes">סיכומי הרצאות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">אודות</a>
            </li>
            
        
      </ul>
      <form class="form-inline mt-2 mt-md-0" action="/post_list/" method="get">
        <input class="form-control mr-sm-2" type="text" placeholder="חיפוש" aria-label="חיפוש" name="s">
        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">חיפוש</button>
      </form>
    </div>
  </nav>
</header><main class="page-content" aria-label="Content" role="main">
      <div class="wrapper text-right">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><div class="PageNavigation">
    
      <a class="prev" href="/2014/08/20/simon_algorithm/">&laquo; חישוב קוונטי - האלגוריתם של סימון</a>
    
    
      <a class="next" href="/2014/09/22/quantum_computing_final/">חישוב קוונטי - דברי סיום ופרידה &raquo;</a>
    
  </div><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">חישוב קוונטי - האלגוריתם של שור</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-08-24T21:11:14+00:00" itemprop="datePublished">Aug 24, 2014
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1>פרולוג, ובו סקירה מהירה של השור הנורא</h1>
<p>לפני שלוש וחצי שנים בערך, כשגילו של הבלוג היה חצי מגילו כיום, התחלתי סדרת פוסטים שכיניתי “<a href="http://www.gadial.net/2011/01/09/surprising_results_in_complexity_prologue/">פרוייקט תוצאות מפתיעות בסיבוכיות</a>”. המטרה שלי הייתה לקחת ארבע תוצאות ידועות בתורת הסיבוכיות שהופיעו במצגת של סקוט אהרונסון בתור דוגמה לתוצאות <strong>מפתיעות</strong>, ולהסביר אותן במלואן פחות או יותר, כולל הפרטים הטכניים. עבור שלוש מהתוצאות הללו (משפט אימרמן; משפט ברינגטון; ההוכחה ש-IP=PSPACE של שמיר) הצלחתי לעמוד ביעד די מהר. עבור האלגוריתם של שור הבנתי די מהר שאין לי יכולת לכתוב עליו מבלי לכתוב סדרת פוסטים על חישוב קוונטי. ומבלי שאכתוב קודם על התמרת פורייה. ובשביל פוסטים על חישוב קוונטי הייתי צריך פוסטים על מרחבי הילברט. ובשביל זה הייתי צריך פוסטים על אלגברה לינארית…. הבנתם את הרעיון. עברו שלוש וחצי שנים, והרגשתי שכבר כתבתי מספיק רקע. לא הייתי מרוצה מכל מה שכתבתי (למשל, הפוסטים על פורייה מייצגים את מיטב המאמץ שאני מסוגל לו כרגע, אבל לדעתי הם לא טובים), אבל הרגשתי מוכן להתחיל את סדרת הפוסטים על חישוב קוונטי. ועכשיו, סוף כל סוף, הגענו אל הפוסט המובטח על האלגוריתם של שור. זו סגירת מעגל שאני מאוד מרוצה מכך שהגעתי אליה; אני רק מקווה שהפוסט עצמו יצדיק את ההמתנה (האלגוריתם עצמו ודאי מצדיק אותה).</p>

<p>הכוכבת של הפוסט היא בעיית <strong>הפירוק לגורמים</strong> של מספרים טבעיים: נתון מספר טבעי <span>\( N \)</span>, ואנחנו רוצים למצוא מספרים ראשוניים <span>\( p_{1},p_{2},\dots,p_{k} \)</span> כך ש-<span>\( N=p_{1}p_{2}\cdots p_{k} \)</span>. הסיבה התיאורטית לכך שאנחנו רוצים למצוא משהו כזה היא שיש כל מני דברים שיותר קל לעשות על מספרים כשאנחנו יודעים את הפירוק לגורמים שלהם; הסיבה הפרקטית היא שיש שיטות הצפנה שמסתמכות על כך שבהינתן <span>\( N \)</span>, אנחנו דווקא <strong>לא</strong> יודעים מה הפירוק לגורמים של <span>\( N \)</span>, כי מי שכן יודע יכול לפצח את ההצפנה. במילים אחרות, יש הסתמכות על כך שבעיית הפירוק לגורמים היא בעיה <strong>קשה</strong> מבחינה חישובית.</p>

<p>פירוק לגורמים היא בעיה עם היסטוריה מפוארת שמתמטיקאים דגולים מכל הדורות התעסקו איתה. היסטוריה כזו היא עניין לפוסט נפרד; אבל אני מקווה שדי ברור שלא מדובר על בעיה זניחה אלא על בעיה מעניינת ומרכזית במתמטיקה. קיימים אלגוריתמים מאוד מאוד מתוחכמים שפותרים אותה בימינו, אבל הם <strong>לא יעילים</strong> מבחינה חישובית. הם אמנם מצליחים לפרק לגורמים מספרים גדולים מאוד, אבל זה עדיין לא מספיק כדי לרסק שיטת הצפנה כמו RSA. בשל כך, כאשר פיטר שור הציג בשנת 1994 אלגוריתם פירוק לגורמים <strong>קוונטי</strong>, זו הייתה סנסציה: אחת מהבעיות החישוביות המפורסמות ביותר נפתרת על ידי מודל חישוב לא קלאסי! על פניו, זה מצביע על כך שהמודל הקוונטי חזק בצורה מהותית יותר מהמודל הקלאסי. עם זאת, חשוב לי לציין שפירוק לגורמים <strong>אינה</strong> מה שנקרא בעיה NP-שלמה (או ליתר דיוק - אם היא כזו, אנחנו לא יודעים איך להוכיח את זה). זה אומר שחישוב קוונטי לאו דווקא פותר כל בעיה ב-NP. זה כן אומר שחישוב קוונטי פותר את מה שהיא כנראה הבעיה החישובית המפורסמת ביותר שאיננו יודעים על שייכות שלה ל-P (או ליתר דיוק, ל-BPP - לחישוב יעיל הסתברותי).</p>

<p>אז איך האלגוריתם של שור עובד?</p>

<p>אם חשבתם (או שמעתם ממישהו) שהוא מקבל קלט <span>\( N \)</span>, עובד עובד עובד ואז מבצע מדידה ומוציא את רשימת הגורמים של <span>\( N \)</span> - תשכחו מזה. באופן שאולי קצת מפתיע אנשים שלא בקיאים בפרטים, האלגוריתם של שור בכלל לא מתעסק עם פירוק לגורמים של <span>\( N \)</span>. הוא מתעסק עם שאלה אחרת: בהינתן מספר <span>\( a \)</span>, מה ה<strong>סדר</strong> של <span>\( a \)</span> מודולו <span>\( N \)</span>, כלומר מהו <span>\( 0&lt;r \)</span> המינימלי המקיים <span>\( a^{r}\equiv_{N}1 \)</span> (הסימון <span>\( \equiv_{N} \)</span> הוא הדרך שלי לסמן שקילות מודולו <span>\( N \)</span>, מה שלרוב מסומן כ-<span>\( a^{r}\equiv1\left(\mbox{mod }N\right) \)</span>; אני מוצא שהסימון שלי חוסך לי כתיבה מיותרת). כבר לפני זמנו של שור ידעו שפתרון לבעיה הזו גורר פתרון לבעיית הפירוק לגורמים - זו תוצאה “קלאסית” בתורת המספרים שהיא הדבר הראשון שאציג (מי שלא מתעניין ברדוקציה הזו יכול לדלג מעליה ולהגיע לחלקים הקוונטיים).</p>

<p>הרעיון הבסיסי של שור הוא זה: בואו נגדיר פונקציה <span>\( f \)</span> באופן הבא: <span>\( f\left(x\right)=a^{x}\left(\mbox{mod }N\right) \)</span>. אם מתקיים <span>\( f\left(x\right)=f\left(y\right) \)</span>, זה אומר ש-<span>\( a^{x}\equiv_{N}a^{y} \)</span>, כלומר <span>\( a^{x-y}\equiv_{N}1 \)</span>, ולא קשה לראות שזה אומר ש-<span>\( r \)</span> מחלק את <span>\( x-y \)</span>, כלומר <span>\( x=y+ir \)</span> עבור <span>\( i \)</span> שלם כלשהו. גם ההפך כמובן נכון: <span>\( f\left(x+ir\right)=f\left(x\right) \)</span> לכל <span>\( i \)</span> שלם. קיבלנו ש-<span>\( f \)</span> היא פונקציה <strong>מחזורית</strong> עם מחזור <span>\( r \)</span>. המטרה של שור היא לגלות את המחזור הזה.</p>

<p>עכשיו, בפוסט הקודם ראינו אלגוריתם ששור שאב ממנו השראה - האלגוריתם של סימון, שפותר את בעיית מציאת המחזור עבור פונקציה פשוטה יחסית (והגדרה טיפה שונה של “מחזור” מזו שכאן). הרעיון של שור יהיה דומה לזה של סימון: המחזור <span>\( r \)</span> במובן מסויים “מרוח בכל המרחב” (כי לכל <span>\( x \)</span> שנגריל באקראי, ה-<span>\( x+ir \)</span>-ים יחזירו אותו ערך כמוהו כשנפעיל את <span>\( f \)</span> עליהם). אם כן, בעזרת הוקוס-פוקוס קוונטי אפשר לשלוף מהמרחב מידע על <span>\( r \)</span> שיאפשר לנו בסופו של דבר למצוא אותו.</p>

<p>אלא שכאן ההוקוס-פוקוס הקוונטי יהיה יותר מסובך, כי הפונקציה <span>\( f \)</span> יותר מסובכת. התעלול המרכזי של שור הוא שימוש בכלי חזק מאוד לניתוח פונקציות, בפרט כאלו מחזוריות: <strong>התמרת פורייה</strong> של <span>\( f \)</span>. אלא שכאן הוא נזקק להתמרת פורייה <strong>קוונטית</strong>, דהיינו לאלגוריתם קוונטי כלשהו שמסוגל לחשב את מקדמי הפורייה של <span>\( f \)</span> ולהפוך אותם לחלק מהמצב הקוונטי שלו. לשם כך שור מגייס וריאציה על האלגוריתם ל<strong>התמרת פורייה מהירה</strong> (העובדה שניתן לממש גרסה קוונטית של התמרת פורייה מהירה היא קסם לא טריוויאלי בפני עצמה). ההתמרה הזו מגדילה את ההסתברות למדידה של תוצאה בעלת ערך בסיום - כזו שאומרת לנו משהו על <span>\( r \)</span> - אבל “אומרת לנו משהו” זה מושג חמקמק בפני עצמו. אין דרך נעימה לומר את זה, אז אתאר במפורש: אנחנו הולכים לקחת את התוצאה שקיבלנו, לחלק אותה במספר גדול מסויים, לקבל מספר רציונלי, לבנות סדרת קירובים אליו ולחפש את <span>\( r \)</span> בתוך סדרת הקירובים הזו. כן, זה נשמע מאוד מוזר. כן, זה בוודאי לא מה שאנשים מצפים לעצמם כשהם שומעים על אלגוריתם קוונטי וחושבים עליו בתור סופר-דופר-חישוב מקבילי. זה <strong>בדיוק</strong> מה שכל כך נחמד פה.</p>

<p>אם כן, מפת הדרכים שלנו היא כזו - ראשית כל אדבר על תורת המספרים הקלאסית ואסביר איך מציאת סדר גוררת פירוק לגורמים. אחר כך אדבר על התמרת פורייה קוונטית, אחר כך על הקירובים הרציונליים, ולבסוף אחבר את כל הדברים הללו לאלגוריתם הסופי של שור. זה יהיה פוסט קצת יותר ארוך מכרגיל, אבל אני מקווה שהחלוקה לחלקים תקל עלינו.</p>

<p><strong>פרק ראשון, ובו יסופר על מציאת סדרים ופירוק לגורמים</strong></p>

<p>אז יש לנו <span>\( N \)</span> ואנחנו רוצים לפרק אותו לגורמים. האבחנה הראשונה היא שמספיק לנו למצוא מספר כלשהו <span>\( 1&lt;a&lt;N \)</span> שמחלק את <span>\( N \)</span>. אם אנחנו יודעים לעשות את זה לכל <span>\( N \)</span> בזמן יעיל, פתרנו את בעיית הפירוק לגורמים. למה? כי עכשיו כל מה שנשאר לעשות הוא לפרק את <span>\( a \)</span> לגורמים ואת <span>\( \frac{N}{a} \)</span> לגורמים (או, במקרה שהם ראשוניים, לזהות את זה; אבל בדיקת ראשוניות היא עניין קל). מכיוון של-<span>\( N \)</span> יש לכל היותר <span>\( \lg N \)</span> גורמים ראשוניים, מספר ההפעלות הכולל של אלגוריתם-מציאת-המחלק שיידרש מאיתנו הוא נמוך.</p>

<p>האבחנה הבאה היא שכדי למצוא מחלק של <span>\( N \)</span>, אין צורך לנחש מחלק שכזה במפורש; מספיק למצוא מספר <span>\( a \)</span> ש<strong>אינו זר</strong> ל-<span>\( N \)</span>, כלומר שיש לו ול-<span>\( N \)</span> מחלק משותף גדול מ-1. מספרים כאלו הם משמעותית יותר נפוצים מאשר מחלקים של <span>\( N \)</span>. אם מצאנו <span>\( a \)</span> כזה, אז מפעילים את <a href="http://www.gadial.net/2011/09/12/euclidean_algorithm_and_rings/">האלגוריתם למציאת מחלק משותף מקסימלי</a> על <span>\( a,N \)</span> ומקבלים מחלק של <span>\( N \)</span>.</p>

<p>כעת, הימור בטוח על <span>\( a \)</span> כזה שהוא לא זר ל-<span>\( N \)</span> יכול להתקבל אם הצלחנו למצוא <strong>שורש לא טריוויאלי </strong>של 1 מודולו <span>\( N \)</span>. שורש “טריוויאלי” הוא <span>\( 1 \)</span> או <span>\( -1 \)</span>, כשחושבים עליהם בתור איברים ב-<span>\( \mathbb{Z}_{N} \)</span> - בבירור כשמעלים אותם בריבוע מקבלים 1, וגם אם <span>\( N \)</span> ראשוני הם עדיין היו שורשים של 1. אבל כש-<span>\( N \)</span> אינו ראשוני יש יותר שורשים של 1 מאשר שני אלו. נניח ש-<span>\( Y \)</span> הוא שורש כזה, כלומר <span>\( Y^{2}\equiv_{N}1 \)</span> אבל <span>\( Y\not\equiv_{N}1,-1 \)</span>, כלומר אפשר לבחור <span>\( 1&lt;Y&lt;N-1 \)</span>. מה זה אומר? ש-<span>\( N|Y^{2}-1=\left(Y-1\right)\left(Y+1\right) \)</span>. עכשיו, קחו גורם ראשוני <span>\( p|N \)</span> כלשהו, אז <span>\( p|\left(Y-1\right)\left(Y+1\right) \)</span>. תכונה מהותית של ראשוניים היא שאם הם מחלקים מכפלה, אז הם מחלקים את אחד המוכפלים, כלומר <span>\( p|Y-1 \)</span> או <span>\( p|Y+1 \)</span>. אני רוצה לטעון שקיים לפחות ראשוני אחד כך ש-<span>\( p|Y-1 \)</span>, אחרת היינו מקבלים ש-<span>\( N|Y+1 \)</span>, בסתירה לכך ש-<span>\( 1&lt;Y&lt;N-1 \)</span>.</p>

<p>מסקנה מכל זה: אם <span>\( Y \)</span> הוא שורש לא טריוויאלי של 1, אז <span>\( Y-1 \)</span> לא זר ל-<span>\( N \)</span>. לכן כדי לפרק את <span>\( N \)</span> לגורמים, מספיק לנו לדעת למצוא שורש לא טריוויאלי של 1 מודולו <span>\( N \)</span>.</p>

<p>איך מציאת סדר קשורה לכל זה?</p>

<p>ובכן, קחו <span>\( 1&lt;A&lt;N-1 \)</span> אקראי כלשהו. אם נמצא <span>\( r \)</span> כלשהו כך ש-<span>\( A^{r}\equiv_{N}1 \)</span>, <strong>וגם</strong> <span>\( r \)</span> זוגי, <strong>וגם </strong><span>\( A^{\frac{r}{2}}\not\equiv_{N}1,-1 \)</span> אז שיחקנו אותה: <span>\( Y=A^{\frac{r}{2}} \)</span> הוא השורש הלא טריוויאלי שאנחנו מחפשים. תכף אני הולך לשכנע אתכם שיש הרבה <span>\( A \)</span>-ים שמקיימים את התכונה הזו, אז מספיק לנו לבחור <span>\( A \)</span> אקראי ואז למצוא <span>\( r \)</span> כך ש-<span>\( A^{r}\equiv_{N}1 \)</span>. אין הכרח ש-<span>\( r \)</span> יהיה הסדר של <span>\( A \)</span>, אבל מה שקל לנו למצוא עם השיטה של שור הוא את הסדר, כי הפונקציה <span>\( f \)</span> שהגדרנו קודם תהיה בעלת מחזור שהוא בדיוק הסדר.</p>

<p>אז רק נשאר לנו להשתכנע שיש הרבה <span>\( A \)</span>-ים מתאימים ונוכל לסיים את החלק הקלאסי של הפוסט ולעבור לקוונטים. בשביל מה שיקרה בהמשך אני אניח שאתם מכירים קצת תורת מספרים בסיסית בפרט, אתם מכירים את <a href="http://www.gadial.net/2012/09/12/chinese_remainder_theorem/">משפט השאריות הסיני</a>. כדי להבין את העיקרון, בואו נתחיל מהמקרה שבו <span>\( N=pq \)</span> עם <span>\( p,q \)</span> ראשוניים אי זוגיים. אנחנו מגרילים <span>\( A\in\mathbb{Z}_{N}^{*} \)</span> ורוצים להבין אותו (למה אני יכול להניח שהוא ב-<span>\( \mathbb{Z}_{N}^{*} \)</span>, כלומר זר ל-<span>\( N \)</span>? כי אפשר לבדוק את זה בקלות, ואם זה לא קורה - ניצחנו ומצאנו גורם של <span>\( N \)</span>). עכשיו, ממשפט השאריות הסיני אנחנו יודעים ש- <span>\( \mathbb{Z}_{N}^{*}\cong\mathbb{Z}_{p}^{*}\times\mathbb{Z}_{q}^{*} \)</span> ולכן מספיק לדבר על זוגות <span>\( \left(Y,Z\right)\in\mathbb{Z}_{p}^{*}\times\mathbb{Z}_{q}^{*} \)</span>. הניתוח עבורם יהיה קל יותר מכיוון ש-<span>\( \mathbb{Z}_{p},\mathbb{Z}_{q} \)</span> הם שדות. להגריל <span>\( A\in\mathbb{Z}_{N}^{*} \)</span> באקראי זה אותו הדבר כמו להגריל את הזוג <span>\( \left(Y,Z\right) \)</span> שמותאם לו על ידי האיזומורפיזם.</p>

<p>אם <span>\( r_{Y},r_{Z} \)</span> הם הסדרים של <span>\( Y,Z \)</span> מה יהיה <span>\( r \)</span>, הסדר של ה-<span>\( A \)</span> שמתאים להם? מכיוון שאם <span>\( A^{s}=1 \)</span> עבור <span>\( s&gt;0 \)</span> כלשהו אז <span>\( r \)</span> מחלק את <span>\( s \)</span>, ומכיוון שכל כפולה משותפת של <span>\( r_{Y},r_{Z} \)</span> היא <span>\( s \)</span> שכזה, אז ברור ש-<span>\( r \)</span> מחלק את כל הכפולות המשותפות של <span>\( r_{Y},r_{Z} \)</span>. מצד שני, גם ברור ש-<span>\( r_{Y}|r \)</span> ו-<span>\( r_{Z}|r \)</span> ולכן הכפולה המשותפת המינימלית שלהם מחלק את <span>\( r \)</span>. המסקנה היא ש-<span>\( r=\mbox{lcm}\left(r_{Y},r_{Z}\right) \)</span>.</p>

<p>עכשיו הטענה המרכזית שלי: כדי שיתקיימו שני הדברים שאני רוצה - ש-<span>\( r \)</span> יהיה זוגי וש-<span>\( A^{\frac{r}{2}} \)</span> יהיה שורש לא טריוויאלי של 1 - מספיק שיתקיים הדבר הבא: שהחזקה הגבוהה ביותר של 2 שמחלקת את <span>\( r_{Y} \)</span> תהיה שונה מזו שמחלקת את <span>\( r_{Z} \)</span>. פורמלית, אפשר לכתוב <span>\( r_{Y}=2^{k}c \)</span> ו-<span>\( r_{Z}=2^{t}d \)</span> כאשר <span>\( c,d \)</span> הם אי זוגיים; אני טוען שמספיק לדרוש <span>\( k\ne t \)</span> כדי שמה שאני רוצה שיקרה, אכן יקרה. ואני גם טוען שזה יקרה בהסתברות <span>\( \frac{3}{4} \)</span> לפחות, אבל את זה נראה עוד מעט.</p>

<p>כדי להבין למה זה קורה, קודם כל שימו לב לכך ש-<span>\( r=2^{\max\left\{ k,t\right\} }\mbox{lcm}\left(c,d\right) \)</span> - זה נובע מהגדרת ה-lcm. כמובן שאם <span>\( k\ne t \)</span> אז <span>\( \max\left\{ k,t\right\} \ge1 \)</span> ולכן <span>\( r \)</span> יהיה זוגי. כמו כן, בואו נניח ש-<span>\( k&lt;t \)</span>; זה אומר ש-<span>\( r=2^{t}\mbox{lcm}\left(c,d\right) \)</span> ולכן <span>\( r_{Y}=2^{k}c|2^{t-1}\mbox{lcm}\left(c,d\right)=\frac{r}{2} \)</span>. מכאן אנו מקבלים ש-<span>\( A^{\frac{r}{2}}\mapsto\left(Y^{\frac{r}{2}},Z^{\frac{r}{2}}\right)=\left(1,Z^{\frac{r}{2}}\right) \)</span> וזה מספיק כדי להוכיח לנו ש-<span>\( A^{\frac{r}{2}}\ne-1 \)</span>, שכן <span>\( -1\mapsto\left(-1,-1\right) \)</span> (וכמובן ש-<span>\( A^{\frac{r}{2}}\ne1 \)</span> כי זה עומד בסתירה לכך ש-<span>\( r \)</span> הוא הסדר של <span>\( A \)</span>).</p>

<p>מה שנשאר לנו הוא לנסות ולהבין מה ההסתברות לכך שעבור איברים שנבחר באקראי מ-<span>\( \mathbb{Z}_{p}^{*} \)</span> ו-<span>\( \mathbb{Z}_{q}^{*} \)</span> נקבל <span>\( k=t \)</span>. לצורך כך די אם נוכיח שקיים איזה שהוא <span>\( k_{0} \)</span> כך שההסתברות שנקבל עבור <span>\( r_{Y}=2^{k}c \)</span> ש-<span>\( k\ge k_{0} \)</span> היא <strong>בדיוק</strong> <span>\( \frac{1}{2} \)</span>. זה אומר שלא משנה מהו <span>\( t \)</span>: אם <span>\( t&lt;k_{0} \)</span> אז ההסתברות שנקבל <span>\( k&lt;k_{0} \)</span> היא <span>\( \frac{1}{2} \)</span> ולכן ההסתברות שנקבל <span>\( k=t \)</span> חסומה על ידי <span>\( \frac{1}{2} \)</span>; ובדומה גם אם <span>\( t\ge k_{0} \)</span>.</p>

<p>כדי להוכיח את הטענה הזו, צריך להבין קצת יותר את המבנה של <span>\( \mathbb{Z}_{p}^{*} \)</span>. לא אוכיח זאת כרגע (זה משפט מעניין ולא טריוויאלי), אבל זו חבורה <strong>ציקלית. </strong>נסמן את היוצר שלה ב-<span>\( g \)</span>, אז <span>\( g \)</span> הוא איבר מסדר <span>\( p-1 \)</span>, ולהגריל איבר ב-<span>\( \mathbb{Z}_{p}^{*} \)</span> זה בעצם להגריל <span>\( 1&lt;d&lt;p-1 \)</span> ולקבל את האיבר <span>\( g^{d} \)</span>.</p>

<p>כעת, בואו נבחר את <span>\( k_{0} \)</span> להיות המעריך של החזקה הגדולה ביותר של 2 שמחלקת את סדר החבורה, כלומר את <span>\( p-1 \)</span> (כלומר <span>\( p-1 \)</span> היא <span>\( 2^{k_{0}} \)</span> כפול משהו אי זוגי). נתבונן באיבר <span>\( g^{d} \)</span>. אני טוען שאם <span>\( d \)</span> אי זוגי, אז הסדר של <span>\( g^{d} \)</span> מתחלק על ידי <span>\( 2^{k_{0}} \)</span>, ואם <span>\( d \)</span> זוגי אז הסדר של <span>\( g^{d} \)</span> אינו מתחלק על ידי <span>\( 2^{k_{0}} \)</span>, מה שמוכיח את הטענה שלנו (כי בין 1 ל-<span>\( p-1 \)</span> יש אותו מספר של זוגיים ואי-זוגיים).</p>

<p>בכל אחד מהמקרים, נסמן ב-<span>\( e \)</span> את הסדר של <span>\( g^{d} \)</span>, כלומר <span>\( \left(g^{d}\right)^{e}=1 \)</span>, או <span>\( g^{de}=1 \)</span>. מכיוון שהסדר של <span>\( g \)</span> הוא <span>\( p-1 \)</span>, נובע מכך ש-<span>\( p-1|de \)</span>, ולכן <span>\( 2^{k_{0}}|de \)</span>. אם <span>\( d \)</span> אי זוגי, אז כל ה-<span>\( 2 \)</span>-ים בביטוי <span>\( de \)</span> מגיעים מ-<span>\( e \)</span> ולכן <span>\( 2^{k_{0}}|e \)</span> - זה היה קל. לטפל במקרה שבו <span>\( d \)</span> זוגי יהיה טיפה יותר קשה.</p>

<p>אם <span>\( d \)</span> זוגי, ננצל את זה שאפשר לחלק אותו ב-2 ונכתוב: <span>\( \left(g^{d}\right)^{\frac{p-1}{2}}=\left(g^{p-1}\right)^{\frac{d}{2}}=1^{\frac{d}{2}}=1 \)</span>. על כן, הסדר של <span>\( g^{d} \)</span> מחלק את <span>\( \frac{p-1}{2} \)</span>, כלומר החזקה הגבוהה ביותר של 2 ב-<span>\( e \)</span> היא לכל היותר <span>\( 2^{k_{0}-1} \)</span>, ומכאן ש-<span>\( e \)</span> לא מתחלק על ידי <span>\( 2^{k_{0}} \)</span>. זה מסיים את ההוכחה.</p>

<p>טיפלנו במקרה של <span>\( N=pq \)</span>, אבל המקרה הכללי לא קשה בהרבה. במקרה הכללי, <span>\( N=\prod_{i=1}^{m}p_{i}^{k_{i}} \)</span> ולכן נקבל ממשפט השאריות הסיני ש-<span>\( \mathbb{Z}_{N}^{*}\cong\prod\mathbb{Z}_{p_{i}^{k_{i}}}^{*} \)</span>. כמקודם, אנחנו מסתכלים על הסדרים של הרכיבים ב-<span>\( \prod\mathbb{Z}_{p_{i}^{k_{i}}}^{*} \)</span> ומספיק לנו שבפירוק של הסדרים הללו לחזקה של 2 ומספר אי זוגי, יהיו שני מספרים עם חזקות שונות של 2. כעת, עבור <span>\( p^{k} \)</span> כלשהו, אנחנו שוב מקבלים ש-<span>\( \mathbb{Z}_{p^{k}}^{*} \)</span> היא ציקלית ולכן הניתוח ההסתברותי הקודם עובד באותה מידה - רק תכתבו <span>\( \varphi\left(p^{k}\right) \)</span> במקום <span>\( p-1 \)</span>. נקבל שהאיברים האקראיים ב-<span>\( \mathbb{Z}_{p^{k}}^{*} \)</span> מתחלקים חצי-חצי מבחינת ההתחלקות של הסדר שלהם בחזקה מסויימת של 2, ומכך נובע שההסתברות שב-<span>\( \prod_{i=1}^{m}\mathbb{Z}_{p_{i}^{k_{i}}}^{*} \)</span> כל הרכיבים שנבחר באקראי יהיו בעלי אותה חזקה של 2 בסדר שלהם היא <span>\( \frac{1}{2^{m}} \)</span>, ולכן ההסתברות שלנו לבחור איבר “מוצלח” היא <span>\( 1-\frac{1}{2^{m}} \)</span>.</p>

<p>זה מסיים את הניתוח ההסתברותי, ומסיים את הרדוקציה, ומסיים את החלק ה”קלאסי” של הפוסט. עכשיו אפשר לעבור לאתגר האמיתי - איך מוצאים את הסדר של איבר <span>\( A \)</span> כלשהו מודולו <span>\( N \)</span>?</p>

<p><strong>פרק שני, ובו הקוונטים מתמירים את התמרת פורייה המהירה אפילו עוד יותר מהר</strong></p>

<p>בואו נסכם ונפרמל את מה שעשינו עד כה. נתון לנו מספר טבעי <span>\( N \)</span>. אנחנו מסתכלים על החוג <span>\( \mathbb{Z}_{N} \)</span> ומגרילים בו איבר <span>\( A \)</span>. אם <span>\( A \)</span> לא זר ל-<span>\( N \)</span>, ניצחנו; אלגוריתם אוקלידס יניב לנו גורם משותף של <span>\( N \)</span> ו-<span>\( A \)</span> וסיימנו. אחרת, <span>\( A \)</span> שייך לחבורה הכפלית מודולו <span>\( N \)</span>, <span>\( \mathbb{Z}_{N}^{*} \)</span>. ככזה, יש לו <strong>סדר</strong>, כלומר <span>\( r \)</span> חיובי מינימלי כך ש-<span>\( A^{r}=1 \)</span> (החשבון מתבצע ב-<span>\( \mathbb{Z}_{N} \)</span> ואני כבר לא טורח לכתוב <span>\( \equiv \)</span> וכאלה). מה שראינו עד כה היה שאם אני מגריל <span>\( A \)</span>, אז בהסתברות טובה <span>\( r \)</span> יהיה זוגי ויתקיים ש-<span>\( A^{\frac{r}{2}}\ne1,-1 \)</span>. במקרה הזה, <span>\( A^{\frac{r}{2}}-1 \)</span> יהיה גורם של <span>\( N \)</span>. לדוגמה, אם <span>\( N=15 \)</span> ואני מגריל <span>\( A=7 \)</span>, אז <span>\( r=4 \)</span>, כי החזקות של 7 מודולו 15 הן <span>\( 7,4,13,1 \)</span>. כעת, <span>\( 7^{\frac{4}{2}}=7^{2}=4 \)</span> וזה אכן לא שורש טריוויאלי כי <span>\( 4\ne1,-1 \)</span>; ואכן, <span>\( 4-1 \)</span> הוא גורם של <span>\( N \)</span>. יפה! זה עובד!</p>

<p>האתגר שלנו הפך להיות מציאת הסדר של <span>\( A \)</span>, אבל גם זה לא הדבר האמיתי שאנחנו פותרים: מה שהאלגוריתם של שור פותר הוא מציאת מחזור של פונקציה. במקרה שלנו, הפונקציה <span>\( f:\mathbb{Z}_{N}\to\mathbb{Z}_{N} \)</span> מוגדרת על ידי <span>\( f\left(x\right)=A^{x} \)</span>. בשל התכונות של הסדר של <span>\( A \)</span>, אנחנו מקבלים שלכל <span>\( x\in\mathbb{Z}_{N} \)</span> מתקיים <span>\( f\left(x+r\right)=f\left(x\right) \)</span>.</p>

<p>אז המטרה החדשה שלנו היא זו: בהינתן <span>\( f:\mathbb{Z}_{N}\to\mathbb{Z}_{N} \)</span> שקיים עבורה <span>\( r \)</span> מינימלי כך ש-<span>\( f\left(x+r\right)=f\left(x\right) \)</span> לכל <span>\( x\in\mathbb{Z}_{N} \)</span>, יש למצוא את <span>\( r \)</span>. הרעיון המרכזי כאן הוא שהניתוח של <span>\( f \)</span> יהיה קל משמעותית יותר אם נעבוד לא על <span>\( f \)</span> עצמה אלא על <strong>התמרת פורייה הבדידה </strong>שלה, שאסמן <span>\( \hat{f} \)</span>. את התמרת פורייה הבדידה הצגתי <a href="http://www.gadial.net/2014/05/21/discrete_fourier_transform_intro/">כאן</a>, ומייד אחר כך הראיתי <a href="http://www.gadial.net/2014/05/27/fast_fourier_transform/">אלגוריתם להתמרת פורייה מהירה</a>. ההגדרה שאני הולך לתת כאן תהיה טיפה שונה מזו שנתתי בפוסטים הללו (וגם בהם השתמשתי בעצם בשתי הגדרות טיפה שונות) כי אני בוחר את ההגדרה שיהיה הכי נוח לעבוד איתה; כל ההגדרות הן פחות או יותר אותו הדבר כך שזה לא משנה.</p>

<p>התמרת פורייה הבדידה של פונקציה <span>\(  f:\mathbb{Z}_{N}\to\mathbb{Z}_{N} \)</span>, שאסמן <span>\( \hat{f} \)</span> מתוארת על ידי זוג משוואות: משוואת אנליזה ומשוואת סינתזה. משוואת האנליזה אומרת לנו איך מוצאים את <span>\( \hat{f} \)</span> מתוך <span>\( f \)</span>; משוואת הסינתזה אומרת לנו איך לשחזר את <span>\( f \)</span> מתוך <span>\( \hat{f} \)</span>. האינטואיציה היא ש-<span>\( \hat{f} \)</span> מתארת הצגה של <span>\( f \)</span> בתור <strong>צירוף לינארי של שורשי יחידה</strong>. אני משתמש בסימון <span>\( \omega_{N}=e^{\frac{2\pi i}{N}} \)</span> כדי לתאר שורש יחידה פרימיטיבי מסדר <span>\( N \)</span>. הפעם נצטרך רק את משוואת האנליזה:</p>

<p><strong>משוואת האנליזה:</strong> <span>\( \hat{f}\left(k\right)=\sum_{t=0}^{N-1}f\left(t\right)\omega_{N}^{kt} \)</span></p>

<p>(בספרים בדרך כלל המשוואה הזו מוכפל ב-<span>\( \sqrt{N} \)</span> מסיבות טכניות; לא אציג את השלב הטכני שדורש אותו בהמשך ולכן לצורכי קריאות לא אכפול ב-<span>\( \sqrt{N} \)</span> בכלל).</p>

<p>עכשיו הקוונטים נכנסים לעניין. מה שאנחנו רוצים לעשות הוא לחשב <strong>התמרת פורייה קוונטית</strong> של <span>\( f \)</span>. פורמלית זה אומר את הדבר הבא: אנחנו רוצים להתחיל מהמצב הקוונטי</p>

<p><span>\( \sum_{x\in\mathbb{Z}_{N}}f\left(x\right)\left|x\right\rangle  \)</span></p>

<p>לבצע חישוב קוונטי, ולהגיע אל המצב הקוונטי</p>

<p><span>\( \sum_{x\in\mathbb{Z}_{N}}\hat{f}\left(x\right)\left|x\right\rangle  \)</span></p>

<p>הדרך שבה אפשר לבצע את החישוב הזה ביעילות משתמשת באותו רעיון שבו מחשבים התמרת פורייה בדידה קלאסית ביעילות - גישת ההפרד-ומשול של <strong>התמרת פורייה המהירה</strong>. בהתמרת פורייה מהירה אנחנו ראשית מניחים ש-<span>\( N \)</span> הוא חזקה של 2, כלומר ניתן לחלק אותו שוב ושוב ב-2 עד שגודלו יהיה 1 (זה <strong>לא</strong> המצב אצלנו אבל עוד מעט אסביר למה זו לא בעיה). אנחנו מנצלים את התכונה הבאה של שורשי היחידה: <span>\( \left(\omega_{N}^{k}\right)^{2}=\omega_{N/2}^{k} \)</span> על מנת להפוך את החישוב של מקדם פורייה <span>\( \hat{f}\left(k\right) \)</span> לחישוב של שתי התמרות על מרחב מגודל <span>\( \frac{N}{2} \)</span>. אחרי כן מאחדים את המידע משתי ההתמרות הללו חזרה לקבלת ההתמרה המקורית; החסכון המרכזי נובע מכך שכל מקדם שמופיע בתת-התמרות משמש אותנו <strong>פעמיים</strong>.</p>

<p>לא אחזור על הפרטים של הפוסט שהיה לי על התמרת פורייה המהירה אלא אציג את השורה התחתונה. אנחנו חושבים על <span>\( f \)</span> בתור <strong>וקטור</strong> מגודל <span>\( N \)</span> של מספרים מרוכבים; נסמן ב-<span>\( \mbox{FT}_{N}\left(f\right) \)</span> את הוקטור של <span>\( \hat{f} \)</span>. אם <span>\( v \)</span> הוא וקטור מאורך זוגי, נסמן ב-<span>\( v_{low} \)</span> את החצי הראשון שלו וב-<span>\( v_{high} \)</span> את החצי השני, ה-<span>\( v_{even} \)</span> את הוקטור שמתקבל מלקיחת הכניסות במקומות הזוגיים (המקום הראשון הוא 0 ולכן נחשב זוגי) וב-<span>\( v_{odd} \)</span> את הוקטור שמתקבל מלקיחת הכניסות במקומות האי-זוגיים. לסיום, נסמן ב-<span>\( W \)</span> את האופרטור שמתואר על ידי מטריצה אלכסונית שהאלכסון שלה כולל את הכניסות <span>\( \omega^{0},\omega^{1},\dots\omega^{\frac{N}{2}-1} \)</span> (כלומר, האופרטור כופל את הכניסה הראשונה בוקטור ב-<span>\( \omega^{0} \)</span>, את השניה ב-<span>\( \omega^{1} \)</span> וכן הלאה). כעת קיבלנו את המשוואות הבאות:</p>

<p><span>\( \mbox{FT}_{N}\left(f\right)_{low}=\mbox{FT}_{N/2}\left(f_{even}\right)+W\cdot\mbox{FT}_{N/2}\left(f_{odd}\right) \)</span></p>

<p><span>\( \mbox{FT}_{N}\left(f\right)_{high}=\mbox{FT}_{N/2}\left(f_{even}\right)-W\cdot\mbox{FT}_{N/2}\left(f_{odd}\right) \)</span></p>

<p>שתי המשוואות הללו מלמדות על האלגוריתם שלנו: מחשבים את <span>\( \mbox{FT}_{N/2}\left(f_{even}\right) \)</span> ואת <span>\( \mbox{FT}_{N/2}\left(f_{odd}\right) \)</span> ואז משתמשים בהם פעמיים כדי לחשב את <span>\( \mbox{FT}_{N}\left(f\right) \)</span>. זו לא בדיוק הצורה שבה הצגתי את ההתמרה המהירה בפוסט הרלוונטי; מן הסתם אני בוחר בדרך ההצגה הזו כי היא תהיה יותר קלה עבורנו בחישוב הקוונטי. מה שמוביל אותנו לשאלה: איך עושים את זה במסגרת חישוב קוונטי?</p>

<p>כזכור, אנחנו מניחים ש-<span>\( N=2^{n} \)</span>. אז הרגיסטר הקוונטי שלנו יהיה בעל <span>\( n \)</span> קיוביטים. את <span>\( f_{low} \)</span> ניתן לתאר בתור החלק של ההתמרה עבור הקיוביטים מהצורה <span>\( \left|0\right\rangle \left|x\right\rangle  \)</span> (כלומר, כאלו ש<strong>מתחילים</strong> ב-0) ואת <span>\( f_{low} \)</span> באמצעות <span>\( \left|1\right\rangle \left|x^{\prime}\right\rangle  \)</span>. בדומה, <span>\( f_{even} \)</span> הוא החלק של <span>\( f \)</span> עם הקיוביטים מהצורה <span>\( \left|x\right\rangle \left|0\right\rangle  \)</span> ו-<span>\( f_{odd} \)</span> החלק עם הקיוביטים מהצורה <span>\( \left|x\right\rangle \left|1\right\rangle  \)</span>. הקלט שלנו הוא <span>\( \sum_{x\in\mathbb{Z}_{N}}f\left(x\right)\left|x\right\rangle  \)</span>. הדבר הראשון שנעשה יהיה להפעיל רקורסיבית את ההתמרה עבור <span>\( \frac{N}{2} \)</span>. זה יניב לנו את המצב הקוונטי הבא:</p>

<p><span>\( \mbox{FT}_{N/2}\left(f_{even}\right)\left|0\right\rangle +\mbox{FT}_{N/2}\left(f_{odd}\right)\left|1\right\rangle  \)</span></p>

<p>השלב הבא הוא כפל של <span>\( \mbox{FT}_{N/2}\left(f_{odd}\right)\left|1\right\rangle  \)</span> ב-<span>\( W \)</span>. המשמעות של זה היא הפעולה הקוונטית הבאה: <span>\( \left|x\right\rangle \left|1\right\rangle \mapsto\omega^{x} \)</span>. איך מבצעים את זה? עוברים ביט-ביט ברגיסטר עד ולא כולל הביט האחרון (ה-<span>\( n \)</span>-י). על הביט ה-<span>\( i \)</span> מפעילים את הפעולה <span>\( \left|0\right\rangle \mapsto\left|0\right\rangle  \)</span> ו-<span>\( \left|1\right\rangle \mapsto\omega^{2^{i}}\left|1\right\rangle  \)</span>, כשהפעולה מותנה בכך שהביט האחרון ברגיסטר יהיה <span>\( \left|1\right\rangle  \)</span>. קצת מחשבה ותראו שזה פועל, בהנחה שאתם לא רואים את זה כרגע.</p>

<p>אם כן, אנחנו מגיעים אל המצב הקוונטי הבא:</p>

<p><span>\( \mbox{FT}_{N/2}\left(f_{even}\right)\left|0\right\rangle +W\cdot\mbox{FT}_{N/2}\left(f_{odd}\right)\left|1\right\rangle  \)</span></p>

<p>האם אתם כבר מנחשים את הצעד הבא? תנו מבט אחד במצב שהגענו אליו, ומבט אחר בשתי המשוואות שמתארות את ההתמרה. רואים?</p>

<p>ובכן, הטריק הוא פשוט, וכבר עשינו אותו בכל מקום בערך - מפעילים את <span>\( H \)</span> על הביט האחרון במצב שהגענו אליו. בחיי, כמה שה-<span>\( H \)</span> הזה שימושי. הסכום שלנו יתפצל לסכום של ארבעה מחוברים:</p>

<p><span>\( \mbox{FT}_{N/2}\left(f_{even}\right)\left|0\right\rangle +W\cdot\mbox{FT}_{N/2}\left(f_{odd}\right)\left|0\right\rangle + \)</span></p>

<p><span>\( \mbox{FT}_{N/2}\left(f_{even}\right)\left|1\right\rangle -W\cdot\mbox{FT}_{N/2}\left(f_{odd}\right)\left|1\right\rangle  \)</span></p>

<p>וזה שווה ל-</p>

<p><span>\( \mbox{FT}_{N}\left(f\right)_{low}\left|0\right\rangle +\mbox{FT}_{N}\left(f\right)\left|1\right\rangle  \)</span></p>

<p>זה עדיין לא בדיוק מה שאנחנו רוצים. הרי <span>\( \mbox{FT}_{N}\left(f\right)_{low} \)</span> היא ההתמרה על כל הקיוביטים שהקיוביט <strong>הראשון</strong>, המשמעותי ביותר שלהם, הוא <span>\( \left|0\right\rangle  \)</span>. כלומר, מה שקיבלנו הוא את <span>\( \sum\hat{f}\left(0x\right)\left|x\right\rangle \left|0\right\rangle  \)</span> במקום את <span>\( \sum\hat{f}\left(0x\right)\left|0x\right\rangle  \)</span>. אבל למרבה המזל, אין לנו בעיה להחליף קיוביטים, ולכן מעבירים את הקיוביט האחרון להיות הראשון ומזיזים את היתר בהתאם. התוצאה היא בדיוק <span>\( \sum_{x\in\mathbb{Z}_{N}}\hat{f}\left(x\right)\left|x\right\rangle  \)</span> המבוקש. מסקנה: אפשר ואפילו לא יותר מדי מסובך לחשב את התמרת פורייה הקוונטית. למעשה, זמן הריצה שלנו הוא מרשים למדי - לוגריתמי ב-<span>\( N \)</span>. זה משהו שבלתי אפשרי לבצע בחישוב קלאסי.</p>

<p>אבל איך זה עוזר לנו?</p>

<p><strong>פרק שלישי, ובו מציאת המחזור לפתרון תעזור</strong></p>

<p>נתחיל מלדבר על הפיל באמצע החדר: כל ענייני התמרת הפורייה שלנו היו עבור <span>\( N \)</span> שהוא חזקה של 2, כלומר <span>\( N=2^{n} \)</span> עבור <span>\( n \)</span> כלשהו. זה לא עניין זניח. בלי זה אין אלגוריתם. אבל הרי אנחנו רוצים <strong>לפרק לגורמים</strong> את <span>\( N \)</span>; מן הסתם הוא לא מהצורה <span>\( 2^{n} \)</span>! (באופן כללי קל לבדוק אם מספר הוא מהצורה <span>\( p^{n} \)</span> עבור <span>\( p \)</span> ראשוני ועושים את זה לפני שמנסים לפרק לגורמים).</p>

<p>לכן מה שנעשה הוא התמרת פורייה לא מעל <span>\( \mathbb{Z}_{N} \)</span> אלא מעל <span>\( \mathbb{Z}_{M} \)</span>, כאשר <span>\( M \)</span> הוא חזקה של 2 שגדולה מספיק כדי לכסות את <span>\( \mathbb{Z}_{N} \)</span> בצורה שנוחה לנו. פורמלית, נחשב את <span>\( m=\left\lceil 2\lg N\right\rceil  \)</span> (כאשר <span>\( \lg \)</span> הוא לוגריתם על בסיס 2) ונגדיר <span>\( M=2^{m} \)</span>. שימו לב שכך מתקיים <span>\( N^{2}&lt;M \)</span>; נזדקק לזה בהמשך. הרגיסטר הקוונטי שלנו יכלול <span>\( m \)</span> קיוביטים עיקריים, ועוד שלל קיוביטי “זבל” לצורך החישוב. האלגוריתם יפעל כך:</p>

<p>ראשית, נשתמש ב-<span>\( H \)</span> כדי לקבל סופרפוזיציה של כל <span>\( \mathbb{Z}_{M} \)</span>, כרגיל. נגיע למצב הקוונטי</p>

<p><span>\( \sum_{x\in\mathbb{Z}_{M}}\left|x\right\rangle \left|0^{t}\right\rangle  \)</span></p>

<p>כאשר ה-<span>\( 0 \)</span>-ים הם יתר הקיוביטים ה”זבליים” שלנו. עכשיו נחשב את הטרנספורמציה <span>\( \left|x\right\rangle \left|y\right\rangle \mapsto\left|x\right\rangle \left|y\oplus A^{x}\right\rangle  \)</span> (כש-<span>\( A^{x} \)</span> הוא מודולו <span>\( N \)</span>, כרגיל). נגיע למצב</p>

<p><span>\( \sum_{x\in\mathbb{Z}_{M}}\left|x\right\rangle \left|y\right\rangle  \)</span></p>

<p>כאשר <span>\( \left|y\right\rangle  \)</span> הוא ערך פלט אפשרי ב-<span>\( \mathbb{Z}_{N} \)</span> (אני משמיט את שאר הקיוביטים ה”זבליים”). נמדוד את החלק השני של הרגיסטר ונקרוס לאיזה ערך קונקרטי <span>\( y_{0}\in\mathbb{Z}_{N} \)</span>. ה-<span>\( \left|x\right\rangle  \)</span>-ים שנישאר איתם הם בדיוק אלו שמקיימים <span>\( A^{x}=y_{0} \)</span>. מי אלו? ובכן, אפשר לכתוב <span>\( x=x_{0}+lr \)</span> כאשר <span>\( x_{0} \)</span> הוא החיובי המינימלי מביניהם, ו-<span>\( r \)</span> הוא הסדר של <span>\( A \)</span> - מה שאנחנו מחפשים. <span>\( l \)</span> הוא מספר טבעי כך שעדיין מתקיים <span>\( x&lt;M \)</span>, כלומר <span>\( x\le M-1 \)</span>, כלומר <span>\( lr\le M-1-x_{0} \)</span>, כלומר <span>\( l\le\left\lfloor \frac{M-1-x_{0}}{r}\right\rfloor  \)</span>. כדי לא להסתרבל, נסמן <span>\( K=\left\lfloor \frac{M-1-x_{0}}{r}\right\rfloor  \)</span>. כעת, אחרי המדידה אנחנו נמצאים במצב הקוונטי</p>

<p><span>\( \sum_{l=0}^{K}\left|x_{0}+lr\right\rangle \left|y_{0}\right\rangle  \)</span></p>

<p>כלומר, יצרנו סופרפוזיציה של כל ערכי ה-<span>\( x \)</span> שעוברים לקלט מסויים ונבדלים כולם זה מזה במחזור <span>\( r \)</span>. בואו ניזכר במה שקרה באלגוריתם של סימון: שם הגענו <strong>בדיוק לאותה סיטואציה</strong>. שם הדבר הבא שעשינו היה להפעיל את <span>\( H \)</span> על המצב, מה שגרם לאיזו סופרפוזיציה נחמדה שכולה איברים שמספקים לנו מידע על המחזור. כאן הפעלה של <span>\( H \)</span> לא תהיה אפקטיבית, אנחנו צריכים משהו מחוכם יותר - וזו בדיוק הנקודה שבה התמרת פורייה נכנסת לעניין. על הסופרפוזיציה שקיבלנו אפשר לחשוב בתור פונקציה שמחזירה 0 או 1, ואת ה-1-ים שלה היא מחזירה במחזוריות של <span>\( r \)</span>. אחרי התמרת פורייה נקבל פונקציה שהערכים שלה מייצגים את ה”תדרים” של הפונקציה המקורית, כשהתדרים ש”מתאימים” ל-<span>\( r \)</span> הם גבוהים ולכן הסיכוי למדוד אותם אחרי ההתמרה הוא גדול יותר.</p>

<p>אם כן, הצעד הבא שלנו הוא זה: אנחנו לוקחים את המצב הקוונטי <span>\( \sum_{l=0}^{K}\left|x_{0}+lr\right\rangle  \)</span> ומפעילים עליו את התמרת פורייה. על פי ההגדרה של התמרת פורייה, זה יניב לנו את המצב הקוונטי הבא:</p>

<p><span>\( \sum_{x\in\mathbb{Z}_{M}}\left(\sum_{l=0}^{K}\omega^{\left(x_{0}+lr\right)x}\right)\left|x\right\rangle  \)</span></p>

<p>ועכשיו מודדים ומקבלים <span>\( x\in\mathbb{Z}_{M} \)</span>. נשארנו עם השאלה הגדולה - מה זה ה-<span>\( x \)</span> הזה? מה הוא בעצם אומר? מה אנחנו צריכים לעשות עכשיו? <span>\( x \)</span> <strong>איננו</strong> <span>\( r \)</span>. אם נחשב את <span>\( A^{x} \)</span> לא נקבל שום דבר מועיל. מה הולך פה?</p>

<p>כדי לקבל אינטואיציה על המשמעות של <span>\( x \)</span> הזה ומה עושים איתו בכלל, בואו נתחיל מתיאור של מקרה מנוון ופשוט יחסית. נניח ש-<span>\( r|M \)</span>, כלומר שאיכשהו במקרה ממוזל יצא שהסדר של <span>\( A \)</span> שאנו מחפשים מחלק את <span>\( M \)</span>, שהוא חזקה של 2 שבחרנו כדי שתהיה מספיק גדולה מ-<span>\( N \)</span>. אין ממש סיכוי שזה יקרה (ואפשר תמיד לבדוק אם חזקות של 2 הן סדר של <span>\( A \)</span> גם בלי מחשב קוונטי), אבל כאמור - במקרה הזה דברים מסתדרים נחמד ואז קל להבין את הרעיון.</p>

<p>במקרה הזה, ל-<span>\( x \)</span> שאנחנו מודדים תהיה משמעות מאוד פשוטה. מכיוון ש-<span>\( M \)</span> מתחלק על ידי <span>\( r \)</span>, זה אומר שקיים <span>\( c \)</span> כך ש-<span>\( M=rc \)</span>. הטענה היא ש-<span>\( x \)</span> הוא פשוט <span>\( ac \)</span> עבור ערך אקראי של <span>\( 0\le a&lt;r \)</span>. אם נוכיח שהטענה הזו נכונה, סיימנו: זה אומר ש-<span>\( \frac{x}{M}=\frac{ac}{rc}=\frac{a}{r} \)</span>. כלומר, <span>\( \frac{x}{M} \)</span> הוא מספר רציונלי מהצורה <span>\( \frac{a}{r} \)</span>. זה אומר שאם ההצגה <span>\( \frac{a}{r} \)</span> היא ההצגה של השבר בתור שבר מצומצם, כלומר ש-<span>\( a \)</span> זר ל-<span>\( r \)</span>, אז על ידי חישוב ההצגה המצומצת של <span>\( \frac{x}{M} \)</span> ולקיחת המכנה, מצאנו את <span>\( r \)</span>! כמובן, לא עבור כל ערך של <span>\( a \)</span> זה עובד, אבל לא קשה להוכיח שעבור רובם זה עובד - אפשר להראות שלפחות (אסימפטוטית) <span>\( \frac{r}{\ln r} \)</span> מה-<span>\( a \)</span>-ים האפשריים יהיו זרים ל-<span>\( r \)</span>.</p>

<p>אם כן, למה ש-<span>\( x \)</span> יצא <span>\( ac \)</span> אקראי שכזה? ובכן, בואו וניקח <span>\( x\in\mathbb{Z}_{M} \)</span> כלשהו, ונראה מה ההסתברות למדוד אותו - כלומר, מה הערך המוחלט בריבוע של המקדם שלו, או במילים אחרות - מהו <span>\( \left|\sum_{l=0}^{K}\omega^{\left(x_{0}+lr\right)x}\right| \)</span>. קודם כל, בואו נפשט קצת את הביטוי הזה:</p>

<p><span>\( \left|\sum_{l=0}^{K}\omega^{\left(x_{0}+lr\right)x}\right|=\left|\sum_{l=0}^{K}\omega^{x_{0}x}\omega^{lrx}\right|=\left|\omega^{x_{0}x}\right|\cdot\left|\sum_{l=0}^{K}\omega^{lrx}\right|=\left|\sum_{l=0}^{K}\omega^{lrx}\right| \)</span></p>

<p>כי <span>\( \left|\omega^{x_{0}x}\right|=1 \)</span>.</p>

<p>עכשיו בואו ניפטר מה-<span>\( K \)</span>. ראשית, <span>\( 0\le x_{0}&lt;r \)</span> (כי אם <span>\( x_{0}\ge r \)</span> גם <span>\( x_{0}-r \)</span> היה מקיים <span>\( A^{x_{0}-r}=y_{0} \)</span>, בסתירה למינימליות <span>\( x_{0} \)</span>), ולכן <span>\( \frac{x_{0}+1}{r}\le1 \)</span>. מכיוון ש-<span>\( \frac{M}{r}=c \)</span> נקבל ש-<span>\( \left\lfloor \frac{M-\left(x_{0}+1\right)}{r}\right\rfloor =c-1 \)</span>. לכן הסכום שאנו מנסים להעריך הוא <span>\( \left|\sum_{l=0}^{c-1}\left(\omega^{rx}\right)^{l}\right| \)</span>.</p>

<p>עכשיו, בואו ניזכר קצת במה שקורה עם שורשי יחידה. <span>\( \omega \)</span> הוא שורש יחידה מסדר <span>\( M \)</span>, כלומר <span>\( \omega^{M}=1 \)</span>. זה אומר ש-<span>\( \sum_{k=0}^{M-1}\omega^{k}=\frac{\omega^{M}-1}{\omega-1}=0 \)</span>, על פי נוסחת הסכום של סדרה הנדסית. בדומה, <span>\( \omega^{r} \)</span> הוא שורש יחידה מסדר <span>\( c \)</span> (כי <span>\( \left(\omega^{r}\right)^{c}=\omega^{M}=1 \)</span>) ולכן <span>\( \sum_{k=0}^{c-1}\left(\omega^{r}\right)^{k}=0 \)</span>. אבל מה עם <span>\( \omega^{rx} \)</span>?</p>

<p>ובכן, נבדיל בין שני מקרים. במקרה הראשון, <span>\( x \)</span> הוא כפולה של <span>\( c \)</span>. על כן, <span>\( rx \)</span> הוא כפולה של <span>\( M \)</span> (כי <span>\( M=rc \)</span>) ולכן <span>\( \omega^{rx}=1 \)</span>, ומכאן נקבל <span>\( \left|\sum_{l=0}^{c-1}\left(\omega^{rx}\right)^{l}\right|=c \)</span>. המקרה השני הוא זה שבו <span>\( x \)</span> אינו כפולה של <span>\( c \)</span>. במקרה זה, לא ייתכן ש-<span>\( rx \)</span> יהיה כפולה של <span>\( M \)</span> (כי אם <span>\( rx=Mt \)</span> אז <span>\( x=\frac{M}{r}t=ct \)</span>) ולכן <span>\( \omega^{rx}\ne1 \)</span> והוא בבירור שורש יחידה מסדר <span>\( c \)</span> ולכן <span>\( \left|\sum_{l=0}^{c-1}\left(\omega^{rx}\right)^{l}\right|=0 \)</span>. קיבלנו, אם כן, תוצאה מקסימה ואלגנטית: כל המקדמים של <span>\( x \)</span>-ים שהם כפולות של <span>\( c \)</span> מקבלים אותו ערך, ואילו כל שאר המקדמים נעלמים. עוד פעם יש לנו סוג של התאבכות בונה והורסת!</p>

<p>לרוע המזל, הסיטואציה הוא היא סיטואציה אידאלית, והמציאות מלוכלכת יותר. בואו נעבור, אם כן, לניתוח של המקרה הכללי, בלי שנוכל להניח ש-<span>\( r \)</span> מחלק את <span>\( M \)</span>.</p>

<p>במקרה הפרטי שלנו הסיטואציה הייתה נקיה במובן הבא: בהסתברות טובה קיבלנו ש-<span>\( \frac{x}{M} \)</span> הוא מספר רציונלי מהצורה <span>\( \frac{a}{r} \)</span>, כלומר היה צריך רק לשלוף את <span>\( r \)</span> מהמכנה. התמרת הפורייה איכשהו איפסה את רוב המקרים שלא מתאימים לתבנית הזו. במקרה הכללי שלנו מה שהולך לקרות הוא שהתמרת הפורייה עדיין תעזור לנו להתמקד על המקרים המועילים יותר, ו”מקרה מועיל” פירושו יהיה ש-<span>\( \frac{x}{M} \)</span> <strong>ניתן לקירוב אופטימלי</strong> על ידי מספר רציונלי מהצורה <span>\( \frac{a}{r} \)</span>. ב”קירוב אופטימלי” הכוונה לכך שמבין כל המספרים הרציונליים שמקרבים את <span>\( \frac{x}{M} \)</span> (שהוא רציונלי בעצמו) <strong>והמכנה שלהם קטן יחסית</strong>, הטוב ביותר יהיה זה שבו המכנה הוא <span>\( r \)</span>.</p>

<p>העניין הזה של “קירוב טוב ביותר עם מכנה קטן יחסית” אולי נשמע מוכר לחלק מכם. הוא קשור ישירות למושג חדש שנראה שהגיע משום מקום: <strong>שברים משולבים</strong>.</p>

<p><strong>פרק רביעי, ובו בשילוב השברים המשולבים אנחנו מסיימים את ההוכחה</strong></p>

<p><a href="http://www.gadial.net/2010/05/29/continued_fractions_1/">הצגתי בעבר</a> שברים משולבים בבלוג ולכן אני לא הולך להציג את הנושא מחדש בכלל, מה גם שהוא אינו קשור לקוונטים. למי שלא רוצה להתעמק בהם כרגע או לא זוכר מה בדיוק הם עושים, די לדעת ששברים משולבים נותנים לנו סדרה הולכת ומשתפרת של קירובים עבור מספרים (רציונליים ואי רציונליים כאחד). ספציפית, אם <span>\( \alpha \)</span> הוא המספר שאנחנו מנסים לקרב, אנחנו מקבלים סדרה <span>\( \frac{A_{1}}{B_{1}},\frac{A_{2}}{B_{2}},\dots \)</span> של קירובים בעלי התכונה ש-<span>\( \left|\alpha-\frac{A_{n}}{B_{n}}\right|&lt;\frac{1}{B_{n}B_{n+1}} \)</span>. הקירובים האלו הם אופטימליים במובן הבא: אם <span>\( \frac{a}{b} \)</span> הוא מספר רציונלי כלשהו כך ש-<span>\( 1\le b\le B_{n} \)</span>, אז <span>\( \left|\alpha-\frac{A_{n}}{B_{n}}\right|\le\left|\alpha-\frac{a}{b}\right| \)</span>. דהיינו <span>\( \frac{A_{n}}{B_{n}} \)</span> הוא הקירוב הרציונלי הטוב ביותר של <span>\( \alpha \)</span> מבין כל המספרים הרציונליים שהמכנה שלהם הוא לכל היותר <span>\( B_{n} \)</span>.</p>

<p>למשפט הזה יש סוג של הופכי נפלא, שאומר שאם מספר רציונלי הוא קירוב <strong>ממש טוב</strong> של <span>\( \alpha \)</span>, אז הוא חייב להתקבל מתוך סדרת הקירובים שהשבר המשולב נותן. פורמלית, אם <span>\( T \)</span> הוא מספר טבעי כלשהו ומתקיים <span>\( \left|\alpha-\frac{a}{b}\right|&lt;\frac{1}{2T^{2}} \)</span> כאשר <span>\( b\le T \)</span>, אז נובע ש-<span>\( \frac{a}{b} \)</span> נמצא בסדרת השברים המשולבים של <span>\( \alpha \)</span>, ויותר מכך: <span>\( \frac{a}{b} \)</span> הוא המספר הרציונלי <strong>היחיד</strong> עם <span>\( b\le T \)</span> המקיים <span>\( \left|\alpha-\frac{a}{b}\right|&lt;\frac{1}{2T^{2}} \)</span>.</p>

<p>את היחידות הזו אפשר לראות עם טיעון די פשוט: נניח ש-<span>\( \frac{a^{\prime}}{b^{\prime}} \)</span> הוא עוד מספר רציונלי שונה מ-<span>\( \frac{a}{b} \)</span> עם <span>\( b^{\prime}\le T \)</span> המקיים <span>\( \left|\alpha-\frac{a^{\prime}}{b^{\prime}}\right|&lt;\frac{1}{2T^{2}} \)</span>, אז נוכל להעריך את ההפרש בין שני הרציונליים הללו ולהגיע לכך שהוא בו זמנית קטן וגדול מדי:</p>

<p><span>\( \left|\frac{a}{b}-\frac{a^{\prime}}{b^{\prime}}\right|=\left|\left(\frac{a}{b}-\alpha\right)+\left(\alpha-\frac{a^{\prime}}{b^{\prime}}\right)\right|\le\left|\left(\frac{a}{b}-\alpha\right)\right|+\left|\left(\alpha-\frac{a^{\prime}}{b^{\prime}}\right)\right|&lt;\frac{1}{2T^{2}}+\frac{1}{2T^{2}}=\frac{1}{T^{2}} \)</span></p>

<p>אבל מצד שני</p>

<p><span>\( \left|\frac{a}{b}-\frac{a^{\prime}}{b^{\prime}}\right|=\left|\frac{ab^{\prime}-a^{\prime}b}{bb^{\prime}}\right|=\frac{\left|ab^{\prime}-a^{\prime}b\right|}{\left|bb^{\prime}\right|}\ge\frac{\left|ab^{\prime}-a^{\prime}b\right|}{T^{2}}\ge\frac{1}{T^{2}} \)</span></p>

<p>והגענו לסתירה, כך שלא ייתכן ש-<span>\( \frac{a^{\prime}}{b^{\prime}} \)</span> שונה מ-<span>\( \frac{a}{b} \)</span>.</p>

<p>כעת, נניח שאכן קיים <span>\( \frac{a}{b} \)</span> עם <span>\( b\le T \)</span> כך ש-<span>\( \left|\alpha-\frac{a}{b}\right|&lt;\frac{1}{2T^{2}} \)</span>. אז מובטח לנו שהאלגוריתם ימצא אותו בשלב כלשהו, אבל כמה מהר? בניסוח אחר: נתון ש-<span>\( \left|\alpha-\frac{A_{n}}{B_{n}}\right|&lt;\frac{1}{2T^{2}} \)</span> כך ש-<span>\( B_{n}\le T \)</span> - מהו <span>\( n \)</span> כפונקציה של <span>\( T \)</span>? בשביל זה אני צריך לשלוף לרגע את הנוסחה שבה נעזרים כדי לחשב את <span>\( B_{n} \)</span> מתוך הפיתוח של <span>\( \alpha \)</span> כשבר משולב: <span>\( B_{n}=a_{n}B_{n-1}+B_{n-2} \)</span>. זה לא חשוב איך מגיעים אל <span>\( a_{n} \)</span> כרגע, אלא רק שהוא תמיד שלם חיובי. לכן <span>\( B_{n}\ge B_{n-1}+B_{n-2}\ge2B_{n-2} \)</span>, וקיבלנו שהערך של <span>\( B_{n} \)</span> קופץ פי 2 אחרי כל זוג איברים, כלומר <span>\( B_{n}\ge2^{\frac{n}{2}} \)</span> (הדבר די דומה לניתוח של קצב הגידול של מספרי פיבונאצ’י ש<a href="http://www.gadial.net/2009/07/01/finding_fibonacci_formula/">תיארתי פעם בבלוג</a>). מכיוון ש-<span>\( B_{n}\le T \)</span> קיבלנו ש-<span>\( 2^{\frac{n}{2}}\le T \)</span>, כלומר <span>\( n\le2\lg T \)</span> - מספר קטן של צעדים, כך שסיבוכיות היא לא הבעיה כאן.</p>

<p>סיימנו עם ההצגה של שברים משולבים ועכשיו אפשר להסביר מה אנחנו עושים באלגוריתם הקוונטי שלנו ולמה. האלגוריתם הוא אותו אלגוריתם שכבר תיארתי. בסופו של דבר אנחנו מקבלים <span>\( x \)</span> כלשהו. אנחנו מחשבים את <span>\( \frac{x}{M} \)</span>, ואז מפתחים את <span>\( \frac{x}{M} \)</span> לשבר משולב ומסתכלים על הקירובים שקיבלנו בדרך. התקווה שלנו היא ש-<span>\( \frac{x}{M} \)</span> יהיה ניתן לקירוב מצויין בעזרת שבר ש-<span>\( r \)</span> מופיע במכנה שלו, מה שיבטיח שה-<span>\( r \)</span> הזה יצוץ בתוך הפיתוח של <span>\( \frac{x}{M} \)</span> לשבר משולב ונמצא אותו. כמה מצויין? ובכן, היינו רוצים <span>\( T \)</span> כך ש-<span>\( r\le T \)</span> ומתקיים <span>\( \left|\frac{x}{M}-\frac{a}{r}\right|&lt;\frac{1}{2T^{2}} \)</span> עבור <span>\( a \)</span> כלשהו - כבר ראינו שזה מבטיח ש-<span>\( \frac{a}{r} \)</span> יתקבל די מהר על ידי הפיתוח של <span>\( \frac{x}{M} \)</span> לשבר משולב.</p>

<p>כעת, בואו ניזכר שאנחנו מנסים לפרק לגורמים מספר <span>\( N \)</span>, וש-<span>\( r \)</span>, הסדר שאנחנו מחפשים, מקיים בהכרח <span>\( r&lt;N \)</span>, כך ש-<span>\( N \)</span> הוא מועמד טבעי להיות ה-<span>\( T \)</span> שלנו. אנחנו רוצים, אם כן, שיתקיים <span>\( \left|\frac{x}{M}-\frac{a}{r}\right|&lt;\frac{1}{2N^{2}} \)</span>. כעת, מכיוון שבחרנו את <span>\( M \)</span> בצורה כזו שיתקיים <span>\( N^{2}&lt;M \)</span>, קיבלנו שכל מה שצריך להוכיח הוא שבהסתברות טובה יתקיים <span>\( \left|\frac{x}{M}-\frac{a}{r}\right|&lt;\frac{1}{2M} \)</span> עם <span>\( a \)</span> זר ל-<span>\( r \)</span> (כי אם <span>\( a \)</span> לא זר ל-<span>\( r \)</span> אז אמנם נגיע אל <span>\( \frac{a}{r} \)</span> אבל המכנה יהיה מחלק כלשהו של <span>\( r \)</span> וזה לא יעזור לנו).</p>

<p>אם כן, אנחנו נכנסים אל הישורת האחרונה של ההוכחה. בואו ננסה להנדס לאחור את הדרישות שלנו ואז נראה מה ההסתברות שהן יתקיימו. ראשית, <span>\( \left|\frac{x}{M}-\frac{a}{r}\right|&lt;\frac{1}{2M} \)</span>. אם נכפול את הביטוי הזה ב-<span>\( Mr \)</span> נקבל <span>\( \left|xr-Ma\right|&lt;\frac{r}{2} \)</span>. בניסוח אחר, זה אומר שאנחנו רוצים שיתקיים <span>\( xr\mbox{ mod M}&lt;\frac{r}{2} \)</span>. זה דומה למה שקרה במקרה ה”מנוון” שבו <span>\( r|M \)</span> וזה גרר ש-<span>\( xr\equiv_{M}0 \)</span>; מה שאני אומר הוא שאנחנו לא חייבים לקבל 0 אלא מספיק שנקבל ערך “קטן דיו” (קטן מ-<span>\( \frac{r}{2} \)</span>). הדרישה השניה שלנו מ-<span>\( x \)</span> היא שנקבל ש-<span>\( a \)</span> זר ל-<span>\( r \)</span> בקירוב <span>\( \frac{a}{r} \)</span> של <span>\( \frac{x}{M} \)</span>. ההוכחה של הפרטים הללו היא טכנית למדי - הלב של הסיבוך הטכני של ההוכחה - ואני לא הולך להציג אותה כאן. השורה התחתונה היא זו: אפשר להוכיח שיש די הרבה <span>\( x \)</span>-ים שמקיימים בו זמנית את שתי הדרישות - ליתר דיוק, לפחות (אסימפטוטית) <span>\( \frac{r}{\log r} \)</span> מהם. כל מה שנשאר להראות הוא של-<span>\( x \)</span> כזה יש סיכוי סביר להיות מוגרל כשמודדים את הרגיסטר הקוונטי. אפשר להראות שהאמפליטודה (אחרי נרמול) של כל <span>\( x \)</span> כזה היא לפחות <span>\( \frac{1}{\sqrt{r}} \)</span>, ולכן ההסתברות שלו לעלות בגורל היא לפחות <span>\( \frac{1}{r} \)</span>, ומכאן שבהסתברות <span>\( \frac{1}{\log r} \)</span> האלגוריתם מצליח. זה נראה כמו הסתברות נמוכה, אבל אפשר “לנפח” אותה על ידי מספר חזרות על האלגוריתם, כך שזו לא הבעיה.</p>

<p><strong>אפילוג, ובו דברי סיכום ופרידה</strong></p>

<p>ראינו את האלגוריתם ואת הניתוח בצורה יחסית מלאה, אם כי לא נכנסנו לכל הפרטים הטכניים (זה בסדר; לזכותי ייאמר שגם רוב הספרים בנושא מתחמקים מחלק מהפרטים הטכניים). לטובת מי שלא שרד את הכל, אני רוצה לתת סיכום קצר של מה שעשינו.</p>

<p>התחלנו עם מה שהוא בעצם הסוף - אם אנחנו יודעים למצוא את הסדר של איבר אקראי <span>\( A \)</span> מודולו <span>\( N \)</span>, יש לנו סיכוי טוב להצליח לפרק את <span>\( N \)</span> לגורמים. האתגר היה למצוא את הסדר הזה, ולשם כך ביצענו חישוב מקבילי של <span>\( f\left(x\right)=A^{x}\mbox{ mod }N  \)</span>, שאחריו “קיבצנו” את כל ה-<span>\( x \)</span>-ים שנותנים תוצאה אקראית כלשהי <span>\( y_{0} \)</span> של <span>\( f \)</span>. על הוקטור שמתאר את ה-<span>\( x \)</span>-ים הללו (נותן להם 1 וליתר 0) הפעלנו התמרת פורייה קוונטית. שני השלבים הללו - החישוב המקבילי של <span>\( f \)</span> וההתמרה הקוונטית - הם המקום שבו הכוח של תורת הקוונטים עוזר לנו. מה שקורה כאן הוא בהחלט מה שאני קורא לו בלעג “סופר-דופר חישוב מקבילי”, אבל כזה שאת התוצאות שלו אנחנו לא מסוגלים לדעת באופן מפורש, רק לבצע מדידה - ולכן החישוב המקבילי מלכתחילה מיועד להטות את המדידה הזו כדי שתספק לנו מידע על <span>\( r \)</span>, גם אם בצורה עקיפה. הצורה העקיפה הזו נראית מוזרה למדי באלגוריתם של שור - בהסתברות טובה, אנחנו מקבלים <span>\( x \)</span> כך ש-<span>\( xr \)</span> “יחסית קרוב” להתחלק ב-<span>\( M \)</span> (שהוא חזקה גדולה של 2 שמהווה חסם מלעיל של <span>\( N \)</span>). מכך נובע ש-<span>\( \left|\frac{x}{M}-\frac{a}{r}\right| \)</span> הוא הפרש קטן מאוד - מה ש<strong>מבטיח</strong> שכאשר אנו מפתחים את <span>\( \frac{x}{M} \)</span> לשבר משולב, אז <span>\( \frac{a}{r} \)</span> יצוץ בדרך. עם קצת מזל, <span>\( a \)</span> יהיה זר ל-<span>\( r \)</span> ואז אפשר יהיה לקרוא את <span>\( r \)</span> מתוך המכנה של השבר שקיבלנו.</p>

<p>גם אם לא תזכרו את כל הפרטים הטכניים (ומי זוכר?) אני חושב שאלו הדברים שכדאי לזכור (ולהתלהב מהם): איך מציאת מחזור של פונקציה מוביל לפירוק לגורמים; איך התמרת פורייה הקוונטית עוזרת לנו; איך השברים המשולבים נכנסים לתמונה. הערב-רב הזה של רעיונות שנראים לא קשורים שמתחברים בצורה לא טריוויאלית ונותנים תוצאה חזקה ומפתיעה - ובכן, זו עבורי המתמטיקה במיטבה.</p>

  </div>

  <hr />
  <p>
    נהניתם? התעניינתם? אם תרצו, אתם מוזמנים לתת טיפ:
  </p>
  <a href='https://ko-fi.com/H2H5XFBQ' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://az743702.vo.msecnd.net/cdn/kofi2.png?v=2' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a><div class="PageNavigation">
    
      <a class="prev" href="/2014/08/20/simon_algorithm/">&laquo; חישוב קוונטי - האלגוריתם של סימון</a>
    
    
      <a class="next" href="/2014/09/22/quantum_computing_final/">חישוב קוונטי - דברי סיום ופרידה &raquo;</a>
    
  </div><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://gadial.net/2014/08/24/shor_algorithm/';
      this.page.identifier = 'http://gadial.net/2014/08/24/shor_algorithm/';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://not-precise.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/2014/08/24/shor_algorithm/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">לא מדויק</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">לא מדויק</li><li><a class="u-email" href="mailto:gadial@gmail.com">gadial@gmail.com</a></li><li>&copy; כל הזכויות שמורות לגדי אלכסנדרוביץ'</li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/%D7%9C%D7%90-%D7%9E%D7%93%D7%95%D7%99%D7%A7-163347110378474"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">לא מדויק</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>RSS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>בלוג על מתמטיקה ומדעי המחשב</p>
      </div>
    </div>

  </div>

</footer><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="assets/js/jquery-slim.min.js"><\/script>')</script><script src="/assets/js/bootstrap.bundle.js"></script>

<!-- Default Statcounter code for New blog
http://www.gadial.net/ -->
<script type="text/javascript">
  var sc_project=5444342; 
  var sc_invisible=1; 
  var sc_security="4a89cbe4"; 
  </script>
  <script type="text/javascript"
  src="https://www.statcounter.com/counter/counter.js"
  async></script>
  <noscript><div class="statcounter"><a title="Web Analytics"
  href="https://statcounter.com/" target="_blank"><img
  class="statcounter"
  src="https://c.statcounter.com/5444342/0/4a89cbe4/1/"
  alt="Web Analytics"></a></div></noscript>
  <!-- End of Statcounter Code --></body>

</html>
