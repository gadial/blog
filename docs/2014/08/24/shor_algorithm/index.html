<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>חישוב קוונטי - האלגוריתם של שור - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2014/08/24/shor_algorithm/">
    <meta property="og:title" content="חישוב קוונטי - האלגוריתם של שור">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2014/08/24/shor_algorithm/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="חישוב קוונטי - האלגוריתם של שור">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2014/08/20/simon_algorithm/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">חישוב קוונטי - האלגוריתם של סימון</span>
            </a>
            

            
            <a href="/2014/09/22/quantum_computing_final/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">חישוב קוונטי - דברי סיום ופרידה</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>חישוב קוונטי - האלגוריתם של שור</h1>
            <div class="post-meta">
                <span class="date">2014-08-24</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/חישוב קוונטי.html">חישוב קוונטי</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/חישוב קוונטי.html">חישוב קוונטי</a>
                    
                    <a href="/tags/פירוק לגורמים.html">פירוק לגורמים</a>
                    
                    <a href="/tags/פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;.html">פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <h1>פרולוג, ובו סקירה מהירה של השור הנורא</h1>
<p>לפני שלוש וחצי שנים בערך, כשגילו של הבלוג היה חצי מגילו כיום, התחלתי סדרת פוסטים שכיניתי "<a href="http://www.gadial.net/2011/01/09/surprising_results_in_complexity_prologue/">פרוייקט תוצאות מפתיעות בסיבוכיות</a>". המטרה שלי הייתה לקחת ארבע תוצאות ידועות בתורת הסיבוכיות שהופיעו במצגת של סקוט אהרונסון בתור דוגמה לתוצאות <strong>מפתיעות</strong>, ולהסביר אותן במלואן פחות או יותר, כולל הפרטים הטכניים. עבור שלוש מהתוצאות הללו (משפט אימרמן; משפט ברינגטון; ההוכחה ש-IP=PSPACE של שמיר) הצלחתי לעמוד ביעד די מהר. עבור האלגוריתם של שור הבנתי די מהר שאין לי יכולת לכתוב עליו מבלי לכתוב סדרת פוסטים על חישוב קוונטי. ומבלי שאכתוב קודם על התמרת פורייה. ובשביל פוסטים על חישוב קוונטי הייתי צריך פוסטים על מרחבי הילברט. ובשביל זה הייתי צריך פוסטים על אלגברה לינארית.... הבנתם את הרעיון. עברו שלוש וחצי שנים, והרגשתי שכבר כתבתי מספיק רקע. לא הייתי מרוצה מכל מה שכתבתי (למשל, הפוסטים על פורייה מייצגים את מיטב המאמץ שאני מסוגל לו כרגע, אבל לדעתי הם לא טובים), אבל הרגשתי מוכן להתחיל את סדרת הפוסטים על חישוב קוונטי. ועכשיו, סוף כל סוף, הגענו אל הפוסט המובטח על האלגוריתם של שור. זו סגירת מעגל שאני מאוד מרוצה מכך שהגעתי אליה; אני רק מקווה שהפוסט עצמו יצדיק את ההמתנה (האלגוריתם עצמו ודאי מצדיק אותה).</p>
<p>הכוכבת של הפוסט היא בעיית <strong>הפירוק לגורמים</strong> של מספרים טבעיים: נתון מספר טבעי <span class="math">\(N\)</span>, ואנחנו רוצים למצוא מספרים ראשוניים <span class="math">\(p_{1},p_{2},\dots,p_{k}\)</span> כך ש-<span class="math">\(N=p_{1}p_{2}\cdots p_{k}\)</span>. הסיבה התיאורטית לכך שאנחנו רוצים למצוא משהו כזה היא שיש כל מני דברים שיותר קל לעשות על מספרים כשאנחנו יודעים את הפירוק לגורמים שלהם; הסיבה הפרקטית היא שיש שיטות הצפנה שמסתמכות על כך שבהינתן <span class="math">\(N\)</span>, אנחנו דווקא <strong>לא</strong> יודעים מה הפירוק לגורמים של <span class="math">\(N\)</span>, כי מי שכן יודע יכול לפצח את ההצפנה. במילים אחרות, יש הסתמכות על כך שבעיית הפירוק לגורמים היא בעיה <strong>קשה</strong> מבחינה חישובית.</p>
<p>פירוק לגורמים היא בעיה עם היסטוריה מפוארת שמתמטיקאים דגולים מכל הדורות התעסקו איתה. היסטוריה כזו היא עניין לפוסט נפרד; אבל אני מקווה שדי ברור שלא מדובר על בעיה זניחה אלא על בעיה מעניינת ומרכזית במתמטיקה. קיימים אלגוריתמים מאוד מאוד מתוחכמים שפותרים אותה בימינו, אבל הם <strong>לא יעילים</strong> מבחינה חישובית. הם אמנם מצליחים לפרק לגורמים מספרים גדולים מאוד, אבל זה עדיין לא מספיק כדי לרסק שיטת הצפנה כמו RSA. בשל כך, כאשר פיטר שור הציג בשנת 1994 אלגוריתם פירוק לגורמים <strong>קוונטי</strong>, זו הייתה סנסציה: אחת מהבעיות החישוביות המפורסמות ביותר נפתרת על ידי מודל חישוב לא קלאסי! על פניו, זה מצביע על כך שהמודל הקוונטי חזק בצורה מהותית יותר מהמודל הקלאסי. עם זאת, חשוב לי לציין שפירוק לגורמים <strong>אינה</strong> מה שנקרא בעיה NP-שלמה (או ליתר דיוק - אם היא כזו, אנחנו לא יודעים איך להוכיח את זה). זה אומר שחישוב קוונטי לאו דווקא פותר כל בעיה ב-NP. זה כן אומר שחישוב קוונטי פותר את מה שהיא כנראה הבעיה החישובית המפורסמת ביותר שאיננו יודעים על שייכות שלה ל-P (או ליתר דיוק, ל-BPP - לחישוב יעיל הסתברותי).</p>
<p>אז איך האלגוריתם של שור עובד?</p>
<p>אם חשבתם (או שמעתם ממישהו) שהוא מקבל קלט <span class="math">\(N\)</span>, עובד עובד עובד ואז מבצע מדידה ומוציא את רשימת הגורמים של <span class="math">\(N\)</span> - תשכחו מזה. באופן שאולי קצת מפתיע אנשים שלא בקיאים בפרטים, האלגוריתם של שור בכלל לא מתעסק עם פירוק לגורמים של <span class="math">\(N\)</span>. הוא מתעסק עם שאלה אחרת: בהינתן מספר <span class="math">\(a\)</span>, מה ה<strong>סדר</strong> של <span class="math">\(a\)</span> מודולו <span class="math">\(N\)</span>, כלומר מהו <span class="math">\(0<r\)</span> המינימלי המקיים <span class="math">\(a^{r}\equiv_{N}1\)</span> (הסימון <span class="math">\(\equiv_{N}\)</span> הוא הדרך שלי לסמן שקילות מודולו <span class="math">\(N\)</span>, מה שלרוב מסומן כ-<span class="math">\(a^{r}\equiv1\left(\text{mod }N\right)\)</span>; אני מוצא שהסימון שלי חוסך לי כתיבה מיותרת). כבר לפני זמנו של שור ידעו שפתרון לבעיה הזו גורר פתרון לבעיית הפירוק לגורמים - זו תוצאה "קלאסית" בתורת המספרים שהיא הדבר הראשון שאציג (מי שלא מתעניין ברדוקציה הזו יכול לדלג מעליה ולהגיע לחלקים הקוונטיים).</p>
<p>הרעיון הבסיסי של שור הוא זה: בואו נגדיר פונקציה <span class="math">\(f\)</span> באופן הבא: <span class="math">\(f\left(x\right)=a^{x}\left(\text{mod }N\right)\)</span>. אם מתקיים <span class="math">\(f\left(x\right)=f\left(y\right)\)</span>, זה אומר ש-<span class="math">\(a^{x}\equiv_{N}a^{y}\)</span>, כלומר <span class="math">\(a^{x-y}\equiv_{N}1\)</span>, ולא קשה לראות שזה אומר ש-<span class="math">\(r\)</span> מחלק את <span class="math">\(x-y\)</span>, כלומר <span class="math">\(x=y+ir\)</span> עבור <span class="math">\(i\)</span> שלם כלשהו. גם ההפך כמובן נכון: <span class="math">\(f\left(x+ir\right)=f\left(x\right)\)</span> לכל <span class="math">\(i\)</span> שלם. קיבלנו ש-<span class="math">\(f\)</span> היא פונקציה <strong>מחזורית</strong> עם מחזור <span class="math">\(r\)</span>. המטרה של שור היא לגלות את המחזור הזה.</p>
<p>עכשיו, בפוסט הקודם ראינו אלגוריתם ששור שאב ממנו השראה - האלגוריתם של סימון, שפותר את בעיית מציאת המחזור עבור פונקציה פשוטה יחסית (והגדרה טיפה שונה של "מחזור" מזו שכאן). הרעיון של שור יהיה דומה לזה של סימון: המחזור <span class="math">\(r\)</span> במובן מסויים "מרוח בכל המרחב" (כי לכל <span class="math">\(x\)</span> שנגריל באקראי, ה-<span class="math">\(x+ir\)</span>-ים יחזירו אותו ערך כמוהו כשנפעיל את <span class="math">\(f\)</span> עליהם). אם כן, בעזרת הוקוס-פוקוס קוונטי אפשר לשלוף מהמרחב מידע על <span class="math">\(r\)</span> שיאפשר לנו בסופו של דבר למצוא אותו.</p>
<p>אלא שכאן ההוקוס-פוקוס הקוונטי יהיה יותר מסובך, כי הפונקציה <span class="math">\(f\)</span> יותר מסובכת. התעלול המרכזי של שור הוא שימוש בכלי חזק מאוד לניתוח פונקציות, בפרט כאלו מחזוריות: <strong>התמרת פורייה</strong> של <span class="math">\(f\)</span>. אלא שכאן הוא נזקק להתמרת פורייה <strong>קוונטית</strong>, דהיינו לאלגוריתם קוונטי כלשהו שמסוגל לחשב את מקדמי הפורייה של <span class="math">\(f\)</span> ולהפוך אותם לחלק מהמצב הקוונטי שלו. לשם כך שור מגייס וריאציה על האלגוריתם ל<strong>התמרת פורייה מהירה</strong> (העובדה שניתן לממש גרסה קוונטית של התמרת פורייה מהירה היא קסם לא טריוויאלי בפני עצמה). ההתמרה הזו מגדילה את ההסתברות למדידה של תוצאה בעלת ערך בסיום - כזו שאומרת לנו משהו על <span class="math">\(r\)</span> - אבל "אומרת לנו משהו" זה מושג חמקמק בפני עצמו. אין דרך נעימה לומר את זה, אז אתאר במפורש: אנחנו הולכים לקחת את התוצאה שקיבלנו, לחלק אותה במספר גדול מסויים, לקבל מספר רציונלי, לבנות סדרת קירובים אליו ולחפש את <span class="math">\(r\)</span> בתוך סדרת הקירובים הזו. כן, זה נשמע מאוד מוזר. כן, זה בוודאי לא מה שאנשים מצפים לעצמם כשהם שומעים על אלגוריתם קוונטי וחושבים עליו בתור סופר-דופר-חישוב מקבילי. זה <strong>בדיוק</strong> מה שכל כך נחמד פה.</p>
<p>אם כן, מפת הדרכים שלנו היא כזו - ראשית כל אדבר על תורת המספרים הקלאסית ואסביר איך מציאת סדר גוררת פירוק לגורמים. אחר כך אדבר על התמרת פורייה קוונטית, אחר כך על הקירובים הרציונליים, ולבסוף אחבר את כל הדברים הללו לאלגוריתם הסופי של שור. זה יהיה פוסט קצת יותר ארוך מכרגיל, אבל אני מקווה שהחלוקה לחלקים תקל עלינו.</p>
<p><strong>פרק ראשון, ובו יסופר על מציאת סדרים ופירוק לגורמים</strong></p>
<p>אז יש לנו <span class="math">\(N\)</span> ואנחנו רוצים לפרק אותו לגורמים. האבחנה הראשונה היא שמספיק לנו למצוא מספר כלשהו <span class="math">\(1<a&lt;N\)</span> שמחלק את <span class="math">\(N\)</span>. אם אנחנו יודעים לעשות את זה לכל <span class="math">\(N\)</span> בזמן יעיל, פתרנו את בעיית הפירוק לגורמים. למה? כי עכשיו כל מה שנשאר לעשות הוא לפרק את <span class="math">\(a\)</span> לגורמים ואת <span class="math">\(\frac{N}{a}\)</span> לגורמים (או, במקרה שהם ראשוניים, לזהות את זה; אבל בדיקת ראשוניות היא עניין קל). מכיוון של-<span class="math">\(N\)</span> יש לכל היותר <span class="math">\(\lg N\)</span> גורמים ראשוניים, מספר ההפעלות הכולל של אלגוריתם-מציאת-המחלק שיידרש מאיתנו הוא נמוך.</p>
<p>האבחנה הבאה היא שכדי למצוא מחלק של <span class="math">\(N\)</span>, אין צורך לנחש מחלק שכזה במפורש; מספיק למצוא מספר <span class="math">\(a\)</span> ש<strong>אינו זר</strong> ל-<span class="math">\(N\)</span>, כלומר שיש לו ול-<span class="math">\(N\)</span> מחלק משותף גדול מ-1. מספרים כאלו הם משמעותית יותר נפוצים מאשר מחלקים של <span class="math">\(N\)</span>. אם מצאנו <span class="math">\(a\)</span> כזה, אז מפעילים את <a href="http://www.gadial.net/2011/09/12/euclidean_algorithm_and_rings/">האלגוריתם למציאת מחלק משותף מקסימלי</a> על <span class="math">\(a,N\)</span> ומקבלים מחלק של <span class="math">\(N\)</span>.</p>
<p>כעת, הימור בטוח על <span class="math">\(a\)</span> כזה שהוא לא זר ל-<span class="math">\(N\)</span> יכול להתקבל אם הצלחנו למצוא <strong>שורש לא טריוויאלי </strong>של 1 מודולו <span class="math">\(N\)</span>. שורש "טריוויאלי" הוא <span class="math">\(1\)</span> או <span class="math">\(-1\)</span>, כשחושבים עליהם בתור איברים ב-<span class="math">\(\mathbb{Z}_{N}\)</span> - בבירור כשמעלים אותם בריבוע מקבלים 1, וגם אם <span class="math">\(N\)</span> ראשוני הם עדיין היו שורשים של 1. אבל כש-<span class="math">\(N\)</span> אינו ראשוני יש יותר שורשים של 1 מאשר שני אלו. נניח ש-<span class="math">\(Y\)</span> הוא שורש כזה, כלומר <span class="math">\(Y^{2}\equiv_{N}1\)</span> אבל <span class="math">\(Y\not\equiv_{N}1,-1\)</span>, כלומר אפשר לבחור <span class="math">\(1<Y&lt;N-1\)</span>. מה זה אומר? ש-<span class="math">\(N|Y^{2}-1=\left(Y-1\right)\left(Y+1\right)\)</span>. עכשיו, קחו גורם ראשוני <span class="math">\(p|N\)</span> כלשהו, אז <span class="math">\(p|\left(Y-1\right)\left(Y+1\right)\)</span>. תכונה מהותית של ראשוניים היא שאם הם מחלקים מכפלה, אז הם מחלקים את אחד המוכפלים, כלומר <span class="math">\(p|Y-1\)</span> או <span class="math">\(p|Y+1\)</span>. אני רוצה לטעון שקיים לפחות ראשוני אחד כך ש-<span class="math">\(p|Y-1\)</span>, אחרת היינו מקבלים ש-<span class="math">\(N|Y+1\)</span>, בסתירה לכך ש-<span class="math">\(1<Y&lt;N-1\)</span>.</p>
<p>מסקנה מכל זה: אם <span class="math">\(Y\)</span> הוא שורש לא טריוויאלי של 1, אז <span class="math">\(Y-1\)</span> לא זר ל-<span class="math">\(N\)</span>. לכן כדי לפרק את <span class="math">\(N\)</span> לגורמים, מספיק לנו לדעת למצוא שורש לא טריוויאלי של 1 מודולו <span class="math">\(N\)</span>.</p>
<p>איך מציאת סדר קשורה לכל זה?</p>
<p>ובכן, קחו <span class="math">\(1<A&lt;N-1\)</span> אקראי כלשהו. אם נמצא <span class="math">\(r\)</span> כלשהו כך ש-<span class="math">\(A^{r}\equiv_{N}1\)</span>, <strong>וגם</strong> <span class="math">\(r\)</span> זוגי, <strong>וגם </strong><span class="math">\(A^{\frac{r}{2}}\not\equiv_{N}1,-1\)</span> אז שיחקנו אותה: <span class="math">\(Y=A^{\frac{r}{2}}\)</span> הוא השורש הלא טריוויאלי שאנחנו מחפשים. תכף אני הולך לשכנע אתכם שיש הרבה <span class="math">\(A\)</span>-ים שמקיימים את התכונה הזו, אז מספיק לנו לבחור <span class="math">\(A\)</span> אקראי ואז למצוא <span class="math">\(r\)</span> כך ש-<span class="math">\(A^{r}\equiv_{N}1\)</span>. אין הכרח ש-<span class="math">\(r\)</span> יהיה הסדר של <span class="math">\(A\)</span>, אבל מה שקל לנו למצוא עם השיטה של שור הוא את הסדר, כי הפונקציה <span class="math">\(f\)</span> שהגדרנו קודם תהיה בעלת מחזור שהוא בדיוק הסדר.</p>
<p>אז רק נשאר לנו להשתכנע שיש הרבה <span class="math">\(A\)</span>-ים מתאימים ונוכל לסיים את החלק הקלאסי של הפוסט ולעבור לקוונטים. בשביל מה שיקרה בהמשך אני אניח שאתם מכירים קצת תורת מספרים בסיסית בפרט, אתם מכירים את <a href="http://www.gadial.net/2012/09/12/chinese_remainder_theorem/">משפט השאריות הסיני</a>. כדי להבין את העיקרון, בואו נתחיל מהמקרה שבו <span class="math">\(N=pq\)</span> עם <span class="math">\(p,q\)</span> ראשוניים אי זוגיים. אנחנו מגרילים <span class="math">\(A\in\mathbb{Z}_{N}^{*}\)</span> ורוצים להבין אותו (למה אני יכול להניח שהוא ב-<span class="math">\(\mathbb{Z}_{N}^{*}\)</span>, כלומר זר ל-<span class="math">\(N\)</span>? כי אפשר לבדוק את זה בקלות, ואם זה לא קורה - ניצחנו ומצאנו גורם של <span class="math">\(N\)</span>). עכשיו, ממשפט השאריות הסיני אנחנו יודעים ש- <span class="math">\(\mathbb{Z}_{N}^{*}\cong\mathbb{Z}_{p}^{*}\times\mathbb{Z}_{q}^{*}\)</span> ולכן מספיק לדבר על זוגות <span class="math">\(\left(Y,Z\right)\in\mathbb{Z}_{p}^{*}\times\mathbb{Z}_{q}^{*}\)</span>. הניתוח עבורם יהיה קל יותר מכיוון ש-<span class="math">\(\mathbb{Z}_{p},\mathbb{Z}_{q}\)</span> הם שדות. להגריל <span class="math">\(A\in\mathbb{Z}_{N}^{*}\)</span> באקראי זה אותו הדבר כמו להגריל את הזוג <span class="math">\(\left(Y,Z\right)\)</span> שמותאם לו על ידי האיזומורפיזם.</p>
<p>אם <span class="math">\(r_{Y},r_{Z}\)</span> הם הסדרים של <span class="math">\(Y,Z\)</span> מה יהיה <span class="math">\(r\)</span>, הסדר של ה-<span class="math">\(A\)</span> שמתאים להם? מכיוון שאם <span class="math">\(A^{s}=1\)</span> עבור <span class="math">\(s>0\)</span> כלשהו אז <span class="math">\(r\)</span> מחלק את <span class="math">\(s\)</span>, ומכיוון שכל כפולה משותפת של <span class="math">\(r_{Y},r_{Z}\)</span> היא <span class="math">\(s\)</span> שכזה, אז ברור ש-<span class="math">\(r\)</span> מחלק את כל הכפולות המשותפות של <span class="math">\(r_{Y},r_{Z}\)</span>. מצד שני, גם ברור ש-<span class="math">\(r_{Y}|r\)</span> ו-<span class="math">\(r_{Z}|r\)</span> ולכן הכפולה המשותפת המינימלית שלהם מחלק את <span class="math">\(r\)</span>. המסקנה היא ש-<span class="math">\(r=\text{lcm}\left(r_{Y},r_{Z}\right)\)</span>.</p>
<p>עכשיו הטענה המרכזית שלי: כדי שיתקיימו שני הדברים שאני רוצה - ש-<span class="math">\(r\)</span> יהיה זוגי וש-<span class="math">\(A^{\frac{r}{2}}\)</span> יהיה שורש לא טריוויאלי של 1 - מספיק שיתקיים הדבר הבא: שהחזקה הגבוהה ביותר של 2 שמחלקת את <span class="math">\(r_{Y}\)</span> תהיה שונה מזו שמחלקת את <span class="math">\(r_{Z}\)</span>. פורמלית, אפשר לכתוב <span class="math">\(r_{Y}=2^{k}c\)</span> ו-<span class="math">\(r_{Z}=2^{t}d\)</span> כאשר <span class="math">\(c,d\)</span> הם אי זוגיים; אני טוען שמספיק לדרוש <span class="math">\(k\ne t\)</span> כדי שמה שאני רוצה שיקרה, אכן יקרה. ואני גם טוען שזה יקרה בהסתברות <span class="math">\(\frac{3}{4}\)</span> לפחות, אבל את זה נראה עוד מעט.</p>
<p>כדי להבין למה זה קורה, קודם כל שימו לב לכך ש-<span class="math">\(r=2^{\max\left\{ k,t\right\} }\text{lcm}\left(c,d\right)\)</span> - זה נובע מהגדרת ה-lcm. כמובן שאם <span class="math">\(k\ne t\)</span> אז <span class="math">\(\max\left\{ k,t\right\} \ge1\)</span> ולכן <span class="math">\(r\)</span> יהיה זוגי. כמו כן, בואו נניח ש-<span class="math">\(k<t\)</span>; זה אומר ש-<span class="math">\(r=2^{t}\text{lcm}\left(c,d\right)\)</span> ולכן <span class="math">\(r_{Y}=2^{k}c|2^{t-1}\text{lcm}\left(c,d\right)=\frac{r}{2}\)</span>. מכאן אנו מקבלים ש-<span class="math">\(A^{\frac{r}{2}}\mapsto\left(Y^{\frac{r}{2}},Z^{\frac{r}{2}}\right)=\left(1,Z^{\frac{r}{2}}\right)\)</span> וזה מספיק כדי להוכיח לנו ש-<span class="math">\(A^{\frac{r}{2}}\ne-1\)</span>, שכן <span class="math">\(-1\mapsto\left(-1,-1\right)\)</span> (וכמובן ש-<span class="math">\(A^{\frac{r}{2}}\ne1\)</span> כי זה עומד בסתירה לכך ש-<span class="math">\(r\)</span> הוא הסדר של <span class="math">\(A\)</span>).</p>
<p>מה שנשאר לנו הוא לנסות ולהבין מה ההסתברות לכך שעבור איברים שנבחר באקראי מ-<span class="math">\(\mathbb{Z}_{p}^{*}\)</span> ו-<span class="math">\(\mathbb{Z}_{q}^{*}\)</span> נקבל <span class="math">\(k=t\)</span>. לצורך כך די אם נוכיח שקיים איזה שהוא <span class="math">\(k_{0}\)</span> כך שההסתברות שנקבל עבור <span class="math">\(r_{Y}=2^{k}c\)</span> ש-<span class="math">\(k\ge k_{0}\)</span> היא <strong>בדיוק</strong> <span class="math">\(\frac{1}{2}\)</span>. זה אומר שלא משנה מהו <span class="math">\(t\)</span>: אם <span class="math">\(t<k_{0}\)</span> אז ההסתברות שנקבל <span class="math">\(k<k_{0}\)</span> היא <span class="math">\(\frac{1}{2}\)</span> ולכן ההסתברות שנקבל <span class="math">\(k=t\)</span> חסומה על ידי <span class="math">\(\frac{1}{2}\)</span>; ובדומה גם אם <span class="math">\(t\ge k_{0}\)</span>.</p>
<p>כדי להוכיח את הטענה הזו, צריך להבין קצת יותר את המבנה של <span class="math">\(\mathbb{Z}_{p}^{*}\)</span>. לא אוכיח זאת כרגע (זה משפט מעניין ולא טריוויאלי), אבל זו חבורה <strong>ציקלית. </strong>נסמן את היוצר שלה ב-<span class="math">\(g\)</span>, אז <span class="math">\(g\)</span> הוא איבר מסדר <span class="math">\(p-1\)</span>, ולהגריל איבר ב-<span class="math">\(\mathbb{Z}_{p}^{*}\)</span> זה בעצם להגריל <span class="math">\(1<d&lt;p-1\)</span> ולקבל את האיבר <span class="math">\(g^{d}\)</span>.</p>
<p>כעת, בואו נבחר את <span class="math">\(k_{0}\)</span> להיות המעריך של החזקה הגדולה ביותר של 2 שמחלקת את סדר החבורה, כלומר את <span class="math">\(p-1\)</span> (כלומר <span class="math">\(p-1\)</span> היא <span class="math">\(2^{k_{0}}\)</span> כפול משהו אי זוגי). נתבונן באיבר <span class="math">\(g^{d}\)</span>. אני טוען שאם <span class="math">\(d\)</span> אי זוגי, אז הסדר של <span class="math">\(g^{d}\)</span> מתחלק על ידי <span class="math">\(2^{k_{0}}\)</span>, ואם <span class="math">\(d\)</span> זוגי אז הסדר של <span class="math">\(g^{d}\)</span> אינו מתחלק על ידי <span class="math">\(2^{k_{0}}\)</span>, מה שמוכיח את הטענה שלנו (כי בין 1 ל-<span class="math">\(p-1\)</span> יש אותו מספר של זוגיים ואי-זוגיים).</p>
<p>בכל אחד מהמקרים, נסמן ב-<span class="math">\(e\)</span> את הסדר של <span class="math">\(g^{d}\)</span>, כלומר <span class="math">\(\left(g^{d}\right)^{e}=1\)</span>, או <span class="math">\(g^{de}=1\)</span>. מכיוון שהסדר של <span class="math">\(g\)</span> הוא <span class="math">\(p-1\)</span>, נובע מכך ש-<span class="math">\(p-1|de\)</span>, ולכן <span class="math">\(2^{k_{0}}|de\)</span>. אם <span class="math">\(d\)</span> אי זוגי, אז כל ה-<span class="math">\(2\)</span>-ים בביטוי <span class="math">\(de\)</span> מגיעים מ-<span class="math">\(e\)</span> ולכן <span class="math">\(2^{k_{0}}|e\)</span> - זה היה קל. לטפל במקרה שבו <span class="math">\(d\)</span> זוגי יהיה טיפה יותר קשה.</p>
<p>אם <span class="math">\(d\)</span> זוגי, ננצל את זה שאפשר לחלק אותו ב-2 ונכתוב: <span class="math">\(\left(g^{d}\right)^{\frac{p-1}{2}}=\left(g^{p-1}\right)^{\frac{d}{2}}=1^{\frac{d}{2}}=1\)</span>. על כן, הסדר של <span class="math">\(g^{d}\)</span> מחלק את <span class="math">\(\frac{p-1}{2}\)</span>, כלומר החזקה הגבוהה ביותר של 2 ב-<span class="math">\(e\)</span> היא לכל היותר <span class="math">\(2^{k_{0}-1}\)</span>, ומכאן ש-<span class="math">\(e\)</span> לא מתחלק על ידי <span class="math">\(2^{k_{0}}\)</span>. זה מסיים את ההוכחה.</p>
<p>טיפלנו במקרה של <span class="math">\(N=pq\)</span>, אבל המקרה הכללי לא קשה בהרבה. במקרה הכללי, <span class="math">\(N=\prod_{i=1}^{m}p_{i}^{k_{i}}\)</span> ולכן נקבל ממשפט השאריות הסיני ש-<span class="math">\(\mathbb{Z}_{N}^{*}\cong\prod\mathbb{Z}_{p_{i}^{k_{i}}}^{*}\)</span>. כמקודם, אנחנו מסתכלים על הסדרים של הרכיבים ב-<span class="math">\(\prod\mathbb{Z}_{p_{i}^{k_{i}}}^{*}\)</span> ומספיק לנו שבפירוק של הסדרים הללו לחזקה של 2 ומספר אי זוגי, יהיו שני מספרים עם חזקות שונות של 2. כעת, עבור <span class="math">\(p^{k}\)</span> כלשהו, אנחנו שוב מקבלים ש-<span class="math">\(\mathbb{Z}_{p^{k}}^{*}\)</span> היא ציקלית ולכן הניתוח ההסתברותי הקודם עובד באותה מידה - רק תכתבו <span class="math">\(\varphi\left(p^{k}\right)\)</span> במקום <span class="math">\(p-1\)</span>. נקבל שהאיברים האקראיים ב-<span class="math">\(\mathbb{Z}_{p^{k}}^{*}\)</span> מתחלקים חצי-חצי מבחינת ההתחלקות של הסדר שלהם בחזקה מסויימת של 2, ומכך נובע שההסתברות שב-<span class="math">\(\prod_{i=1}^{m}\mathbb{Z}_{p_{i}^{k_{i}}}^{*}\)</span> כל הרכיבים שנבחר באקראי יהיו בעלי אותה חזקה של 2 בסדר שלהם היא <span class="math">\(\frac{1}{2^{m}}\)</span>, ולכן ההסתברות שלנו לבחור איבר "מוצלח" היא <span class="math">\(1-\frac{1}{2^{m}}\)</span>.</p>
<p>זה מסיים את הניתוח ההסתברותי, ומסיים את הרדוקציה, ומסיים את החלק ה"קלאסי" של הפוסט. עכשיו אפשר לעבור לאתגר האמיתי - איך מוצאים את הסדר של איבר <span class="math">\(A\)</span> כלשהו מודולו <span class="math">\(N\)</span>?</p>
<p><strong>פרק שני, ובו הקוונטים מתמירים את התמרת פורייה המהירה אפילו עוד יותר מהר</strong></p>
<p>בואו נסכם ונפרמל את מה שעשינו עד כה. נתון לנו מספר טבעי <span class="math">\(N\)</span>. אנחנו מסתכלים על החוג <span class="math">\(\mathbb{Z}_{N}\)</span> ומגרילים בו איבר <span class="math">\(A\)</span>. אם <span class="math">\(A\)</span> לא זר ל-<span class="math">\(N\)</span>, ניצחנו; אלגוריתם אוקלידס יניב לנו גורם משותף של <span class="math">\(N\)</span> ו-<span class="math">\(A\)</span> וסיימנו. אחרת, <span class="math">\(A\)</span> שייך לחבורה הכפלית מודולו <span class="math">\(N\)</span>, <span class="math">\(\mathbb{Z}_{N}^{*}\)</span>. ככזה, יש לו <strong>סדר</strong>, כלומר <span class="math">\(r\)</span> חיובי מינימלי כך ש-<span class="math">\(A^{r}=1\)</span> (החשבון מתבצע ב-<span class="math">\(\mathbb{Z}_{N}\)</span> ואני כבר לא טורח לכתוב <span class="math">\(\equiv\)</span> וכאלה). מה שראינו עד כה היה שאם אני מגריל <span class="math">\(A\)</span>, אז בהסתברות טובה <span class="math">\(r\)</span> יהיה זוגי ויתקיים ש-<span class="math">\(A^{\frac{r}{2}}\ne1,-1\)</span>. במקרה הזה, <span class="math">\(A^{\frac{r}{2}}-1\)</span> יהיה גורם של <span class="math">\(N\)</span>. לדוגמה, אם <span class="math">\(N=15\)</span> ואני מגריל <span class="math">\(A=7\)</span>, אז <span class="math">\(r=4\)</span>, כי החזקות של 7 מודולו 15 הן <span class="math">\(7,4,13,1\)</span>. כעת, <span class="math">\(7^{\frac{4}{2}}=7^{2}=4\)</span> וזה אכן לא שורש טריוויאלי כי <span class="math">\(4\ne1,-1\)</span>; ואכן, <span class="math">\(4-1\)</span> הוא גורם של <span class="math">\(N\)</span>. יפה! זה עובד!</p>
<p>האתגר שלנו הפך להיות מציאת הסדר של <span class="math">\(A\)</span>, אבל גם זה לא הדבר האמיתי שאנחנו פותרים: מה שהאלגוריתם של שור פותר הוא מציאת מחזור של פונקציה. במקרה שלנו, הפונקציה <span class="math">\(f:\mathbb{Z}_{N}\to\mathbb{Z}_{N}\)</span> מוגדרת על ידי <span class="math">\(f\left(x\right)=A^{x}\)</span>. בשל התכונות של הסדר של <span class="math">\(A\)</span>, אנחנו מקבלים שלכל <span class="math">\(x\in\mathbb{Z}_{N}\)</span> מתקיים <span class="math">\(f\left(x+r\right)=f\left(x\right)\)</span>.</p>
<p>אז המטרה החדשה שלנו היא זו: בהינתן <span class="math">\(f:\mathbb{Z}_{N}\to\mathbb{Z}_{N}\)</span> שקיים עבורה <span class="math">\(r\)</span> מינימלי כך ש-<span class="math">\(f\left(x+r\right)=f\left(x\right)\)</span> לכל <span class="math">\(x\in\mathbb{Z}_{N}\)</span>, יש למצוא את <span class="math">\(r\)</span>. הרעיון המרכזי כאן הוא שהניתוח של <span class="math">\(f\)</span> יהיה קל משמעותית יותר אם נעבוד לא על <span class="math">\(f\)</span> עצמה אלא על <strong>התמרת פורייה הבדידה </strong>שלה, שאסמן <span class="math">\(\hat{f}\)</span>. את התמרת פורייה הבדידה הצגתי <a href="http://www.gadial.net/2014/05/21/discrete_fourier_transform_intro/">כאן</a>, ומייד אחר כך הראיתי <a href="http://www.gadial.net/2014/05/27/fast_fourier_transform/">אלגוריתם להתמרת פורייה מהירה</a>. ההגדרה שאני הולך לתת כאן תהיה טיפה שונה מזו שנתתי בפוסטים הללו (וגם בהם השתמשתי בעצם בשתי הגדרות טיפה שונות) כי אני בוחר את ההגדרה שיהיה הכי נוח לעבוד איתה; כל ההגדרות הן פחות או יותר אותו הדבר כך שזה לא משנה.</p>
<p>התמרת פורייה הבדידה של פונקציה <span class="math">\( f:\mathbb{Z}_{N}\to\mathbb{Z}_{N}\)</span>, שאסמן <span class="math">\(\hat{f}\)</span> מתוארת על ידי זוג משוואות: משוואת אנליזה ומשוואת סינתזה. משוואת האנליזה אומרת לנו איך מוצאים את <span class="math">\(\hat{f}\)</span> מתוך <span class="math">\(f\)</span>; משוואת הסינתזה אומרת לנו איך לשחזר את <span class="math">\(f\)</span> מתוך <span class="math">\(\hat{f}\)</span>. האינטואיציה היא ש-<span class="math">\(\hat{f}\)</span> מתארת הצגה של <span class="math">\(f\)</span> בתור <strong>צירוף לינארי של שורשי יחידה</strong>. אני משתמש בסימון <span class="math">\(\omega_{N}=e^{\frac{2\pi i}{N}}\)</span> כדי לתאר שורש יחידה פרימיטיבי מסדר <span class="math">\(N\)</span>. הפעם נצטרך רק את משוואת האנליזה:</p>
<p><strong>משוואת האנליזה:</strong> <span class="math">\(\hat{f}\left(k\right)=\sum_{t=0}^{N-1}f\left(t\right)\omega_{N}^{kt}\)</span></p>
<p>(בספרים בדרך כלל המשוואה הזו מוכפל ב-<span class="math">\(\sqrt{N}\)</span> מסיבות טכניות; לא אציג את השלב הטכני שדורש אותו בהמשך ולכן לצורכי קריאות לא אכפול ב-<span class="math">\(\sqrt{N}\)</span> בכלל).</p>
<p>עכשיו הקוונטים נכנסים לעניין. מה שאנחנו רוצים לעשות הוא לחשב <strong>התמרת פורייה קוונטית</strong> של <span class="math">\(f\)</span>. פורמלית זה אומר את הדבר הבא: אנחנו רוצים להתחיל מהמצב הקוונטי</p>
<p><span class="math">\(\sum_{x\in\mathbb{Z}_{N}}f\left(x\right)\left|x\right\rangle \)</span></p>
<p>לבצע חישוב קוונטי, ולהגיע אל המצב הקוונטי</p>
<p><span class="math">\(\sum_{x\in\mathbb{Z}_{N}}\hat{f}\left(x\right)\left|x\right\rangle \)</span></p>
<p>הדרך שבה אפשר לבצע את החישוב הזה ביעילות משתמשת באותו רעיון שבו מחשבים התמרת פורייה בדידה קלאסית ביעילות - גישת ההפרד-ומשול של <strong>התמרת פורייה המהירה</strong>. בהתמרת פורייה מהירה אנחנו ראשית מניחים ש-<span class="math">\(N\)</span> הוא חזקה של 2, כלומר ניתן לחלק אותו שוב ושוב ב-2 עד שגודלו יהיה 1 (זה <strong>לא</strong> המצב אצלנו אבל עוד מעט אסביר למה זו לא בעיה). אנחנו מנצלים את התכונה הבאה של שורשי היחידה: <span class="math">\(\left(\omega_{N}^{k}\right)^{2}=\omega_{N/2}^{k}\)</span> על מנת להפוך את החישוב של מקדם פורייה <span class="math">\(\hat{f}\left(k\right)\)</span> לחישוב של שתי התמרות על מרחב מגודל <span class="math">\(\frac{N}{2}\)</span>. אחרי כן מאחדים את המידע משתי ההתמרות הללו חזרה לקבלת ההתמרה המקורית; החסכון המרכזי נובע מכך שכל מקדם שמופיע בתת-התמרות משמש אותנו <strong>פעמיים</strong>.</p>
<p>לא אחזור על הפרטים של הפוסט שהיה לי על התמרת פורייה המהירה אלא אציג את השורה התחתונה. אנחנו חושבים על <span class="math">\(f\)</span> בתור <strong>וקטור</strong> מגודל <span class="math">\(N\)</span> של מספרים מרוכבים; נסמן ב-<span class="math">\(\text{FT}_{N}\left(f\right)\)</span> את הוקטור של <span class="math">\(\hat{f}\)</span>. אם <span class="math">\(v\)</span> הוא וקטור מאורך זוגי, נסמן ב-<span class="math">\(v_{low}\)</span> את החצי הראשון שלו וב-<span class="math">\(v_{high}\)</span> את החצי השני, ה-<span class="math">\(v_{even}\)</span> את הוקטור שמתקבל מלקיחת הכניסות במקומות הזוגיים (המקום הראשון הוא 0 ולכן נחשב זוגי) וב-<span class="math">\(v_{odd}\)</span> את הוקטור שמתקבל מלקיחת הכניסות במקומות האי-זוגיים. לסיום, נסמן ב-<span class="math">\(W\)</span> את האופרטור שמתואר על ידי מטריצה אלכסונית שהאלכסון שלה כולל את הכניסות <span class="math">\(\omega^{0},\omega^{1},\dots\omega^{\frac{N}{2}-1}\)</span> (כלומר, האופרטור כופל את הכניסה הראשונה בוקטור ב-<span class="math">\(\omega^{0}\)</span>, את השניה ב-<span class="math">\(\omega^{1}\)</span> וכן הלאה). כעת קיבלנו את המשוואות הבאות:</p>
<p><span class="math">\(\text{FT}_{N}\left(f\right)_{low}=\text{FT}_{N/2}\left(f_{even}\right)+W\cdot\text{FT}_{N/2}\left(f_{odd}\right)\)</span></p>
<p><span class="math">\(\text{FT}_{N}\left(f\right)_{high}=\text{FT}_{N/2}\left(f_{even}\right)-W\cdot\text{FT}_{N/2}\left(f_{odd}\right)\)</span></p>
<p>שתי המשוואות הללו מלמדות על האלגוריתם שלנו: מחשבים את <span class="math">\(\text{FT}_{N/2}\left(f_{even}\right)\)</span> ואת <span class="math">\(\text{FT}_{N/2}\left(f_{odd}\right)\)</span> ואז משתמשים בהם פעמיים כדי לחשב את <span class="math">\(\text{FT}_{N}\left(f\right)\)</span>. זו לא בדיוק הצורה שבה הצגתי את ההתמרה המהירה בפוסט הרלוונטי; מן הסתם אני בוחר בדרך ההצגה הזו כי היא תהיה יותר קלה עבורנו בחישוב הקוונטי. מה שמוביל אותנו לשאלה: איך עושים את זה במסגרת חישוב קוונטי?</p>
<p>כזכור, אנחנו מניחים ש-<span class="math">\(N=2^{n}\)</span>. אז הרגיסטר הקוונטי שלנו יהיה בעל <span class="math">\(n\)</span> קיוביטים. את <span class="math">\(f_{low}\)</span> ניתן לתאר בתור החלק של ההתמרה עבור הקיוביטים מהצורה <span class="math">\(\left|0\right\rangle \left|x\right\rangle \)</span> (כלומר, כאלו ש<strong>מתחילים</strong> ב-0) ואת <span class="math">\(f_{low}\)</span> באמצעות <span class="math">\(\left|1\right\rangle \left|x^{\prime}\right\rangle \)</span>. בדומה, <span class="math">\(f_{even}\)</span> הוא החלק של <span class="math">\(f\)</span> עם הקיוביטים מהצורה <span class="math">\(\left|x\right\rangle \left|0\right\rangle \)</span> ו-<span class="math">\(f_{odd}\)</span> החלק עם הקיוביטים מהצורה <span class="math">\(\left|x\right\rangle \left|1\right\rangle \)</span>. הקלט שלנו הוא <span class="math">\(\sum_{x\in\mathbb{Z}_{N}}f\left(x\right)\left|x\right\rangle \)</span>. הדבר הראשון שנעשה יהיה להפעיל רקורסיבית את ההתמרה עבור <span class="math">\(\frac{N}{2}\)</span>. זה יניב לנו את המצב הקוונטי הבא:</p>
<p><span class="math">\(\text{FT}_{N/2}\left(f_{even}\right)\left|0\right\rangle +\text{FT}_{N/2}\left(f_{odd}\right)\left|1\right\rangle \)</span></p>
<p>השלב הבא הוא כפל של <span class="math">\(\text{FT}_{N/2}\left(f_{odd}\right)\left|1\right\rangle \)</span> ב-<span class="math">\(W\)</span>. המשמעות של זה היא הפעולה הקוונטית הבאה: <span class="math">\(\left|x\right\rangle \left|1\right\rangle \mapsto\omega^{x}\)</span>. איך מבצעים את זה? עוברים ביט-ביט ברגיסטר עד ולא כולל הביט האחרון (ה-<span class="math">\(n\)</span>-י). על הביט ה-<span class="math">\(i\)</span> מפעילים את הפעולה <span class="math">\(\left|0\right\rangle \mapsto\left|0\right\rangle \)</span> ו-<span class="math">\(\left|1\right\rangle \mapsto\omega^{2^{i}}\left|1\right\rangle \)</span>, כשהפעולה מותנה בכך שהביט האחרון ברגיסטר יהיה <span class="math">\(\left|1\right\rangle \)</span>. קצת מחשבה ותראו שזה פועל, בהנחה שאתם לא רואים את זה כרגע.</p>
<p>אם כן, אנחנו מגיעים אל המצב הקוונטי הבא:</p>
<p><span class="math">\(\text{FT}_{N/2}\left(f_{even}\right)\left|0\right\rangle +W\cdot\text{FT}_{N/2}\left(f_{odd}\right)\left|1\right\rangle \)</span></p>
<p>האם אתם כבר מנחשים את הצעד הבא? תנו מבט אחד במצב שהגענו אליו, ומבט אחר בשתי המשוואות שמתארות את ההתמרה. רואים?</p>
<p>ובכן, הטריק הוא פשוט, וכבר עשינו אותו בכל מקום בערך - מפעילים את <span class="math">\(H\)</span> על הביט האחרון במצב שהגענו אליו. בחיי, כמה שה-<span class="math">\(H\)</span> הזה שימושי. הסכום שלנו יתפצל לסכום של ארבעה מחוברים:</p>
<p><span class="math">\(\text{FT}_{N/2}\left(f_{even}\right)\left|0\right\rangle +W\cdot\text{FT}_{N/2}\left(f_{odd}\right)\left|0\right\rangle +\)</span></p>
<p><span class="math">\(\text{FT}_{N/2}\left(f_{even}\right)\left|1\right\rangle -W\cdot\text{FT}_{N/2}\left(f_{odd}\right)\left|1\right\rangle \)</span></p>
<p>וזה שווה ל-</p>
<p><span class="math">\(\text{FT}_{N}\left(f\right)_{low}\left|0\right\rangle +\text{FT}_{N}\left(f\right)\left|1\right\rangle \)</span></p>
<p>זה עדיין לא בדיוק מה שאנחנו רוצים. הרי <span class="math">\(\text{FT}_{N}\left(f\right)_{low}\)</span> היא ההתמרה על כל הקיוביטים שהקיוביט <strong>הראשון</strong>, המשמעותי ביותר שלהם, הוא <span class="math">\(\left|0\right\rangle \)</span>. כלומר, מה שקיבלנו הוא את <span class="math">\(\sum\hat{f}\left(0x\right)\left|x\right\rangle \left|0\right\rangle \)</span> במקום את <span class="math">\(\sum\hat{f}\left(0x\right)\left|0x\right\rangle \)</span>. אבל למרבה המזל, אין לנו בעיה להחליף קיוביטים, ולכן מעבירים את הקיוביט האחרון להיות הראשון ומזיזים את היתר בהתאם. התוצאה היא בדיוק <span class="math">\(\sum_{x\in\mathbb{Z}_{N}}\hat{f}\left(x\right)\left|x\right\rangle \)</span> המבוקש. מסקנה: אפשר ואפילו לא יותר מדי מסובך לחשב את התמרת פורייה הקוונטית. למעשה, זמן הריצה שלנו הוא מרשים למדי - לוגריתמי ב-<span class="math">\(N\)</span>. זה משהו שבלתי אפשרי לבצע בחישוב קלאסי.</p>
<p>אבל איך זה עוזר לנו?</p>
<p><strong>פרק שלישי, ובו מציאת המחזור לפתרון תעזור</strong></p>
<p>נתחיל מלדבר על הפיל באמצע החדר: כל ענייני התמרת הפורייה שלנו היו עבור <span class="math">\(N\)</span> שהוא חזקה של 2, כלומר <span class="math">\(N=2^{n}\)</span> עבור <span class="math">\(n\)</span> כלשהו. זה לא עניין זניח. בלי זה אין אלגוריתם. אבל הרי אנחנו רוצים <strong>לפרק לגורמים</strong> את <span class="math">\(N\)</span>; מן הסתם הוא לא מהצורה <span class="math">\(2^{n}\)</span>! (באופן כללי קל לבדוק אם מספר הוא מהצורה <span class="math">\(p^{n}\)</span> עבור <span class="math">\(p\)</span> ראשוני ועושים את זה לפני שמנסים לפרק לגורמים).</p>
<p>לכן מה שנעשה הוא התמרת פורייה לא מעל <span class="math">\(\mathbb{Z}_{N}\)</span> אלא מעל <span class="math">\(\mathbb{Z}_{M}\)</span>, כאשר <span class="math">\(M\)</span> הוא חזקה של 2 שגדולה מספיק כדי לכסות את <span class="math">\(\mathbb{Z}_{N}\)</span> בצורה שנוחה לנו. פורמלית, נחשב את <span class="math">\(m=\left\lceil 2\lg N\right\rceil \)</span> (כאשר <span class="math">\(\lg\)</span> הוא לוגריתם על בסיס 2) ונגדיר <span class="math">\(M=2^{m}\)</span>. שימו לב שכך מתקיים <span class="math">\(N^{2}&lt;M\)</span>; נזדקק לזה בהמשך. הרגיסטר הקוונטי שלנו יכלול <span class="math">\(m\)</span> קיוביטים עיקריים, ועוד שלל קיוביטי "זבל" לצורך החישוב. האלגוריתם יפעל כך:</p>
<p>ראשית, נשתמש ב-<span class="math">\(H\)</span> כדי לקבל סופרפוזיציה של כל <span class="math">\(\mathbb{Z}_{M}\)</span>, כרגיל. נגיע למצב הקוונטי</p>
<p><span class="math">\(\sum_{x\in\mathbb{Z}_{M}}\left|x\right\rangle \left|0^{t}\right\rangle \)</span></p>
<p>כאשר ה-<span class="math">\(0\)</span>-ים הם יתר הקיוביטים ה"זבליים" שלנו. עכשיו נחשב את הטרנספורמציה <span class="math">\(\left|x\right\rangle \left|y\right\rangle \mapsto\left|x\right\rangle \left|y\oplus A^{x}\right\rangle \)</span> (כש-<span class="math">\(A^{x}\)</span> הוא מודולו <span class="math">\(N\)</span>, כרגיל). נגיע למצב</p>
<p><span class="math">\(\sum_{x\in\mathbb{Z}_{M}}\left|x\right\rangle \left|y\right\rangle \)</span></p>
<p>כאשר <span class="math">\(\left|y\right\rangle \)</span> הוא ערך פלט אפשרי ב-<span class="math">\(\mathbb{Z}_{N}\)</span> (אני משמיט את שאר הקיוביטים ה"זבליים"). נמדוד את החלק השני של הרגיסטר ונקרוס לאיזה ערך קונקרטי <span class="math">\(y_{0}\in\mathbb{Z}_{N}\)</span>. ה-<span class="math">\(\left|x\right\rangle \)</span>-ים שנישאר איתם הם בדיוק אלו שמקיימים <span class="math">\(A^{x}=y_{0}\)</span>. מי אלו? ובכן, אפשר לכתוב <span class="math">\(x=x_{0}+lr\)</span> כאשר <span class="math">\(x_{0}\)</span> הוא החיובי המינימלי מביניהם, ו-<span class="math">\(r\)</span> הוא הסדר של <span class="math">\(A\)</span> - מה שאנחנו מחפשים. <span class="math">\(l\)</span> הוא מספר טבעי כך שעדיין מתקיים <span class="math">\(x<M\)</span>, כלומר <span class="math">\(x\le M-1\)</span>, כלומר <span class="math">\(lr\le M-1-x_{0}\)</span>, כלומר <span class="math">\(l\le\left\lfloor \frac{M-1-x_{0}}{r}\right\rfloor \)</span>. כדי לא להסתרבל, נסמן <span class="math">\(K=\left\lfloor \frac{M-1-x_{0}}{r}\right\rfloor \)</span>. כעת, אחרי המדידה אנחנו נמצאים במצב הקוונטי</p>
<p><span class="math">\(\sum_{l=0}^{K}\left|x_{0}+lr\right\rangle \left|y_{0}\right\rangle \)</span></p>
<p>כלומר, יצרנו סופרפוזיציה של כל ערכי ה-<span class="math">\(x\)</span> שעוברים לקלט מסויים ונבדלים כולם זה מזה במחזור <span class="math">\(r\)</span>. בואו ניזכר במה שקרה באלגוריתם של סימון: שם הגענו <strong>בדיוק לאותה סיטואציה</strong>. שם הדבר הבא שעשינו היה להפעיל את <span class="math">\(H\)</span> על המצב, מה שגרם לאיזו סופרפוזיציה נחמדה שכולה איברים שמספקים לנו מידע על המחזור. כאן הפעלה של <span class="math">\(H\)</span> לא תהיה אפקטיבית, אנחנו צריכים משהו מחוכם יותר - וזו בדיוק הנקודה שבה התמרת פורייה נכנסת לעניין. על הסופרפוזיציה שקיבלנו אפשר לחשוב בתור פונקציה שמחזירה 0 או 1, ואת ה-1-ים שלה היא מחזירה במחזוריות של <span class="math">\(r\)</span>. אחרי התמרת פורייה נקבל פונקציה שהערכים שלה מייצגים את ה"תדרים" של הפונקציה המקורית, כשהתדרים ש"מתאימים" ל-<span class="math">\(r\)</span> הם גבוהים ולכן הסיכוי למדוד אותם אחרי ההתמרה הוא גדול יותר.</p>
<p>אם כן, הצעד הבא שלנו הוא זה: אנחנו לוקחים את המצב הקוונטי <span class="math">\(\sum_{l=0}^{K}\left|x_{0}+lr\right\rangle \)</span> ומפעילים עליו את התמרת פורייה. על פי ההגדרה של התמרת פורייה, זה יניב לנו את המצב הקוונטי הבא:</p>
<p><span class="math">\(\sum_{x\in\mathbb{Z}_{M}}\left(\sum_{l=0}^{K}\omega^{\left(x_{0}+lr\right)x}\right)\left|x\right\rangle \)</span></p>
<p>ועכשיו מודדים ומקבלים <span class="math">\(x\in\mathbb{Z}_{M}\)</span>. נשארנו עם השאלה הגדולה - מה זה ה-<span class="math">\(x\)</span> הזה? מה הוא בעצם אומר? מה אנחנו צריכים לעשות עכשיו? <span class="math">\(x\)</span> <strong>איננו</strong> <span class="math">\(r\)</span>. אם נחשב את <span class="math">\(A^{x}\)</span> לא נקבל שום דבר מועיל. מה הולך פה?</p>
<p>כדי לקבל אינטואיציה על המשמעות של <span class="math">\(x\)</span> הזה ומה עושים איתו בכלל, בואו נתחיל מתיאור של מקרה מנוון ופשוט יחסית. נניח ש-<span class="math">\(r|M\)</span>, כלומר שאיכשהו במקרה ממוזל יצא שהסדר של <span class="math">\(A\)</span> שאנו מחפשים מחלק את <span class="math">\(M\)</span>, שהוא חזקה של 2 שבחרנו כדי שתהיה מספיק גדולה מ-<span class="math">\(N\)</span>. אין ממש סיכוי שזה יקרה (ואפשר תמיד לבדוק אם חזקות של 2 הן סדר של <span class="math">\(A\)</span> גם בלי מחשב קוונטי), אבל כאמור - במקרה הזה דברים מסתדרים נחמד ואז קל להבין את הרעיון.</p>
<p>במקרה הזה, ל-<span class="math">\(x\)</span> שאנחנו מודדים תהיה משמעות מאוד פשוטה. מכיוון ש-<span class="math">\(M\)</span> מתחלק על ידי <span class="math">\(r\)</span>, זה אומר שקיים <span class="math">\(c\)</span> כך ש-<span class="math">\(M=rc\)</span>. הטענה היא ש-<span class="math">\(x\)</span> הוא פשוט <span class="math">\(ac\)</span> עבור ערך אקראי של <span class="math">\(0\le a<r\)</span>. אם נוכיח שהטענה הזו נכונה, סיימנו: זה אומר ש-<span class="math">\(\frac{x}{M}=\frac{ac}{rc}=\frac{a}{r}\)</span>. כלומר, <span class="math">\(\frac{x}{M}\)</span> הוא מספר רציונלי מהצורה <span class="math">\(\frac{a}{r}\)</span>. זה אומר שאם ההצגה <span class="math">\(\frac{a}{r}\)</span> היא ההצגה של השבר בתור שבר מצומצם, כלומר ש-<span class="math">\(a\)</span> זר ל-<span class="math">\(r\)</span>, אז על ידי חישוב ההצגה המצומצת של <span class="math">\(\frac{x}{M}\)</span> ולקיחת המכנה, מצאנו את <span class="math">\(r\)</span>! כמובן, לא עבור כל ערך של <span class="math">\(a\)</span> זה עובד, אבל לא קשה להוכיח שעבור רובם זה עובד - אפשר להראות שלפחות (אסימפטוטית) <span class="math">\(\frac{r}{\ln r}\)</span> מה-<span class="math">\(a\)</span>-ים האפשריים יהיו זרים ל-<span class="math">\(r\)</span>.</p>
<p>אם כן, למה ש-<span class="math">\(x\)</span> יצא <span class="math">\(ac\)</span> אקראי שכזה? ובכן, בואו וניקח <span class="math">\(x\in\mathbb{Z}_{M}\)</span> כלשהו, ונראה מה ההסתברות למדוד אותו - כלומר, מה הערך המוחלט בריבוע של המקדם שלו, או במילים אחרות - מהו <span class="math">\(\left|\sum_{l=0}^{K}\omega^{\left(x_{0}+lr\right)x}\right|\)</span>. קודם כל, בואו נפשט קצת את הביטוי הזה:</p>
<p><span class="math">\(\left|\sum_{l=0}^{K}\omega^{\left(x_{0}+lr\right)x}\right|=\left|\sum_{l=0}^{K}\omega^{x_{0}x}\omega^{lrx}\right|=\left|\omega^{x_{0}x}\right|\cdot\left|\sum_{l=0}^{K}\omega^{lrx}\right|=\left|\sum_{l=0}^{K}\omega^{lrx}\right|\)</span></p>
<p>כי <span class="math">\(\left|\omega^{x_{0}x}\right|=1\)</span>.</p>
<p>עכשיו בואו ניפטר מה-<span class="math">\(K\)</span>. ראשית, <span class="math">\(0\le x_{0}&lt;r\)</span> (כי אם <span class="math">\(x_{0}\ge r\)</span> גם <span class="math">\(x_{0}-r\)</span> היה מקיים <span class="math">\(A^{x_{0}-r}=y_{0}\)</span>, בסתירה למינימליות <span class="math">\(x_{0}\)</span>), ולכן <span class="math">\(\frac{x_{0}+1}{r}\le1\)</span>. מכיוון ש-<span class="math">\(\frac{M}{r}=c\)</span> נקבל ש-<span class="math">\(\left\lfloor \frac{M-\left(x_{0}+1\right)}{r}\right\rfloor =c-1\)</span>. לכן הסכום שאנו מנסים להעריך הוא <span class="math">\(\left|\sum_{l=0}^{c-1}\left(\omega^{rx}\right)^{l}\right|\)</span>.</p>
<p>עכשיו, בואו ניזכר קצת במה שקורה עם שורשי יחידה. <span class="math">\(\omega\)</span> הוא שורש יחידה מסדר <span class="math">\(M\)</span>, כלומר <span class="math">\(\omega^{M}=1\)</span>. זה אומר ש-<span class="math">\(\sum_{k=0}^{M-1}\omega^{k}=\frac{\omega^{M}-1}{\omega-1}=0\)</span>, על פי נוסחת הסכום של סדרה הנדסית. בדומה, <span class="math">\(\omega^{r}\)</span> הוא שורש יחידה מסדר <span class="math">\(c\)</span> (כי <span class="math">\(\left(\omega^{r}\right)^{c}=\omega^{M}=1\)</span>) ולכן <span class="math">\(\sum_{k=0}^{c-1}\left(\omega^{r}\right)^{k}=0\)</span>. אבל מה עם <span class="math">\(\omega^{rx}\)</span>?</p>
<p>ובכן, נבדיל בין שני מקרים. במקרה הראשון, <span class="math">\(x\)</span> הוא כפולה של <span class="math">\(c\)</span>. על כן, <span class="math">\(rx\)</span> הוא כפולה של <span class="math">\(M\)</span> (כי <span class="math">\(M=rc\)</span>) ולכן <span class="math">\(\omega^{rx}=1\)</span>, ומכאן נקבל <span class="math">\(\left|\sum_{l=0}^{c-1}\left(\omega^{rx}\right)^{l}\right|=c\)</span>. המקרה השני הוא זה שבו <span class="math">\(x\)</span> אינו כפולה של <span class="math">\(c\)</span>. במקרה זה, לא ייתכן ש-<span class="math">\(rx\)</span> יהיה כפולה של <span class="math">\(M\)</span> (כי אם <span class="math">\(rx=Mt\)</span> אז <span class="math">\(x=\frac{M}{r}t=ct\)</span>) ולכן <span class="math">\(\omega^{rx}\ne1\)</span> והוא בבירור שורש יחידה מסדר <span class="math">\(c\)</span> ולכן <span class="math">\(\left|\sum_{l=0}^{c-1}\left(\omega^{rx}\right)^{l}\right|=0\)</span>. קיבלנו, אם כן, תוצאה מקסימה ואלגנטית: כל המקדמים של <span class="math">\(x\)</span>-ים שהם כפולות של <span class="math">\(c\)</span> מקבלים אותו ערך, ואילו כל שאר המקדמים נעלמים. עוד פעם יש לנו סוג של התאבכות בונה והורסת!</p>
<p>לרוע המזל, הסיטואציה הוא היא סיטואציה אידאלית, והמציאות מלוכלכת יותר. בואו נעבור, אם כן, לניתוח של המקרה הכללי, בלי שנוכל להניח ש-<span class="math">\(r\)</span> מחלק את <span class="math">\(M\)</span>.</p>
<p>במקרה הפרטי שלנו הסיטואציה הייתה נקיה במובן הבא: בהסתברות טובה קיבלנו ש-<span class="math">\(\frac{x}{M}\)</span> הוא מספר רציונלי מהצורה <span class="math">\(\frac{a}{r}\)</span>, כלומר היה צריך רק לשלוף את <span class="math">\(r\)</span> מהמכנה. התמרת הפורייה איכשהו איפסה את רוב המקרים שלא מתאימים לתבנית הזו. במקרה הכללי שלנו מה שהולך לקרות הוא שהתמרת הפורייה עדיין תעזור לנו להתמקד על המקרים המועילים יותר, ו"מקרה מועיל" פירושו יהיה ש-<span class="math">\(\frac{x}{M}\)</span> <strong>ניתן לקירוב אופטימלי</strong> על ידי מספר רציונלי מהצורה <span class="math">\(\frac{a}{r}\)</span>. ב"קירוב אופטימלי" הכוונה לכך שמבין כל המספרים הרציונליים שמקרבים את <span class="math">\(\frac{x}{M}\)</span> (שהוא רציונלי בעצמו) <strong>והמכנה שלהם קטן יחסית</strong>, הטוב ביותר יהיה זה שבו המכנה הוא <span class="math">\(r\)</span>.</p>
<p>העניין הזה של "קירוב טוב ביותר עם מכנה קטן יחסית" אולי נשמע מוכר לחלק מכם. הוא קשור ישירות למושג חדש שנראה שהגיע משום מקום: <strong>שברים משולבים</strong>.</p>
<p><strong>פרק רביעי, ובו בשילוב השברים המשולבים אנחנו מסיימים את ההוכחה</strong></p>
<p><a href="http://www.gadial.net/2010/05/29/continued_fractions_1/">הצגתי בעבר</a> שברים משולבים בבלוג ולכן אני לא הולך להציג את הנושא מחדש בכלל, מה גם שהוא אינו קשור לקוונטים. למי שלא רוצה להתעמק בהם כרגע או לא זוכר מה בדיוק הם עושים, די לדעת ששברים משולבים נותנים לנו סדרה הולכת ומשתפרת של קירובים עבור מספרים (רציונליים ואי רציונליים כאחד). ספציפית, אם <span class="math">\(\alpha\)</span> הוא המספר שאנחנו מנסים לקרב, אנחנו מקבלים סדרה <span class="math">\(\frac{A_{1}}{B_{1}},\frac{A_{2}}{B_{2}},\dots\)</span> של קירובים בעלי התכונה ש-<span class="math">\(\left|\alpha-\frac{A_{n}}{B_{n}}\right|&lt;\frac{1}{B_{n}B_{n+1}}\)</span>. הקירובים האלו הם אופטימליים במובן הבא: אם <span class="math">\(\frac{a}{b}\)</span> הוא מספר רציונלי כלשהו כך ש-<span class="math">\(1\le b\le B_{n}\)</span>, אז <span class="math">\(\left|\alpha-\frac{A_{n}}{B_{n}}\right|\le\left|\alpha-\frac{a}{b}\right|\)</span>. דהיינו <span class="math">\(\frac{A_{n}}{B_{n}}\)</span> הוא הקירוב הרציונלי הטוב ביותר של <span class="math">\(\alpha\)</span> מבין כל המספרים הרציונליים שהמכנה שלהם הוא לכל היותר <span class="math">\(B_{n}\)</span>.</p>
<p>למשפט הזה יש סוג של הופכי נפלא, שאומר שאם מספר רציונלי הוא קירוב <strong>ממש טוב</strong> של <span class="math">\(\alpha\)</span>, אז הוא חייב להתקבל מתוך סדרת הקירובים שהשבר המשולב נותן. פורמלית, אם <span class="math">\(T\)</span> הוא מספר טבעי כלשהו ומתקיים <span class="math">\(\left|\alpha-\frac{a}{b}\right|&lt;\frac{1}{2T^{2}}\)</span> כאשר <span class="math">\(b\le T\)</span>, אז נובע ש-<span class="math">\(\frac{a}{b}\)</span> נמצא בסדרת השברים המשולבים של <span class="math">\(\alpha\)</span>, ויותר מכך: <span class="math">\(\frac{a}{b}\)</span> הוא המספר הרציונלי <strong>היחיד</strong> עם <span class="math">\(b\le T\)</span> המקיים <span class="math">\(\left|\alpha-\frac{a}{b}\right|&lt;\frac{1}{2T^{2}}\)</span>.</p>
<p>את היחידות הזו אפשר לראות עם טיעון די פשוט: נניח ש-<span class="math">\(\frac{a^{\prime}}{b^{\prime}}\)</span> הוא עוד מספר רציונלי שונה מ-<span class="math">\(\frac{a}{b}\)</span> עם <span class="math">\(b^{\prime}\le T\)</span> המקיים <span class="math">\(\left|\alpha-\frac{a^{\prime}}{b^{\prime}}\right|&lt;\frac{1}{2T^{2}}\)</span>, אז נוכל להעריך את ההפרש בין שני הרציונליים הללו ולהגיע לכך שהוא בו זמנית קטן וגדול מדי:</p>
<p><span class="math">\(\left|\frac{a}{b}-\frac{a^{\prime}}{b^{\prime}}\right|=\left|\left(\frac{a}{b}-\alpha\right)+\left(\alpha-\frac{a^{\prime}}{b^{\prime}}\right)\right|\le\left|\left(\frac{a}{b}-\alpha\right)\right|+\left|\left(\alpha-\frac{a^{\prime}}{b^{\prime}}\right)\right|&lt;\frac{1}{2T^{2}}+\frac{1}{2T^{2}}=\frac{1}{T^{2}}\)</span></p>
<p>אבל מצד שני</p>
<p><span class="math">\(\left|\frac{a}{b}-\frac{a^{\prime}}{b^{\prime}}\right|=\left|\frac{ab^{\prime}-a^{\prime}b}{bb^{\prime}}\right|=\frac{\left|ab^{\prime}-a^{\prime}b\right|}{\left|bb^{\prime}\right|}\ge\frac{\left|ab^{\prime}-a^{\prime}b\right|}{T^{2}}\ge\frac{1}{T^{2}}\)</span></p>
<p>והגענו לסתירה, כך שלא ייתכן ש-<span class="math">\(\frac{a^{\prime}}{b^{\prime}}\)</span> שונה מ-<span class="math">\(\frac{a}{b}\)</span>.</p>
<p>כעת, נניח שאכן קיים <span class="math">\(\frac{a}{b}\)</span> עם <span class="math">\(b\le T\)</span> כך ש-<span class="math">\(\left|\alpha-\frac{a}{b}\right|&lt;\frac{1}{2T^{2}}\)</span>. אז מובטח לנו שהאלגוריתם ימצא אותו בשלב כלשהו, אבל כמה מהר? בניסוח אחר: נתון ש-<span class="math">\(\left|\alpha-\frac{A_{n}}{B_{n}}\right|&lt;\frac{1}{2T^{2}}\)</span> כך ש-<span class="math">\(B_{n}\le T\)</span> - מהו <span class="math">\(n\)</span> כפונקציה של <span class="math">\(T\)</span>? בשביל זה אני צריך לשלוף לרגע את הנוסחה שבה נעזרים כדי לחשב את <span class="math">\(B_{n}\)</span> מתוך הפיתוח של <span class="math">\(\alpha\)</span> כשבר משולב: <span class="math">\(B_{n}=a_{n}B_{n-1}+B_{n-2}\)</span>. זה לא חשוב איך מגיעים אל <span class="math">\(a_{n}\)</span> כרגע, אלא רק שהוא תמיד שלם חיובי. לכן <span class="math">\(B_{n}\ge B_{n-1}+B_{n-2}\ge2B_{n-2}\)</span>, וקיבלנו שהערך של <span class="math">\(B_{n}\)</span> קופץ פי 2 אחרי כל זוג איברים, כלומר <span class="math">\(B_{n}\ge2^{\frac{n}{2}}\)</span> (הדבר די דומה לניתוח של קצב הגידול של מספרי פיבונאצ'י ש<a href="http://www.gadial.net/2009/07/01/finding_fibonacci_formula/">תיארתי פעם בבלוג</a>). מכיוון ש-<span class="math">\(B_{n}\le T\)</span> קיבלנו ש-<span class="math">\(2^{\frac{n}{2}}\le T\)</span>, כלומר <span class="math">\(n\le2\lg T\)</span> - מספר קטן של צעדים, כך שסיבוכיות היא לא הבעיה כאן.</p>
<p>סיימנו עם ההצגה של שברים משולבים ועכשיו אפשר להסביר מה אנחנו עושים באלגוריתם הקוונטי שלנו ולמה. האלגוריתם הוא אותו אלגוריתם שכבר תיארתי. בסופו של דבר אנחנו מקבלים <span class="math">\(x\)</span> כלשהו. אנחנו מחשבים את <span class="math">\(\frac{x}{M}\)</span>, ואז מפתחים את <span class="math">\(\frac{x}{M}\)</span> לשבר משולב ומסתכלים על הקירובים שקיבלנו בדרך. התקווה שלנו היא ש-<span class="math">\(\frac{x}{M}\)</span> יהיה ניתן לקירוב מצויין בעזרת שבר ש-<span class="math">\(r\)</span> מופיע במכנה שלו, מה שיבטיח שה-<span class="math">\(r\)</span> הזה יצוץ בתוך הפיתוח של <span class="math">\(\frac{x}{M}\)</span> לשבר משולב ונמצא אותו. כמה מצויין? ובכן, היינו רוצים <span class="math">\(T\)</span> כך ש-<span class="math">\(r\le T\)</span> ומתקיים <span class="math">\(\left|\frac{x}{M}-\frac{a}{r}\right|&lt;\frac{1}{2T^{2}}\)</span> עבור <span class="math">\(a\)</span> כלשהו - כבר ראינו שזה מבטיח ש-<span class="math">\(\frac{a}{r}\)</span> יתקבל די מהר על ידי הפיתוח של <span class="math">\(\frac{x}{M}\)</span> לשבר משולב.</p>
<p>כעת, בואו ניזכר שאנחנו מנסים לפרק לגורמים מספר <span class="math">\(N\)</span>, וש-<span class="math">\(r\)</span>, הסדר שאנחנו מחפשים, מקיים בהכרח <span class="math">\(r<N\)</span>, כך ש-<span class="math">\(N\)</span> הוא מועמד טבעי להיות ה-<span class="math">\(T\)</span> שלנו. אנחנו רוצים, אם כן, שיתקיים <span class="math">\(\left|\frac{x}{M}-\frac{a}{r}\right|&lt;\frac{1}{2N^{2}}\)</span>. כעת, מכיוון שבחרנו את <span class="math">\(M\)</span> בצורה כזו שיתקיים <span class="math">\(N^{2}&lt;M\)</span>, קיבלנו שכל מה שצריך להוכיח הוא שבהסתברות טובה יתקיים <span class="math">\(\left|\frac{x}{M}-\frac{a}{r}\right|&lt;\frac{1}{2M}\)</span> עם <span class="math">\(a\)</span> זר ל-<span class="math">\(r\)</span> (כי אם <span class="math">\(a\)</span> לא זר ל-<span class="math">\(r\)</span> אז אמנם נגיע אל <span class="math">\(\frac{a}{r}\)</span> אבל המכנה יהיה מחלק כלשהו של <span class="math">\(r\)</span> וזה לא יעזור לנו).</p>
<p>אם כן, אנחנו נכנסים אל הישורת האחרונה של ההוכחה. בואו ננסה להנדס לאחור את הדרישות שלנו ואז נראה מה ההסתברות שהן יתקיימו. ראשית, <span class="math">\(\left|\frac{x}{M}-\frac{a}{r}\right|&lt;\frac{1}{2M}\)</span>. אם נכפול את הביטוי הזה ב-<span class="math">\(Mr\)</span> נקבל <span class="math">\(\left|xr-Ma\right|<\frac{r}{2}\)</span>. בניסוח אחר, זה אומר שאנחנו רוצים שיתקיים <span class="math">\(xr\text{ mod M}&lt;\frac{r}{2}\)</span>. זה דומה למה שקרה במקרה ה"מנוון" שבו <span class="math">\(r|M\)</span> וזה גרר ש-<span class="math">\(xr\equiv_{M}0\)</span>; מה שאני אומר הוא שאנחנו לא חייבים לקבל 0 אלא מספיק שנקבל ערך "קטן דיו" (קטן מ-<span class="math">\(\frac{r}{2}\)</span>). הדרישה השניה שלנו מ-<span class="math">\(x\)</span> היא שנקבל ש-<span class="math">\(a\)</span> זר ל-<span class="math">\(r\)</span> בקירוב <span class="math">\(\frac{a}{r}\)</span> של <span class="math">\(\frac{x}{M}\)</span>. ההוכחה של הפרטים הללו היא טכנית למדי - הלב של הסיבוך הטכני של ההוכחה - ואני לא הולך להציג אותה כאן. השורה התחתונה היא זו: אפשר להוכיח שיש די הרבה <span class="math">\(x\)</span>-ים שמקיימים בו זמנית את שתי הדרישות - ליתר דיוק, לפחות (אסימפטוטית) <span class="math">\(\frac{r}{\log r}\)</span> מהם. כל מה שנשאר להראות הוא של-<span class="math">\(x\)</span> כזה יש סיכוי סביר להיות מוגרל כשמודדים את הרגיסטר הקוונטי. אפשר להראות שהאמפליטודה (אחרי נרמול) של כל <span class="math">\(x\)</span> כזה היא לפחות <span class="math">\(\frac{1}{\sqrt{r}}\)</span>, ולכן ההסתברות שלו לעלות בגורל היא לפחות <span class="math">\(\frac{1}{r}\)</span>, ומכאן שבהסתברות <span class="math">\(\frac{1}{\log r}\)</span> האלגוריתם מצליח. זה נראה כמו הסתברות נמוכה, אבל אפשר "לנפח" אותה על ידי מספר חזרות על האלגוריתם, כך שזו לא הבעיה.</p>
<p><strong>אפילוג, ובו דברי סיכום ופרידה</strong></p>
<p>ראינו את האלגוריתם ואת הניתוח בצורה יחסית מלאה, אם כי לא נכנסנו לכל הפרטים הטכניים (זה בסדר; לזכותי ייאמר שגם רוב הספרים בנושא מתחמקים מחלק מהפרטים הטכניים). לטובת מי שלא שרד את הכל, אני רוצה לתת סיכום קצר של מה שעשינו.</p>
<p>התחלנו עם מה שהוא בעצם הסוף - אם אנחנו יודעים למצוא את הסדר של איבר אקראי <span class="math">\(A\)</span> מודולו <span class="math">\(N\)</span>, יש לנו סיכוי טוב להצליח לפרק את <span class="math">\(N\)</span> לגורמים. האתגר היה למצוא את הסדר הזה, ולשם כך ביצענו חישוב מקבילי של <span class="math">\(f\left(x\right)=A^{x}\text{ mod }N \)</span>, שאחריו "קיבצנו" את כל ה-<span class="math">\(x\)</span>-ים שנותנים תוצאה אקראית כלשהי <span class="math">\(y_{0}\)</span> של <span class="math">\(f\)</span>. על הוקטור שמתאר את ה-<span class="math">\(x\)</span>-ים הללו (נותן להם 1 וליתר 0) הפעלנו התמרת פורייה קוונטית. שני השלבים הללו - החישוב המקבילי של <span class="math">\(f\)</span> וההתמרה הקוונטית - הם המקום שבו הכוח של תורת הקוונטים עוזר לנו. מה שקורה כאן הוא בהחלט מה שאני קורא לו בלעג "סופר-דופר חישוב מקבילי", אבל כזה שאת התוצאות שלו אנחנו לא מסוגלים לדעת באופן מפורש, רק לבצע מדידה - ולכן החישוב המקבילי מלכתחילה מיועד להטות את המדידה הזו כדי שתספק לנו מידע על <span class="math">\(r\)</span>, גם אם בצורה עקיפה. הצורה העקיפה הזו נראית מוזרה למדי באלגוריתם של שור - בהסתברות טובה, אנחנו מקבלים <span class="math">\(x\)</span> כך ש-<span class="math">\(xr\)</span> "יחסית קרוב" להתחלק ב-<span class="math">\(M\)</span> (שהוא חזקה גדולה של 2 שמהווה חסם מלעיל של <span class="math">\(N\)</span>). מכך נובע ש-<span class="math">\(\left|\frac{x}{M}-\frac{a}{r}\right|\)</span> הוא הפרש קטן מאוד - מה ש<strong>מבטיח</strong> שכאשר אנו מפתחים את <span class="math">\(\frac{x}{M}\)</span> לשבר משולב, אז <span class="math">\(\frac{a}{r}\)</span> יצוץ בדרך. עם קצת מזל, <span class="math">\(a\)</span> יהיה זר ל-<span class="math">\(r\)</span> ואז אפשר יהיה לקרוא את <span class="math">\(r\)</span> מתוך המכנה של השבר שקיבלנו.</p>
<p>גם אם לא תזכרו את כל הפרטים הטכניים (ומי זוכר?) אני חושב שאלו הדברים שכדאי לזכור (ולהתלהב מהם): איך מציאת מחזור של פונקציה מוביל לפירוק לגורמים; איך התמרת פורייה הקוונטית עוזרת לנו; איך השברים המשולבים נכנסים לתמונה. הערב-רב הזה של רעיונות שנראים לא קשורים שמתחברים בצורה לא טריוויאלית ונותנים תוצאה חזקה ומפתיעה - ובכן, זו עבורי המתמטיקה במיטבה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>