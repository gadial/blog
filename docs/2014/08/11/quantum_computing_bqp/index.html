<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>חישוב קוונטי - מה זה בדיוק - לא מדויק</title>
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <header>
            <h1>חישוב קוונטי - מה זה בדיוק</h1>
            <div class="post-meta">
                <span class="date">2014-08-11</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/פיזיקה.html">פיזיקה</a>
                    
                    <a href="/categories/חישוב קוונטי.html">חישוב קוונטי</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/BQP.html">BQP</a>
                    
                    <a href="/tags/חישוב קוונטי.html">חישוב קוונטי</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>הפוסט הזה הוא הלב התיאורטי של כל סדרת הפוסטים שלי על חישוב קוונטי. עד עכשיו הצגתי את הרעיונות הפיזיקליים ואת המסגרת המתמטית שבה הם מתוארים, ונתתי דוגמאות לתעלולים שונים ומשונים שמתבצעים בעזרת הרעיונות הפיזיקליים הללו ומפורמלים בעזרת המתמטיקה, אבל לא דיברתי בכלל על מה שמדעני מחשב אוהבים לדבר עליו - <strong>מודלים חישוביים</strong>. זה בדיוק מה שצריך לדבר עליו אם רוצים לטעון טענות כמו "כנראה שחישוב קוונטי חזק יותר מחישוב רגיל" שאני עומד לטעון בהמשך - צריך להבין מה זה אומר "חישוב קוונטי" ומה זה "חישוב רגיל"; ומה זה אומר "חזק יותר", ולמה "כנראה". כל הדברים הללו דורשים פורמליזם, וכזה יגיע בהמשך.</p>
<p>לפני שנגיע לפורמליזם ואולי נבריח קוראים שהגיעו לכאן בטעות, אני רוצה להקדיש כמה דקות להסבר למה חישוב קוונטי הוא <strong>יותר</strong> מאשר מציגים אותו לרוב, כשהפעם אני גם יכול לגבות את עצמי בהסברים יותר רציניים מאשר בפתיחת סדרת הפוסטים הזו. המיסקונספציה העיקרית שאני רוצה לצאת נגדה בכל סדרת הפוסטים הזו על חישוב קוונטי היא התפיסה של חישוב קוונטי בתור "סופר-דופר-חישוב-מקבילי" ותו לא. זו תפיסה שמוצגת בכל מקום, כולל במאמרים ובספרים של אנשים רציניים מאוד שכנראה מבינים את התחום הרבה יותר טוב ממני, אבל עושים פשרות בשל הנסיון לכתוב לקהל רחב.</p>
<p>בואו נראה כמה דוגמאות לזה. בכתבה <a href="http://www.calcalist.co.il/internet/articles/0,7340,L-3620956,00.html">הזו</a> אומרים</p>
<blockquote>בניגוד למחשב רגיל, שיכול לבצע רק חישוב אחד בכל פעם - מהיר ככל שיהיה, מחשב קוונטי מסוגל לבצע כמה חישובים במקביל או להימנע במקרים מסוימים מביצוע חישובים שאינם הכרחיים להשלמת משימה. בכך הוא מקצר משמעותית את הזמן הדרוש להשלמתה.</blockquote>
<p>כלומר, חישוב מקבילי ששונה מזה של מחשב "רגיל" (שבו כדי להשיג מקביליות אמיתית צריך כמה מעבדים שרצים במקביל, אבל גם במקרה זה כל מעבד עדיין מבצע פעולה אחת בפעם).</p>
<p>ו<a href="http://www.ynet.co.il/articles/0,7340,L-3117096,00.html">כאן</a> אומרים</p>
<blockquote>באמצעות קיוביטים הנמצאים במצב הביניים הזה אפשר ליצור מעבדים למחשבים, שיפעלו במקביל: החלקיקים שינועו במעגלים האלקטרוניים יהיו בכמה מצבים בעת ובעונה אחת, תוך כדי שהם מבצעים מספר פעולות חישוביות בעת ובעונה אחת.</blockquote>
<p>שזה שוב אותו דבר.</p>
<p>ואילו <a href="http://www.ynet.co.il/articles/0,7340,L-3788331,00.html">כאן</a> אומרים</p>
<blockquote>המערכות השזורות מציעות אפשרות לחישוב במקביל - כלומר, בדיקה של מספר פתרונות בעת ובעונה אחת, באמצעות חישוב המתבצע לפי חוקים מתמטיים חדשים, שאינם מתקיימים מחוץ למערכות שזורות... חישוב קוונטי כזה דומה לבעיה של סריקת מספר גדול של מזוודות בחיפוש אחר פצצה. במצב רגיל יש לסרוק את המזוודות בזו אחר זו, תהליך שעלול להימשך זמן רב מדי. לעומת זאת, התייחסות למזוודות כאל מערכות שזורות מאפשרת לבדוק רק חלק קטן מהן, ובכל זאת לקבל מידע על כולן - ובכך לקבוע במהירות ובוודאות היכן מוטמנת הפצצה. המגבלה העיקרית על השימוש במערכות שזורות לצורך חישובים מהירים היא הכלל הידוע של תורת הקוונטים, שלפיו המדידה - או התצפית - משפיעה על התוצאה. מכיוון שכך, במשך כל תהליך החישוב אסור "להציץ" אל תוך המערכת...</blockquote>
<p>כאן כבר רומזים קצת על המורכבות של הסיפור האמיתי (ה"חוקים מתמטיים חדשים" והעובדה ש"אסור להציץ") אבל גם כאן מתקבל רושם שגוי.</p>
<p>הדוגמה המצערת ביותר מבחינתי היא בספר Anathem של ניל סטיבנסון. סטיבנסון הוא סופר מדע בדיוני מוכשר ביותר, שלא מהסס להיכנס לפרטים טכניים ולהציג רעיונות מתמטיים לא טריוויאליים. לא אגלה כלום על עלילת Anathem או הרקע שלו כדי לא לקלקל לקוראים הפוטנציאליים, אבל אציין שסטיבנסון בהחלט לוקח את הזמן בספר הזה כדי להסביר רעיונות לא טריוויאליים לעומק, ויש לו זמן, ויש לו הצדקה עלילתית לזה, והוא עושה את זה מצוין והספר באופן כללי נפלא. מתישהו בספר הוא עושה את זה גם עבור מחשב קוונטי. והתיאור שלו הוא בדיוק התיאור ה"מקבילי" הרגיל - לא אצטט כאן, אבל הרעיון הוא שהמחשב נמצא בסופרפוזיציה של כל האפשרויות שהוא רוצה לבדוק, מבצע את החישוב בכולן, ואז מודדים אותו והוא קורס אל התוצאה ה"נכונה".</p>
<p>התיאורים הללו הם כולם <strong>נכונים</strong>. אני לא בא לומר שמישהו טועה כאן במשהו. חישוב קוונטי הוא אכן, בבסיסו, חישוב מקבילי מחוכם. אבל אני חושב שהתיאורים הללו <strong>מפספסים את הפואנטה</strong> ולא באמת מעבירים לקורא ההדיוט את הסיבה שבגללה חישוב קוונטי הוא משהו חדש לגמרי ושונה באופיו מחישובים רגילים. אני גם חושב שהתיאורים הללו גורמים לחישוב קוונטי להיראות <strong>חזק יותר מכפי שהוא באמת</strong>.</p>
<p>אז הנה שתי הנקודות שאני חושב שכל מי שרוצה להכיר חישוב קוונטי צריך להיות מודע להן, גם אם הוא רוצה להסתפק בידע ברמת המדע הפופולרי. גם הן, כמובן, לא כל הסיפור, אבל לדעתי ברמת המדע הפופולרי הן מה שחסר כדי שהסיפור יהיה פחות או יותר שלם. הראשונה מראה למה חישוב קוונטי הוא במובן מסויים <strong>מוגבל</strong>, והשניה מראה למה חישוב קוונטי הוא במובן מסויים <strong>חזק</strong>.</p>
<p>הנקודה הראשונה היא שחישוב קוונטי שמתנהל כך: מתחילים עם סופרפוזיציה של כל הקלטים האפשריים לפונקציה כלשהי, מחשבים את הפונקציה על כולם "בבת אחת" ולבסוף מבצעים מדידה - חישוב כזה הוא <strong>חסר ערך</strong>. מה שנקבל בו בסופו של דבר הוא את הערך של הפונקציה על אחד מהקלטים, ואת הערך הזה נקבל <strong>באקראי</strong>. באותה המידה כבר יכלנו לבחור קלט באקראי ואז לבצע את החישוב עליו בעצמנו. לב לבו של העניין - האתגר המרכזי של כל אלגוריתם קוונטי שהתחיל עם גישת הסופרפוזיציה של הכל - הוא בביצוע מניפולציה כלשהי של הסופרפוזיציה-של-כל-ערכי-הפונקציה בצורה כזו שמבטיחה שהפלט שנקבל יכיל אינפורמציה מועילה עבורנו. אנחנו נראה בהמשך דוגמאות לשתי דרכים שונות לעשות את זה - דרך אחת היא לתת איכשהו משקל הסתברותי גבוה יותר לתוצאות "רצויות" של הפונקציה, שיבטיחו הסתברות יותר גבוהה למדוד אותה; ודרך אחרת היא לשלוף מידע מועיל שנמצא בצורה כלשהי <strong>בכל</strong> ערכי הפונקציה. אלו לא רעיונות שקל להסביר על רגל אחת ולכן יוקדשו להם פוסטים; מה שחשוב לי להסביר ברמת המדע הפופולרי הוא עד כמה השלב הזה קריטי. אחרי שביצענו חישוב קוונטי וקיבלנו סופרפוזיציה של כל ערכי הפונקציה האפשריים, <strong>אין לנו דרך לגשת אל המידע הזה</strong> בצורה ישירה - אנחנו חייבים להשתמש בתכסיסים שיאפשרו לנו לשלוף איכשהו פיסת מידע מתוך הסופרפוזיציה הנפלאה הזו. הברכה של הסופרפוזיציה שהיא בלב החישוב הקוונטי היא גם הקללה שלו. לטעמי זה מרתק, מרתק לחלוטין; הרבה יותר מרתק מסתם "חישוב קוונטי מבצע המון פעולות במקביל".</p>
<p>הנקודה השניה שחשוב לי להתייחס אליה - והיא לטעמי אפילו יותר Mind blowing מהראשונה, אם כי ייתכן שרק עבור קוראים עם יותר ידע מתמטי - היא מה ההבדל המהותי בין חישוב קוונטי ובין חישוב <strong>הסתברותי</strong>. חישוב הסתברותי הוא משהו שקיים במחשבים כבר כיום ומוכיח את עצמו בצורה נפלאה בפועל (למשל, <a href="http://www.gadial.net/2009/08/09/miller_rabin/">אלגוריתם מילר-רבין</a> למציאת ראשוניים). אפשר לתאר חישובים הסתברותיים בצורה דומה מאוד לזו שבה אתאר חישוב קוונטי בפוסט הזה; במובן מסויים גם חישוב הסתברותי הוא סוג של מקביליות (החישוב לא נמצא בו זמנית בכמה מצבים, אבל הוא <strong>יכול</strong> להיות בכמה מצבים שונים על אותו קלט ולכל מצב יש את "ההסתברות שאני נמצא במצב הזה כרגע"). גם חישוב קוונטי נגמר על ידי מדידה, שמחזירה תוצאה באופן הסתברותי. אז מה כל כך שונה, תגידו? למה יש אלגוריתם קוונטי יעיל שיודע לפרק מספר לגורמים אבל אין אלגוריתם הסתברותי יעיל שעושה את זה? אני אסביר את מלוא ההבדל הטכני לקראת סוף הפוסט, אבל הנה שורת מחץ (שהיא כמובן לא מדויקת ונועדה לתת אפקט Wham) בשבילכם - כי בחישוב קוונטי, להבדיל מחישוב הסתברותי רגיל, ההסתברויות יכולות להיות <strong>מספר שלילי</strong>.</p>
<p>עבורי, הרגע שבו "נפל לי האסימון" והתחלתי להבין מה זה חישוב קוונטי ולמה הוא כל כך נפלא היה בדיוק כשהבנתי את הנקודה הזו. אני מקווה שאלו מכם שישרדו איתי עד סוף הפוסט, כשאציג את הפורמליזם המלא, יחושו כמוני.</p>
<p>עכשיו בואו נעבור לדבר על הגדרות פורמליות. ראשית כל אני רוצה להזכיר בקצרה איך מפרמלים חישובים רגילים. המודל הסטנדרטי הוא <strong>מכונת טיורינג</strong>. המודל הזה הוא המצאה גאונית, לא פחות; בזמנו של טיורינג לא היו מחשבים, וכל הפורמליזמים המתמטיים שתיארו את מה שהיום אנחנו קוראים לו פונקציות ניתנות לחישוב היו מאוד מתמטיים באופיים. בא טיורינג והמציא משהו שנראה כמו מכונה, שאפשר לממש פיזיקלית, ואפשר "להרגיש בידיים" מה היא עושה. הרעיון הוא כזה: יש לנו סרט שמחולק לתאים כאשר בכל תא יכול להיות כתוב 0 או 1 (לרוב מרשים גם תאים ריקים, או ערכים נוספים פרט ל-0 או 1, אבל הפעם זה לא יסייע לנו). על גבי הסרט הזה מתרוצצת לה מכונה קטנה שכוללת ראש קורא וכותב, ומחוברת ליחידה לוגית שמכילה סט סופי של הוראות. ההוראות הן תמיד מהצורה "אם עכשיו אתה רואה 0 ואתה נמצא במצב בקרה 7, אז כתוב 1 ולך צעד אחד ימינה" וכדומה. זה הכל. היצור הקטן והעלוב הזה, שאפשר לבנות אותו בלגו אם רוצים, יכול לממש כל תוכנית מחשב שאתם יכולים לכתוב כיום.</p>
<p>עכשיו, מה שאנחנו נרצה לדבר עליו כל הזמן הוא מכונות טיורינג <strong>יעילות</strong>. המושג של "יעילות" הוא לא טריוויאלי, והקונצנזוס שהגיעו אליו יכול להיראות מוזר לחלקכם. הרעיון הוא שמכונה היא יעילה אם זמן הריצה שלה על כל קלט הוא <strong>פולינומי</strong> בגודל הקלט. כלומר, קיים פולינום <span class="math">\(p\)</span> כך שלכל קלט <span class="math">\(x\)</span>, זמן הריצה של המכונה על <span class="math">\(x\)</span> הוא לכל היותר <span class="math">\(p\left(\left|x\right|\right)\)</span>, כאשר <span class="math">\(\left|x\right|\)</span> הוא מספר הביטים שמרכיבים את <span class="math">\(x\)</span>. המגבלה הזו על זמן הריצה של המכונה גם משרה מגבלה על גודל הסרט שהיא עשויה "לנצל" - אפשר להניח שגודל הסרט הוא לא יותר מ-<span class="math">\(p\left(\left|x\right|\right)\)</span>. ליודעי דבר אעיר שאני מנסה להתחמק כאן מכך שבהגדרה הכללית שלה, הסרט של מכונת טיורינג הוא <strong>לא חסום</strong>, ואז לכו תתווכחו עם אנשים שטוענים שזה לא מודל ריאליסטי כי אין בעולם האמיתי סרטים לא חסומים (כמובן, גם עכשיו יבוא חכמולוג ויטען שעבור <span class="math">\(x\)</span> מספיק גדול, <span class="math">\(p\left(\left|x\right|\right)\)</span> יכול להיות גדול יותר ממספר האטומים ביקום ולכן אין מימוש פיזיקלי למכונת הטיורינג שמטפלת ב-<span class="math">\(x\)</span> הזה; אבל זו תמיד עם העובדה שאנחנו מרשים ל-<span class="math">\(x\)</span> להיות גדול באופן בלתי חסום).</p>
<p>הדבר החשוב ביותר במודל הזה הוא ה<strong>לוקליות</strong> שלו ("אה-הא!" אתם אומרים, "זה מה שהולך להישבר במכונה קוונטית!" - ובכן, לא). הראש הקורא וכותב הוא קטן ומסכן ובכל רגע נתון הוא נמצא רק על תא מסויים בסרט. זה אומר שהשינוי שהוא יכול לעשות הוא תמיד במקום אחד; הוא לא יכול לשנות את כל הסרט בו זמנית, והוא לא יכול לראות את כל הסרט בבת אחת ולהגיב על פי זה. זה לא כל כך חשוב שהוא יכול לראות רק תא אחד בו זמנית - אפשר היה גם לדבר על סיטואציה שבה הוא רואה את מאה התאים שמסביבו ויכול לשנות את כולם בבת אחת - מה שקריטי הוא רק שמספר התאים שהוא יכול לראות בו זמנית הוא <strong>חסום</strong>, כלומר לא תלוי ב-<span class="math">\(\left|x\right|\)</span>. מודל שבו המגבלה הזו תוסר יהיה כבר <strong>חזק מדי</strong> ואני לא הולך לדבר עליו (לב הבעיה במודל כזה הוא שאחד משניים - או שהתיאור הפורמלי של מכונה במודל הזה יהיה <strong>אינסופי</strong>, וזה לא ריאליסטי; או שהתיאור שלה יהיה סופי, אבל אז אפשר יהיה לסמלץ אותה עם מכונת טיורינג מוגבלת ולא הרווחנו כלום).</p>
<p>עכשיו, אפשר קצת להגמיש את ההגדרה ולקבל מודל שקול למכונת טיורינג אבל שמרחם עלינו קצת ברמת הפרטים. במודל הזה, שדומה יותר לאופן שבו מחשב פועל, החישוב שלנו על קלט <span class="math">\(x\)</span> מתחיל עם <strong>רגיסטר</strong> שגודלו <span class="math">\(p\left(\left|x\right|\right)\)</span>, כאשר "רגיסטר" הוא שם מפוצץ לתא זכרון שכולל כמה ביטים. בואו נסמן <span class="math">\(\left|x\right|=m\)</span> ו-<span class="math">\(p\left(\left|x\right|\right)=n\)</span>, אז הרגיסטר ניתן לתיאור על ידי סדרה <span class="math">\(a_{1},\dots,a_{n}\)</span> של ביטים. אבל מכיוון שאנחנו בסדרת פוסטים על קוונטים, בואו נשתמש בסימון <span class="math">\(\left|a_{1}\dots a_{n}\right\rangle \)</span> כדי לתאר את התוכן של הרגיסטר בזמן נתון כלשהו.</p>
<p>בתחילת החישוב, הרגיסטר כולל את הקלט ואפסים בכל מקום אחר, כלומר המצב ההתחלתי של החישוב ניתן לתיאור בתור <span class="math">\(\left|x0^{n-m}\right\rangle \)</span>. וכעת, מהו החישוב? סדרה של ערכים שונים שהרגיסטר מקבל, כך שכל שני ערכים סמוכים בסדרה מתקבלים האחד מהשני על ידי ביצוע של צעד חישוב אחד.</p>
<p>כעת, מהו צעד חישוב? במכונת טיורינג, כפי שאמרנו, מה שחשוב בצעד חישוב הוא ה<strong>לוקליות</strong> שלו. כל צעד מתבסס על כמות חסומה של מידע, ומשפיע רק על כמות חסומה של ביטים בסרט. עם זאת, צריך להיזהר לא לחסום את המידע הזה <strong>יותר מדי</strong> - אחרת אנחנו עלולים לקבל מודל מוגבל וחלש יותר ממכונת טיורינג. הנה פשרה מתקבלת על הדעת: כל צעד חישוב מסתכל על שלושה ביטים מתוך הרגיסטר, ומשנה רק אותם, כשהערך החדש שהוא נותן להם מחושב איכשהו מתוך הביטים הללו.</p>
<p>פורמלית, כל פעולה אטומית כזו ניתנת לתיאור באמצעות מעגל לוגי קטן <span class="math">\(F\)</span> שמקבל שלושה קלטים ומוציא שלושה פלטים, כלומר <span class="math">\(F\left(x,y,z\right)=\left(a,b,c\right)\)</span>. עכשיו אני אשתמש בסימון קצת עקום כדי לתאר את פעולת <span class="math">\(F\)</span> על רגיסטר שלם, אבל תבינו את הכוונה שלי:</p>
<p><span class="math">\(F^{ijk}\left|x_{1}\dots x_{n}\right\rangle =\left|x_{1}\dots x_{i-1}ax_{i+1}\dots x_{j-1}bx_{j+1}\dots x_{k-1}cx_{k+1}\dots x_{n}\right\rangle \)</span></p>
<p>כאשר <span class="math">\(\left(a,b,c\right)=F\left(x_{i},x_{j},x_{k}\right)\)</span>.</p>
<p>זה סימון מתוסבך, אבל המשמעות ברורה: <span class="math">\(F^{ijk}\)</span> הוא האופרטור שפועל על הרגיסטר על ידי הפעלת <span class="math">\(F\)</span> על הביטים <span class="math">\(x_{i},x_{j},x_{k}\)</span> והחלפתם בתוצאה של <span class="math">\(F\)</span>. למה, הו למה אני משתמש בכזה סימון מתוסבך כשיש לי מכונת טיורינג? מן הסתם, כי חישובים קוונטיים יתוארו (בצורה נוחה) בעזרת הסימון המתוסבך הזה ואני רוצה שתראו שגם חישוב רגיל אפשר לתאר באותו האופן (כלומר, ההבדל בין שתי שיטות החישוב הוא לא <strong>כזה</strong> גדול).</p>
<p>אם כן, אפשר לתאר חישוב רגיל בתור הפעלה סדרתית של אופרטורים שפועלים על שלושה ביטים כל אחד בתורו, אבל הנה לכם שאלה - <strong>אילו אופרטורים</strong> מפעילים? יש הרבה אופרטורים אפשריים, איך מחליטים מה להפעיל בכל שלב? ובכן, התחושה הטבעית שלנו היא שהמכונה עצמה צריכה להחליט על המקום מה להפעיל, בהתבסס על מצבים פנימיים שלה או משהו דומה. אבל מסתבר שאפשר גם בלי זה - אפשר יהיה <strong>להתחייב מראש</strong> על סדרת האופרטורים שמפעילים על הרגיסטר, וזאת מבלי לדעת בכלל מה הקלט שהולכים לקבל אלא רק מה אורכו.</p>
<p>במילים אחרות - לכל מספר טבעי <span class="math">\(n\)</span>, המודל החישובי שלנו כולל סדרת שערים <span class="math">\(F_{1},F_{2},\dots,F_{n}\)</span>, והחישוב הוא הפעלה סדרתית של ה-<span class="math">\(F_{i}\)</span>-ים הללו על הרגיסטר, החל מהרגיסטר ההתחלתי. יש רק בעיה אחת עם ההגדרה זו - היא אומרת שנדרש אינסוף מידע כדי לתאר את המודל החישובי שלנו (וזה אומר, אינטואיטיבית, שהוא לא משהו שאפשר לממש בפועל - "תוכנית מחשב אינסופית"). למה אינסוף מידע? הרי <span class="math">\(F_{1},\dots,F_{n}\)</span> היא סדרה סופית בהחלט! ובכן, כי אנחנו צריכים סדרה כזו <strong>לכל <span class="math">\(n\)</span></strong> (ליתר דיוק, לכל <span class="math">\(n\)</span> שמתקבל בתור <span class="math">\(p\left(\left|x\right|\right)\)</span> עבור <span class="math">\(x\)</span> כלשהו, אבל לרוב יהיו אינסוף כאלו). לכן מה שמקובל לדרוש הוא שלכל אינסוף סדרות השערים הללו יהיה איזה שהוא תיאור קומפטי, סופי, מין "נוסחה" שנותנת אותם. איך אני יכול לפרמל את ה"נוסחה" הזו מבלי להגביל את עצמנו יותר מדי? ובכן, זה יצחיק אתכם בוודאי, אבל בעזרת מכונת טיורינג.</p>
<p>זה נראה מגוחך, כי באתי להגדיר מודל חישוב שקול למכונת טיורינג, ובסוף אני אשתמש במכונת טיורינג כדי לתאר חלק ממנו. אבל שימו לב שאני עדיין מקבל מודל שקול, והמכונה הנוספת שבה אני אשתמש תפעל בצורה מוגבלת למדי (היא לא תדע מה הקלט אלא רק מה אורכו) ושהיעד האמיתי שלי הוא הגדרה של חישוב קוונטי.</p>
<p>עכשיו, הנה הגדרה פורמלית לגמרי. קודם אתן אותה ואז אסביר את מה שעדיין אולי לא ברור: פונקציה <span class="math">\(f:\left\{ 0,1\right\} ^{*}\to\left\{ 0,1\right\} \)</span> ניתנת לחישוב (רגיל) בזמן פולינומי אם קיים פולינום <span class="math">\(T:\mathbb{N}\to\mathbb{N}\)</span> כלשהו וקיימת מכונת טיורינג דטרמיניסטית <span class="math">\(M\)</span> פולינומית שעל כל קלט מהצורה <span class="math">\(\left(1^{m},1^{T\left(m\right)}\right)\)</span> עבור <span class="math">\(m\in\mathbb{N}\)</span> פולטת סדרה <span class="math">\(F_{1},\dots,F_{T\left(n\right)}\)</span> של שערים, כך שלכל <span class="math">\(x\in\left\{ 0,1\right\} ^{*}\)</span> מקבלים את <span class="math">\(f\left(x\right)\)</span> באופן הבא (נסמן <span class="math">\(m=\left|x\right|\)</span> ו-<span class="math">\(n=T\left(m\right)\)</span>):</p>
<ol>
    <li>מריצים את <span class="math">\(M\)</span> על <span class="math">\(\left(1^{m},1^{n}\right)\)</span> ומקבלים סדרה <span class="math">\(F_{1},\dots,F_{n}\)</span> של שערים.</li>
    <li>מאתחלים את הרגיסטר למצב <span class="math">\(R_{0}=\left|x0^{n-m}\right\rangle \)</span>.</li>
    <li>מחשבים את הסדרה <span class="math">\(R_{1},R_{2},\dots,R_{n}\)</span> על ידי הנוסחה <span class="math">\(R_{i}=F_{i}\left(R_{i-1}\right)\)</span>.</li>
    <li>נסמן <span class="math">\(R_{n}=\left|r_{1}r_{2}\dots r_{n}\right\rangle \)</span>, אז הפלט של התהליך כולו הוא <span class="math">\(r_{1}\)</span>.</li>
</ol>
<p>רוב מה שהולך כאן כבר ברור, אני מקווה. ייתכן שלא ברור מה זו הפונקציה <span class="math">\(f:\left\{ 0,1\right\} ^{*}\to\left\{ 0,1\right\} \)</span> שצצה פתאום. הסימון <span class="math">\(\left\{ 0,1\right\} ^{*}\)</span> מתאר את "כל המחרוזות הבינאריות מאורך סופי", והפונקציה מוציאה פלט שהוא ביט בודד; לא אכנס עכשיו לפירוט, אבל בפועל זה כל מה שצריך (פלט של כמה ביטים יכול להיות מתואר על ידי כמה חישובים שונים שכל אחד מהם מוציא ביט אחר).</p>
<p>דבר אחר שלא ברור הוא מה הקלט המוזר הזה ש-<span class="math">\(M\)</span> מקבלת. האם לא היה מספיק להעביר ל-<span class="math">\(M\)</span> את המספר <span class="math">\(n\)</span> וזהו? זו נקודה טכנית שאין צורך להתעמק בה יותר מדי - המטרה שלנו היא לדרוש מ-<span class="math">\(M\)</span> לא לרוץ יותר מדי זמן מעבר לכמות השערים שהיא צריכה לכתוב ולמספר הביטים של הקלט, ולכן אנחנו מעבירים לה "קלט מדומה" שהאורך שלו הוא סכום האורכים של שני הנתונים הללו. זאת מכיוון שזמן ריצה של מכונה נמדד ביחס לאורך הקלט. אני לא יודע אם אזדקק לנקודה הזו בהמשך באופן מפורש; אני מעדיף להכניס אותה פנימה כי היא חלק מההגדרה הפורמלית.</p>
<p>זה אתגר נחמד לקוראים שבקיאים קצת בחישוביות להוכיח שהמודל החדש שקול למודל הרגיל. החלק המעניין הוא סימולציה של מכונת טיורינג "רגילה" במודל החדש. הנה התעלול שיאפשר לכם לעשות את זה: מפתה לחשוב על הרגיסטר רק בתור תוכן הסרט של המכונה, אבל בפועל כדי להשתמש בו כך: לכל תא בסרט של המכונה יהיה איבר מתאים ברגיסטר, אבל לידו יהיו איברים שמתאימים למצבי הבקרה הפנימיים של המכונה. ערך של 1 עבור משתנה של מצב בקרה פנימי <span class="math">\(q\)</span> שנמצא ליד משתנה של התא ה-<span class="math">\(i\)</span> במכונה אומר "המכונה כרגע נמצאת בתא <span class="math">\(i\)</span> ובמצב הבקרה <span class="math">\(q\)</span>". עכשיו, מספיק שנקרא את שני הביטים של תא הבקרה ותא הסרט כדי שנדע מה המכונה רוצה לעשות; הביט השלישי שלנו יתאים לתא הבקרה שאליו המכונה <strong>עוברת</strong>. מה ש-<span class="math">\(M\)</span> תפלוט היא סדרה של <span class="math">\(F\)</span>-ים שמתארים שוב ושוב את כל המעברים האפשריים של המכונה בהתאם לטבלת המעברים שלה. מסובך? מבולבלים? בסדר גמור, אפשר לשאול אותי בתגובות.</p>
<p>בואו נעבור סוף סוף לסיבה שלשמה התכנסנו פה - הגדרה פורמלית של חישוב קוונטי. בעצם כבר יש לנו את כל הרכיבים, כמעט. ראינו כבר שערים קוונטיים בפוסט הקודם - אלו פשוט טרנספורמציות אוניטריות. אני מרשה שערים שפועלים על שלושה קיוביטים לכל היותר (ולכן מתוארים על ידי מטריצה <span class="math">\(8\times8\)</span> - למה?). כרגיל, אפשר לטעון שזו הגדרה מגבילה מדי, אבל גם אם הייתי מחליף את "שלושה קיוביטים" ב"ארבעה קיוביטים" או מספר קבוע דומה לא הייתי מקבל מחלקה חזקה יותר, ואילו שער קוונטי שפועל על רגיסטר מאורך שרירותי - זה משהו שלא סביר בכלל שנוכל לממש, פיזיקלית.</p>
<p>המשמעות של פעולה של שער קוונטי שמטפל בשלושה קיוביטים כשמפעילים אותו על רגיסטר של יותר משלושה קיוביטים אמורה להיות ברורה: על שאר הקיוביטים השער פועל כמו הזהות, ולכן הטרנספורמציה הכוללת שהוא מייצג היא מכפלה טנזורית של השער עם הרבה "זהויות" עבור כל קיוביט שלא נוגעים בו. כבר ראינו את זה בפוסטים הקודמים.</p>
<p>משהסכמנו על שערים קוונטיים שמקבלים לכל היותר שלושה קיוביטים, הנה ההגדרה הפורמלית:</p>
<p>אנחנו אומרים שפונקציה <span class="math">\(f:\left\{ 0,1\right\} ^{*}\to\left\{ 0,1\right\} \)</span> שייכת למחלקה <span class="math">\(\mbox{BQP}\)</span> אם קיים פולינום <span class="math">\(T:\mathbb{N}\to\mathbb{N}\)</span> כלשהו וקיימת מכונת טיורינג דטרמיניסטית <span class="math">\(M\)</span> פולינומית שעל כל קלט מהצורה <span class="math">\(\left(1^{m},1^{T\left(m\right)}\right)\)</span> עבור <span class="math">\(m\in\mathbb{N}\)</span> פולטת סדרה <span class="math">\(F_{1},\dots,F_{T\left(n\right)}\)</span> של שערים <strong>קוונטיים</strong>, כך שלכל <span class="math">\(x\in\left\{ 0,1\right\} ^{*}\)</span> מקבלים את <span class="math">\(f\left(x\right)\)</span> באופן הבא <strong>בהסתברות של לפחות</strong> <span class="math">\(\frac{2}{3}\)</span> (נסמן <span class="math">\(m=\left|x\right|\)</span> ו-<span class="math">\(n=T\left(m\right)\)</span>):</p>
<ol>
    <li>מריצים את <span class="math">\(F_{1},\dots,F_{n}\)</span> של שערים קוונטיים.</li>
    <li>מאתחלים את הרגיסטר למצב הקוונטי <span class="math">\(R_{0}=\left|x0^{n-m}\right\rangle \)</span>.</li>
    <li>מחשבים את הסדרה <span class="math">\(R_{1},R_{2},\dots,R_{n}\)</span> על ידי הנוסחה <span class="math">\(R_{i}=F_{i}\left(R_{i-1}\right)\)</span>.</li>
    <li><strong>מודדים</strong> את <span class="math">\(R_{n}\)</span> ביחס לבסיס הסטנדרטי ומקבלים את התוצאה <span class="math">\(Y=\left|y_{1}y_{2}\dots y_{n}\right\rangle \)</span>.</li>
    <li>הפלט של התהליך הוא <span class="math">\(y_{1}\)</span>.</li>
</ol>
<p>שימו לב שההגדרה הזו היא במהותה הסתברותית - אנחנו לא דורשים ש<strong>תמיד</strong> נקבל ש-<span class="math">\(y_{1}=f\left(x\right)\)</span>, רק שזה יקרה <strong>ברוב הפעמים</strong> (ספציפית, ב-<span class="math">\(\frac{2}{3}\)</span> מהפעמים, כי זה מאפשר לנו לחזור שוב ושוב על החישוב ו"לנפח" את ההסתברות שנקבל את התוצאה הנכונה). זה עלול להיראות לכם מגביל, אבל צריך לזכור שבעניינים כמו פירוק לגורמים, האקראיות הזו לא קריטית - אם מצאנו פירוק לגורמים, אנחנו נדע בודאות שהוא "עובד"; החסרון היחיד של אקראיות כאן הוא שלא מובטח לנו שהפירוק לגורמים יתבצע מהר; אבל בהסתברות מאוד, מאוד, מאוד גבוהה זה אכן מה שיקרה. כמו שמילר-רבין ההסתברותי עובד טוב בעולם האמיתי.</p>
<p>מה פשר BQP? פשוט: P מדבר על זמן חישוב פולינומי; Q מדבר על חישוב קוונטי; ו-B מדבר על חישוב הסתברותי עם שגיאה <strong>חסומה</strong> (שגיאה חסומה היא שגיאה שלא יכולה להיות קרובה כרצוננו לחצי - כי חצי, מבחינה הסתברותית, פירושו "לא יודעים כלום"). השם דומה מאוד, ולא במקרה, ל-BPP, שהיא המחלקה הסטנדרטית של חישוב הסתברותי רגיל - ה-P באמצע הוא מלשון "הסתברותי" במקום "קוונטי".</p>
<p>כדי להשלים את התמונה, אני רוצה לתת את ההגדרה הפורמלית של BPP כדי שנוכל להשוות אותה ל-BQP ולהבין למה המחלקה השניה חזקה לפחות כמו הראשונה (ועל פי האמונה שלנו, חזקה יתר). בדרך כלל מגדירים את BPP באמצעות <strong>מכונת טיורינג הסתברותית</strong>: מכונה כזו זהה למכונת טיורינג רגילה, רק שבכל שלב של החישוב, במקום צעד אפשרי אחד יש לה <strong>שני</strong> צעדים אפשריים שהיא בוחרת ביניהם באקראי, בהסתברות אחידה. זה אומר שאין למכונה פלט בודד, אלא ישנה התפלגות על הפלטים האפשריים - הפלט של המכונה הוא משתנה מקרי. בדרך כלל מגבילים את עצמנו לפלט שהוא ביט בודד, ואז נדרשת הדרישה שכבר ראינו, להסתברות <span class="math">\(\frac{2}{3}\)</span> לפחות לתת את הפלט ה"נכון" על כל קלט <span class="math">\(x\)</span>.</p>
<p>הנה הגדרה חלופית, דומה באופיה להגדרה שנתתי של BQP. הדבר הראשון שאני צריך לעשות הוא להגדיר איך מתנהג "שער הסתברותי" <span class="math">\(F\)</span>. כרגיל, שער כזה מתייחס לשלושה ביטים ובהתאם לקלט הזה, מוציא פלט של שלושה ביטים, רק שעכשיו יכולה להיות לו התפלגות על כל הפלטים האפשריים. פורמלית:</p>
<p><span class="math">\( F\left(x,y,z\right)=\sum_{\left(a,b,c\right)\in\left\{ 0,1\right\} ^{3}}p_{\left(a,b,c\right)}^{\left(x,y,z\right)}\left(a,b,c\right)\)</span></p>
<p>כאשר <span class="math">\(0\le p_{\left(a,b,c\right)}^{\left(x,y,z\right)}\le1\)</span> היא ההסתברות שעל קלט <span class="math">\(\left(x,y,z\right)\)</span> ה"שער" יחזיר פלט <span class="math">\(\left(a,b,c\right)\)</span> ו-<span class="math">\(\sum_{\left(a,b,c\right)\in\left\{ 0,1\right\} ^{3}}p_{\left(a,b,c\right)}^{\left(x,y,z\right)}=1\)</span>, כרגיל עם הסתברות.</p>
<p>את ההגדרה הזו אפשר להרחיב על רגיסטר. במקרה של מכונה הסתברותית, רגיסטר יהיה תמיד סכום מהצורה <span class="math">\(\sum a_{v}v\)</span> כאשר <span class="math">\(v=\left|v_{1}v_{2}\cdots v_{n}\right\rangle \)</span> ו-<span class="math">\(0\le a_{v}\le1\)</span> כך ש-<span class="math">\(\sum_{v}a_{v}=1\)</span>. אז <span class="math">\(F\)</span> ראשית כל יתייחס לשלושה ביטים ספציפיים, כמו קודם:</p>
<p><span class="math">\(F^{ijk}\left(\left|v_{1}v_{2}\cdots v_{n}\right\rangle \right)=\sum_{\left(a,b,c\right)\in\left\{ 0,1\right\} ^{3}}p_{\left(a,b,c\right)}^{\left(v_{i},v_{j},v_{k}\right)}\left|v_{1}\cdots v_{i-1}av_{i+1}\cdots b\cdots c\cdots v_{n}\right\rangle \)</span></p>
<p>ולבסוף מרחיבים לינארית:</p>
<p><span class="math">\( F^{ijk}\left(\sum a_{v}v\right)=\sum a_{v}F^{ijk}\left(v\right)\)</span>.</p>
<p>ועכשיו הנה הגדרה פורמלית:</p>
<p>אנחנו אומרים שפונקציה <span class="math">\(f:\left\{ 0,1\right\} ^{*}\to\left\{ 0,1\right\} \)</span> שייכת למחלקה <span class="math">\(\mbox{BPP}\)</span> אם קיים פולינום <span class="math">\(T:\mathbb{N}\to\mathbb{N}\)</span> כלשהו וקיימת מכונת טיורינג דטרמיניסטית <span class="math">\(M\)</span> פולינומית שעל כל קלט מהצורה <span class="math">\(\left(1^{m},1^{T\left(m\right)}\right)\)</span> עבור <span class="math">\(m\in\mathbb{N}\)</span> פולטת סדרה <span class="math">\(F_{1},\dots,F_{T\left(n\right)}\)</span> של שערים <strong>הסתברותיים</strong>, כך שלכל <span class="math">\(x\in\left\{ 0,1\right\} ^{*}\)</span> מקבלים את <span class="math">\(f\left(x\right)\)</span> באופן הבא <strong>בהסתברות של לפחות</strong> <span class="math">\(\frac{2}{3}\)</span> (נסמן <span class="math">\(m=\left|x\right|\)</span> ו-<span class="math">\(n=T\left(m\right)\)</span>):</p>
<ol>
    <li>מריצים את <span class="math">\( M\)</span> על <span class="math">\(\left(1^{m},1^{n}\right)\)</span> ומקבלים סדרה <span class="math">\(F_{1},\dots,F_{n}\)</span> של שערים הסתברותיים.</li>
    <li>מאתחלים את הרגיסטר למצב <span class="math">\(R_{0}=\left|x0^{n-m}\right\rangle \)</span>.</li>
    <li>מחשבים את הסדרה <span class="math">\(R_{1},R_{2},\dots,R_{n}\)</span> על ידי הנוסחה <span class="math">\(R_{i}=F_{i}\left(R_{i-1}\right)\)</span>.</li>
    <li><strong>"מודדים"</strong> את <span class="math">\(R_{n}\)</span> ומקבלים את התוצאה <span class="math">\(Y=\left|y_{1}y_{2}\dots y_{n}\right\rangle \)</span>.</li>
    <li>הפלט של התהליך הוא <span class="math">\(y_{1}\)</span>.</li>
</ol>
<p>ה"מדידה" בשלב 4 היא פשוטה: אם אנחנו נמצאים במצב <span class="math">\(\sum a_{v}v\)</span>, אז ההסתברות שנקבל <span class="math">\(v\)</span> היא <span class="math">\(a_{v}\)</span>.</p>
<p>זה מאוד דומה למכונה קוונטית. מאוד מאוד דומה! אז מה ההבדל הגדול?</p>
<p>ההבדל הוא בדיוק בפרטים הטכניים, אלו שעליהם אף פעם לא מדברים במדע פופולרי (אני משקר, לפעמים כן מדברים וכל הכבוד למי שכן). חישוב קוונטי פשוט מאפשר לנו להשתמש ב<strong>יותר</strong> אופרטורים שפועלים על ה"רגיסטר", מה שמאפשר לבנות אלגוריתמים מתוחכמים יותר.</p>
<p>מצב כללי של רגיסטר של מכונה הסתברותית הוא צירוף לינארי <span class="math">\(\sum a_{v}v\)</span> כאשר המקדמים <span class="math">\(a_{v}\)</span> מתאימים לכללי תורת ההסתברות: כולם מספרים ממשיים בין 0 ו-1, והסכום של כולם הוא 1, כלומר <span class="math">\(\sum a_{v}=1\)</span>. האופרטורים שאנחנו יכולים להשתמש בהם בחישוב הסתברותי חייבים לשמר את הסיטואציה הזו (כמובן, בהגדרות "טבעיות" כמו של מכונת טיורינג הסתברותית אף אחד לא מכריח אותנו לעשות את זה; זה פשוט מה שנובע מההגדרה).</p>
<p>לעומת זאת, מצב כללי של רגיסטר של מכונה קוונטית הוא צירוף לינארי <span class="math">\(\sum a_{v}v\)</span> כאשר המקדמים יכולים להיות <strong>מספרים מרוכבים</strong> כלשהם, ואנחנו דורשים רק שהסכום של ריבועי הערכים המוחלטים שלהם יהיה 1, כלומר <span class="math">\(\sum\left|a_{v}\right|^{2}=1\)</span>. זה מאפשר לנו יותר חופש פעולה; יותר אופרטורים; וכפי שאמרתי בהתחלה, מקדמים שליליים של ה"הסתברות". אם תרצו, לב העניין הוא בכך שהמקדמים של מצב קוונטי הם בעלי <strong>יותר</strong> משמעות מאשר הסתברות גרידא; כבר ראינו <a href="http://www.gadial.net/2014/08/05/quantum_cryptography/">בפוסט של הצפנה קוונטית</a> למה זה יכול להיות קריטי לחלוטין לפעמים.</p>
<p>זהו, סיימנו עם הפורמליזם המדויק. בפוסט הבא נתחיל להראות את הלחם והחמאה של האלגוריתמים הקוונטיים המפורסמים.</p>
        </article>
        
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2014/08/16/grover_algorithm/" class="nav-link nav-next">
                <span class="nav-label">→ פוסט חדש יותר</span>
                <span class="nav-title">אלגוריתם גרובר</span>
            </a>
            
            
            
            <a href="/2014/08/09/quantum_gates/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר ←</span>
                <span class="nav-title">חישוב קוונטי - טלפורטציה, קידוד צפוף ושערים קוונטיים</span>
            </a>
            
        </nav>
        
        
        <footer>
            <p>בלוג מתמטיקה בעברית</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>