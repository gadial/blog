<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>שערים ומעגלים קוונטיים - מבוא על קצה המזלג - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_site/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/new_site/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/new_site/">דף הבית</a>
                <a href="/new_site/random.html">פוסט אקראי</a>
                <a href="/new_site/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_site/2014/08/16/grover_algorithm/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">אלגוריתם גרובר</span>
            </a>
            

            
            <a href="/new_site/2014/08/20/simon_algorithm/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">חישוב קוונטי - האלגוריתם של סימון</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>שערים ומעגלים קוונטיים - מבוא על קצה המזלג</h1>
            <div class="post-meta">
                <span class="date">2014-08-19</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/חישוב קוונטי.html">חישוב קוונטי</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/חישוב קוונטי.html">חישוב קוונטי</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>הפוסט הזה הולך להתעסק בפרטי ה-Low level של חישוב קוונטי - הרכיבים הבסיסיים שבהם אנחנו משתמשים בחישוב כזה (<strong>שערים קוונטיים</strong>) ומה שאנחנו בונים באמצעותם (<strong>מעגלים קוונטיים</strong>). כשאני אומר Low-level הכוונה היא אך ורק לזה שאנחנו מתעסקים בפרטים הבסייסים שמהם מורכבים חישובים סבוכים; זה בשום פנים ואופן לא אומר שזה תחום "ירוד" מבחינת ערכו (כי הוא לא) או לא מעניין (כי הוא מעניין נורא) או פשוט (כי הוא לא פשוט בכלל). מה שכן, הפוסט עצמו כן יהיה ירוד; אני אתאר את התחום הזה בצורה מאוד High-level - רעיונות כלליים ותו לא, בלי להיכנס לעומק הפרטים.</p>
<p>כרגיל, לפני שמדברים על איך זה עובד בקוונטים, לא יזיק להיזכר איך זה עובד בחישוב קלאסי. בחישוב קלאסי כל יחידת מידע בסיסית - ביט - היא בעלת שני ערכים אפשריים, 0 או 1. אפשר היה לבנות מעגלים קלאסיים שבהם יחידת מידע יכולה להכיל עוד ערכים אפשריים אבל פשוט אין בכך צורך. המטרה שלנו בחישוב קלאסי ניתנת לרוב לתיאור בתור חישוב של <strong>פונקציה</strong>: פורמלית, נתונה פונקציה בוליאנית <span class="math">\(f:\left\{ 0,1\right\} ^{n}\to\left\{ 0,1\right\} \)</span> ואנחנו רוצים לבנות מעגל שמורכב משערים בסיסיים שיש לו <span class="math">\(n\)</span> "כניסות" ויציאה אחת, כך שאם הכניסות מקבלות את הערך <span class="math">\(a\)</span> (חשבו על <span class="math">\(a\)</span> בתור סדרה של <span class="math">\(n\)</span> ביטים) אז היציאה תקבל, אחרי שהמעגל יבצע את החישוב שלו, את הערך <span class="math">\(f\left(a\right)\)</span>. אם אנחנו יודעים לעשות דבר כזה נוכל גם לטפל בסיטואציות יותר מורכבות כמו מעגלים עם יותר מפלט אחד, או מעגלים עם יחידות זכרון, וכדומה.</p>
<p>"שערים לוגיים" הם רכיבים פשוטים יחסית שמחשבים פונקציות פשוטות - לרוב כאלו על מספר מצומצם מאוד של משתנים - 1 או 2 זה כל מה שנדרש בדרך כלל (בעולם האמיתי יש גם רכיב שנקרא Field Programmable Gate Array - בקיצור FPGA - שמקבל מספר גדול יותר של משתנים וניתן לבנות אחד כזה לכל פונקציה אפשרית על אותם משתנים - אבל נעזוב את זה).</p>
<p>יש לנו בדיוק 4 פונקציות על משתנה יחיד, ובדיוק 16 פונקציות על שני משתנים. חלק מהן טריוויאליות ולא מעניינות כל כך (למשל, <span class="math">\(f\left(x\right)=x\)</span> או <span class="math">\(f\left(x\right)=0\)</span>) ולכן אנחנו נוהגים להצטמצם לדיבור על תת-קבוצה מעניינת של פונקציות. שלוש הפונקציות הפופולריות ביותר הן NOT, AND ו-OR. אני משער שכולם מכירים אותן אבל אזכיר בכל זאת: NOT (שמסומנת לפעמים ב-<span class="math">\(\neg\)</span>) מקבלת ביט יחיד והופכת אותו - אם קיבלה 0 מחזירה 1, ואם קיבלה 1 מחזירה 0. AND (שמסומנת לפעמים ב-<span class="math">\(\wedge\)</span>) מקבלת שני ביטים ומחזירה 1 רק אם שניהם 1, אחרת מחזירה 0; ו-OR (שמסומנת לפעמים ב-<span class="math">\(\vee\)</span>) מקבלת שני ביטים ומחזירה 0 רק אם שניהם 0, אחרת מחזירה 1.</p>
<p>מסתבר שאפשר לבנות <strong>כל</strong> פונקציה <span class="math">\(f:\left\{ 0,1\right\} ^{n}\to\left\{ 0,1\right\} \)</span> באמצעות הרכבות של שערים כאלו - זה מה שמוכיח קיום צורה קנונית דוגמת DNF לפונקציות בוליאניות. לא אכנס לפרטים הללו כרגע כי זה לא חשוב. מה שכן מעניין הוא שלמרות הפופולריות של שערים אלו, למעשה אפשר היה "לחסוך" אותם ולהשתמש רק בשער אחד - שער שנקרא NAND, והוא מעין שילוב בין AND ו-NOT; הוא מקבל שני ביטים ומחזיר 0 רק אם שניהם 1, אחרת מחזיר 1. כל פונקציה בוליאנית ניתן לתאר עם מעגל שבנוי רק משערי NAND, אבל לרוב יותר נוח לתאר ולממש מעגלים כאלו עם פונקציות אחרות. לי יוצא, למשל, להתעסק הרבה עם מעגלים שמיוצגים בפורמט שנקרא And-Inverter Graph (ובקיצור AIG): בפורמט הזה המעגל בנוי כולו רק משערי AND ו-NOT, באופן שמאפשר ייצוג קומפקטי (כל שער AND מקבל מספר טבעי; הכניסות שלו מיוצגות על ידי שני מספרים שלמים, כאשר מספר שלילי פירושו שמפעילים NOT על הקלט לשער ממש לפני שהוא נכנס). אין צורך בשער OR כאן כי בעזרת כללי דה-מורגן אפשר "לסמלץ" אותו עם שערי AND ו-NOT.</p>
<p>עכשיו אפשר לעבור לדבר על שערים קוונטיים. בדומה לחישוב קלאסי, גם בשערים קוונטיים אנחנו מדברים על פעולה על מספר קטן של קיוביטים - נאמר, 3. רק שקיוביט היא יצור יותר מורכב מביט והערך שלו בכל שלב הוא סופרפוזיציה כלשהי של 0 ו-1. זה היתרון; החסרון הוא שהפעולות שאנחנו יכולים להפעיל על קיוביט, או על קבוצה שלהן, חייבות להיות <strong>אוניטריות</strong>. בפרט זה אומר שהן חייבות להיות הפיכות. ועכשיו לכו תבינו איך לממש שער כמו AND שהוא לא הפיך.</p>
<p>לפני שנדבר על שער מסובך נורא כמו AND, בואו נדבר על בעיה בסיסית יותר. במעגל קלאסי, ערך היציאה של שער כלשהו יכול לשמש בתור ערך הכניסה של הרבה שערים שונים, וגם קלט למעגל יכול להיכנס להרבה שערים שונים. זה לא מובן מאליו; זה אומר שברמת המימוש הפיזיקלית שלנו צריך איכשהו <strong>לשכפל</strong> את הערך של הביט. במחשב קלאסי אין בעיה לעשות את זה, אבל במחשב קוונטי? כבר אמרתי בפוסט קודם שבתורת הקוונטים מתקיים משפט בסיסי שנקרא No Cloning theorem שאומר שבלתי אפשרי לשכפל מצב קוונטי כללי.</p>
<p>אז מה כן אפשר לעשות? ובכן, אפשר <strong>לבזבז</strong> קיוביט על ביצוע ההעתקה הזו. למה אני מתכוון? זכרו שהאופן שבו אני מתאר חישוב קוונטי הוא כזה שבו אנחנו מתחילים עם הקלט שלנו <span class="math">\(\left|x\right\rangle \)</span> במצב קוונטי כלשהו, אבל המערכת שלנו כוללת עוד קיוביטים "לשימוש כללי", כך שהמצב של המערכת כולה הוא <span class="math">\(\left|x\right\rangle \left|0\dots0\right\rangle \)</span>. מה שנוכל לעשות הוא לקחת את אחד מהקיוביטים העודפים הללו, שנמצא במצב <span class="math">\(\left|0\right\rangle \)</span>, ולהחליף אותו בקיוביט שאנחנו רוצים לשכפל. זה "יבזבז" לנו את הקיוביט הזה, כי לא נוכל להשתמש בו שוב בעתיד בשביל אותו תעלול, אבל אם יש לנו מלאי התחלתי גדול מספיק של קיוביטים שאפשר לבזבז זו לא בעיה.</p>
<p>מה שאנחנו מחפשים, אם כן, הוא שער שיקבל שני קיוביטים <span class="math">\(\left|a\right\rangle \left|b\right\rangle \)</span> ויחזיר <span class="math">\(\left|a^{\prime}\right\rangle \left|b^{\prime}\right\rangle \)</span> כך שאם <span class="math">\(b=0\)</span> אז <span class="math">\(b^{\prime}=a\)</span>. שער כזה הוא קל למימוש: <span class="math">\(\left|a\right\rangle \left|b\right\rangle \mapsto\left|a\right\rangle \left|a\oplus b\right\rangle \)</span>. קל לראות שזה אופרטור אוניטרי (העובדה שהוא הפיך ברורה מכך שבהינתן <span class="math">\(\left|a^{\prime}\right\rangle \left|b^{\prime}\right\rangle \)</span> קל לשחזר את המצב המקורי: <span class="math">\(a=a^{\prime}\)</span> ו-<span class="math">\(b=a^{\prime}\oplus b^{\prime}\)</span>). כבר נתקלנו באופרטור הזה בפוסט קודם וקראנו לו <span class="math">\(C_{not}\)</span> קיצור של Controlled-Not, מכיוון שאם תחשבו על זה רגע תראו שמה שהוא עושה הוא לבצע NOT לקיוביט <span class="math">\(b\)</span> אם ורק אם <span class="math">\(a\)</span> היה 1 (ובקיוביט הראשון הוא לא נוגע).</p>
<p>עכשיו בואו נעבור לדבר על הבעיה השניה, בעיית ה-AND. אינטואיציה ראשונית שלי הייתה לנקוט בתעלול דומה. כלומר: <span class="math">\(\left|a\right\rangle \left|b\right\rangle \mapsto\left|a\right\rangle \left|a\wedge b\right\rangle \)</span>. זה רעיון נחמד אבל הוא לא עובד, כי <span class="math">\(\left|0\right\rangle \left|0\right\rangle \)</span> ו-<span class="math">\(\left|0\right\rangle \left|1\right\rangle \)</span> מתמפים שניהם ל-<span class="math">\(\left|0\right\rangle \left|0\right\rangle \)</span> ולכן הפעולה אינה הפיכה. אז מה כן אפשר לעשות? ובכן, אותו תעלול, אבל עם <strong>שלושה</strong> קיוביטים, כאשר אנחנו משמרים את שני הראשונים: <span class="math">\(\left|a\right\rangle \left|b\right\rangle \left|c\right\rangle \mapsto\left|a\right\rangle \left|b\right\rangle \left|c\oplus\left(a\wedge b\right)\right\rangle \)</span>. אם מפעילים את הפעולה הזו על המצב <span class="math">\(\left|a\right\rangle \left|b\right\rangle \left|0\right\rangle \)</span> (כלומר, התעלקנו על קיוביט <span class="math">\(\left|0\right\rangle \)</span> טרי) אז מקבלים בדיוק את <span class="math">\(\left|a\right\rangle \left|b\right\rangle \left|a\wedge b\right\rangle \)</span> כפי שאנחנו רוצים.</p>
<p>הפעולה הזו היא מעין שער <span class="math">\(C_{not}\)</span> מתוחכם: היא הופכת את <span class="math">\(c\)</span> רק אם גם <span class="math">\(a\)</span> וגם <span class="math">\(b\)</span> שניהם 1. בשל כך נהוג לקרוא לה בשם שער <span class="math">\(CC_{not}\)</span> (או לפעמים "שער טופולי" על שם ממציאו). אפשר, כמובן, גם להגדיר שער כזה בחישוב קלאסי: שני הביטים הראשונים של הפלט אינם מעניינים (כי אפשר לשכפל ביטים בחישוב קלאסי) כך שהשער בגרסתו הקלאסית הוא מהצורה <span class="math">\(CC_{not}\left(a,b,c\right)=c\oplus\left(a\wedge b\right)\)</span>. השער הקלאסי הזה, בדומה ל-NAND, הוא אוניברסלי. כדי להיווכח באוניברסליות הזו מספיק לשים לב שאפשר לסמלץ עם השער פעולות AND ו-NOT, וזה קל: <span class="math">\(\neg x=CC_{not}\left(1,1,x\right)\)</span> ו-<span class="math">\(a\wedge b=CC_{not}\left(a,b,0\right)\)</span>.</p>
<p>המשמעות של האוניברסליות הזו עבור חישוב קוונטי היא זו: אם יש לנו פונקציה בוליאנית <span class="math">\(f:\left\{ 0,1\right\} ^{n}\to\left\{ 0,1\right\} \)</span> כלשהי, אז קיים מעגל שמכיל רק שערי טופולי, שמבצע את הטרנספורמציה הבאה: <span class="math">\(\left|x_{1}\dots x_{n}\right\rangle \left|0\dots0\right\rangle \mapsto\left|x_{1}\dots x_{n}\right\rangle \left|f\left(x\right)\right\rangle \left|b_{1}\dots b_{m}\right\rangle \)</span>. כאן ה-<span class="math">\(b_{1},\dots,,b_{m}\)</span> הם קיוביטים "זבליים" שקיבלו ערך כלשהו במהלך החישוב ולכו תדעו מה קורה איתם עכשיו - פשוט לא מתעסקים איתם יותר. האוניברסליות הזו מראה לנו די בקלות שחישוב קוונטי מכליל חישוב רגיל - כל מה שצריך לעשות הוא לבצע את החישוב של המעגל ולמדוד את הקיוביט הנכון, שבודאות יהיה ב-<span class="math">\(f\left(x\right)\)</span>. יש כאן גם, כמובן, ענייני סיבוכיות שלא אכנס אליהם.</p>
<p>מה שצריך לשים לב אליו הוא שה"אוניברסליות" של שער טופולי אינה אוניברסליות של חישוב קוונטי. כלומר, קיימים אופרטורים קוונטיים שלא ניתן לסמלץ רק בעזרת שערי טופולי. למעשה, על פניו נראה ש"אוניברסליות" של סט שערים קוונטיים היא עניין בעייתי, בגלל העושר הגדול של אופרטורים שאפשר לדבר עליהם - לכל <span class="math">\(n\)</span> יש אינסוף אופרטורים שפועלים על רגיסטר של <span class="math">\(n\)</span> קיוביטים, והאופרטורים הללו הם מעל <span class="math">\(\mathbb{C}\)</span>, כלומר המקדמים שלהם הם מספרים מרוכבים כלליים - מספר לא בן מניה בכלל. לכן כשמדברים על אוניברסליות לא הולכים על הגישה התובענית ביותר, של לסמלץ את כל האופרטורים; מספיק מבחינתנו שאפשר יהיה <strong>לקרב</strong> אותם ברמה סבירה. אפשר להוכיח שבהינתן קירובים טובים שכאלו, החישוב הסופי יתנהג כמעט כמו חישוב עם האופרטורים האמיתיים ולא המקורבים - ומכיוון שתוצאת החישוב היא הסתברותית ממילא, זה לא משנה הרבה. אני לא אכנס כאן להגדרה הפורמלית של רמת הקירוב שנדרשת; מספיק שהבנו את הרעיון.</p>
<p>על מנת לבצע חישוב קוונטי אוניברסלי שכזה, מספיק להשתמש בשערי טופולי, בשערי הדאמר <span class="math">\(H\)</span> ובשער נוסף שפועל על קיוביט יחיד ומסומן באות <span class="math">\(S\)</span> ומתואר על ידי המטריצה <span class="math">\(\left[\begin{array}{cc}1 &amp; 0\\0 &amp; i\end{array}\right]\)</span>; לא אכנס להוכחה שהם מספיקים. בפועל משתמשים בהרבה יותר שערים כדי לתאר בנוחות חישובים קוונטיים. הזכרתי כבר את השערים <span class="math">\(X,Y,Z\)</span> שמתאימים למטריצות פאולי - למשל <span class="math">\(X=\left[\begin{array}{cc}0 &amp; 1\\1 &amp; 0\end{array}\right]\)</span>. אולי כדאי לומר על <span class="math">\(X\)</span> עוד מילה: על פניו <span class="math">\(X\)</span> הוא האנלוג הקוונטי לשער NOT, שהרי <span class="math">\(X\left|0\right\rangle =\left|1\right\rangle \)</span> ו-<span class="math">\(X\left|1\right\rangle =\left|0\right\rangle \)</span>; אבל שימו לב שמתקיים, למשל, <span class="math">\(X\left|+\right\rangle =X\left(\frac{\left|0\right\rangle +\left|1\right\rangle }{\sqrt{2}}\right)=\left|+\right\rangle \)</span>, וזה כבר פחות מתאים לאינטואיציה שלנו לגבי NOT, כך שצריך להיזהר.</p>
<p>בעזרת השערים הללו וכמה תעלולים שלא אתאר כרגע ניתן לבנות שערים שהם מעין הכללה מרחיקת לכת של <span class="math">\(CC_{not}\)</span>. חשבו על אופרטור קוונטי <span class="math">\(U\)</span> כלשהו, אז ניתן לבנות מעגל משערים קוונטיים בסיסיים כך ש-<span class="math">\(\left|x\right\rangle \left|y\right\rangle \mapsto\left|x\right\rangle U^{x_{1}\cdots x_{n}}\left|y\right\rangle \)</span>, כאשר <span class="math">\(x,y\)</span> יכולים להיות מורכבים כל אחד ממספר קיוביטים. מה שזה אומר: אם כל ה-<span class="math">\(x\)</span>-ים הם 1, אז הפעל את <span class="math">\(U\)</span> על ה-<span class="math">\(y\)</span>; אחרת השאר אותו ללא שינוי. זה מעין Controlled-U. זה גם בדיוק השער שלו נזקקנו בפוסט הקודם של אלגוריתם גרובר - שער שבדק אם כל הקיוביטים במצב קוונטי כלשהו הם 0, ואם כן הוא העביר אותו למצב אחר ואחרת השאיר אותו ללא שינוי. אפשר לבנות מעגל עבור השער הזה די בקלות - לוקחים את הקיוביטים של המצב, מעתיקים אותם על גבי קיוביטים "לכתיבה בלבד" טריים, הופכים אותם עם <span class="math">\(X\)</span> ואז משתמשים בשער ה-Controlled-U. הפרטים של הבניות הללו הם מעניינים למדי, אבל כאמור - בפוסט הזה לא התכוונתי להיכנס אליהם ברצינות. המטרה העיקרית שלי הייתה לקבל קצת יותר תחושה של "למה זה אפשרי" לפני שאנחנו מגיעים לאקשן האלגוריתמי הרציני שלנו.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_site/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>