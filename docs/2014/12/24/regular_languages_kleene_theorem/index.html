<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>שפות רגולריות - משפט קלייני - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2014/12/21/regular_languages_closure_2/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">שפות רגולריות - תכונות סגור (חלק ב&#39;)</span>
            </a>
            

            
            <a href="/2015/01/12/mixumia/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">מיקסומיה - תורת הטבע השלמה</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>שפות רגולריות - משפט קלייני</h1>
            <div class="post-meta">
                <span class="date">2014-12-24</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/משפט קלייני.html">משפט קלייני</a>
                    
                    <a href="/tags/שפות רגולריות.html">שפות רגולריות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>את הדיון שלי על שפות רגולריות התחלתי בהצגה של מושג האוטומט הסופי הדטרמיניסטי. האוטומט הזה היה מין מכונת חישוב תאורטית שמבצעת פעולה של <strong>זיהוי</strong> מתי מילה שייכת או לא שייכת לשפה כלשהי. הגדרתי את אוסף <strong>השפות הרגולריות</strong> בתור השפות שמתקבלות על ידי אוטומט כזה. אחר כך התחלתי להתעסק בתכונות סגור של שפות רגולריות - פעולות שאפשר להפעיל על שפות רגולריות קיימות ולקבל כתוצרים שפות רגולריות חדשות - כשחלק מהיעד שלי היה למצוא קבוצה קטנה יחסית של פעולות סגור ו"שפות בסיס" שמהן ניתן ליצור את כל השפות הרגולריות. את מה שהגעתי אליו בסופו של דבר אפשר לנסח כך: שפות הבסיס הן כל השפות שיש בהן לכל היותר מילה אחת מאורך לכל היותר 1; ופעולות הסגור הן איחוד, שרשור וסגור-קלייני. הטענה הזו נקראת לפעמים "משפט קלייני" וכך אקרא לה כאן (אין קונצנזוס בשפות על מה בדיוק נקרא "משפט קלייני" בהקשר של שפות רגולריות; יש כמה ניסוחים שונים ואני לא אכנס לדיון הזה כי הוא משעמם).</p>
<p>בפוסט הזה אני רוצה להוכיח את הטענה הזו בצורה פורמלית יחסית. בואו נתחיל.</p>
<p>אם כבר פורמליזם, צריך לזכור שברקע של הדיון שלנו תמיד יש קבוצה סופית <span class="math">\(\Sigma\)</span> שנקראת <strong>אלפבית</strong> - מתוכה נלקחות האותיות שמהן נבנות מילים. כשאני מדבר על שפות רגולריות, אני בעצם אומר "השפות הרגולריות שמורכבות ממילים שבנויות מתוך אותיות <span class="math">\(\Sigma\)</span>". כל מה שאעשה בהמשך לא ממש תלוי ב-<span class="math">\(\Sigma\)</span> (אולי אניח באופן מובלע שזו לא קבוצה ריקה אחרת אין בכלל מילים חוץ מהמילה הריקה) במובן זה שלכל <span class="math">\(\Sigma\)</span> סופית ההוכחות עובדות באותה מידה בדיוק.</p>
<p>קבוצת שפות הבסיס שלי, אם כן, היא הקבוצה הבאה: <span class="math">\(\left\{ \emptyset,\left\{ \varepsilon\right\} \right\} \cup\left\{ \left\{ \sigma\right\} \ |\ \sigma\in\Sigma\right\} \)</span>. דהיינו, השפה הריקה, השפה שהאיבר היחיד שלה הוא המילה הריקה, והשפה שהאיבר היחיד שלה הוא המילה מאורך 1 <span class="math">\(\sigma\)</span>, לכל אות <span class="math">\(\sigma\in\Sigma\)</span>.</p>
<p>מבין פעולות הסגור, איחוד שפות זו פשוט פעולת האיחוד הרגילה של קבוצות. שרשור של שפות הוגדר להיות <span class="math">\(L_{1}\cdot L_{2}\triangleq\left\{ w_{1}w_{2}\ |\ w_{1}\in L_{1},w_{2}\in L_{2}\right\} \)</span> (כששרשור של מילים מוגדר בצורה הרגילה - המילה שמתקבלת מ"הדבקת" שתי המילים על פי הסדר שלהן). סגור-קלייני היה הפעולה המסובכת ביותר והפחות טבעית מבין הפעולות: <span class="math">\(L^{*}\triangleq\bigcup_{n=0}^{\infty}L^{n}\)</span>, כאשר חזקה של שפות מוגדרת באופן הטבעי: <span class="math">\(L^{0}\triangleq\left\{ \varepsilon\right\} \)</span> ו-<span class="math">\(L^{n+1}\triangleq L^{n}\cdot L\)</span>. כזכור, הגדרתי את סגור-קליניי מלכתחילה כי הייתה לי "אינטואיציה" שזו הפעולה שאזדקק לה כדי להוכיח את משפט קלייני. מה שיהיה נחמד בהוכחה (בין היתר) הוא שנבין <strong>בדיוק</strong> למה צריך דווקא את הפעולה הזו.</p>
<p>המשפט אומר שקבוצת השפות הרגולריות היא הקבוצה שנוצרת אינדוקטיבית מהבסיס ופעולות היצירה הללו. לא חייבים להבין מה זו קבוצה נוצרת אינדוקטיבית, אבל זה לא יזיק אז אקדיש לכך כמה פסקאות ואפשר לדלג אם רוצים. הרעיון הוא שזו <strong>הקבוצה הקטנה ביותר</strong> שמכילה את הבסיס וסגורה לפעולות היצירה. באופן כללי, אם יש לי "עולם" <span class="math">\(X\)</span>, קבוצת <strong>בסיס</strong> <span class="math">\(B\subseteq X\)</span> וקבוצה <span class="math">\(F\)</span> של <strong>פעולות יצירה </strong>שהן פונקציות מהצורה <span class="math">\(f:X^{n}\to X\)</span> (כלומר, פונקציות שמקבלות <span class="math">\(n\)</span> קלטים, כאשר <span class="math">\(n\)</span> יכול להיות מספר טבעי חיובי כלשהו), אז אסמן ב-<span class="math">\(X_{B,F}\)</span> את הקבוצה הקטנה ביותר כך ש-<span class="math">\(B\subseteq X_{B,F}\)</span> ולכל <span class="math">\(f\in F\)</span> מתקיים ש-<span class="math">\(f\left(X_{B,F}\right)\subseteq X_{B,F}\)</span> (הסימון "<span class="math">\(f\left(D\right)\)</span>" לקבוצה <span class="math">\(D\)</span> כלשהו פירושו כל הפלטים שמקבלים כאשר מציבים ב-<span class="math">\(f\)</span> את כל הקומבינציות האפשריות של איברים ב-<span class="math">\(D\)</span>; הסיבה שאני בכלל טורח לומר זאת במפורש היא שאם <span class="math">\(f\)</span> היא פונקציה שמקבלת כמה קלטים, יכול להיראות לחלקכם מוזר שפתאום אני מכניס לה את ה"קלט" <span class="math">\(D\)</span>. זה לא באמת קלט; זה סימון של התמונה של <span class="math">\(f\)</span>).</p>
<p>עכשיו, תשאלו, למה הקבוצה הזו בכלל קיימת? ובכן, הנה טענה חביבה: <span class="math">\(X_{B,F}=\bigcap\left\{ D\subseteq X\ |\ B\subseteq D\wedge\forall f\in F:f\left(D\right)\subseteq D\right\} \)</span>. במילים: <span class="math">\(X_{B,F}\)</span> מתקבלת מחיתוך כל הקבוצות שמכילות את <span class="math">\(B\)</span> וסגורות תחת <span class="math">\(F\)</span>. זו דרך סטנדרטית במתמטיקה להגדיר אובייקטים "הכי קטנים" שכאלו באמצעות חיתוך מסוג זה. חשוב לשים לב לכך שהחיתוך לא נלקח מעל קבוצה ריקה של אובייקטים; <span class="math">\(X\)</span> עצמו תמיד נכלל כאיבר בחיתוך. לכן החיתוך מוגדר היטב, ולא קשה להוכיח שהוא אכן שווה ל-<span class="math">\(X_{B,F}\)</span>.</p>
<p>מה שנחמד ב-<span class="math">\(X_{B,F}\)</span> הוא שקל להוכיח עליה טענות באינדוקציה: מוכיחים שמשהו מתקיים עבור <span class="math">\(B\)</span> ומשתמר עבור כל <span class="math">\(f\in F\)</span> ומקבלים שאותו משהו מתקיים לכל <span class="math">\(X_{B,F}\)</span>. בעזרת אינדוקציית מבנה שכזו אפשר להוכיח, למשל, שאיבר כלשהו שייך ל-<span class="math">\(X_{B,F}\)</span> אם ורק אם קיימת לו <strong>סדרת יצירה</strong> - סדרה סופית שכל איבר בה הוא או איבר של <span class="math">\(B\)</span> או מתקבל מאיברים קודמים בסדרה על ידי הפעלת <span class="math">\(f\)</span>, והאיבר האחרון בה הוא האיבר שהסדרה "יוצרת". אולי לחלקכם זה מזכיר את האופן שבו מתוארות הוכחות במתמטיקה - סדרה של טענות כך שכל טענה היא אקסיומה או הנחה או נובעת מקודמותיה על ידי כלל היסק. זה כמובן לא מקרי - אפשר להגדיר את "קבוצת המשפטים היכיחים" (מאקסיומות/הנחות נתונות ועם כללי היסק נתונים) בדיוק בתור קבוצה אינדוקטיבית שכזו.</p>
<p>חזרה לענייננו - המסקנה שלנו מכל הדיון שלמעלה היא שכדי להוכיח את משפט קלייני, צריך לעשות שני דברים. ראשית, להוכיח שקבוצת השפות הרגולריות אכן כוללת את הבסיס וסגורה ביחס לפעולות הסגור. את זה עשיתי בפוסטים הקודמים. הדבר השני שצריך להראות הוא שכל שפה רגולרית אכן ניתנת ליצירה מתוך הבסיס בעזרת פעולות הסגור, במספר סופי של פעולות (זו "סדרת היצירה" המדוברת). זה מה שנעשה בפוסט הזה.</p>
<p>אם כן, הבה וניקח אוטומט סופי דטרמיניסטי כלשהו, <span class="math">\(A=\left(\Sigma,Q,q_{1},\delta,F\right)\)</span>. אני מסמן את מצבי האוטומט בתור <span class="math">\(Q=\left\{ q_{1},q_{2},\dots,q_{n}\right\} \)</span>. שימו לב שאני בוחר הפעם לסמן את המצב ההתחלתי של האוטומט ב-<span class="math">\(q_{1}\)</span> במקום ב-<span class="math">\(q_{0}\)</span> כרגיל; הסיבה לכך תתברר בהמשך אבל היא לא משהו קריטי - זה פשוט יפשט קצת סימון אחר שאציג עוד מעט.</p>
<p>עכשיו אפשר סוף סוף לדבר על השאלה המרכזית שלנו - איך לכל הרוחות פעולות היצירה שלנו קשורות בכלל למה שאוטומט סופי דטרמיניסטי עושה? אוטומט רץ על מילים וחושב מחשבות עמוקות ובסוף פולט תשובה. פעולות יצירה... ובכן, הן בונות שפות. מה הקשר? איך בכלל ניגשים לזה? זו שאלה טובה מאוד ולא פשוטה בכלל, והעובדה שיש לה תשובה חדה ואלגנטית שפותרת את הכל היא אחת הסיבות שבגללן התוצאה הזו יפה כל כך.</p>
<p>כדי להגיע לתשובה הזו, בואו ננסה לחשוב שניה באופן הבא: שפות הן קבוצות של מילים. מה זו מילה עבור אוטומט? קל להגיד "מה שהוא רץ עליה ומכריע אם היא בשפה או לא", אבל בעצם מילה היא יותר מזה - מילה היא אובייקט ש<strong>פועל</strong> על האוטומט - גורם לו לעבור ממצב א' אל מצב ב'. מכיוון שאנחנו עוסקים כאן באוטומט סופי דטרמיניסטי, שאין לו זכרון בשום מקום מלבד המצבים שלו, כדי להבין באופן מלא מה האוטומט עושה, צריך רק להבין את אותן פעולות - מה גורם לאוטומט לעבור ממצב א' למצב ב'.</p>
<p>אז אני יכול לנסות ולהגדיר שפות באופן הבא: לכל זוג מצבים <span class="math">\(q,p\in Q\)</span> נגדיר <span class="math">\(L_{q,p}=\left\{ w\in\Sigma^{*}\ |\ \hat{\delta}\left(q,w\right)=p\right\} \)</span> - שפת כל המילים שמעבירות את האוטומט מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span>. אם נצליח לבנות את השפות הללו, בבירור סיימנו, כי <span class="math">\(L\left(A\right)=\bigcup_{p\in F}L_{q_{0},p}\)</span> (שפת האוטומט היא אוסף כל המילים שמעבירות את האוטומט מהמצב ההתחלתי <span class="math">\(q_{0}\)</span> אל מצב מקבל כלשהו <span class="math">\(p\in F\)</span>). אז מה הבעיה? שאין לי מושג איך לבנות את <span class="math">\(L_{q,p}\)</span>, מן הסתם. זו עדיין שפה מסובכת, אפילו אם היא אולי פחות מסובכת מ"כל המילים שהאוטומט מקבל".</p>
<p>אם השתמשתי בטריק של "לעבור מהשפה הקשה <span class="math">\(L\left(A\right)\)</span> לאיחוד של שפות יותר פשוטות מהצורה <span class="math">\(L_{q,p}\)</span>" אולי אפשר לעשות את התעלול הזה שוב? אני אוטומטית חושב על כך שאפשר לפרק את <span class="math">\(L_{q,p}\)</span> על פי <strong>אורך</strong> המילים. כלומר, אסמן <span class="math">\(L_{q,p}^{k}\triangleq\left\{ w\in L_{q,p}\ |\ \left|w\right|=k\right\} \)</span> ואז <span class="math">\(L_{q,p}=\bigcup_{k=0}^{\infty}L_{q,p}^{k}\)</span>. על פניו זה רעיון די טוב, כי אני יכול לתאר את <span class="math">\(L_{q,p}^{k}\)</span> באופן <strong>אינדוקטיבי</strong> על פי פירוק לפי הצעד האחרון: <span class="math">\(L_{q,p}^{k}=\bigcup_{i=1}^{n}\left\{ w\sigma\ |\ w\in L_{q,q_{i}}^{k-1}\wedge\delta\left(q_{i},\sigma\right)=p\right\} \)</span>. במילים: <span class="math">\(L_{q,p}^{k}\)</span> כוללת את כל המילים מהצורה <span class="math">\(w\sigma\)</span> כך ש-<span class="math">\(w\)</span> היא מאורך <span class="math">\(k-1\)</span> ומעבירה את האוטומט מ-<span class="math">\(q\)</span> אל מצב <span class="math">\(q_{i}\)</span> כלשהו, ואילו <span class="math">\(\sigma\)</span> מעבירה אותנו מ-<span class="math">\(q_{i}\)</span> אל <span class="math">\(p\)</span>.</p>
<p>זה לא עובד. זה רעיון נחמד, אבל זה לא עובד. לא בגלל שזה לא נכון, אלא בגלל המשוואה הזו: <span class="math">\(L_{q,p}=\bigcup_{k=0}^{\infty}L_{q,p}^{k}\)</span>. כתבתי בכוונה את המשוואה הזו בצורה מטעה. אם נלך על פי ההגדרות היבשות שנתתי קודם, הרי ש-<span class="math">\(\bigcup_{k=0}^{\infty}L_{q,p}^{k}\)</span> היא בעצם <span class="math">\(L_{p,q}^{*}\)</span> וזה כמובן לא נכון, כי ה-<span class="math">\(k\)</span> שמופיע ב-<span class="math">\(L_{q,p}^{k}\)</span> הוא לא חזקה של שפה - הוא בסך הכל חלק מהסימון שאני משתמש בו. אני בכוונה מנסה להטעות אתכם ככה כדי להכריח אתכם לחשוב קצת ולהבין מה השתבש כאן. זה חשוב.</p>
<p>אם כן, המשוואה <span class="math">\(L_{q,p}=\bigcup_{k=0}^{\infty}L_{q,p}^{k}\)</span> היא אמנם נכונה לגמרי, אבל היא מציגה את <span class="math">\(L_{q,p}\)</span> בתור איחוד אינסופי של שפות - ואיחוד אינסופי שכזה הוא לא בהכרח רגולרי גם אם השפות המעורבות רגולריות. לכן כל הגישה שלנו של לפרק את <span class="math">\(L_{q,p}\)</span> על פי אורך המילה נידונה לכישלון - אורכי המילים הם לא חסומים ולכן בהכרח נקבל איחודים אינסופיים בעייתיים.</p>
<p>אז חזרה אל שולחן השרטוט ואל השאלה הבסיסית שלנו - מה <strong>כן</strong> חסום כאן? והתשובה ברורה - מספר המצבים של האוטומט <span class="math">\(A\)</span>, שהוא בדיוק <span class="math">\(n\)</span>. אבל איך אפשר להשתמש בזה כדי לפשט את <span class="math">\(L_{q,p}\)</span>?</p>
<p>אנחנו רוצים איכשהו <strong>להגביל</strong> את המילים ב-<span class="math">\(L_{q,p}\)</span> ולקחת רק חלק מהן. קודם הגבלנו על פי אורך. עכשיו אני רוצה להגביל איכשהו על פי מצבי האוטומט. אני יודע שהמילים ב-<span class="math">\(L_{q,p}\)</span> מעבירות את האוטומט מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span>, אז איך שאר מצבי האוטומט יכולים להיכנס לתמונה? מתי הם רלוונטיים? ובכן, בדיוק כשאנחנו מסתכלים על <strong>המסלול</strong> שמעביר אותנו מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span>. אם אני רוצה <strong>להגביל</strong>, מה אני יכול לעשות? לי נראה ברור (כי ברור שהכל נראה לי ברור בדיעבד, כשאני כבר מכיר את ההוכחה...) שהדרך הנכונה להגביל היא <strong>לאסור</strong> על מעבר במצבים מסויימים. אפשר להמשיך עם המשחק הזה עוד קצת, אבל אני מאמין שמכאן ועד להגדרה הנכונה זה בעיקר ניסוי וטעיה וגישוש, אז הנה אתן את ההגדרה המרכזית כאן, שפותרת את הכל:</p>
<p>אני אגדיר את <span class="math">\(L_{q,p}^{k}\)</span> (כאשר שוב, ה-<span class="math">\(k\)</span> הזה <strong>הוא לא</strong> חזקה, הוא סתם סימון) להיות שפת כל המילים שמעבירות את האוטומט מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span>, באופן כזה שהמסלול מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span> לא עובר באף מצב שהאינדקס שלו גדול מ-<span class="math">\(k\)</span>. דגש על המילה <strong>עובר</strong>: האוטומט יכול <strong>להתחיל</strong> או <strong>לסיים</strong> את המסלול במצב שהאינדקס שלו גדול מ-<span class="math">\(k\)</span>. כלומר, מותר ל-<span class="math">\(q\)</span> או <span class="math">\(p\)</span> עצמם להיות בעלי אינדקס גדול מ-<span class="math">\(k\)</span>, כל עוד הם מופיעים רק בהתחלה ובסוף ולא בתוך המסלול בעצמם.</p>
<p>ומכיוון שאי אפשר רק עם הגדרה מילולית, הנה הגדרה פורמלית:</p>
<p><span class="math">\(L_{q,p}^{k}\triangleq\left\{ w\in\Sigma^{*}\ |\ \hat{\delta}\left(q,w\right)=p\wedge\forall u\ne\varepsilon,w:w=uv\wedge\hat{\delta}\left(q,u\right)=q_{i}\Rightarrow i\le k\right\} \)</span></p>
<p>ההגדרה הזו אומרת - כל המילים <span class="math">\(w\in\Sigma^{*}\)</span> כך שקודם כל, <span class="math">\(w\)</span> מעבירה את האוטומט מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span>; וחוץ מזה, לכל פירוק <span class="math">\(w=uv\)</span> לא טריוויאלי (כלומר, ש-<span class="math">\(u\)</span> היא לא ריקה או לא כל <span class="math">\(w\)</span>), המצב שאליו מגיעים מ-<span class="math">\(q\)</span> אחרי קריאת <span class="math">\(u\)</span> הוא בעל אינדקס קטן או שווה ל-<span class="math">\(k\)</span>.</p>
<p>זהו זה. ההגדרה הזו פותרת את הכל. עד כדי כך שאני ממליץ לכם לא לנסות להמשיך לקרוא את ההוכחה אלא לנסות להמשיך להוכיח בעצמכם לפי שתיגשו לקרוא את המשך ההוכחה שלי.</p>
<p>המשך ההוכחה הוא זה: אני הולך להוכיח באופן אינדוקטיבי שכל השפות <span class="math">\(L_{q,p}^{k}\)</span> הן נוצרות אינדוקטיבית מקבוצות הבסיס באמצעות פעולות הסגור (עבור <span class="math">\(p,q\in Q\)</span> כלשהם ו-<span class="math">\(0\le k\le n\)</span>). זה יסיים את ההוכחה בגלל שברור לחלוטין ש-<span class="math">\(L_{q,p}^{n}=L_{q,p}\)</span> (כי אם המגבלה שלנו על המילים ב-<span class="math">\(L_{q,p}\)</span> היא "בקריאה שלכן אסור לעבור במצב עם אינדקס גדול מ-<span class="math">\(n\)</span>" והאינדקס הגדול ביותר של מצב באוטומט הוא <span class="math">\(n\)</span>, אין מגבלה). האינדוקציה תהיה על <span class="math">\(k\)</span>.</p>
<p>נתחיל מ-<span class="math">\(k=0\)</span>. במקרה הזה, <span class="math">\(L_{q,p}^{k}\)</span> היא שפה מוגבלת במיוחד. מכיוון שבחרתי שהאינדקס של מצב באוטומט שלי יתחיל מ-1 (ו<strong>זו</strong> הסיבה שבגללה בחרתי את הבחירה הזו, אחרת הייתי צריך להתחיל מ-<span class="math">\(k=-1\)</span>) הרי ש-<span class="math">\(L_{q,p}^{0}\)</span> היא שפת כל המילים <span class="math">\(w\)</span> שקריאתן מעבירה את <span class="math">\(q\)</span> ל-<span class="math">\(p\)</span> <strong>בלי מצבי ביניים בכלל</strong>. כלומר, מעבירה בלכל היותר צעד אחד. זה מראה מייד ש-<span class="math">\(L_{q,p}^{0}\)</span> היא איחוד סופי של שפות בסיס שלנו, או שהיא <span class="math">\(\emptyset\)</span> שגם היא שפת בסיס. אבל אני ארחיב קצת עבור מי שלא רואה את זה.</p>
<p>ראשית, שימו לב לכך ש-<span class="math">\(q=p\)</span> אם ורק אם <span class="math">\(\varepsilon\in L_{q,p}^{0}\)</span> (כי <span class="math">\(\hat{\delta}\left(q,\varepsilon\right)=q\)</span> - כך זה הוגדר). כמו כן, לכל <span class="math">\(\sigma\in\Sigma\)</span> מתקיים ש-<span class="math">\(\delta\left(q,\sigma\right)=p\)</span> אם ורק אם <span class="math">\(\sigma\in L_{q,p}^{0}\)</span>. זה אומר שאפשר לכתוב את השפה שלנו בקיצור בתור:</p>
<p><span class="math">\(L_{q,p}^{0}=\left\{ \tau\in\Sigma\cup\left\{ \varepsilon\right\} \ |\ \hat{\delta}\left(q,\tau\right)=p\right\} =\bigcup_{\hat{\delta}\left(q,\tau\right)=p}\left\{ \tau\right\} \)</span></p>
<p>מכיוון ש-<span class="math">\(\tau\in\Sigma\cup\left\{ \varepsilon\right\} \)</span>, כל שפה מהצורה <span class="math">\(\left\{ \tau\right\} \)</span> היא אחת משפות הבסיס שלנו. ואם יוצא ש-<span class="math">\(L_{q,p}^{0}=\emptyset\)</span> גם זה בסדר כי גם <span class="math">\(\emptyset\)</span> היא אחת משפות הבסיס שלנו. וזה כמובן לא מקרי - זו הסיבה שבגללה בחרנו את שפות הבסיס הללו.</p>
<p>סיימנו עם בסיס האינדוקציה שלנו. כעת לאקשן האמיתי: נניח שכל השפות <span class="math">\(L_{q,p}^{k-1}\)</span> עבור <span class="math">\(q,p\in Q\)</span> כלשהם הן אינדוקטיביות (נוצרו מקבוצות הבסיס על ידי פעולות הסגור) ונוכיח ש-<span class="math">\(L_{q,p}^{k}\)</span> הן כאלו. כלומר, ניקח <span class="math">\(q,p\in Q\)</span> כלשהם ונראה איך אפשר "לבנות" את <span class="math">\(L_{q,p}^{k}\)</span> מתוך שפות עם <span class="math">\(k-1\)</span> למעלה, בעזרת פעולות הסגור.</p>
<p>נתחיל בשאלה המתבקשת - מה ההבדל בין <span class="math">\(L_{q,p}^{k}\)</span> ובין <span class="math">\(L_{q,p}^{k-1}\)</span>? ברור ש-<span class="math">\(L_{q,p}^{k-1}\subseteq L_{q,p}^{k}\)</span>; רק צריך להבין מי המילים ב-<span class="math">\(L_{q,p}^{k}\)</span> שלא נמצאות ב-<span class="math">\(L_{q,p}^{k-1}\)</span>. על פי הגדרה, אלו כל המילים שלא עוברות באף מצב ביניים עם אינדקס גדול מ-<span class="math">\(k\)</span>, אבל <strong>כן </strong>עוברות במצב ביניים עם אינדקס גדול מ-<span class="math">\(k-1\)</span> - כלומר, אלו בדיוק המילים שעוברות במצב <span class="math">\(q_{k}\)</span> לפחות פעם אחת.</p>
<p>עכשיו, בואו נניח ש-<span class="math">\(w\in L_{q,p}^{k}\)</span> היא מילה שמעבירה את <span class="math">\(q\)</span> ל-<span class="math">\(p\)</span> ועוברת ב-<span class="math">\(q_{k}\)</span> <strong>בדיוק</strong> פעם אחת (ובשאר הזמן היא עוברת רק במצבים עם אינדקס קטן יותר). זה אומר שאפשר לפרק אותה כך - <span class="math">\(w=uv\)</span> כך ש-<span class="math">\(u\)</span> מעבירה את <span class="math">\(q\)</span> אל <span class="math">\(q_{k}\)</span> ואילו <span class="math">\(v\)</span> מעבירה את <span class="math">\(q_{k}\)</span> אל <span class="math">\(p\)</span>, ובשני המקרים הללו לא עוברים במצב ביניים עם אינדקס גדול מ-<span class="math">\(k-1\)</span> - כי בכל <span class="math">\(w\)</span> לא עוברים במצב ביניים עם אינדקס גדול מ-<span class="math">\(k\)</span>, וכי <strong>בתוך</strong> הריצה של <span class="math">\(u\)</span> ושל <span class="math">\(v\)</span> לא מופיע <span class="math">\(q_{k}\)</span>, אלא רק ב<strong>קצוות</strong> של הריצה הזו (בסיום הריצה על <span class="math">\(u\)</span> ובתחילת הריצה על <span class="math">\(v\)</span>. מכאן ש-<span class="math">\(v\in L_{q,q_{k}}^{k-1}\)</span> ואילו <span class="math">\(u\in L_{q_{k},p}^{k-1}\)</span>.</p>
<p>המקרה הזה היה פשוט יחסית. בואו נעבור לרמת הסיבוך הבאה: נניח ש-<span class="math">\(w\in L_{q,p}^{k}\)</span> היא מילה שמעבירה את <span class="math">\(q\)</span> ל-<span class="math">\(p\)</span> ועוברת ב-<span class="math">\(q_{k}\)</span> בדיוק <strong>פעמיים</strong>. עכשיו אפשר לפרק את <span class="math">\(w\)</span> כך: <span class="math">\(w=uzv\)</span> כך ש-<span class="math">\(v\in L_{q,q_{k}}^{k-1}\)</span> ואילו <span class="math">\(u\in L_{q_{k},p}^{k-1}\)</span>. ומה עם <span class="math">\(z\)</span>? ובכן, הוא מייצג את החלק בריצה שבין ההגעה הראשונה ל-<span class="math">\(q_{k}\)</span> ובין ההגעה השניה ל-<span class="math">\(q_{k}\)</span>, כלומר <span class="math">\(z\in L_{q_{k},q_{k}}^{k-1}\)</span>.</p>
<p>ועכשיו בואו נניח ש-<span class="math">\(w\in L_{q,p}^{k}\)</span> היא מילה שמעבירה את <span class="math">\(q\)</span> ל-<span class="math">\(p\)</span> ועוברת ב-<span class="math">\(q_{k}\)</span> בדיוק <strong>שלוש פעמיים</strong>. עכשיו אפשר לפרק את <span class="math">\(w\)</span> בתור <span class="math">\(w=uz_{1}z_{2}v\)</span> כאשר <span class="math">\(z_{1},z_{2}\in L_{q_{k},q_{k}}^{k-1}\)</span>.כבר הבנתם לאן אני חותר? אם לא, בואו נדבר על מילה שעוברת ב-<span class="math">\(q_{k}\)</span> בדיוק <strong>ארבע</strong> פעמים - עכשיו נפרק אותה בתור <span class="math">\(uz_{1}z_{2}z_{3}v\)</span> כאשר <span class="math">\(z_{1},z_{2},z_{3}\in L_{q_{k},q_{k}}^{k-1}\)</span>. ובאופן כללי? באופן כללי זה מסורבל מדי לכתוב את כל ה-<span class="math">\(z\)</span>-ים הללו, ולכן אפשר להשתמש ב<strong>חזקה של שפה</strong>: אם <span class="math">\(w\in L_{q,p}^{k}\)</span> היא מילה שמעבירה את <span class="math">\(q\)</span> ל-<span class="math">\(p\)</span> ועוברת ב-<span class="math">\(q_{k}\)</span> בדיוק <span class="math">\(t\)</span> פעמים, אז אפשר לפרק אותה כך: <span class="math">\(w=uzv\)</span> כך ש-<span class="math">\(z\in\left(L_{q_{k},q_{k}}^{k-1}\right)^{t-1}\)</span>. הפעם ה-<span class="math">\(t-1\)</span> שמופיע למעלה הוא לא אינדקס אלא כן בא על תקן חזקה של שפה.</p>
<p>מה המסקנה? כדי לתאר את כל המילים ב-<span class="math">\(w\in L_{q,p}^{k}\backslash L_{q,p}^{k-1}\)</span> אנחנו רוצים לתאר את כל המילים שהן <strong>שרשור</strong> של מילה אחת מתוך <span class="math">\(L_{q,q_{k}}^{k-1}\)</span>, מילה אחת מתוך <span class="math">\(L_{q_{k},p}^{k-1}\)</span>, וביניהן מילה אחת מתוך אחת מהחזקות האפשריות של <span class="math">\(L_{q_{k},q_{k}}^{k-1}\)</span> - כל חזקה אפשרית. האם אנחנו מכירים פעולה שנותנת לנו את זה? בוודאי - זו <strong>בדיוק</strong> הפעולה של סגור-קלייני! אמרתי לכם שנבין סוף סוף למה <strong>בדיוק</strong> צריך את הפעולה הזו? הנה, זו הנקודה המדוייקת שבה היא צצה מעצמה.</p>
<p>נסכם. קיבלנו את המשוואה <span class="math">\(L_{q,p}^{k}=L_{q,p}^{k-1}\cup L_{q,q_{k}}^{k-1}\left(L_{q_{k},q_{k}}^{k-1}\right)^{*}L_{q_{k},p}^{k-1}\)</span>, והמשוואה הזו מסיימת את ההוכחה, כי היא מתארת את היצירה של <span class="math">\(L_{q,p}^{k}\)</span> מתוך שפות שאנחנו כבר יודעים ששייכות לקבוצה האינדוקטיבית שלנו, בעזרת פעולות הסגור שלנו (איחוד, שרשור וסגור-קלייני). בדרך כלל אני לא נוהג להתלהב ממשוואות כי זו לא הפואנטה במתמטיקה, אבל את המשוואה הזו אני אוהב בגלל הסיפור הציורי שהיא מספרת (כל הקטע הזה של "עובר ב-<span class="math">\(q_{k}\)</span> בדיוק כך-וכך פעמים"). אני מקווה שאתם מסכימים.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>