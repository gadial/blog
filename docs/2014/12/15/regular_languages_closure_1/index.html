<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>שפות רגולריות - תכונות סגור (חלק א&#39;) - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2014/12/15/regular_languages_closure_1/">
    <meta property="og:title" content="שפות רגולריות - תכונות סגור (חלק א&#39;)">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2014/12/15/regular_languages_closure_1/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="שפות רגולריות - תכונות סגור (חלק א&#39;)">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- Post-specific social media image -->
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2014/11/19/nondeterministic_automata/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">אוטומטים אי דטרמיניסטיים ושאר מריעין בישין</span>
            </a>
            

            
            <a href="/2014/12/21/regular_languages_closure_2/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">שפות רגולריות - תכונות סגור (חלק ב&#39;)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>שפות רגולריות - תכונות סגור (חלק א&#39;)</h1>
            <div class="post-meta">
                <span class="date">2014-12-15</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אוטומטים.html">אוטומטים</a>
                    
                    <a href="/tags/שפות רגולריות.html">שפות רגולריות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסטים הקודמים הצגתי כמה מודלים שונים של אוטומט סופי - דטרמיניסטי, לא דטרמיניסטי, ולא דטרמיניסטי עם מסעי <span class="math">\(\varepsilon\)</span>. שלושת המודלים הללו היו <strong>שקולים חישובית</strong> - כל שפה שניתן היה לזהות באחד מהם, היה ניתן לזהות גם באחרים (אולי עם אוטומט יותר מסובך). לקבוצת השפות שאפשר לזהות עם אוטומט כזה קראנו <strong>אוסף השפות הרגולריות</strong> (למעשה, תמיד יש לנו ברקע גם א"ב כלשהו שהשפות מוגדרות מעליו, כך שלדבר על <strong>ה</strong>שפות הרגולריות זה טיפה בעייתי כי יש אוסף שפות רגולריות מעל כל א"ב, אבל עזבו אתכם מהדקויות הללו, לא סתם קוראים לבלוג לא מדויק).</p>
<p>כמובן, חיש קל עולה מאליה השאלה - אילו שפות הן רגולריות? קל לראות שהשפה הריקה <span class="math">\(\emptyset\)</span> היא רגולרית - אוטומט עם מצב יחיד שאינו מקבל. קל גם לראות שאוסף כל המילים מעל <span class="math">\(\Sigma\)</span>, שאותו סימנתי בסימון <span class="math">\(\Sigma^{*}\)</span>, הוא רגולרי - אוטומט עם מצב יחיד שהוא מקבל וכל אות מובילה ממנו לעצמו. טיפה יותר מעניין לבנות אוטומט שמקבל בדיוק מילה אחת - לכל מילה <span class="math">\(w=\sigma_{1}\dots\sigma_{n}\)</span> האוטומט הזה יכלול <span class="math">\(n+1\)</span> מצבים שהאוטומט עובר בהם לפי הסדר כל עוד הוא קורא אותיות שמתאימות למילה <span class="math">\(w\)</span>, ואם מתישהו משהו השתבש או שהוא קיבל יותר מ-<span class="math">\(n\)</span> אותיות, הוא עובר למצב "בור" שאינו מקבל וכל קשת ממנו נכנסת חזרה אליו. נסו בעצמכם לצייר אוטומט כזה עבור מילים ספציפיות ולכתוב אותו פורמלית. זה קל.</p>
<p>מה שאני רוצה לטעון עכשיו הוא שכל שפה סופית היא רגולרית - זה צעד המשך מתבקש למה שכבר אמרתי. גם די ברור איך לבנות אוטומט לכל שפה סופית - בפרט אם מותר לי אי-דטרמיניזם, אני פשוט יכול לחזור על הבניה של האוטומט עבור מילה ספציפית עבור כמה מילים בבת אחת. אבל אני לא רוצה לעשות את זה. למעשה, אני רוצה לבנות כמה שפחות אוטומטים. לבנות אוטומטים זה לא מעניין. זו טרחה. יותר מכך, אם גם אני מרגיש מחוייב משום מה <strong>להוכיח</strong> שאוטומט נתון מקבל את השפה שאני טוען שהוא מקבל - זה כבר ממש קוץ בתחת. ומתמטיקאים הם עצלנים. אז מה שאני רוצה לעשות הוא למצוא דרך אלטרנטיבית לבנות שפות רגולריות חדשות מתוך שפות רגולריות קיימות. כלומר, אני מחפש <strong>פעולות</strong> שניתן להפעיל על שפות קיימות שיוצרות מהן שפות חדשות, באופן כזה שמובטח שאם הקלטים לפעולות הללו היו שפות רגולריות, גם השפה שמתקבלת כפלט היא רגולרית. לפעולות כאלו קוראים <strong>תכונות סגור</strong> (כי פורמלית, אלו הן פונקציות - אולי במספר משתנים - מקבוצות השפות לעצמה, שקבוצת השפות הרגולריות סגורה ביחס אליהן, במשמעות הסטנדרטית של "סגירות" שכזו במתמטיקה).</p>
<p>למעשה, כבר ראינו תכונת סגור בפוסט הקודם - לצורך חימום, הוכחתי שהשפות הרגולריות סגורות תחת חיתוך, על ידי בניית מה שקראתי לו "אוטומט מכפלה". אותה בניה, עם וריאציה חכמה על בחירת המצבים המקבלים, גם יכולה להראות סגירות תחת איחוד, אבל למעשה יש דרך פשוטה בהרבה להראות סגירות לאיחוד: בהינתן שפות רגולריות <span class="math">\(L_{1},L_{2}\)</span> נבנה אוטומט אי-דטרמיניסטי שמקבל את <span class="math">\(L_{1}\cup L_{2}\)</span> באופן הבא: הוא יורכב משני אוטומטים שאחד מהם מקבל את <span class="math">\(L_{1}\)</span> והשני את <span class="math">\(L_{2}\)</span>, ובנוסף מצב התחלתי חדש שכל מה שעושים בו הוא מסע-<span class="math">\(\varepsilon\)</span> לאחד משני המצבים ההתחלתיים של האוטומטים הללו. כלומר, הדבר הראשון שהאוטומט עושה הוא להחליט אי-דטרמיניסטית אם בא לו היום לבדוק אם הקלט שלו שייך ל-<span class="math">\(L_{1}\)</span> או אם הוא שייך ל-<span class="math">\(L_{2}\)</span>, ואז הוא רץ בהתאם.</p>
<p>אם חושבים על זה עוד קצת, רואים שבעצם יש כאן רעיון כללי - אפשר לבנות <strong>אוטומט עם כמה מצבים התחלתיים</strong> במקום להסתפק בדרישה השרירותית שלי למצב התחלתי יחיד. בהינתן אוטומט עם כמה מצבים התחלתיים, תמיד אפשר להמיר אותו בכזה עם מצב התחלתי יחיד שיש ממנו מסעי-<span class="math">\(\varepsilon\)</span> לכל המצבים ההתחלתיים של האוטומט המקורי. אם כן, הבניה של האיחוד היא בעצם "בנה אוטומט חדש שכולל את שני האוטומטים עבור השפות, וקבוצת המצבים ההתחלתיים שלו היא קבוצת המצבים ההתחלתיים של שני האוטומטים". הבניה הכי קלה בעולם, בערך (מרגע שיש לנו את השקילות הלא טריוויאלית של המודלים השונים לאוטומט).</p>
<p>עוד פעולת סגור קלילה היא משלים - קחו רגע כדי לשכנע את עצמכם שהאוטומט עבור משלים של שפה (המשלים של <span class="math">\(L\)</span>, שאסמן <span class="math">\(\overline{L}\)</span>, הוא כל המילים ב-<span class="math">\(\Sigma^{*}\)</span> שאינן ב-<span class="math">\(L\)</span>) הוא פשוט האוטומט של השפה, בהיפוך של המצבים המקבלים (מי שהיה מקבל הופך ללא-מקבל, ומי שקודם לא היה מקבל הופך למקבל); <strong>אבל</strong>, רק בתנאי שהאוטומט הזה הוא אוטומט סופי דטרמיניסטי.</p>
<p>נקודה שנוטה לבלבל אנשים היא שאם ניקח אוטומט אי דטרמיניסטי ונהפוך את המצבים המקבלים שלו, הרבה דברים שונים ומשונים עלולים לקרות - ייתכן שנקבל את אותה שפה בדיוק כמו קודם; ייתכן שפתאום נקבל כל מילה אפשרית; וייתכנו עוד דברים. למה זה קורה? ובכן, זכרו שאוטומט אי דטרמיניסטי מקבל מילה אם <strong>קיים</strong> מסלול שבו האוטומט מגיע על המילה למצב מקבל. אבל בהחלט ייתכן שעל אותה מילה יש לו גם מסלול אחר שמגיע למצב <strong>לא מקבל</strong>. לכן, אחרי שנהפוך את קבוצת המצבים המקבלים של האוטומט המסלול הזה יהפוך למסלול שמגיע למצב מקבל, ולכן גם באוטומט החדש יהיה קיים מסלול מקבל על אותה מילה, והמילה תתקבל גם בו.</p>
<p>כעת, הראינו סגירות לאיחוד וחיתוך רק עבור זוגות של שפות, אבל באינדוקציה קל להראות שיש סגירות לחיתוך ואיחוד של כל <strong>מספר סופי</strong> של שפות. מכאן אנחנו מקבלים מייד את הטענה על כך שכל שפה סופית היא רגולרית - היא איחוד של מספר סופי של סינגלטונים, וראינו שסינגלטון הוא שפה רגולרית. עם זאת, הדרישה על הסופיות כאן היא קריטית - אפשר לבנות את השפה <span class="math">\(\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} \)</span> בתור איחוד אינסופי של סינגלטונים, וכבר ראינו שזו לא שפה רגולרית. אם כן, אין לנו סגירות לאיחוד אינסופי. מכך נובע גם שאין סגירות לחיתוך אינסופי, שכן אפשר להציג איחוד באמצעות חיתוך ומשלים - זה מה שמכונה "כלל דה-מורגן" (אחד משניהם, יש שניים שדואליים זה לזה): <span class="math">\(\bigcup L_{n}=\overline{\bigcap\overline{L_{n}}}\)</span>. אם חיתוך אינסופי היה פעולת סגור, אז מכיוון שבאגף ימין מתרחשות רק פעולות סגור, היינו מקבלים שגם אגף שמאל הוא תכונת סגור, וכרגע הסברתי למה הוא לא.</p>
<p>עד עכשיו השתעשענו עם תכונות סגור שהן פעולות "רגילות" על קבוצות. אבל שפה היא לא סתם קבוצה - היא קבוצה של מילים, ועל מילים אפשר לעשות פעולות מגניבות שלא דיברתי עליהן עד עכשיו. הפעולה הבסיסית שאפשר לבצע על מילים היא <strong>לשרשר</strong> שתי מילים - לחבר אותן זו לזו כדי ליצור מילה חדשה. אם <span class="math">\(u=\sigma_{1}\dots\sigma_{n}\)</span> ו-<span class="math">\(v=\tau_{1}\dots\tau_{k}\)</span> הן שתי מילים כלשהן, אז השרשור שלהן הוא <span class="math">\(u\cdot v=\sigma_{1}\dots\sigma_{n}\tau_{1}\dots\tau_{k}\)</span>. לרוב אני אשמיט את הנקודה, כפי שעושים לעתים קרובות עם סימונים דמויי כפל שכאלו.</p>
<p>השימוש הזה ב"מילים" וב"כפל" עשוי להישמע מוכר לחלק מהקוראים - זו טרמינולוגיה שנפוצה גם ב<strong>תורת החבורות</strong>. ואכן, לרגע נראה ש-<span class="math">\(\Sigma^{*}\)</span> היא חבורה ביחס לפעולת השרשור הזו. זו פעולה בינארית, אסוציאטיבית, ואפילו עם איבר יחידה נייטרלי (המילה הריקה <span class="math">\(\varepsilon\)</span>, כמובן). רק מה, אין לנו "הופכי". אם <span class="math">\(u\)</span> היא מילה לא ריקה, אז לא קיימת מילה <span class="math">\(v\)</span> כך ש-<span class="math">\(uv=\varepsilon\)</span>. זה כאילו ש-<span class="math">\(\Sigma^{*}\)</span> היא המספרים השלמים, בלי האפשרות לכפול בהופכי של מספר ("לחלק"). עדיין, גם מבנה אלגברי שהוא כמעט-כמו-חבורה-רק-בלי-הופכי הוא מעניין ונקרא <strong>מונואיד</strong>. לא חייבים להיות בקיאים במונואידים כדי להבין את מה שאעשה בהמשך, אבל נחמד לדעת שהמושג קיים.</p>
<p>כעת, שרשור היא פעולה על מילים, לא על שפות, אבל נובעת ממנה די בקלות פעולה על שפות: <span class="math">\(L_{1}\cdot L_{2}=\left\{ uv\ |\ u\in L_{1},v\in L_{2}\right\} \)</span>. דהיינו, לוקחים את כל הזוגות של מילה מפה ומילה משם, ומשרשרים. תשוו את זה עם הגדרה סטנדרטית מאלגברה לינארית וכדומה - <span class="math">\(V+U=\left\{ v+u\ |\ v\in V,u\in U\right\} \)</span>.</p>
<p>כמובן, לגמרי לא יפתיע אתכם לגלות ששרשור הוא תכונת סגור של שפות רגולריות. האינטואיציה כאן פשוטה - לוקחים אוטומטים עבור שתי השפות, ומכל מצב מקבל באוטומט אחד מוסיפים מעבר-<span class="math">\(\varepsilon\)</span> למצב ההתחלתי של האוטומט השני. למה זה עובד? ובכן, האוטומט קורא מילה <span class="math">\(w\)</span>. הוא אמור לקבל אותה רק אם קיימים <span class="math">\(u,v\)</span> כך ש-<span class="math">\(w=uv\)</span> וכמו כן <span class="math">\(u\in L_{1}\)</span> ו-<span class="math">\(v\in L_{2}\)</span>. אז בהתחלה האוטומט רץ על <span class="math">\(w\)</span> עם האוטומט של <span class="math">\(L_{1}\)</span>. בכל פעם שבה הוא מגיע למצב מקבל, הוא אומר לעצמו - אה, אולי זה עתה סיימתי לקרוא את ה-<span class="math">\(u\)</span> שלי ועכשיו צריך להתחיל לקרוא את ה-<span class="math">\(v\)</span>? אם התשובה שלו לעצמו על כך היא חיובית, הוא יתחיל לרוץ מעכשיו כמו האוטומט של <span class="math">\(L_{2}\)</span>. מכיוון שאנחנו באוטומט אי דטרמיניסטי פה זה לא חשוב שאולי הניחוש שלו היה לא נכון - אם קיים פירוק נכון, יהיה ניחוש שבו האוטומט בוחר בו, ומגלה שהמילה אכן שייכת לשרשור השפות, ולכן מקבל. כמקודם, אני משאיר לכם לטפל בפרטים אם אתם רוצים תרגול.</p>
<p>סגירות לשרשור חוסכת לנו עוד קצת עבודה - כדי להגיד שכל השפות הסופיות הן רגולריות, מספיק להיווכח בכך שהשפה הריקה רגולרית, שהשפה שמכילה רק את המילה הריקה היא רגולרית, ושכל שפה עם מילה אחת שהיא אות בודדת היא רגולרית. עכשיו אפשר לקבל כל שפה עם מילה מאורך כלשהו בעזרת שרשור של שפות של אותיות בודדות (איך?) ואז להשתמש באיחוד כדי להגיע לכל שפה סופית.</p>
<p>אוקיי, אבל יש המון שפות רגולריות שאינן סופיות. האם אני יכול להגיע אליהן באמצעות מה שדיברתי עליו כרגע, דהיינו השפה הריקה, השפה שכוללת את המילה הריקה, כל השפות שכוללות אות יחידה, פעולת האיחוד ופעולת השרשור? ובכן, לא. די בבירור (הוכחה באינדוקציה!) אני יכול להגיע <strong>רק</strong> לשפות הסופיות. אפשר לומר זאת כך: הקבוצה הנוצרת מהבסיס של השפות שהזכרתי ומפעולות היצירה של איחוד ושרשור היא בדיוק אוסף השפות הסופיות. אם כן, אני צריך להרחיב את הבסיס או את פעולות היצירה שלי אם אני רוצה להגיע לכל השפות הרגולריות. למי מכם שמכיר, הסיטואציה הזו דומה לאקסיומות צרמלו-פרנקל של תורת הקבוצות - מתחילים עם אקסיומה על קיום הקבוצה הריקה, ועל כך שאפשר לבנות קבוצה שמכילה זוג קבוצות נתונות, ואקסיומה על איחוד, וכו'; אבל כל אלו לא מספיקות כדי להוכיח שקיימת קבוצה אינסופית וצריך להוסיף אקסיומה מפורשת עבור כך.</p>
<p>אפשרי ומתבקש לומר שנוסיף את <span class="math">\(\Sigma^{*}\)</span> לבסיס ואת פעולת המשלים לתכונות הסגור - הרי כבר ראינו שהשפה הזו היא רגולרית ושמשלים היא תכונת סגור (למעשה, אין צורך להוסיף את <span class="math">\(\Sigma^{*}\)</span> במפורש, הרי היא מתקבלת מהשפה הריקה על ידי משלים). רק מה, זה לא יהיה מספיק. לא קשה להוכיח שאחרי שנעשה את זה, נקבל שאנחנו יודעים ליצור את כל השפות שהן או סופיות או <strong>קו-סופיות</strong>, כלומר המשלימה שלהן סופית. יש עוד המון שפות רגולריות אחרות (למשל, שפת כל המילים מאורך זוגי). אז לא, תשכחו ממשלים. אנחנו צריכים להוסיף פעולת סגור אחרת, חזקה יותר, שמאפשרת לנו ליצור שפות אינסופיות "מעניינות".</p>
<p>מה הפעולה הנוספת שלנו תהיה? זו אולי השאלה המעניינת ביותר מבין השאלות הבסיסיות שצצות כשמתעסקים בשפות רגולריות, ולכן די עצוב לי שהיא "מספויילרת" בקורסים בנושא שמציגים את הפעולה הזו הרבה לפני שמבינים עד כמה היא מגניבה. אני בעצם אומר שאני מסוגל לתת פעולה אחת נוספת שביחד עם אלו שכבר תיארתי תאפשר לנו לקבל <strong>בדיוק את כל</strong> השפות הרגולריות - לא יותר מדי (כלומר, זו תהיה תכונת סגור, כמובן) ולא פחות מדי. תחשבו עכשיו שאתם החוקרים הראשונים בג'ונגל הזה של תורת השפות הפורמליות - מאיפה בכלל תתחילו לחפש כזו פעולה? (למעשה, בעצם כבר ספיילרתי די הרבה - אמרתי ש<strong>קיימת</strong> פעולה כזו אז אתם בכלל יודעים שיש טעם לחפש; חוקרי הג'ונגל המקוריים לא ידעו).</p>
<p>בואו ננסה להבין רגע מה קורה בשפה הרגולרית הטיפוסית. את השפות הסופיות הבנו, אז בואו ניקח שפה רגולרית אינסופית. יש אוטומט סופי דטרמיניסטי <span class="math">\(A\)</span> שמקבל אותה. ננקוט בתעלול דומה לזה שבו השתמשתי כדי להוכיח ש-<span class="math">\(\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} \)</span> אינה רגולרית: נסמן ב-<span class="math">\(n\)</span> את מספר המצבים של <span class="math">\(A\)</span>, ועכשיו נשאל את עצמנו איך <span class="math">\(A\)</span> רץ על מילה <span class="math">\(z\)</span> שאורכה הוא לפחות <span class="math">\(n\)</span>. מכיוון שעל מילה באורך לפחות <span class="math">\(n\)</span> האוטומט <span class="math">\(A\)</span> יראה בריצה שלו לפחות <span class="math">\(n+1\)</span> מצבים, יהיה מצב <span class="math">\(q\)</span> שבו הוא מבקר פעמיים. לכן אפשר לפרק את <span class="math">\(z\)</span> לשלושה חלקים: <span class="math">\(z=uvw\)</span>, כאשר <span class="math">\(u\)</span> הוא המילה שנקראת <strong>עד</strong> שמגיעים ל-<span class="math">\(q\)</span>; <span class="math">\(v\)</span> הוא המילה שנקראת כשהולכים מ-<span class="math">\(q\)</span> אל עצמו, ו-<span class="math">\(w\)</span> היא המילה שנקראת מ-<span class="math">\(q\)</span> בדרך אל מצב מקבל כלשהו.</p>
<p>האבחנה המרכזית כעת היא שגם אם נוותר על <span class="math">\(v\)</span> נקבל מילה שבשפה - <span class="math">\(uw\)</span>. החישוב עליה הוא פשוט - לך מהמצב ההתחלתי עד <span class="math">\(q\)</span>, ואז לך מ-<span class="math">\(q\)</span> אל מצב מקבל. אבל שימו לב, גם <span class="math">\(uvvw\)</span> בשפה - החישוב עליה הוא "לך מהמצב ההתחלתי עד <span class="math">\(q\)</span>, תחזור פעם אחת ל-<span class="math">\(q\)</span>, תחזור עוד פעם ל-<span class="math">\(q\)</span>, ואז לך מ-<span class="math">\(q\)</span> אל מצב מקבל". וגם <span class="math">\(uvvvw\)</span> בשפה, וכן הלאה.</p>
<p>די ברור שאנחנו צריכים קיצור כלשהו כאן - במקום לכתוב <span class="math">\(vvvvv\)</span> יותר הגיוני לכתוב <span class="math">\(v^{4}\)</span>. נוח גם להגדיר <span class="math">\(v^{0}=\varepsilon\)</span>, ואז את הטענה שלי למעלה ניתן לסכם כך: <span class="math">\(uv^{k}w\)</span> שייכת לשפה לכל <span class="math">\(k\ge0\)</span>.</p>
<p>אם כן, הנה רעיון לפעולה שאנחנו מחפשים: העלאה בחזקה. אבל "סתם" העלאה בחזקה כבר מכוסה על ידי שרשור; מה שאנחנו רוצים הוא פעולה שמחזירה קבוצה של <strong>כל</strong> החזקות של מילה נתונה. האם זה יהיה מספיק טוב?</p>
<p>ובכן, לא. וכדי לראות את זה, בואו ניקח שפה מעל <span class="math">\(\Sigma=\left\{ a,b\right\} \)</span> שכוללת את כל המילים מאורך זוגי. האם אפשר לבנות אותה על ידי אברי הבסיס והפעולות שלנו?</p>
<p>אפשר להתחיל מהשפה <span class="math">\(\left\{ a\right\} \)</span>, לשרשר אותה לעצמה ולקבל את השפה <span class="math">\(\left\{ aa\right\} \)</span>, לאחד עם <span class="math">\(\left\{ bb\right\} \)</span> שנבנית באופן דומה ועם <span class="math">\(\left\{ \varepsilon\right\} \)</span> ולקבל <span class="math">\(\left\{ aa,bb,\varepsilon\right\} \)</span>. זו התחלה טובה, אבל זה עדיין לא מכסה את כל המילים מאורך 2 שאמורות להיות בשפה - עם עוד קצת עבודה אפשר לקבל את <span class="math">\(\left\{ aa,bb,ab,ba,\varepsilon\right\} \)</span>, וזה אכן מכסה לנו את כל המילים עד וכולל אורך 2. עכשיו, אם אני אפעיל על השפה הזו את הפעולה "החזר את השפה שכוללת את כל החזקות של המילים בשפת הקלט", אני אקבל שפה נאה למדי - היא תהיה אינסופית, ויהיה בה למשל את <span class="math">\(\left(aa\right)^{k}\)</span> לכל <span class="math">\(k\)</span>, וגם מילים כמו <span class="math">\(abababab\)</span>. הבעיה היא שזה לא מספיק. מי חסר? למשל, המילה <span class="math">\(abba\)</span>. היא לא מתקבלת בתור חזקה של אף אחת מהמילים <span class="math">\(aa,bb,ab,ba\)</span>.</p>
<p>האינטואיציה היא ש-<span class="math">\(abba\)</span> מתקבלת משרשור של שתי מילים - <span class="math">\(ab\)</span> ו-<span class="math">\(ba\)</span>. אם נסתכל על האוטומט הפשוט ביותר עבור השפה של כל המילים מאורך זוגי, נראה ששתי המילים הללו מעבירות אותנו מהמצב ההתחלתי חזרה לעצמו - לולאה. אם כן, מה שפספסתי קודם עם הדוגמה שלי הוא שלפעמים אפשר להגיע מ-<span class="math">\(q\)</span> אל עצמו <strong>עם כמה מילים שונות</strong>. מה שאני רוצה הוא לא סתם חזקה של אותה מילה, אלא "כל השרשורים של מילים שמעבירות את <span class="math">\(q\)</span> לעצמו".</p>
<p>זה מוביל אותנו להגדרת חזקה של שפה, שמוגדרת באופן המתבקש: <span class="math">\(L^{0}=\left\{ \varepsilon\right\} \)</span> ו-<span class="math">\(L^{k}=L\cdot L^{k-1}\)</span>. כלומר, החזקה ה-<span class="math">\(k\)</span> של <span class="math">\(L\)</span> היא כל המילים שמתקבלות משרשור של <span class="math">\(k\)</span> מילים מתוך <span class="math">\(L\)</span>. עכשיו, הפעולה שאני מעוניין בה היא כזו שלוקחת את כל החזקות של השפה "בבת אחת":</p>
<p><span class="math">\(L^{*}=\bigcup_{k=0}^{\infty}L^{k}\)</span></p>
<p>הפעולה הזאת נקראת "איטרציה" או "סגור קלייני" או "כוכב קלייני" וכדומה. אני קורא לה לרוב סגור קלייני. זו הפעולה שחיפשנו: הטענה שלי היא שאפשר לבנות את <strong>כל השפות הרגולריות</strong> מתוך <span class="math">\(\emptyset,\left\{ \varepsilon\right\} \)</span>, כל הסינגלטונים של אותיות ב-<span class="math">\(\Sigma\)</span> ופעולות האיחוד, השרשור וסגור קלייני. זו טענה כבדה שדורשת הוכחה, וההוכחה היא מבריקה ויפהפיה ולא קלה בכלל, ולכן אחכה איתה להמשך.</p>
<p>לבינתיים, אנחנו רוצים להבין למה סגור קלייני היא בכלל תכונת סגור. דהיינו, למה אם <span class="math">\(L\)</span> היא רגולרית כך גם <span class="math">\(L^{*}\)</span>. הרי <span class="math">\(L^{*}\)</span> מוגדרת בעזרת איחוד אינסופי ואמרנו שאיחוד אינסופי הוא לא תכונות סגור, לא? ובכן נכון; איחוד אינסופי <strong>כללי</strong> הוא לא תכונת סגור, אבל כאן עושים איחוד אינסופי על קבוצות מאוד ספציפיות - החזקות של <span class="math">\(L\)</span>.</p>
<p>בואו נחשוב על איך יתנהג אוטומט שמקבל את <span class="math">\(L^{*}\)</span>. הוא מן הסתם יהיה מבוסס על אוטומט <span class="math">\(A\)</span> שמקבל את <span class="math">\(L\)</span>, ויהיה בו רעיון דומה לזה שהיה באוטומט עבור שרשור שפות: מסמלצים את <span class="math">\(A\)</span> ובכל פעם שבה מגיעים למצב מקבל, אפשר "לנחש" שסיימנו לקרוא מילה אחת וצריך להתחיל את ריצת <span class="math">\(A\)</span> מהתחלה - כלומר, לבצע מסע-<span class="math">\(\varepsilon\)</span> למצב ההתחלתי של <span class="math">\(A\)</span>. זה <strong>כמעט</strong> עובד, למעט נקודה מעצבנת אחת: שימו לב לכך ש-<span class="math">\(\varepsilon\in L^{*}\)</span> תמיד, מכיוון ש-<span class="math">\(L^{0}=\left\{ \varepsilon\right\} \)</span> נכלל באיחוד. בפתרון שהצעתי זה עתה, אם המצב ההתחלתי של <span class="math">\(A\)</span> הוא לא מקבל, אז <span class="math">\(\varepsilon\)</span> לא תתקבל (למה?).</p>
<p>אפשר כמובן להגיד - אוקיי, אז בואו נעשה מעבר-<span class="math">\(\varepsilon\)</span> מהמצב ההתחלתי של <span class="math">\(A\)</span> למצב מקבל שאי אפשר לצאת ממנו. כלומר, בתחילת הריצה שלו האוטומט יחליט אם בא לו להמר שהקלט שלו ריק ולקבל אותו ישר, או להתחיל חישוב ישיר. אבל גם זה ייכשל. למה? כי במהלך הריצה שלו <span class="math">\(A\)</span> עשוי להגיע חזרה אל המצב ההתחלתי באופן תמים תוך כדי קריאת מילה למרות שאותה מילה לא בשפה (ולא על ידי הגעה למצב מקבל ואז מעבר-<span class="math">\(\varepsilon\)</span> למצב ההתחלתי). בעצם, אין הבדל בין הפתרון שהצעתי כרגע ובין להפוך את <span class="math">\(q_{0}\)</span> למצב מקבל.</p>
<p>אז מה עושים? אפשר, כמובן, לומר שזה לא באמת חשוב - שמספיק להוכיח ש-<span class="math">\(\bigcup_{k=1}^{\infty}L^{k}\)</span> רגולרית כי אחר כך אפשר לאחד אותה עם <span class="math">\(\left\{ \varepsilon\right\} \)</span> הרגולרית. אבל זה תרגיל סביר בבניית אוטומטים לבנות אוטומט שיודע לקבל את <span class="math">\(L^{*}\)</span> ישירות. הפתרון טיפה מסורבל אבל לא כזה נורא כשברור מה הוא בא להשיג. אנחנו פשוט מוסיפים מצב התחלתי חדש ומצב מקבל חדש (ומבטלים את שאר המצבים המקבלים). מהמצב ההתחלתי אפשר לעבור במסע-<span class="math">\(\varepsilon\)</span> ישירות למצב המקבל, או למצב ההתחלתי של <span class="math">\(A\)</span>; ומכל מצב מקבל של <span class="math">\(A\)</span> אפשר לעבור למצב המקבל "האמיתי" או לחזור למצב ההתחלתי של <span class="math">\(A\)</span>, שוב באמצעות מסע-<span class="math">\(\varepsilon\)</span>. נסו לצייר את זה לעצמכם ולהשתכנע שזה יעבוד.</p>
<p>בפוסט הבא - עוד תכונות סגור! אפילו יותר מופרעות!</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>