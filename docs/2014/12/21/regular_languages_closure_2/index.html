<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>שפות רגולריות - תכונות סגור (חלק ב&#39;) - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2014/12/21/regular_languages_closure_2/">
    <meta property="og:title" content="שפות רגולריות - תכונות סגור (חלק ב&#39;)">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2014/12/21/regular_languages_closure_2/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="שפות רגולריות - תכונות סגור (חלק ב&#39;)">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2014/12/15/regular_languages_closure_1/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">שפות רגולריות - תכונות סגור (חלק א&#39;)</span>
            </a>
            

            
            <a href="/2014/12/24/regular_languages_kleene_theorem/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">שפות רגולריות - משפט קלייני</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>שפות רגולריות - תכונות סגור (חלק ב&#39;)</h1>
            <div class="post-meta">
                <span class="date">2014-12-21</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/שפות רגולריות.html">שפות רגולריות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסט הקודם דיברתי על תכונות סגור יחסית סטנדרטיות של שפות רגולריות (עם החריג של פעולת סגור קלייני, שהייתי צריך לתת לה מוטיבציה מורכבת כלשהי). עכשיו בואו נעבור לתכונת סגור שונה לגמרי - <strong>הומומורפיזם</strong>. המילה הזו בטח מוכרת לכל מי שעשה קורס באלגברה מופשטת, וספציפית בתורת החבורות. הומומורפיזם בין שתי חבורות הוא פונקציה <span class="math">\(h:G\to H\)</span> המקיימת <span class="math">\(h\left(ab\right)=h\left(a\right)h\left(b\right)\)</span> - כלומר, היא <strong>מכבדת</strong> את פעולות הכפל של החבורות (או, אם תרצו, <strong>משמרת את המבנה</strong> של החבורה). מונואיד, אמרנו, הוא "כמעט כמו חבורה" ולכן אין מניעה להגדיר הומומורפיזמים בצורה זהה עבורו. אם כן, בהינתן שני אלפביתים <span class="math">\(\Sigma,\Delta\)</span>, נגדיר הומומורפיזם בתור פונקציה <span class="math">\(h:\Sigma^{*}\to\Delta^{*}\)</span> שמקיימת <span class="math">\(h\left(uv\right)=h\left(u\right)h\left(v\right)\)</span> לכל זוג מילים <span class="math">\(u,v\in\Sigma^{*}\)</span>.</p>
<p>חיש קל מתברר שאם <span class="math">\(h\)</span> היא הומומורפיזם, אז מספיק לדעת את הערכים שלה על אברי <span class="math">\(\Sigma\)</span> כדי לדעת מה היא תחזיר לכל איבר שהוא. הרי אם <span class="math">\(w=\sigma_{1}\dots\sigma_{n}\)</span> היא מילה כלשהי, אז <span class="math">\(h\left(w\right)=h\left(\sigma_{1}\dots\sigma_{n}\right)=h\left(\sigma_{1}\right)\cdots h\left(\sigma_{n}\right)\)</span>. לכן זה האופן שבו מגדירים הומומורפיזם - פונקציה <span class="math">\(h:\Sigma\to\Delta^{*}\)</span> שאחר כך כבר מורחבת באופן טבעי לכל <span class="math">\(\Sigma^{*}\)</span>. איבר אחד שאולי לא ברור לגמרי איך להרחיב את <span class="math">\(h\)</span> עליו הוא המילה הריקה <span class="math">\(\varepsilon\)</span>; אבל מכיוון ש-<span class="math">\(h\left(\varepsilon\right)=h\left(\varepsilon\cdot\varepsilon\right)=h\left(\varepsilon\right)\cdot h\left(\varepsilon\right)\)</span> הרי שמשיקולי אורך נטו (<span class="math">\(\left|h\left(\varepsilon\right)\right|=2\left|h\left(\varepsilon\right)\right|\)</span>) כבר ברור שבהכרח <span class="math">\(h\left(\varepsilon\right)=\varepsilon\)</span>.</p>
<p>כעת, הטענה שלי היא שהומומורפיזם הוא תכונת סגור - דהיינו, שהתמונה של כל שפה רגולרית תחת הומומורפיזם היא שפה רגולרית. כזכור, מסמנים <span class="math">\(h\left(L\right)=\left\{ h\left(w\right)\ |\ w\in L\right\} \)</span> (זה המושג הרגיל של תמונה של קבוצה תחת פונקציה). איך אני אוכיח שזו אכן תכונת סגור? ובכן, יש לי כעת כלי נשק חזק - אני מכיר את <strong>המבנה האינדוקטיבי</strong> של קבוצת השפות הרגולרית, וזה מאפשר לי להוכיח עליה דברים <strong>באינדוקציית מבנה</strong>. מספיק שאוכיח שהטענה נכונה עבור אברי הבסיס ושהיא משתמרת עבור פעולות היצירה.</p>
<p>אברי הבסיס של קבוצת השפות הרגולריות כוללים את <span class="math">\(\emptyset\)</span> - וכמובן ש-<span class="math">\(h\left(\emptyset\right)=\emptyset\)</span> ולכן התמונה של <span class="math">\(\emptyset\)</span> רגולרית; כוללים את <span class="math">\(\left\{ \varepsilon\right\} \)</span> וכמובן ש-<span class="math">\(h\left(\left\{ \varepsilon\right\} \right)=\left\{ \varepsilon\right\} \)</span> רגולרית; וכוללים את <span class="math">\(\left\{ \sigma\right\} \)</span> לכל <span class="math">\(\sigma\in\Sigma\)</span> וכמובן ש-<span class="math">\(h\left(\left\{ \sigma\right\} \right)=\left\{ h\left(\sigma\right)\right\} \)</span> רגולרית (כי סינגלטון הוא שפה סופית ולכן רגולרית). נשאר לטפל בפעולות היצירה.</p>
<p>ניקח אם כן שפות <span class="math">\(L_{1},L_{2}\)</span> ונניח שהן רגולריות ושמתקיים שגם <span class="math">\(h\left(L_{1}\right),h\left(L_{2}\right)\)</span> רגולריות. כעת שימו לב לכך ש-<span class="math">\(h\left(L_{1}\cup L_{2}\right)=h\left(L_{1}\right)\cup h\left(L_{2}\right)\)</span> ומכאן שגם <span class="math">\(h\left(L_{1}\cup L_{2}\right)\)</span> רגולרית; ושמתקיים <span class="math">\(h\left(L_{1}\cdot L_{2}\right)=h\left(L_{1}\right)\cdot h\left(L_{2}\right)\)</span> ומכאן שגם <span class="math">\(h\left(L_{1}\cdot L_{2}\right)\)</span> רגולרית; ושמתקיים <span class="math">\(h\left(L_{1}^{*}\right)=\left(h\left(L_{1}\right)\right)^{*}\)</span> ולכן גם <span class="math">\(h\left(L_{1}^{*}\right)\)</span> רגולרית - כלומר, פעולות היצירה משמרות את התכונה "<span class="math">\(h\)</span> מעבירה שפה רגולרית לשפה רגולרית". מן הסתם צריך להוכיח ה"שימו לב שמתקיים"-ים שלי אבל זה תרגיל טוב עבורכם.</p>
<p>את ההוכחה הזו ניתן להכליל בלי קושי גם עבור תכונת סגור יותר מופרעת - <strong>הצבה</strong>. הצבה דומה להומומורפיזם, רק שבמקום ש-<span class="math">\(h\)</span> תחזיר <strong>מילה</strong> על כל אות, היא מחזירה <strong>שפה</strong>. השוויון <span class="math">\(h\left(w\right)=h\left(\sigma_{1}\right)\cdots h\left(\sigma_{n}\right)\)</span> הוא עדיין בעל משמעות עבור הצבה שכזו שכן אנחנו יודעים לשרשר שפות, ולכן ברור איך הצבה מוגדרת למילים. ועבור שפות? <span class="math">\(h\left(L\right)=\bigcup_{w\in L}h\left(w\right)\)</span>.</p>
<p>כעת, ההוכחה עבור הומומורפיזם עוברת כמעט אחד-לאחד עבור הצבות. מה יכול להשתבש? בדיוק דבר אחד- <span class="math">\(h\left(\left\{ \sigma\right\} \right)\)</span> אינו הסינגלטון <span class="math">\(\left\{ h\left(\sigma\right)\right\} \)</span>; הוא <strong>שפה כלשהי</strong> (הרי את <span class="math">\(h\)</span> על <span class="math">\(\sigma\)</span> ניתן להגדיר איך שבא לנו). אם כן, ברור מה הדרישה שאנחנו חייבים לדרוש - ש-<span class="math">\(h\)</span> תחזיר לכל <span class="math">\(\sigma\)</span> לא סתם שפה, אלא שפה רגולרית. להצבה שעושה את זה קוראים <strong>הצבה רגולרית</strong> ומה שראינו הוא שהצבה רגולרית שכזו היא תכונת סגור של שפות רגולריות.</p>
<p>הומומורפיזם הוא בעצם מקרה פרטי של הצבה שבו ההצבה מחזירה סינגלטון לכל אות. אז למה טרחתי לדבר על הומומורפיזם לבד? כי יש לי עניין גם במה שנקרא <strong>ההומומורפיזם ההפוך</strong>. באופן כללי, הומומורפיזם לא בהכרח יהיה חח"ע ועל, ולכן לא יהיה הפיך בתור פונקציה, אבל זה לא מונע מאיתנו לדבר על <strong>המקור</strong> של שפה כלשהי תחת ההומומורפיזם. פורמלית, אם <span class="math">\(h:\Sigma^{*}\to\Delta^{*}\)</span> הוא הומומורפיזם, ו-<span class="math">\(L\subseteq\Delta^{*}\)</span> אז מגדירים <span class="math">\(h^{-1}\left(L\right)\triangleq\left\{ w\in\Sigma^{*}\ |\ h\left(w\right)\in L\right\} \)</span>. כצפוי, אני רוצה לטעון שזו תכונת סגור, אבל בואו נראה קודם כל שימוש קלאסי בתכונת הסגור הזו כדי להבין למה היא כל כך מעניינת.</p>
<p>נניח ש-<span class="math">\(L\)</span> היא שפה רגולרית מעל <span class="math">\(\Sigma\)</span>, ואני רוצה מסיבות השמורות עמי להתעסק עם השפה שמתקבלת מ-<span class="math">\(L\)</span> על ידי לקיחת כל מילה ב-<span class="math">\(L\)</span> מאורך זוגי והסרה של כל האותיות במקומות האי-זוגיים שלה. כלומר, אני רוצה לטפל בשפה <span class="math">\(\left\{ \sigma_{2}\sigma_{4}\dots\sigma_{2n}\ |\ \exists\sigma_{1},\dots,\sigma_{2n-1}:\sigma_{1}\sigma_{2}\dots\sigma_{2n}\in L\right\} \)</span>. איך אני מראה שהשפה הזו רגולרית? אפשר עם אוטומט מחוכם שמבצע סימולציה של האוטומט עבור <span class="math">\(L\)</span> ו"מנחש" את האותיות במקומות האי-זוגיים, אבל יש דרך הרבה יותר פשוטה לקבל את השפה הזו מתוך <span class="math">\(L\)</span> באמצעות תכונות סגור, מרגע שהתרגלנו כבר לעבוד עם תכונות הסגור הללו. מה שאני ארצה לעשות הוא לקחת את המילים של <span class="math">\(L\)</span> שהן מאורך זוגי ולשים איכשהו סימון - "תג" - על כל אות במקום אי-זוגי. ואז להפעיל הומומורפיזם שמוחק את כל האותיות עם תגים ולא נוגע באחרות. עיקר העבודה כאן היא לבצע את התיוג הזה, ובשביל זה אשתמש בהומומורפיזם הפוך.</p>
<p>פורמלית, בואו ניקח את האלפבית <span class="math">\(\Sigma\)</span> ונגדיר לו אלפבית מקביל של "אותיות עם תג" - <span class="math">\(\Sigma^{\prime}=\left\{ \sigma^{\prime}\ |\ \sigma\in\Sigma\right\} \)</span>. כעת, נגדיר הומומורפיזם <span class="math">\(h:\left(\Sigma\cup\Sigma^{\prime}\right)^{*}\to\Sigma^{*}\)</span> שמוגדר באופן הבא: <span class="math">\(h\left(\sigma\right)=h\left(\sigma^{\prime}\right)=\sigma\)</span>. כלומר, ההומומורפיזם פשוט מסיר תגים מהמילה (מבלי למחוק את האותיות עם התגים!)</p>
<p>זה נראה כמו הומומורפיזם מטופש ולא מעניין, וזה נכון; מה שמעניין הוא ההומומורפיזם ההפוך. תחשבו על זה קצת ותראו ש-<span class="math">\(h^{-1}\left(L\right)\)</span> הוא "כל המילים מתוך <span class="math">\(L\)</span> כשכל מילה מופיעה עם כל קומבינציות התגים האפשריות עליה" (למשל: מתוייגת כולה; לא מתוייגת בכלל; כל מקום אי זוגי מתוייג; וכו' וכו').</p>
<p>כרגע יש <strong>יותר מדי</strong> תיוגים על המילים בשפה שקיבלנו, אבל זו לא בעיה - כדי להתמקד רק על התיוג שאנחנו רוצים, אפשר לבצע חיתוך עם שפה רגולרית אחרת: <span class="math">\(h^{-1}\left(L\right)\cap\left(\Sigma^{\prime}\Sigma\right)^{*}\)</span> זו בדיוק שפת כל המילים מ-<span class="math">\(L\)</span> שהן מאורך זוגי ומכילות תגים על המקומות האי זוגיים (למה השפה הימנית בחיתוך היא רגולרית? מתכונות הסגור שכבר ראינו).</p>
<p>כעת כל שנותר לעשות הוא להגדיר הומומורפיזם נוסף, <span class="math">\(g:\left(\Sigma\cup\Sigma^{\prime}\right)^{*}\to\Sigma^{*}\)</span> על ידי <span class="math">\(g\left(\sigma\right)=\sigma\)</span> ו-<span class="math">\(g\left(\sigma^{\prime}\right)=\varepsilon\)</span>. כלומר, הומומורפיזם שמוחק את האותיות המתוייגות. כעת <span class="math">\(g\left(h^{-1}\left(L\right)\cap\left(\Sigma^{\prime}\Sigma\right)^{*}\right)\)</span> היא בדיוק השפה המבוקשת. תעלול התיוג הסטנדרטי פותר עוד תרגילים דומים בצורה נחמדה.</p>
<p>עכשיו בואו נראה שהומומורפיזם הפוך הוא תכונת סגור. אני אעשה את זה בדרך הסטנדרטית: אקח אוטומט <span class="math">\(A\)</span> עבור השפה <span class="math">\(L\)</span> ואבנה אוטומט <span class="math">\(A^{\prime}\)</span> עבור <span class="math">\(h^{-1}\left(L\right)\)</span>. מכיוון שהבניה פשוטה בצורה קיצונית אני אציג אותה בצורה פורמלית. אבל קודם - הרעיון. יש לנו הומומורפיזם <span class="math">\(h:\Sigma\to\Delta\)</span>. יש לנו שפה <span class="math">\(L\subseteq\Delta^{*}\)</span> (שימו לב - השפה לא מעל <span class="math">\(\Sigma^{*}\)</span> כמו בדרך כלל). כעת אנו מקבלים מילה <span class="math">\(w\in\Sigma^{*}\)</span> וצריכים לקבוע האם <span class="math">\(h\left(w\right)\in L\)</span>. איך נעשה את זה? מן הסתם, סימולציה של האוטומט <span class="math">\(A\)</span> עבור השפה <span class="math">\(L\)</span>, אבל סימולציה שלו על מה? על הקלט <span class="math">\(h\left(w\right)\)</span>.</p>
<p>בואו נציג שניה את <span class="math">\(w\)</span> כשרשור אותיות: <span class="math">\(w=\sigma_{1}\sigma_{2}\dots\sigma_{n}\)</span>. אז אנחנו יודעים ש-<span class="math">\(h\left(w\right)=h\left(\sigma_{1}\right)\dots h\left(\sigma_{n}\right)\)</span>. מכאן שהגיוני שהסימולציה שלנו תתנהל כך: קודם כל נקרא את <span class="math">\(\sigma_{1}\)</span> מתוך הקלט האמיתי שלנו, ואז נבצע סימולציה של <span class="math">\(A\)</span> על <span class="math">\(h\left(\sigma_{1}\right)\)</span>. אחר כך נקרא את <span class="math">\(\sigma_{2}\)</span> ונמשיך את הסימולציה של <span class="math">\(A\)</span>, הפעם על <span class="math">\(h\left(\sigma_{2}\right)\)</span> וכן הלאה. בסוף נקבל אם ורק אם <span class="math">\(A\)</span> קיבלה. פשוט!</p>
<p>אם כן, פורמליזם. נסמן <span class="math">\(A=\left(\Delta,Q,q_{0},\delta,F\right)\)</span>, וכעת נבנה את האוטומט החדש שלנו, <span class="math">\(A^{\prime}=\left(\Sigma,Q,q_{0},\delta^{\prime},F\right)\)</span> - אותם מצבים, אותו מצב התחלתי, אותם מצבים מקבלים. ההבדלים הם רק בא"ב, כמובן, ובפונקציית המעברים, שמוגדרת כך:</p>
<p><span class="math">\(\delta^{\prime}\left(q,\sigma\right)=\hat{\delta}\left(q,h\left(\sigma\right)\right)\)</span></p>
<p>שימו לב שברמת הפורמליזם, אנחנו אפילו לא מבצעים סימולציה של <span class="math">\(A\)</span> על <span class="math">\(h\left(\sigma\right)\)</span> - אין לנו צורך ממש להריץ את <span class="math">\(A\)</span> צעד צעד. אנחנו פשוט קופצים אוטומטית אל המצב שאליו <span class="math">\(A\)</span> אמורה להגיע אחרי קריאת <span class="math">\(h\left(\sigma\right)\)</span> - שזה מידע שאנחנו יכולים לבצע "אופליין", לא כחלק מריצת האלגוריתם עצמו.</p>
<p>עדיין לא השתכנעתם שזה עובד? מצויין! הנה לכם תרגיל קל ונחמד - להוכיח שזה עובד. פורמלית.</p>
<p>לפני תכונת הסגור האחרונה שאני רוצה להציג, שיש בה עניין מוזר למדי, אני אקח הפסקה ואדבר על תכונה קלילה במיוחד - היפוך. בהינתן מילה <span class="math">\(w=\sigma_{1}\sigma_{2}\dots\sigma_{n}\)</span>, נגדיר את ההיפוך שלה באופן המתבקש - אותן האותיות אבל בסדר הפוך: <span class="math">\(w^{R}\triangleq\sigma_{n}\dots\sigma_{2}\sigma_{1}\)</span>. הקפיצה להיפוך של שפה היא מיידית: <span class="math">\(L^{R}=\left\{ w^{R}\ |\ w\in L\right\} \)</span>. הטענה היא שהיפוך של שפה רגולרית הוא עדיין שפה רגולרית. איך מוכיחים את זה? אם מדגדג לכם לומר "ניקח אוטומט עבור <span class="math">\(L\)</span> ופשוט נהפוך את כיווני הקשתות", אתם צודקים. מה שנחמד פה הוא שאם עושים את ההיפוך הזה על אוטומט סופי דטרמיניסטי, רוב הסיכויים שהאוטומט שתקבלו יהיה אי-דטרמיניסטי, אבל כבר ראינו שהמודלים שקולים אז אין עם זה בעיה (אבל זה רק ממחיש כמה חשוב היה לדבר על אוטומט אי-דטרמיניסטי לפני שהתחלנו לדבר על תכונות סגור).</p>
<p>נעבור לתכונה האחרונה, שנקראת "חלוקה" וקצת קשה להסביר אותה. הרעיון הוא כזה: קחו שתי שפות <span class="math">\(L_{1},L_{2}\)</span>. עכשיו, קחו מילה כלשהי מ-<span class="math">\(L_{1}\)</span>. תבדקו אם אפשר לפרק אותה לשני חלקים - רישא וסיפא (רישא - כל האותיות החל מתחילת המילה עד מקום מסויים; סיפא - כל האותיות החל ממקום מסויים במילה ועד סופה), באופן כזה שהסיפא שייכת ל-<span class="math">\(L_{2}\)</span>. אם כן, זרקו את הרישא לסל. התוצאה של פעולת החלוקה היא כל המילים שנכנסות כך לסל. פורמלית:</p>
<p><span class="math">\(L_{1}/L_{2}\triangleq\left\{ x\in\Sigma^{*}\ |\ \exists y\in L_{2}:xy\in L_{1}\right\} \)</span></p>
<p>הפעולה הזו נקראת <strong>חלוקה מימין</strong> כי <span class="math">\(y\)</span> הוא בחלק הימני של המילה. אבל יש גם חלוקה משמאל:</p>
<p><span class="math">\(L_{2}\backslash L_{1}\triangleq\left\{ x\in\Sigma^{*}\ |\ \exists y\in L_{2}:yx\in L_{1}\right\} \)</span></p>
<p>אני אדבר רק על חלוקה מימין, כי חלוקה משמאל אפשר לקבל באמצעות היפוך: <span class="math">\(L_{2}\backslash L_{1}=\left(L_{1}^{R}/L_{2}^{R}\right)^{R}\)</span>.</p>
<p>על פניו, אפשר להוכיח שחלוקה מימין היא תכונת סגור באמצעות מה שכבר ראינו. נניח ש-<span class="math">\(L_{1},L_{2}\)</span> רגולריות. נשתמש בתיוג בעזרת הומומורפיזם הפוך על <span class="math">\(L_{1}\)</span> ונחתוך עם השפה <span class="math">\(\Sigma^{*}L_{2}^{\prime}\)</span> (כל המילים שמורכבות מרישא לא מתוייגת כלשהי ומסיפא מתוייגת ב-<span class="math">\(L_{2}\)</span>). נפעיל על התוצאה הומומורפיזם שמוחק אותיות עם תגים, וסיימנו. אז למה בעצם אני מדבר על התכונה הזו בנפרד ולמה אני אומר שיש איתה "עניין מוזר במיוחד"? ובכן, כי אני יכול לעשות יותר ממה שכבר תיארתי - אני טוען שכל עוד <span class="math">\(L_{1}\)</span> היא רגולרית, אז החלוקה שלה ב-<span class="math">\(L_{2}\)</span> תהיה רגולרית - <strong>מבלי</strong> שאצטרך את זה ש-<span class="math">\(L_{2}\)</span> תהיה רגולרית. <span class="math">\(L_{2}\)</span> יכולה להיות כל שפה שהיא, כולל שפות שהן בכלל לא כריעות (כלומר, אין אלגוריתם שיודע לקבוע, בהינתן מילה, אם היא בשפה או לא - למשל, <a href="http://www.gadial.net/2007/09/26/halting_problem/">בעיית העצירה</a>).</p>
<p>אז מה עושים? נניח ש-<span class="math">\(A=\left(\Sigma,Q,q_{0},\delta,F\right)\)</span> הוא אוטומט עבור <span class="math">\(L_{1}\)</span>. נבנה אוטומט <span class="math">\(A^{\prime}\)</span> עבור <span class="math">\(L_{1}/L_{2}\)</span>. הרעיון, כרגיל, יהיה לבצע סימולציה של <span class="math">\(A\)</span>; אנחנו קוראים מילה <span class="math">\(x\)</span> ומסמלצים עליה את <span class="math">\(A\)</span>. האקשן מגיע כש-<span class="math">\(x\)</span> נגמרת. בשלב הזה אנחנו עוצרים ושואלים את עצמנו - האם קיימת איזו שהיא <span class="math">\(y\in L_{2}\)</span> שאני יכול לקרוא <strong>החל מהמקום שהגעתי אליו</strong> ולסיים במצב מקבל?</p>
<p>אם <span class="math">\(L_{2}\)</span> היא שפה מסובכת, אז לענות לשאלה הזו זה דבר קשה עד בלתי אפשרי. אבל, וזה קטע מבלבל אז תשארו איתי - לשאלה הזו <strong>קיימת תשובה גם אם אנחנו לא יודעים אותה</strong>, ומכך נובע שקיים אוטומט <span class="math">\(A^{\prime}\)</span> שמתאים לשפת החלוקה גם אם אנחנו לא יודעים מהו.</p>
<p>לפני שתספיקו להתלונן, הנה האוטומט, פורמלית: <span class="math">\(A^{\prime}=\left(\Sigma,Q,q_{0},\delta,F^{\prime}\right)\)</span>. כלומר: אותה קבוצת מצבים, אותו מצב התחלתי ואותה פונקציית מעברים כמו של <span class="math">\(A\)</span>. ההבדל היחיד הוא קבוצת המצבים המקבלים, שמוגדרת כך:</p>
<p><span class="math">\(F^{\prime}=\left\{ q\in Q\ |\ \exists y\in L_{2}:\hat{\delta}\left(q,y\right)\in F\right\} \)</span></p>
<p>אין ויכוח על כך שמבחינה מתמטית <span class="math">\(F^{\prime}\)</span> <strong>קיימת</strong>, ושהיא באמת <strong>מוגדרת היטב</strong> - כלומר, עבור כל <span class="math">\(q\in Q\)</span> ההגדרה לא מאפשרת לו להיות בו זמנית בתוך ומחוץ ל-<span class="math">\(F^{\prime}\)</span>. העניין הוא שלא תמיד תהיה לנו יכולת למצוא אלגוריתמית את <span class="math">\(F\)</span>. אבל כל העניין הוא שזה לא באמת חשוב: כדי להראות ששפה היא רגולרית אנחנו לא צריכים <strong>למצוא</strong> אוטומט עבור השפה שלה, רק להראות שאוטומט כזה <strong>קיים</strong>. והוכחה פורמלית קצרה תראה ש-<span class="math">\(F^{\prime}\)</span> שנתתי אכן גורמת לכך ש-<span class="math">\(L\left(A^{\prime}\right)=L_{1}/L_{2}\)</span>.</p>
<p>כהערת אגב, כל שאר תכונות הסגור שהראיתי כאן כן היו קונסטרוקיטיביות, כלומר בהינתן אוטומטים עבור השפות שמתחילים מהן, אני יודע איך לבנות אוטומטים עבור השפות שמתקבלות מפעולות הסגור. יוצאת מן הכלל אחת היא פעולת ההצבה, שבהוכחה עבורה הסתמכתי על כך שאני יודע לתאר כל שפה רגולרית באמצעות פעולות החיבור-שרשור-סגור קלייני מתוך שפות הבסיס (ריקה והסינגלטונים). זה ה"חוב" שנשאר לי, ובפוסט הזה אשלם אותו בשמחה, כי ההוכחה שאראה (שאינה קשה בצורה חריגה אבל יש בה רעיון אחד מבריק) היא אחד מהדברים החביבים עלי בנושא הזה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>