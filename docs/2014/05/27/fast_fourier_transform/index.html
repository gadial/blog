<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>התמרת פורייה המהירה - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                text-align: center;
                margin-bottom: 10px;
            }
            
            .top-nav .nav-links {
                flex-direction: column;
                width: 100%;
            }
            
            .top-nav .nav-links a {
                text-align: center;
                padding: 8px;
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/new_blog/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/new_blog/">דף הבית</a>
                <a href="/new_blog/random.html">פוסט אקראי</a>
                <a href="/new_blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_blog/2014/05/21/discrete_fourier_transform_intro/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">התמרת פורייה הבדידה - מה זה בכלל?</span>
            </a>
            

            
            <a href="/new_blog/2014/06/10/vector_space_tensor_product/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">מכפלות טנזוריות (של מרחבים וקטוריים)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>התמרת פורייה המהירה</h1>
            <div class="post-meta">
                <span class="date">2014-05-27</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אנליזה מתמטית.html">אנליזה מתמטית</a>
                    
                    <a href="/categories/מבני נתונים ואלגוריתמים.html">מבני נתונים ואלגוריתמים</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/התמרת פורייה המהירה.html">התמרת פורייה המהירה</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסט הקודם הצגתי את התמרת פורייה הבדידה, והבאתי דוגמה אחת לשימוש בה - כפל מהיר של פולינומים. אמרתי גם שכדי שהכפל באמת יהיה מהיר, עלינו לדעת לבצע את התמרת פורייה מהר; ואמרתי גם שהתמרת פורייה הבדידה מיוחדת בכך שהיא עוסקת בכמות סופית של מידע, ולכן אפשר לתכנת אותה במחשב בצורה פשוטה. כפי שאתם ודאי מנחשים מכל זה, הפוסט הנוכחי יהיה הרבה יותר מוטה לכיוון של מדעי המחשב מאשר הפוסטים הקודמים על פורייה; בפרט, אני הולך לדבר על שאלות של <strong>סיבוכיות </strong>ולהציג <strong>אלגוריתמים</strong>.</p>
<p>אבל ראשית, בואו ניזכר מהי התמרת פורייה הבדידה. אני הולך להשתמש בפוסט הזה בסימונים קצת שונים מאלו שהשתמשתי בהם בפוסט הקודם, כי הסימונים הישנים יהיו פחות נוחים לי. על כן אני ממליץ לאלו מכם שקראו את הפוסט הקודם לשכוח מהכל ולהתחיל מחדש. בכל הנוגע לסימונים, זאת אומרת.</p>
<p>אנחנו מסמנים את <strong>שורש היחידה הפרמיטיבי ה-<span class="math">\(n\)</span>-י</strong> בסימון <span class="math">\(\omega_{n}=e^{\frac{2\pi i}{n}}\)</span>, והחזקות שלו <span class="math">\(\left(\omega_{n}^{0},\omega_{n}^{1},\dots,\omega_{n}^{n-1}\right)\)</span> הן כל <span class="math">\(n\)</span> שורשי היחידה מסדר <span class="math">\(n\)</span>. הקלט להתמרת פורייה הבדידה היא סדרה <span class="math">\(\left(a_{0},a_{1},\dots,a_{n-1}\right)\)</span> של <span class="math">\(n\)</span> מספרים מרוכבים (האינדקס מתחיל מ-0 כי אנחנו במדעי המחשב, כמובן) והפלט הוא סדרה <span class="math">\(\left(b_{0},b_{1},\dots,b_{n-1}\right)\)</span> של סדרה של מספרים מרוכבים, כך שמתקיים הקשר הבא בין הסדרות, לכל <span class="math">\(0\le k&lt;n\)</span>:</p>
<p><span class="math">\(b_{k}=\sum_{t=0}^{n-1}a_{t}\omega_{n}^{-kt}\)</span> (<strong>משוואת אנליזה</strong>)</p>
<p><span class="math">\(a_{k}=\frac{1}{n}\sum_{t=0}^{n-1}b_{t}\omega_{n}^{kt}\)</span> (<strong>משוואת סינתזה</strong>)</p>
<p>למעשה, בפוסט הקודם המשוואות נראו טיפה אחרת (ה-<span class="math">\(\frac{1}{n}\)</span> הופיע במשוואת האנליזה דווקא) אבל ההבדל אינו מהותי ומעכשיו המשוואות שיעניינו אותי הן אלו שהצגתי כאן.</p>
<p>במבט ראשון, לא נראה שיש בכלל צורך באלגוריתם כלשהו - המשוואות שמאפשרות לנו לחשב את <span class="math">\(b_{k}\)</span> לכל <span class="math">\(k\)</span> הן פשוטות מאוד. פשוט כופלים שורשי יחידה ב-<span class="math">\(a_{t}\)</span>-ים ומחברים. מה הסיפור? ובכן, פשוט מאוד: יש <span class="math">\(n\)</span> איברים <span class="math">\(b_{t}\)</span> שאנחנו רוצים לחשב, ולכל אחד מהם נצטרך לבצע <span class="math">\(n\)</span> פעולות של כפל ו-<span class="math">\(n\)</span> פעולות של חיבור. סה"כ <span class="math">\(\Theta\left(n^{2}\right)\)</span> פעולות. זה לא המון, אבל זה גם לא מעט. אם <span class="math">\(n=1000\)</span> זה אומר שנזדקק למיליון פעולות בערך.</p>
<p>מה שאנחנו <strong>רוצים</strong> הוא אלגוריתם שמבצע את כל המהומה הזו עם <span class="math">\(\Theta\left(n\log n\right)\)</span> פעולות, כלומר כאשר <span class="math">\(n=1000\)</span> הוא מבצע בערך 7,000 פעולות - ההבדל בין זה ובין מיליון הוא די ברור. להשוואת זמני ריצה בפועל במימושים אמיתיים נגיע בסוף, אבל בינתיים תאמינו לי שזה הבדל גדול.</p>
<p>האלגוריתם שאציג לא יהיה סוף דבר - הוא יהיה שיטה נאיבית יחסית להתמודדות עם הבעיה. זה אומר שיש שיטות מורכבות יותר שאני לא מציג, והוא גם יניח הנחה מוזרה - ש-<span class="math">\(n\)</span> הוא חזקה של 2. עם זאת, הוא ישיג לנו את זמן ה-<span class="math">\(\Theta\left(n\log n\right)\)</span> המובטח ויתן תחושה של "איך עושים את הקסם הזה", שזה מה שאני מחפש.</p>
<p>לפני שנצלול לפרטים, הנה הרעיון, וזה רעיון פשוט מאוד. ראשית, בואו נשים לב שאת משוואות האנליזה ניתן לתאר בתור <strong>הצבה של שורשי יחידה בפולינום</strong>. נגדיר את הפולינום <span class="math">\(A\left(x\right)=\sum_{t=0}^{n-1}a_{t}x^{t}\)</span>. כעת נשים לב לכך ש-<span class="math">\(b_{k}=A\left(\omega_{n}^{-k}\right)\)</span>. אז אפשר לשאול את השאלה הכללית: בהינתן פולינום <span class="math">\(A\)</span> עם <span class="math">\(n\)</span> מקדמים ו-<span class="math">\(n\)</span> נקודות <span class="math">\(x_{0},\dots,x_{n-1}\)</span>, האם ניתן למצוא את <span class="math">\(y_{0},\dots,y_{n-1}\)</span> המוגדרים על ידי <span class="math">\(y_{k}=A\left(x_{k}\right)\)</span> ב-<span class="math">\(\Theta\left(n\log n\right)\)</span> פעולות במקום ב-<span class="math">\(\Theta\left(n^{2}\right)\)</span>?</p>
<p>זו שאלה טובה, ולמיטב ידיעתי התשובה היא <strong>לא </strong>(אבל אני לא מומחה ואין לי הוכחה כרגע). כלומר, אם אני מנסה לחשב את הערכים של <span class="math">\(A\)</span> בנקודות <strong>שרירותיות כלשהן</strong>, אין לי דרך חכמה לעשות את זה. הקסם של התמרת פורייה המהירה הוא שבמקרה <strong>הספציפי</strong> של שורשי היחידה, דווקא כן אפשר לעשות קיצורי דרך בחישובים. זה אומר שהאלגוריתם יצטרך להסתמך איכשהו על תכונות מיוחדות שיש לשורשי היחידה ולסתם מספרים שרירותיים אין.</p>
<p>הרעיון הבסיסי באלגוריתם הוא פשוט מאוד: <strong>הפרד ומשול</strong>. הדוגמה הקלאסית שצריכה להיות לכם בראש היא זו של <a href="http://www.gadial.net/2012/07/10/all_sorts_of_slow_sorts/">אלגוריתם מיון-מיזוג</a>: הרעיון באלגוריתם המיון הזה הוא לקחת את הרשימה שממיינים, לפצל אותה לשניים, למיין כל תת-רשימה באופן רקורסיבי, ואז למזג את שתי הרשימות הממויינות שהתקבלו, תוך ניצול העובדה ש<strong>קל יחסית</strong> למזג שתי רשימות ממויינות.</p>
<p>גם כן אנחנו הולכים לקחת את הסדרה שאנחנו רוצים לבצע לה התמרה, לפצל אותה לשתי תת-סדרות, למצוא התמרה לכל אחת בנפרד ואז "למזג" את שתי ההתמרות להתמרה אחת, יחסית ביעילות. ברמה הטכנית זה מתבצע בעזרת הפולינום <span class="math">\(A\)</span> שתיארתי: אנחנו מפרקים את <span class="math">\(A\)</span> לשני תת-פולינומים <span class="math">\(A^{0},A^{1}\)</span>, ובמקום לחשב את הערך של <span class="math">\(A\)</span> על שורשי היחידה מסדר <span class="math">\(n\)</span>, אנחנו מחשבים את הערכים של שני תתי-הפולינומים על שורשי היחידה מסדר <span class="math">\(\frac{n}{2}\)</span>. את הערכים הללו אנחנו יכולים "למזג" אחר כך ולקבל את הערכים של <span class="math">\(A\)</span> על שורשי היחידה מסדר <span class="math">\(n\)</span>. זה כל הסיפור; רק צריך להבין איך מתבצע שלב ה"מיזוג" במקרה הנוכחי. רק שימו לב לכך שראינו מדוע הכרחי להניח ש-<span class="math">\(n\)</span> הוא חזקה של 2: אנחנו חייבים ש-<span class="math">\(n\)</span> יתחלק ב-2 כדי הפירוק לשני תתי-פולינומים יעבוד ללא בעיות, ומכיוון שאנו פותרים באופן רקורסיבי גם <span class="math">\(\frac{n}{2}\)</span> יצטרך לקיים את התכונה הזו וכן הלאה (עד למקרה של <span class="math">\(n=1\)</span> שהוא טריוויאלי - ההתמרה של סדרה מאורך 1 הוא הסדרה עצמה).</p>
<p>כלי הנשק המתמטי הבסיסי שלנו כאן הוא התכונה הבאה של שורשי היחידה מסדר <span class="math">\(n\)</span>, כאשר <span class="math">\(n\)</span> הוא מספר זוגי: אם נעלה את כל שורשי היחידה מסדר <span class="math">\(n\)</span> בריבוע, נקבל את כל שורשי היחידה מסדר <span class="math">\(\frac{n}{2}\)</span>, כאשר כל שורש יחידה שכזה מתקבל בדיוק פעמיים. הנה דוגמה קלה: שורשי היחידה מסדר 4 הם המספרים <span class="math">\(1,i,-1,-i\)</span>. אם נעלה אותם בריבוע נקבל את המספרים <span class="math">\(1,-1,1,-1\)</span>, שהם שורשי היחידה מסדר 2, וכל אחד מהם התקבל בדיוק פעמיים. כבר מהדוגמה הזו מתקבל הרושם ש-<span class="math">\(\frac{n}{2}\)</span> שורשי היחידה הראשונים, עד <span class="math">\(\omega_{n}^{\frac{n}{2}}\)</span>, כבר מספיקים כדי "לכסות" את כל שורשי היחידה מסדר <span class="math">\(\frac{n}{2}\)</span>, וש-<span class="math">\(\frac{n}{2}\)</span> השורשים הבאים נותנים בדיוק את אותם ערכים (באותו סדר) כשמעלים אותם בריבוע.</p>
<p>בואו נוכיח את זה פורמלית. האבחנה הכללית היא ש-<span class="math">\(\omega_{dn}^{dk}=\omega_{n}^{k}\)</span>, וזה נובע ישירות מההגדרה: <span class="math">\(\omega_{dn}^{dk}=e^{\frac{2\pi idk}{dn}}=e^{\frac{2\pi ik}{n}}=\omega_{n}^{k}\)</span>. כמו כן, <span class="math">\(\omega_{n}^{k+n}=\omega_{n}^{k}\cdot\omega_{n}^{n}=\omega_{n}^{k}\)</span> (כי <span class="math">\(\omega_{n}^{n}=1\)</span> שהרי <span class="math">\(\omega_{n}\)</span> הוא שורש יחידה מסדר <span class="math">\(n\)</span>). לכן:</p>
<p>מכאן נקבל לכל <span class="math">\(0\le k&lt;\frac{n}{2}\)</span>:</p>
<p><span class="math">\(\left(\omega_{n}^{k+\frac{n}{2}}\right)^{2}=\omega_{n}^{2k+n}=\omega_{n/2}^{k+n/2}=\omega_{n/2}^{k}=\omega_{n}^{2k}=\left(\omega_{n}^{k}\right)^{2}\)</span></p>
<p>ראינו שהריבועים של <span class="math">\(\omega_{n}^{k}\)</span> ושל <span class="math">\(\omega_{n}^{k+\frac{n}{2}}\)</span> זהים, אבל למה הם שורש יחידה מסדר <span class="math">\(\frac{n}{2}\)</span>? אה, זה קל: כי <span class="math">\(\left[\left(\omega_{n}^{k}\right)^{2}\right]^{\frac{n}{2}}=\left(\omega_{n}^{k}\right)^{n}=1\)</span>. כעת, האם אנחנו באמת תופסים את <strong>כל</strong> שורשי היחידה מסדר <span class="math">\(\frac{n}{2}\)</span> כך? שוב, די בבירור כן, כי <span class="math">\(\omega_{n/2}^{k}=\omega_{n}^{2k}=\left(\omega_{n}^{k}\right)^{2}\)</span> (כאשר <span class="math">\(0\le k&lt;\frac{n}{2}\)</span>).</p>
<p>אז אם לסכם: הריבועים של <span class="math">\(\omega_{n}^{0},\omega_{n}^{1},\omega_{n}^{2},\dots,\omega_{n}^{\frac{n}{2}-1}\)</span> נותנים בדיוק את כל שורשי היחידה מסדר <span class="math">\(\frac{n}{2}\)</span>, והם זהים (גם בסדר שלהם) לריבועים של <span class="math">\(\omega_{n}^{\frac{n}{2}},\omega_{n}^{\frac{n}{2}+1},\dots,\omega_{n}^{n-1}\)</span>. עכשיו אפשר לעבור לאלגוריתם עצמו.</p>
<p>כזכור, אנחנו מתבוננים בפולינום <span class="math">\(A\left(x\right)=\sum_{t=0}^{n-1}a_{t}x^{t}\)</span> ורוצים לחשב את ההצבה של שורשי היחידה בו. מה שנעשה יהיה לפרק אותו לשני פולינומים - זה של המקדמים במקומות הזוגיים, וזה של המקדמים במקומות האי זוגיים. נגדיר:</p>
<p><span class="math">\(A^{0}\left(x\right)=\sum_{t=0}^{\frac{n}{2}-1}a_{2t}x^{t}=a_{0}x^{0}+a_{2}x^{1}+a_{4}x^{2}+\dots+a_{n-2}x^{\frac{n}{2}-1}\)</span></p>
<p><span class="math">\(A^{1}\left(x\right)=\sum_{t=0}^{\frac{n}{2}-1}a_{2t+1}x^{2t+1}=a_{1}x^{0}+a_{3}x^{1}+a_{5}x^{2}+\dots+a_{n-1}x^{\frac{n}{2}-1}\)</span></p>
<p>שימו לב - החזקות של ה-<span class="math">\(x\)</span>-ים הן רציפות, מ-1 ועד <span class="math">\(\frac{n}{2}-1\)</span>, ולכן קיבלנו שני פולינומים ממעלה נמוכה בחצי מזו של <span class="math">\(A\left(x\right)\)</span>, שפשוט מחלקים ביניהם את המקדמים שלו.</p>
<p>עכשיו, אפשר לתאר את <span class="math">\(A\left(x\right)\)</span> בעזרת שני הפולינומים הללו בצורה הפשוטה הבאה:</p>
<p><span class="math">\(A\left(x\right)=A^{0}\left(x^{2}\right)+xA^{1}\left(x^{2}\right)\)</span></p>
<p>אם אתם לא מאמינים, נסו לבצע את החישוב בעצמכם, זה קל.</p>
<p>המסקנה פשוטה:</p>
<p><span class="math">\(A\left(\omega_{n}^{k}\right)=A^{0}\left(\omega_{n}^{2k}\right)+\omega_{n}^{k}A^{1}\left(\omega_{n}^{2k}\right)=A^{0}\left(\omega_{n/2}^{k}\right)+\omega_{n}^{k}A^{1}\left(\omega_{n/2}^{k}\right)\)</span></p>
<p>וכפי שראינו, עבור <span class="math">\(k\ge\frac{n}{2}\)</span> אין צורך לחשב את הערכים של <span class="math">\(A^{0},A^{1}\)</span> על <span class="math">\(\omega_{n}^{k}\)</span> במפורש, אפשר להשתמש בערך שלו על <span class="math">\(\omega_{n}^{k-\frac{n}{2}}\)</span>. <strong>זו</strong> הנקודה שבה אנחנו מנצלים את שורשי היחידה כדי לחסוך משהו.</p>
<p>הנה פסאודו-קוד של האלגוריתם. מכיוון שאני חסיד גדול של גישת "לתת פסאודו-קוד שבאמת אפשר להריץ", הוא כתוב עבור מערכת האלגברה הממוחשבת Sage, שמשתמשת בשפה שהיא כמעט פייתון, עם כמה הרחבות (למשל, הסימן של החזקה). הדברים היחידים שנאלצתי לכתוב כאן ולא הייתי כותב בפסאודו קוד הם I במקום i בשביל השורש של מינוס 1, והמרה מפורשת של <span class="math">\(\frac{n}{2}\)</span> למספר שלם, אחרת Sage לא מוכן לבצע פעולות מודולו <span class="math">\(\frac{n}{2}\)</span>.</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fft</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span>
  <span class="n">omega</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a0</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
  <span class="n">a1</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
  <span class="n">b0</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
  <span class="n">b1</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">b0</span><span class="p">[</span><span class="n">k</span> <span class="o">%</span> <span class="n">Integer</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> <span class="n">omega</span><span class="o">^</span><span class="n">k</span><span class="o">*</span><span class="n">b1</span><span class="p">[</span><span class="n">k</span> <span class="o">%</span> <span class="n">Integer</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">b</span>
</code></pre></div>


</div>

<p>כמובן, הקוד הזה מסתיר בתוכו מורכבות בסיסית ש-Sage מטפל בה אוטומטית אבל בשפות תכנות פשוטות אין אותה - אריתמטיקה עם שורשי היחידה <span class="math">\(\omega_{n}^{k}\)</span>. אנחנו מעלים אותם בחזקות, ומחברים אותם, ובלאגן שלם. מי שירצה לממש את התמרת פורייה יצטרך, כמובן, לממש קודם את החלק שמתעסק באריתמטיקה של המספרים הללו (ולכן של מספרים מרוכבים בכלל). לרוב פשוט מתבססים על ספריות קיימות.</p>
<p>קל לנתח את סיבוכיות האלגוריתם על ידי מבט בקוד. בשורות 6-7 ("הפיצול") יש לנו לולאות עם זמן <span class="math">\(O\left(n\right)\)</span> לכל אחת, וכך גם בשורה 10 ("המיזוג"). בשורות 8-9 יש לנו קריאה רקורסיבית לאלגוריתם עם קלט שגודלו חצי מהגודל הנוכחי. אז סיבוכיות האלגוריתם נתונה על ידי פתרון המשוואה <span class="math">\(T\left(n\right)=2T\left(\frac{n}{2}\right)+\Theta\left(n\right)\)</span> - אותה משוואה של מיון מיזוג, שפתרונה הוא <span class="math">\(T\left(n\right)=\Theta\left(n\log n\right)\)</span>.</p>
<p>מכאן גם קל לממש את האלגוריתם עבור ההתמרה ההפוכה. אפשר לכתוב את כל הקוד מחדש, אבל בשביל מה? הנוסחה, כזכור, היא <span class="math">\(a_{k}=\frac{1}{n}\sum_{t=0}^{n-1}b_{t}\omega_{n}^{kt}\)</span>. היא מאוד דומה לנוסחה של התמרה רגילה. אולי אפשר לחשב את ההתמרה ההפוכה בעזרת שימוש בהתמרה הרגילה? יש שני הבדלים בין ההתמרה הרגילה וההפוכה. ראשית, יש את הכפל ב-<span class="math">\(\frac{1}{n}\)</span>; ושנית, יש את הסימן של החזקה של שורש היחידה: הנוסחה של ההתמרה הרגילה היא <span class="math">\(b_{k}=\sum_{t=0}^{n-1}a_{t}\omega_{n}^{-kt}\)</span> ושם יש מינוס בחזקה, בעוד שכרגע אין.</p>
<p>התעלול המרכזי שנשתמש בו הוא שאנחנו כבר יודעים ש-<span class="math">\(\left(\omega_{n}^{k}\right)^{0}=\left(\omega_{n}^{k}\right)^{n}\)</span> ולכן <span class="math">\(\left(\omega_{n}^{k}\right)^{-t}=\left(\omega_{n}^{k}\right)^{n-t}\)</span>. לכן אפשר לכתוב את נוסחת ההתמרה הרגילה גם כך:</p>
<p><span class="math">\(b_{k}=\sum_{t=0}^{n-1}a_{t}\omega_{n}^{-kt}=\sum_{t=0}^{n-1}a_{t}\left(\omega_{n}^{k}\right)^{n-t}=\sum_{r=1}^{n}a_{n-r}\left(\omega_{n}^{k}\right)^{r}\)</span></p>
<p>כאן ביצעתי את החלפת המשתנה <span class="math">\(r=n-t\)</span>.</p>
<p>אם נסמן <span class="math">\(a_{n}\triangleq a_{0}\)</span> אפשר לכתוב את הסכום האחרון שלמעלה בתור <span class="math">\(\sum_{r=0}^{n-1}a_{n-r}\left(\omega_{n}^{k}\right)^{r}\)</span>, שנראה קצת יותר מוכר.</p>
<p>אם כן, אם נתונה לי הסדרה <span class="math">\(c_{0},c_{1},\dots,c_{n-1}\)</span> ואני רוצה לבצע עליה את ההתמרה ההפוכה, אני בעצם רוצה לחשב התמרת פורייה רגילה על הסדרה <span class="math">\(a_{0},\dots,a_{n-1}\)</span> המוגדרת על ידי המשוואה:</p>
<p><span class="math">\(\sum_{r=0}^{n-1}a_{n-r}\left(\omega_{n}^{k}\right)^{r}=\frac{1}{n}\sum_{t=0}^{n-1}c_{t}\left(\omega_{n}^{k}\right)^{t}\)</span></p>
<p>זה נותן לי את השוויונות הבאים:</p>
<p><span class="math">\(a_{n-t}=\frac{1}{n}c_{t}\)</span> כאשר <span class="math">\(0\le t&lt;n\)</span></p>
<p>כלומר, <span class="math">\(a_{t}=\frac{1}{n}c_{n-t}\)</span> כאשר <span class="math">\(0&lt;t\le n\)</span>. עבור <span class="math">\(a_{0}\)</span> כזכור מתקיים <span class="math">\(a_{0}=a_{n}\)</span>.</p>
<p>אם לסכם את מה שעשינו כאן, ה-<span class="math">\(a\)</span>-ים שלנו מתקבלים מה-<span class="math">\(c\)</span>-ים בצורה הבאה: את כל ה-<span class="math">\(c\)</span>-ים כופלים ב-<span class="math">\(\frac{1}{n}\)</span>; את האיבר הראשון שלהם משאירים ללא שינוי; את הסדר של היתר הופכים. במילים אחרות, אם <span class="math">\(c=\left(1,2,3,4\right)\)</span> אז נקבל <span class="math">\(a=\left(\frac{1}{4},1,\frac{3}{4},\frac{1}{2}\right)\)</span>. זה יוצא מאוד פשוט בקוד פייתון, שבו יש קונבנציה שאינדקסים שליליים ברשימה עוברים עליה מהסוף להתחלה:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">inverse_fft</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">fft</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">n</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">))])</span>
</code></pre></div>


</div>

<p>ומכאן קצרה הדרך לקוד עבור קונבולוציה:</p>
<div class="code-block">

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">convolution</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
  <span class="n">a_pad</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))]</span>
  <span class="n">b_pad</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))]</span>
  <span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">a_pad</span><span class="p">)</span>
  <span class="n">B</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">b_pad</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">inverse_fft</span><span class="p">([</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))])[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>


</div>

<p>הקוד הזה הוא נאיבי, במובן זה שהוא מניח ששתי הרשימות הן באותו האורך (ושהאורך הזה הוא חזקה של 2). יותר מזה, הוא גם עושה משהו מוזר - "מרפד" כל רשימה עם אפסים באופן שמכפיל את גודלה. למה? ובכן, כי שיקרתי קצת בפוסט הקודם: יצרתי את הרושם שקונבולוציה של שתי רשימות סופיות של מספרים אוטומטית מניחה שכל שאר המקומות הם 0, וזה אכן מה שצפוי שיהיה ומה שאנחנו משתמשים בו כשאנחנו כופלים פולינומים, למשל, אבל זה <strong>לא</strong> מה שהתמרת פורייה הבדידה עובדת איתו. זכרו שהתמרת פורייה הבדידה מתייחסת לרשימה של מספרים כאילו הם מייצגים פונקציה <strong>מחזורית</strong>, כלומר מחוץ לגבולות הרשימה הפונקציה מתחילה לחזור על עצמה. זה אומר שהקונבולוציה שאותה התמרת פורייה יודעת להפוך לכפל היא כזו שמניחה שהפונקציה היא מחזורית. הריפוד הוא פשוט דרך להתחמק מזה - אנחנו שמים אפסים בכל המקומות שעשויים להשפיע על החישוב, ואז מתעלמים מהאיברים ה"מיותרים" שנוצרו במהלך חישוב הקונבולוציה. זה מרגיש מלוכלך נורא, אבל זה למעשה לא פתרון כזה גרוע.</p>
<p>סיימנו לבינתיים עם FFT ועם התמרות פורייה למיניהן, אבל כמובן שהסיפור רק מתחיל כאן; פורייה נהיה מעניין כשמשתמשים בו בפועל. אני מקווה להציג בעתיד (אולי הלא רחוק) כמה שימושים מעניינים באמת.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>