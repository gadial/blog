<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>פותרים את SAT - אלגוריתם CDCL - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2014/02/03/cdcl_sat_solving/">
    <meta property="og:title" content="פותרים את SAT - אלגוריתם CDCL">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2014/02/03/cdcl_sat_solving/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="פותרים את SAT - אלגוריתם CDCL">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <a href="/lecture_notes.html">סיכומי הרצאות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2014/02/02/hamburger_manipulation/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">המניפולציה המתמטית של ההמבורגר</span>
            </a>
            

            
            <a href="/2014/02/09/hilbert_spaces/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">אז מה זה מרחב הילברט?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>פותרים את SAT - אלגוריתם CDCL</h1>
            <div class="post-meta">
                <span class="date">2014-02-03</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                    <a href="/categories/מבני נתונים ואלגוריתמים.html">מבני נתונים ואלגוריתמים</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/DPLL.html">DPLL</a>
                    
                    <a href="/tags/אלגוריתם CDCL.html">אלגוריתם CDCL</a>
                    
                    <a href="/tags/בעיית SAT.html">בעיית SAT</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p><a href="http://www.gadial.net/2013/12/11/dpll_algorithm/">בפוסט הקודם</a> על פתרונות לבעיית SAT ראינו את אלגוריתם DPLL - זה היה פחות או יותר האלגוריתם הבסיסי שרוב פותרי ה-SAT המדוייקים (להבדיל מהסתברותיים) מבוססים עליו, אבל מן הסתם פותרים מודרניים הולכים רחוק יותר ממנו, ובפוסט הזה אני רוצה להציג אלגוריתם קצת יותר מודרני שמתבסס על DPLL אבל עושה עוד דברים מתוחכמים - אלגוריתם CDCL, קיצור של Conflict-Driven Clause Learning. כמובן, כמו DPLL גם זה לא "אלגוריתם" במלוא מובן המילה אלא בעיקר "מסגרת" שלתוכה אפשר לצקת שלל שיפורים ושפצורים, אבל הרעיונות הכלליים שלו עדיין מעניינים.</p>
<p>בואו ניזכר מה DPLL עושה, ברמה הבסיסית: הוא מבצע לסירוגין שתי פעולות שונות - הראשונה היא בחינה של הפסוק שיש לו כרגע וזיהוי השמות למשתנים ספציפיים ש<strong>חייבות</strong> להתרחש, ופישוט של הפסוק לאחר ביצוע ההשמות הללו; והשניה היא בחירה של משתנה כלשהו וערך להציב בו. אם כן, יש לנו שני סוגים של השמות למשתנים: אלו שבהן <strong>בחרנו</strong> לתת למשתנה ערך מסויים - במקרה הזה, המשתנה ייקרא "משתנה בחירה" (Decision Variable), ואלו שבהן "לא הייתה לנו ברירה" והערך ששמנו במשתנה נבע מהבחירות שעשינו. כאשר האלגוריתם מזהה שהוא "נתקע" - כלומר, הוא מגלה שיש פסוקית שכבר אין לו סיכוי לספק - הוא פשוט חוזר אחורה אל משתנה הבחירה האחרון שטרם ניסינו בו את האפשרות השניה, ומנסה אותה.</p>
<p>המבנה של CDCL דומה אבל קצת יותר חכם. בראש ובראשונה, כאשר מתגלה ש"נתקענו" - מה שנקרא בטרמינולוגיה של האלגוריתם הזה Conflict, האלגוריתם לא סתם מתייאש ואומר "בואו נחזור אחורה" - הוא מנסה <strong>ללמוד</strong> מזה מידע כלשהו על מה שגרם לקונפליקט. את המידע שהוא לומד הוא ממדל בצורת <strong>אילוץ חדש</strong> שמוסיפים לפסוק ה-CNF שמנסים לפתור. אחר כך האלגוריתם חוזר אחורה ומבטל חלק ממשתני הבחירה האחרונים (לאו דווקא רק אחד אחורה). אספקט נחמד של האלגוריתם הוא שאין צורך לבצע "ניהול חשבונות" כדי לזכור עבור משתנה בחירה אם כבר ניסינו בו את האפשרות השניה - האילוצים שאנחנו לומדים כבר יבטיחו שלא ננסה לתת למשתנה בחירה כלשהו את אותה האפשרות פעמיים.</p>
<p>כל זה מאוד אבסטרקטי ולכן בואו נראה דוגמה קונקרטית, שאני גונב מה-Handbook of Satisfiability (יש דבר כזה!). פסוק <span class="math">\(\varphi=C_{1}\wedge C_{2}\wedge C_{3}\wedge C_{4}\wedge C_{5}\wedge C_{6}\)</span> שמורכב מהפסוקיות הבאות:</p>
<p><span class="math">\(C_{1}=\left(x_{1}\vee x_{31}\vee\neg x_{2}\right)\)</span></p>
<p><span class="math">\(C_{2}=\left(x_{1}\vee\neg x_{3}\right)\)</span></p>
<p><span class="math">\(C_{3}=\left(x_{2}\vee x_{3}\vee x_{4}\right)\)</span></p>
<p><span class="math">\(C_{4}=\left(\neg x_{4}\vee\neg x_{5}\right)\)</span></p>
<p><span class="math">\(C_{5}=\left(x_{21}\vee\neg x_{4}\vee\neg x_{6}\right)\)</span></p>
<p><span class="math">\(C_{6}=\left(x_{5}\vee x_{6}\right)\)</span></p>
<p>בואו נניח שבמהלך הריצה האלגוריתם שלנו הציב -<span class="math">\(x_{1}\)</span> את הערך 0, ואחר כך ב-<span class="math">\(x_{31}\)</span> הציב את הערך 0, ולבסוף הציב ב-<span class="math">\(x_{21}\)</span> את הערך 0. מה קורה?</p>
<p>ובכן, ההצבה ב-<span class="math">\(x_{1}\)</span> תגרום ל-<span class="math">\(C_{2}\)</span> להפוך לפסוק <span class="math">\(\left(\neg x_{3}\right)\)</span> כך ש-<span class="math">\(x_{3}\)</span> חייב להיות 0. בדומה, <span class="math">\(C_{1}\)</span> יאבד גם את <span class="math">\(x_{1}\)</span> וגם את <span class="math">\(x_{31}\)</span> ולכן גם <span class="math">\(x_{2}\)</span> חייב להיות 0. עכשיו משני אלו נקבל ב-<span class="math">\(C_{3}\)</span> ש-<span class="math">\(x_{4}\)</span> חייב להיות 1, וזה יגרור ש-<span class="math">\(x_{5}\)</span> הוא 0 בגלל <span class="math">\(C_{4}\)</span>, וש-<span class="math">\(x_{6}\)</span> חייב להיות 0 על פי <span class="math">\(C_{5}\)</span>. אבל עכשיו "הפסדנו" את <span class="math">\(C_{6}\)</span> כי שני הליטרלים שלו (החיובי והשלילי) קיבלו 0. השאלה היא מה אפשר ללמוד מזה.</p>
<p>ובכן, כל המלל שלעיל הוא קצת מסורבל. קל יותר להבין מה הלך כאן אם מציירים את זה בתור גרף:</p>
<p><strong><a href="/img/2014/02/sat_implication_grap.png"><img class="alignnone size-full wp-image-3037" alt="sat_implication_grap" src="/img/2014/02/sat_implication_grap.png" width="976" height="293" /></a></strong></p>
<p>מה שיש לנו כאן מכונה Implication graph - "גרף הגרירות". הצמתים שלו הן כל ההשמות למשתנים - הן משתני הבחירה והן המשתנים הנגררים. יש קשת מהשמה אחת להשמה אחרת אם ההשמה האחת הייתה מעורבת בגרירה של האחרת - והכיתוב של הקשת הוא הפסוקית שבה התבצעה הגרירה הזו. <span class="math">\(X\)</span> מייצג את ההרס והחורבן של הסתירה שהגענו אליה - אם תרצו, אפשר לחשוב עליו כאילו הוא נגרר מפסוקית ש"התרוקנה", או ממשתנה אחד שהושמו בו שני ערכים שונים (זו בעצם אינדיקציה לכך שיש שתי פסוקיות שמתרוקנות - אחת כשמציבים במשתנה הזה 0 והשניה שמתרוקנת כשמציבים בו 1).</p>
<p>פורמלית, אם <span class="math">\(x\)</span> הוא משתנה אז כדי שהצומת <span class="math">\(x=1\)</span> יופיע בגרף צריכה להיות ב-<span class="math">\(\varphi\)</span> פסוקית מהצורה <span class="math">\(\left(l_{1}\vee\dots\vee l_{k}\vee x\right)\)</span> כך ש-<span class="math">\(l_{1},\dots,l_{k}\)</span> קיבלו כולם את הערך 0 בהשמה למשתנים שלהם, ואז מהצמתים של ההשמות הללו תהיה קשת אל הצומת <span class="math">\(x=1\)</span>. הסיפור עבור <span class="math">\(x=0\)</span> דומה רק שהפסוקית צריכה להיות מהצורה <span class="math">\(\left(l_{1}\vee\dots\vee l_{k}\vee\neg x\right)\)</span>.</p>
<p>הצמתים היחידים בגרף שאין להם אב הם הצמתים שמייצגים השמות למשתני החלטה (כי ההשמות הללו לא נגררו משום דבר). כמובן, בפסוק ענקי עשוי להיות גרף גרירות ענקי, ורובו לאו דווקא יהיה רלוונטי בכלל לקונפליקט שאליו הגענו בסוף. לכן נהוג להצטמצם לתת-גרף ("גרף הקונפליקט") שבו "מגלחים" את החלק המיותר - אם ל-<span class="math">\(X\)</span> יש יותר ממשתנה אחד שגורר אותו (יש קונפליקט בכמה משתנים) מתמקדים רק בצמתים של משתנה אחד, והולכים ממנו אחורה תוך שלוקחים רק את מה שחייבים: לכל צומת בוחרים פסוקית אחת ולוקחים את כל הצמתים שנכנסים אליו והקשתות שלהם מסומנות בפסוקית הזו, עד שמגיעים בכל מקום לצמתים של השמות למשתני בחירה.</p>
<p>כמובן, האופן שבו בוחרים איך בדיוק לצמצם גרף גרירה כללי לתת-גרף הקונפליקט הזה הוא עניין לאינסוף היוריסטיקות שיכולות להשפיע באופן דרסטי על איכות הפותר. אבל אני לא מבין בזה יותר מדי ולא אכנס לזה עכשיו.</p>
<p>נניח שיש לנו גרף קונפליקט ואנחנו רוצים ללמוד ממנו משהו. מה נעשה עכשיו? אם נחשוב על זה לרגע, ברור שכל קשת בגרף הזו קריטית - אם נעיף אחת מהקשתות, הגרירות של הגרף כבר לא יתקיימו והקונפליקט לא יתרחש. איך מעיפים קשת? "לומדים" פסוקית חדשה שמחסלת את ההשמה שהקשת יצאה ממנה. למשל, נניח שאנחנו רוצים לחסל את הקשת שיוצאת מ-<span class="math">\(x_{5}=0\)</span>. אנחנו יכולים להוסיף לפסוק שלנו את הפסוקית <span class="math">\(\left(x_{5}\right)\)</span> שמכריחה את <span class="math">\(x_{5}\)</span> להיות 1, ובכך נמנע את הקונפליקט. הבעיה היא שזו גישה חזקה <strong>מדי</strong> - אנחנו נסגרים על הערך שניתן ל-<span class="math">\(x_{5}\)</span> מכאן ואילך, ולא חושבים שאולי פספסנו אפשרויות שבהן <span class="math">\(x_{5}\)</span> עדיין יקבל 0 והפסוק יסתפק (וזה בעייתי מאוד כי באופן כללי ייתכן שיש השמה כזו, אבל אין השמה שבה <span class="math">\(x_{5}\)</span> מקבל 1 והפסוק מסתפק).</p>
<p>אז אפשר ללכת לקיצוניות השניה: אפשר לומר שצריך להיפטר מקשת <strong>כלשהי</strong> בגרף, ולהוסיף פסוקית שאומרת שלפחות אחת מההשמות שמופיעות בגרף, חוץ מ-<span class="math">\(x_{6}=1\)</span>, היא פסולה: <span class="math">\(\left(x_{31}\vee x_{1}\vee x_{2}\vee x_{3}\vee\neg x_{4}\vee x_{21}\vee x_{5}\vee x_{6}\right)\)</span>. למה חוץ מ-<span class="math">\(x_{6}=1\)</span>? כי כבר אמרנו ש-<span class="math">\(x_{6}=0\)</span> פסול, ואם נאמר שגם <span class="math">\(x_{6}=1\)</span> פסול נכסה בכך את כל האפשרויות מבלי לומר משהו מעניין חדש, כי כל השמה פוסלת את <span class="math">\(x_{6}=0\)</span> או את <span class="math">\(x_{6}=1\)</span>.</p>
<p>הבעיה היא שהפסוקית הזו בבירור גדולה מדי - אנחנו יכולים להיות יותר ממוקדים מזה. אז מה הסוד? לוקחים חתך בגרף.</p>
<p>אינטואיטיבית, חתך הוא קטיעה של קשתות בגרף כך שהגרף יתפרק לשני חלקים. פורמלית, חתך הוא פשוט חלוקה של צמתי הגרף לשתי קבוצות, ונהוג לדבר על הקשתות שחוצות את החתך - כל הקשתות שקצה אחד שלהן הוא בקבוצה אחת של החתך והקצה השני בקבוצה השניה. הנה דוגמה לחתך בגרף שלנו:</p>
<p><strong><a href="/img/2014/02/sat_implication_graph_cut_1.png"><img class="alignnone size-full wp-image-3038" alt="sat_implication_graph_cut_1" src="/img/2014/02/sat_implication_graph_cut_1.png" width="2105" height="790" /></a></strong></p>
<p>אז אנחנו לוקחים חתך שמקיים את התכונה הבאה: בקבוצה האחת שלו יש את כל משתני ההחלטה, ובקבוצה השניה יש לפחות אחד מהמשתנים שגרם לקונפליקט, ואת הצומת <span class="math">\(X\)</span>. נסתכל על הקשתות שחוצות את החתך, ובאופן יותר ספציפי - בצמתים שמהם הקשתות יצאו. לא קשה במיוחד להשתכנע שאם יש לנו השמה <strong>כלשהי</strong> שמתאימה להשמות שכתובות בצמתים הללו, אז בהכרח נגיע לקונפליקט (בלי קשר לשאלה מה ההשמה עושה לשאר הצמתים). אז בכל השמה שמספקת את הפסוק, לפחות אחת מההשמות הללו חייבת להשתנות. המשמעות של זה עבור החתך הספציפי שבחרנו הוא הוספת הפסוקית הבאה לפסוק:</p>
<p><span class="math">\(\left(\neg x_{4}\vee x_{21}\right)\)</span></p>
<p>זה כמובן הרבה יותר פשוט (ומצמצם יותר את מרחב החיפוש של אלגוריתם ה-CDCL) מאשר הפסוקית המפלצתית שתיארתי קודם. אבל זו לא האפשרות היחידה, כמובן; הנה חתך שנותן לנו את הפסוקית <span class="math">\(\left(x_{21}\vee x_{2}\vee x_{3}\right)\)</span>:</p>
<p><strong><a href="/img/2014/02/sat_implication_graph_cut_2.png"><img class="alignnone size-full wp-image-3039" alt="sat_implication_graph_cut_2" src="/img/2014/02/sat_implication_graph_cut_2.png" width="2105" height="953" /></a></strong></p>
<p>ושוב, איך מחליטים איזה חתך לקחת? אין לי תשובה נחמדה - היוריסטיקות, היוריסטיקות, היוריסטיקות. ודברים קצת יותר חכמים שאני לא הולך להיכנס אליהם עכשיו.</p>
<p>חזרה לאלגוריתם ה-CDCL שלנו. אחרי שהאלגוריתם נתקל בקונפליקט, הוא מביט בגרף קונפליקט עבורו, בוחר חתך, מוסיף פסוקית לפסוק שלו, ואז קופץ חזרה אחורה - כלומר, מבטל חלק ממשתני הבחירה (לא מחליף את ערכם; פשוט שוכח שאי פעם הושם בהם ערך).</p>
<p>לצורך כך, גרף הגרירות צריך להכיל עוד פריט מידע שלא כתבתי בו כי זה כבר היה מסרבל: לכל השמה צריך להוסיף את <strong>דרגת ההחלטה</strong> שלה. דרגת החלטה של צומת החלטה היא קלה: היא שווה לדרגת ההחלטה של צומת ההחלטה הקודם, ועוד 1. עבור צמתים אחרים, דרגת ההחלטה שלהם היא המקסימלית מבין דרגות ההחלטה של הצמתים שנכנסים אליהם (מכיוון שרק אחרי שכל ההשמות הללו בוצעו ערכו של הצומת נקבע). כעת, אחרי שהחלטנו איזו פסוקית להוסיף, אנחנו מסתכלים על דרגות ההחלטה של הליטרלים שבפסוקיות - אם נלך אחורה ונבטל את כל ההחלטות עד וכולל דרגת ההחלטה הגבוהה ביותר של ליטרל בפסוקית, הפסוקית "תיכנס לפעולה".</p>
<p>בואו נסתכל על הדוגמה שלנו לשם כך. אצלנו דרגת ההחלטה של <span class="math">\(x_{1}\)</span> היא 0, של <span class="math">\(x_{31}\)</span> היא 1 ושל <span class="math">\(x_{21}\)</span> היא 2. מה זה אומר על ההשמות הנגזרות? <span class="math">\(x_{3}=0\)</span> היא מדרגה 0 (נובעת רק מ-<span class="math">\(x_{1}=0\)</span>) ו-<span class="math">\(x_{2}=0\)</span> היא מדרגה 1, ולכן <span class="math">\(x_{4}=1\)</span> היא מדרגה 1, ולכן <span class="math">\(x_{5}=0\)</span> היא מדרגה 1 וכך גם <span class="math">\(x_{6}=1\)</span>, ואילו <span class="math">\(x_{6}=0\)</span> היא מדרגה 2. נניח עכשיו שאנחנו לוקחים חתך שיוסיף לנו את הפסוקית <span class="math">\(\left(x_{2}\vee x_{3}\right)\)</span>. אם עכשיו נחזור רק צעד אחד אחורה בזמן ונבטל את ההשמה של דרגה 2, כלומר את <span class="math">\(x_{21}=0\)</span>, זה לא יבטל את ההצבה של 0 ב-<span class="math">\(x_{2},x_{3}\)</span> ונישאר תקועים עם פסוקית שלא הסתפקה. אז יש לנו שתי אפשרויות: או לבטל גם את ההשמה בדרגה 1, כלומר את <span class="math">\(x_{31}=0\)</span>, מה שיבטל את ההשמה <span class="math">\(x_{2}=0\)</span>; או לבטל אפילו את ההשמה בדרגה 0.</p>
<p>במקרה הראשון, נקבל ש-<span class="math">\(x_{3}=0\)</span> עדיין מתקיים, ולכן הפסוקית <span class="math">\(\left(x_{2}\vee x_{3}\right)\)</span> תהפוך ל-<span class="math">\(x_{2}\)</span>; במילים אחרות, ההצבה של דרגה 0, זו של <span class="math">\(x_{1}=0\)</span>, תגרור ש-<span class="math">\(x_{2}=1\)</span>. ואז יקרה משהו מעניין - אם תסתכלו על הפסוקית <span class="math">\(C_{1}\)</span>, תראו שאחרי ההשמה הזו, נהיה חייבים להציב <span class="math">\(x_{31}=1\)</span>. במילים אחרות, הוספת הפסוקית <span class="math">\(\left(x_{2}\vee x_{3}\right)\)</span> וחזרה אחורה עד לביטול לדרגה 1 גרמה לכך ש-<span class="math">\(x_{31}\)</span> כבר לא יהיה משתנה בחירה אלא משתנה נגזר, והערך שאנחנו מציבים בו יהיה הפוך מהערך שהצבנו בו כשהוא היה משתנה בחירה והגענו לסתירה. בקיצור, זה עובד!</p>
<p>במקרה השני, יש לנו משחק חדש - הפסוקית <span class="math">\(\left(x_{2}\vee x_{3}\right)\)</span> לא תגרום לשום דבר להתרחש מייד. אבל היא תהיה חלק מהפסוק שלנו, ופעפועים עתידיים הולכים להתחשב בה.</p>
<p>אם כן, זהו הרעיון הכללי שמאחורי "למידת פסוקיות". לי הרעיון הזה נשמע פשוט יחסית, וזה מאוד מפתיע ששיטות כאלו הן כל כך יעילות (יחסית). אבל בזכות היעילות הגבוהה שלהן, פותרי SAT הם שימושיים מאוד בפתרון בעיות אמיתיות; בפוסט הבא אתחיל להציג דוגמה לתחום שכזה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>