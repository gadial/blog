<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט קלייני - הוכחה נוספת - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                text-align: center;
                margin-bottom: 10px;
            }
            
            .top-nav .nav-links {
                flex-direction: column;
                width: 100%;
            }
            
            .top-nav .nav-links a {
                text-align: center;
                padding: 8px;
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/new_blog/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/new_blog/">דף הבית</a>
                <a href="/new_blog/random.html">פוסט אקראי</a>
                <a href="/new_blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_blog/2015/05/14/pumping_lemma_full/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">למת הניפוח לשפות רגולריות - גרסה מלאה</span>
            </a>
            

            
            <a href="/new_blog/2015/06/09/numbers_and_games_intro/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">על משחקים ומספרים (חלק א&#39;: משחקים. וקצת מספרים)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט קלייני - הוכחה נוספת</h1>
            <div class="post-meta">
                <span class="date">2015-05-28</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/משפט קלייני.html">משפט קלייני</a>
                    
                    <a href="/tags/שפות פורמליות.html">שפות פורמליות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אולי המשפט המרכזי בסדרת הפוסטים שלי על שפות רגולריות היה משפט קלייני. כזכור, שפה רגולרית היא שפה שקיים אוטומט סופי דטרמיניסטי שמקבל אותה, אבל משפט קלייני נתן אפיון שונה לגמרי עבורה, שאפשר לנו להבין מה המבנה הכללי של אוסף השפות הרגולריות. כזכור, הוא אמר שהשפות הרגולריות הן בדיוק השפות שמתקבלות על ידי פעולות האיחוד, השרשור וסגור-קלייני ("הפעולות הרגולריות"), מתוך אוסף בסיס של שפות שכלל את השפה הריקה, השפה שהמילה היחידה בה היא המילה הריקה, ולכל אות <span class="math">\(\sigma\in\Sigma\)</span>, השפה <span class="math">\(\left\{ \sigma\right\} \)</span>.</p>
<p>ההוכחה הייתה נפלאה, לטעמי. הרעיון היה להתחיל מאוטומט <span class="math">\(A\)</span> ולהגדיר שפות שאיכשהו ממדלות חישובים ב-<span class="math">\(A\)</span>: השפה <span class="math">\(L_{i,j}^{k}\)</span> תיארה את כל המילים שמעבירות את האוטומט מהמצב <span class="math">\(q_{i}\)</span> למצב <span class="math">\(q_{j}\)</span> בלי לעבור במצב עם אינדקס גדול מ-<span class="math">\(k\)</span> בתוך החישוב הזה. את השפות הללו היה ניתן לתאר בצורה רקורסיבית באמצעות הפעולות הרגולריות, כשתנאי הבסיס של הרקורסיה היו שפות פשוטות במיוחד שמתקבלות משפות הבסיס על ידי פעולות רגולריות.</p>
<p>עכשיו אני רוצה לתת הוכחה קצת שונה.</p>
<p>כמובן, שאלה מתבקשת תמיד כשנותנים הוכחה נוספת למשהו שכבר הוכחנו היא - למה? למה בכלל לטרוח להוכיח משהו שוב? אנחנו כבר יודעים שהוא נכון! אז למה למה למה?</p>
<p>ובכן, כי זה מגניב.</p>
<p>וגם, כי זה נותן לנו עוד נקודת מבט מעניינת, וקצת יותר כללית, על המשפט ומה שהוא אומר. מה שאני אעשה יהיה להוכיח את המשפט לא עבור אוטומטים סופיים דטרמיניסטיים, אלא עבור סוג מוכלל שלהם, והמשפט שאוכיח יהיה יותר כללי מאשר משפט קלייני הרגיל. ובנוסף לכל זה, ההוכחה עצמה היא מאוד טבעית ומתבקשת - מתחילים מאוטומט מוכלל שכזה, ואז באופן איטרטיבי מעיפים ממנו מצבים ומתקנים את האוטומט בהתאם; איכשהו בסוף נגיע לאוטומט טריוויאלי שכולל תיאור "מיידי" של השפה. בהמשך הדיבור המעורפל הזה יתברר.</p>
<p>לאוטומט רגיל יש פונקציית מעברים שמקבלת את המצב הנוכחי ואות מ-<span class="math">\(\Sigma\)</span>, ומחזירה את המצב שעוברים עליו. מבחינה רעיונית, אנחנו "אוכלים" את האות הזו מהקצה הימני של הקלט תוך כדי ביצוע המעבר. כבר ראינו הרחבה של המודל הרגיל שבו את האות מ-<span class="math">\(\Sigma\)</span> מחליפה המילה הריקה, ואז האינטואיטיציה הייתה שביצענו מעבר אבל לא אכלנו כלום מהקלט. אם כן, בואו ניקח את הרעיון הזה צעד אחד קדימה ונגדיר פונקציית מעברים שיכולה לקבל כל מילה שהיא: <span class="math">\(\delta:Q\times\Sigma^{*}\to2^{Q}\)</span>. שימו לב שאני מצהיר מראש שהפונקציה הזו מתארת אוטומט <strong>אי דטרמיניסטי</strong>: עבור זוג של מצב ומילה, ייתכן שעוברים ליותר ממצב אחד, וייתכן גם שלא עוברים לשום מצב עבורה.</p>
<p>איך נראה "חישוב" באוטומט כזה? ובכן, זה לא כזה מסובך: בכל צעד חישוב "מנחשים" מילה <span class="math">\(w\)</span> כלשהי שהיא רישא של הקלט הנוכחי, "אוכלים" אותה מהקלט, ועוברים למצב כלשהו מתוך <span class="math">\(\delta\left(q,w\right)\)</span>, כאשר <span class="math">\(q\)</span> הוא המצב הנוכחי. להגדיר את פונקציית המעברים המורחבת מבחינה פורמלית זה עניין קצת מעצבן ולא ניכנס אליו - תחת זאת, בואו נראה עוד דרך לחשוב על האוטומט הזה.</p>
<p>בתיאור הרגיל של אוטומט, אנחנו מציירים אותו בתור גרף שבו הצמתים הם מצבי האוטומט, ויש קשת ממצב אחד לאחר עם סימונים שהם האותיות שמעבירות את המצב הראשון לשני. בהכללה שלי אפשר לחשוב שיש קשת בין <strong>כל</strong> זוג מצבים (וגם בין מצב לעצמו), ולכל קשת כזו יש סימון שהוא <strong>שפה</strong> (שיכולה להיות גם השפה הריקה, למשל, ובמצב הזה אני אתייחס לכך כאילו פשוט אין קשת). פורמלית, לכל זוג מצבים <span class="math">\(q_{i},q_{j}\)</span> קיימת שפה <span class="math">\(L_{ij}\subseteq\Sigma^{*}\)</span> שמכילה את כל המילים שמעבירות בצעד יחיד את <span class="math">\(q_{i}\)</span> אל <span class="math">\(q_{j}\)</span>: <span class="math">\(L_{ij}=\left\{ w\in\Sigma^{*}\ |\ q_{j}\in\delta\left(q_{i},w\right)\right\} \)</span>. אפשר להגדיר את השפה שהאוטומט מקבל בצורה הבאה: לכל מסלול <span class="math">\(q_{i_{1}}\to q_{i_{2}}\to\dots\to q_{i_{k}}\)</span> כך שהמצב הראשון בו הוא התחלתי והמצב האחרון בו הוא מקבל, נסתכל על השרשור <span class="math">\(L_{i_{1}i_{2}}L_{i_{2}i_{3}}\cdots L_{i_{k-1}i_{k}}\)</span>. נאחד את כל השרשורים הללו, לכל (אולי אינסוף) המסלולים ממצב התחלתי למצב מקבל - קיבלנו את שפת האוטומט.</p>
<p>המודל הזה כמובן חזק בצורה פסיכית. כל שפה <span class="math">\(L\)</span> ניתן לקבל על ידי אוטומט טריוויאלי לגמרי, עם מצב התחלתי <span class="math">\(q_{0}\)</span>, מצב מקבל יחיד <span class="math">\(q_{f}\)</span>, ומעבר <span class="math">\(\delta\left(q_{0},L\right)=q_{f}\)</span>. למעשה, זו הפואנטה - בגישת "צמצום האוטומט" שתיארתי קודם, אנחנו נתחיל מאוטומט כללי ונצטמצם בסוף לאוטומט טריוויאלי שכזה. עדיין, אם המודל חזק כל כך, מה הטעם בו? מה למדנו ממנו?</p>
<p>ובכן, זה פשוט. הנה הגרסה המורחבת של קלייני: השפה שמתקבלת על ידי אוטומט נתון כלשהו מהמודל הזה נמצאת בקבוצה האינדוקטיבית שנוצרת על ידי הפעולות הרגולריות, כשקבוצת שפות הבסיס כוללת בדיוק את השפות <span class="math">\(L_{ij}\)</span> עבור האוטומט הזה. למה זו גרסה מורחבת של קלייני? כי <strong>כל</strong> אוטומט סופי רגיל הוא כזה שהשפות <span class="math">\(L_{ij}\)</span> שלו כוללות לכל היותר את כל השפות מהצורה <span class="math">\(\left\{ \sigma\right\} \)</span>, את השפה <span class="math">\(\left\{ \varepsilon\right\} \)</span> (למשל, במעבר ממצב לעצמו, או אם יש לנו מסעי-<span class="math">\(\varepsilon\)</span>) ואת השפה <span class="math">\(\emptyset\)</span> (כשיש זוג מצבים שאין בכלל מעבר מהראשון אל השני), ואיחודים שלהן (למשל, אם <span class="math">\(\delta\left(q,a\right)=p\)</span> וגם <span class="math">\(\delta\left(q,b\right)=p\)</span> ואלו המעברים היחידים שמעבירים את <span class="math">\(q\)</span> אל <span class="math">\(p\)</span> אז נקבל ש-<span class="math">\(L_{qp}=\left\{ a,b\right\} \)</span>). זה בדיוק הבסיס שלנו במשפט קלייני ה"רגיל".</p>
<p>נעבור להוכחת המשפט עצמו. בואו ניקח אוטומט מוכלל <span class="math">\(A\)</span> כלשהו. נסמן את מצביו ב-<span class="math">\(Q=\left\{ q_{1},q_{2},\dots,q_{n}\right\} \)</span>. נוסיף שני מצבים מיוחדים <span class="math">\(q_{s},q_{f}\)</span> כך ש-<span class="math">\(q_{s}\)</span> יהיה המצב ההתחלתי היחיד, <span class="math">\(q_{f}\)</span> יהיה המצב המקבל היחיד, ויהיה מעבר-<span class="math">\(\varepsilon\)</span> מ-<span class="math">\(q_{s}\)</span> לכל מצב התחלתי ב-<span class="math">\(A\)</span> ומכל מצב מקבל ב-<span class="math">\(A\)</span> ל-<span class="math">\(q_{f}\)</span>. הרעיון עכשיו יהיה להעיף באופן סדרתי את הצמתים <span class="math">\(q_{1},q_{2},\dots,q_{n}\)</span> מהאוטומט, כך שאחרי כל העפה אנחנו מתקנים את הסימונים על הקשתות שנותרו באוטומט בצורה שמבטיחה שנקבל אוטומט שקול (כלומר, שמקבל את אותה שפה). אחרי שנעיף את כל הצמתים הללו נישאר רק עם <span class="math">\(q_{s},q_{f}\)</span>, והקשת מ-<span class="math">\(q_{s}\)</span> אל <span class="math">\(q_{f}\)</span> תקודד בדיוק את השפה שלנו (שאר הקשתות בגרף לא ישפיעו; הקשת מ-<span class="math">\(q_{f}\)</span> אל <span class="math">\(q_{s}\)</span> היא עם הסימון <span class="math">\(\emptyset\)</span> והקשתות מהצמתים לעצמם הן עם הסימון <span class="math">\(\left\{ \varepsilon\right\} \)</span>). לכן כל מה שאנחנו צריכים לעשות כדי להוכיח את המשפט הוא להראות איך כל "תיקון סימוני קשתות" ניתן לביצוע עם הסימונים הנוכחיים שעל הקשתות והפעולות הרגולריות. כאן זה כבר תרגיל נחמד שאפשר לתת לסטודנטים לאוטומטים והם יצליחו לפתור בעצמם; אבל בואו נעשה אותו במפורש. כפי שתראו, זה מאוד מזכיר את הבניה שבה השתמשנו בהוכחת משפט קלייני המקורי.</p>
<p>נניח שאנחנו רוצים להעיף את הצומת <span class="math">\(q_{i}\)</span>. זה יחסל את כל המסלולים שעוברים דרך <span class="math">\(q_{i}\)</span>. מכיוון ש-<span class="math">\(q_{i}\)</span> הוא לא המצב ההתחלתי או הסופי, אנחנו מתעניינים מלכתחילה רק במסלולים ש-<span class="math">\(q_{i}\)</span> מופיע במהלכם, כלומר שיש צומת שנכנסים ממנו אל <span class="math">\(q_{i}\)</span> וצומת שיוצאים מ-<span class="math">\(q_{i}\)</span> אליו. נרצה, אם כן, לחבר את כל הצמתים שנכנסים ל-<span class="math">\(q_{i}\)</span> אל כל הצמתים שיוצאים מ-<span class="math">\(q_{i}\)</span>.</p>
<p>בואו ניקח שני צמתים כאלו: צומת <span class="math">\(q_{j}\)</span> כך שיש קשת <span class="math">\(q_{j}\to q_{i}\)</span>, וצומת <span class="math">\(q_{k}\)</span> כך שיש קשת <span class="math">\(q_{i}\to q_{k}\)</span> (זכרו שאצלנו בעצם יש קשת מכל צומת לכל צומת, אבל היא עשויה להיות מסומנת בשפה הריקה ואם תבדקו, תראו שזה שקול לכך שלא תהיה קשת). אנחנו רוצים "להוסיף" קשת מ-<span class="math">\(q_{j}\)</span> אל <span class="math">\(q_{k}\)</span>, אבל כמובן שאולי כבר יש כזו - השפה <span class="math">\(L_{jk}\)</span> מתארת את הסימון שלה. אז אנחנו רוצים לבנות <span class="math">\(L_{jk}^{\prime}\)</span> "מתוקנת".</p>
<p>מה השפה המתוקנת צריכה לכלול? את כל המילים שמעבירות את <span class="math">\(q_{j}\)</span> אל <span class="math">\(q_{k}\)</span> באופן ישיר, כלומר את <span class="math">\(L_{jk}\)</span>, וכמו כן את כל המילים שמעבירות את <span class="math">\(q_{j}\)</span> אל <span class="math">\(q_{k}\)</span> באמצעות שימוש במצב הביניים <span class="math">\(q_{i}\)</span>. נאיבית אפשר לחשוב שהמילים הללו הן בדיוק <span class="math">\(L_{ji}\cdot L_{ik}\)</span>, כלומר שרשור של מילה שמעבירה אותנו מ-<span class="math">\(q_{j}\)</span> אל <span class="math">\(q_{i}\)</span> ואז מ-<span class="math">\(q_{i}\)</span> אל <span class="math">\(q_{k}\)</span>; אבל זכרו שאנחנו עשויים להישאר ב-<span class="math">\(q_{i}\)</span> במשך מספר צעדים שבהם נלך מ-<span class="math">\(q_{i}\)</span> אל עצמה. מכאן שהשפה היא <span class="math">\(L_{ji}\cdot L_{ii}^{*}\cdot L_{ik}\)</span>, וקיבלנו ש-<span class="math">\(L_{jk}^{\prime}=L_{jk}\cup L_{ji}\cdot L_{ii}^{*}\cdot L_{ik}\)</span>. זה מסיים את ההוכחה, ובצורה מאוד נחמדה - אנחנו רואים בדיוק איך כל שלוש הפעולות הרגולריות באות לידי ביטוי באותה משוואה.</p>
<p>שאלה מעניינת אחת עולה מכל העניין הזה. משפט קלייני נותן לנו, דה פקטו, דרך לבנות ביטוי רגולרי עבור שפה בהינתן האוטומט שלה - ביטוי רגולרי די מסובך, אבל ביטוי רגולרי. האם הביטוי שנקבל מתוך ההוכחה ה"חדשה" שונה מהותית מאשר הביטוי שנקבל מההוכחה ה"ישנה"? התשובה היא כן ולא. כן, כי אכן אנחנו עשויים לקבל ביטויים שונים (ושימו לב ששתי ההוכחות היו תלויות בסדר כלשהו על מצבי האוטומט, וסדרים שונים יניבו ביטויים רגולריים שונים). לא, כי ישנן מניפולציות סינטקטיות מסויימות שניתן לבצע על הביטויים הרגולריים כדי לקבל מתוך האחד את השני. זה מביא אותנו לתחום שאני לא הולך להיכנס אליו בפוסטים הללו כי לטעמי הוא יותר מדי טכני מכדי להצדיק פוסטים מעניינים - הבדיקה עד כמה שני ביטויים רגולריים הם שקולים, על פי סוג המניפולציות הסינטקטיות שמעבירות אחד אל השני (ככל שנדרשות יותר פעולות מתוחכמות יותר כך השקילות היא פחות "ברורה").</p>
<p>אם כן, ההוכחה לא נותנת לנו שום דבר חדש לגמרי - אבל מה אכפת לי, היא ממש יפה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>