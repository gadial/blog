<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>שפות חסרות הקשר - למת הניפוח, הלמה של אוגדן ושפות רב משמעיות - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2015/04/15/pumping_lemma_cf/">
    <meta property="og:title" content="שפות חסרות הקשר - למת הניפוח, הלמה של אוגדן ושפות רב משמעיות">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2015/04/15/pumping_lemma_cf/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="שפות חסרות הקשר - למת הניפוח, הלמה של אוגדן ושפות רב משמעיות">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2015/03/31/pushdown_automata_cfg_equiv/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">שקילות אוטומט מחסנית ודקדוק חסר הקשר</span>
            </a>
            

            
            <a href="/2015/04/16/birthday_riddle/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">חידת יום הולדת</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>שפות חסרות הקשר - למת הניפוח, הלמה של אוגדן ושפות רב משמעיות</h1>
            <div class="post-meta">
                <span class="date">2015-04-15</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/הלמה של אוגדן.html">הלמה של אוגדן</a>
                    
                    <a href="/tags/למת הניפוח לשפות חסרות הקשר.html">למת הניפוח לשפות חסרות הקשר</a>
                    
                    <a href="/tags/שפות פורמליות.html">שפות פורמליות</a>
                    
                    <a href="/tags/שפות רב משמעיות.html">שפות רב משמעיות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אני ממשיך לדבר על תכונות שונות ומשונות של שפות חסרות הקשר, וממשיך עם האנלוגיה לשפות רגולריות. אחד מהדברים שעשינו בשפות רגולריות היה להוכיח משהו שנקרא "<a href="http://www.gadial.net/2015/02/03/pumping_lemma_regular_languages/">למת הניפוח</a>", שהצביע על סוג של תבניתיות שכל שפה רגולרית חייבת לקיים. משהו מאוד דומה קיים גם עבור שפות חסרות הקשר, אבל כרגיל עם שפות חסרות הקשר, זה קצת יותר מסובך. אני אראה את המשהו המאוד דומה. ואז אני אכליל אותו עוד קצת. ואז אני אשתמש בהכללה כדי להראות משהו שנראה בלתי קשור בעליל. בלמת הניפוח לשפות רגולריות השתמשנו כדי להוכיח ששפות <strong>אינן</strong> רגולריות, ובאופן דומה אפשר להשתמש בלמת הניפוח לשפות חסרות הקשר כדי להוכיח ששפות אינן חסרות הקשר; אבל אני אוכיח גם משהו שונה לחלוטין - ששפה חסרת הקשר מסויימת היא <strong>רב-משמעית טבועה</strong>, דהיינו שכל דקדוק עבור השפה בהכרח יהיה רב משמעי (אזכיר את כל ההגדרות בהמשך). זה שימוש יפה שאני מאוד מחבב כי על פניו בכלל לא ברור מה הקשר.</p>
<p>.נתחיל עם להיזכר מה הלך בשפות רגולריות. שם, בהינתן שפה רגולרית <span class="math">\(L\)</span>, הוכחנו שקיים <span class="math">\(n\)</span> טבעי כך שלכל מילה <span class="math">\(z\in L\)</span> המקיימת <span class="math">\(\left|z\right|\ge n\)</span> קיים פירוק <span class="math">\(z=uvw\)</span> כך ש-<span class="math">\(\left|uv\right|\le n\)</span> ו-<span class="math">\(\left|v\right|\ge1\)</span> ו-<span class="math">\(uv^{i}w\in L\)</span> לכל <span class="math">\(i\ge0\)</span>. הרעיון מאחורי ההוכחה היה פשוט ויפה - ניקח אוטומט עבור השפה, ונריץ אותו על מילה ארוכה מספיק - מתישהו בהכרח תהיה בריצה "לולאה" (מצב כלשהו שהופיע פעמיים), ואז נוכל לקחת את תת-המילה שהאוטומט קרא על הלולאה ולהעלים אותה או לחזור עליה כמה פעמים שנרצה, ועדיין נקבל את המילה.</p>
<p>הרעיון של למת הניפוח לשפות חסרות הקשר הוא <strong>בדיוק אותו דבר</strong>, אבל בהקשר קצת שונה - לא של אוטומט (אמנם הצגתי אוטומט מחסנית עבור שפות חסרות הקשר, אבל אני לא אשתמש בו כאן), אלא של דקדוק חסר הקשר. מה שארצה לומר הוא שאם דקדוק חסר הקשר מייצר מילה שהיא ארוכה מספיק, אז בעץ הגזירה של המילה יהיה חייב להיות מסלול ארוך מאוד - כל כך ארוך, עד שמשתנה כלשהו של הדקדוק יופיע בו פעמיים. כלומר, יהיה משתנה שגוזר "את עצמו ועוד קצת". ואז נוכל לוותר על הגזירה הזו או לחזור עליה כמה פעמים שנרצה, ובכך להשיג אפקט ניפוח שדומה לזה של הלמה עבור שפות פורמליות, אבל הניסוח המדוייק שלו קצת יותר מסובך. בואו ניתן את הניסוח הזה:</p>
<p>אם <span class="math">\(L\)</span> היא שפה חסרת הקשר אז קיים <span class="math">\(n\)</span> טבעי כך שלכל מילה <span class="math">\(z\in L\)</span> קיים פירוק <span class="math">\(z=uvwxy\)</span> כך ש-<span class="math">\(\left|vwx\right|\le n\)</span> ו-<span class="math">\(\left|vx\right|\ge1\)</span> ו-<span class="math">\(uv^{i}wx^{i}y\in L\)</span> לכל <span class="math">\(i\ge0\)</span>.</p>
<p>במבט ראשון זה קצת מפחיד - יש פה פתאום פירוק לחמישה חלקים במקום שלושה, והניפוח הוא של שני חלקים בו זמנית, וכל העסק נראה מוזר - אבל אחרי שנראה את ההוכחה נבין למה זה טבעי ופשוט למדי. בינתיים, תרגיל פשוט כדי לידד אתכם עם הניסוח החדש - תוכיחו שאם שפה מקיימת את למת הניפוח לשפות רגולריות, אז היא מקיימת את למת הניפוח לשפות חסרות הקשר ("מקיימת את למת הניפוח" פירושו, "מקיימת את החלק של ה"אז קיים", בלי להתחייב על ה"אם").</p>
<p>כדי להוכיח את הלמה אני צריך לקחת דקדוק עבור <span class="math">\(L\)</span>, אבל כדי שהחיים יהיו קלים אני לא לוקח סתם דקדוק, אלא דקדוק שנמצא ב<strong>צורה נורמלית</strong> פשוטה מאוד - הצורה הנורמלית של חומסקי. דקדוק בצורה הזו כולל רק שני סוגים של כללי גזירה: <span class="math">\(A\to a\)</span> או <span class="math">\(A\to BC\)</span>. כלומר, משתנה יכול או לגזור אות אחת, או להתפצל לשני משתנים. שימו לב שדקדוק בצורה הנורמלית הזו לא יכול לגזור את <span class="math">\(\varepsilon\)</span> כך שאני מניח לכאורה ש-<span class="math">\(L\)</span> לא כוללת את <span class="math">\(\varepsilon\)</span>, אבל זה לא ממש משנה - אם <span class="math">\(L\)</span> כוללת את <span class="math">\(\varepsilon\)</span> אני אוכיח את למת הניפוח על <span class="math">\(L\backslash\left\{ \varepsilon\right\} \)</span> והמסקנה שאקבל תהיה תקפה גם עבור <span class="math">\(L\)</span> באותה מידה (כי אני אקח <span class="math">\(n\ge1\)</span> ולכן <span class="math">\(\varepsilon\)</span> ממילא לא רלוונטית).</p>
<p>כמובן, צריך להסביר למה לכל שפה חסרת הקשר בלי <span class="math">\(\varepsilon\)</span> יש דקדוק מהצורה הנורמלית של חומסקי. אני אקדיש לזה בדיוק פסקה אחת, ואתם <strong>לא חייבים להבין </strong>אותה ואם אתם מסתבכים פשוט תדלגו הלאה. האינטואיציה לא קשה - כל גזירה שמערבת גם משתנים וגם טרמינלים אפשר להחליף בגזירה שיש בה רק משתנים על ידי הוספת משתני עזר. למשל, אם יש לי את הגזירה <span class="math">\(A\to BaC\)</span> אני יכול להוסיף משתנה עזר חדש <span class="math">\(A_{a}\)</span> שהגזירה היחידה שלו היא <span class="math">\(A_{a}\to a\)</span> ואז להחליף את הגזירה הנתונה ב-<span class="math">\(BA_{a}C\)</span>. עכשיו, אם יש לי גזירה של שלושה משתנים או יותר, אני יכול "להקטין" אותה בעזרת משתני עזר. למשל, אם <span class="math">\(A\to B_{1}B_{2}B_{3}B_{4}\)</span> אני אוסיף משתני עזר חדשים <span class="math">\(C_{1},C_{2},C_{3}\)</span> ואת הגזירות <span class="math">\(A\to B_{1}C_{1}\)</span> ו-<span class="math">\(C_{1}\to B_{2}C_{2}\)</span> ו-<span class="math">\(C_{3}\to B_{3}B_{4}\)</span>. אז בעצם, הדבר היחיד שמסובך לטפל בו הוא גזירות מהצורה <span class="math">\(A\to B\)</span> (גזירות כאלו נקראות "כללי יחידה") וגזירות מהצורה <span class="math">\(A\to\varepsilon\)</span>. מגזירות כאלו תמיד אפשר להיפטר באופן דומה לאיך שנפטרים מכללי-<span class="math">\(\varepsilon\)</span> באוטומט סופי דטרמיניסטי - קודם כל מגלים את כל המשתנים <span class="math">\(B\)</span> שעבורם מתקיים <span class="math">\(A\Rightarrow^{*}B\)</span> (סתם לקחת משתנים כך ש-<span class="math">\(A\to B\)</span> לא מספיק, כי מה קורה אם <span class="math">\(B\to C\)</span>? אז נקבל ש-<span class="math">\(A\Rightarrow^{*}C\)</span> - זה דומה ל"סגור-<span class="math">\(\varepsilon\)</span>" עבור שפות רגולריות), ועכשיו מוסיפים לדקדוק את כל הגזירות מהצורה <span class="math">\(A\to\alpha\)</span> כך ש-<span class="math">\(B\to\alpha\)</span> היה גזירה בדקדוק המקורי. לבסוף, מעיפים את כל כללי היחידה. באופן דומה אפשר גם לטפל בגזירות מהצורה <span class="math">\(A\to\varepsilon\)</span> - קודם כל מגלים את כל המשתנים שהם "אפיסים", כלומר <span class="math">\(A\Rightarrow^{*}\varepsilon\)</span>, ואחר כך לכל גזירה <span class="math">\(A\to X_{1}X_{2}\dots X_{n}\)</span> (כאשר כל <span class="math">\(X\)</span> כזה יכול להיות או משתנה או טרמינל) מחליפים אותה בכל הגזירות מהצורה <span class="math">\(A\to Y_{1}\dots Y_{n}\)</span> כאשר <span class="math">\(Y_{i}=X_{i}\)</span> אם <span class="math">\(X_{i}\)</span> לא אפיס, ו-<span class="math">\(Y_{i}\in\left\{ \varepsilon,X_{i}\right\} \)</span> אם הוא כן. ואז מסירים את כל הגזירות מהצורה <span class="math">\(A\to\varepsilon\)</span> מהדקדוק.</p>
<p>עכשיו, מה שאני הולך להוכיח הוא שאם <span class="math">\(z\in L\)</span> מקיימת <span class="math">\(\left|z\right|\ge n\)</span> אז קיים לה פירוק <span class="math">\(z=uvwxy\)</span> עם <span class="math">\(\left|vwx\right|\le n\)</span> ו-<span class="math">\(\left|vx\right|\ge1\)</span> כך שמתקיימים שלושת הדברים הבאים:</p>
<p><span class="math">\(S\Rightarrow^{*}uAy\)</span> עבור משתנה <span class="math">\(A\)</span> כלשהו.</p>
<p><span class="math">\(A\Rightarrow^{*}vAx\)</span></p>
<p><span class="math">\(A\Rightarrow^{*}w\)</span></p>
<p>זה מסביר את המבנה ה"מוזר" של הפירוק. בואו נגיד במילים מה הם שלושת הדברים הללו: יש בדקדוק משתנה <span class="math">\(A\)</span> שגוזר את עצמו, ואותו המשתנה ניתן לגזירה מתוך <span class="math">\(S\)</span>, ובנוסף הוא יודע לגזור מילה טרמינלית. כאשר גוזרים אותו מתוך <span class="math">\(S\)</span> נסמן ב-<span class="math">\(u,y\)</span> את "מה שמתפזר לצדדים", ובאופן דומה כאשר <span class="math">\(A\)</span> גוזר את עצמו נסמן ב-<span class="math">\(v,x\)</span> את "מה שמתפזר לצדדים", וב-<span class="math">\(w\)</span> אנחנו מסמנים את המילה הטרמינלית שאנחנו יודעים שהוא יודע לגזור. אם הראינו את שלושת הדברים הללו, ברור שאפשר לייצר את <span class="math">\(uv^{i}wx^{i}z\)</span> לכל <span class="math">\(i\ge0\)</span>: על ידי ביצוע הגזירה <span class="math">\(S\Rightarrow^{*}uAy\)</span>, הפעלה <span class="math">\(i\)</span> פעמים של הגזירה <span class="math">\(A\Rightarrow^{*}vAx\)</span> ולבסוף הפעלה אחת של <span class="math">\(A\Rightarrow^{*}w\)</span>.</p>
<p>עיקר האתגר יהיה להוכיח ש-<span class="math">\(A\)</span> כזה קיים בכלל. הרעיון הוא כזה: אם <span class="math">\(z\)</span> היא מילה גדולה מספיק, אז עץ הגזירה שלה יהיה חייב להיות עמוק, מסיבה שאסביר בהמשך. בואו נסמ ב-<span class="math">\(k=\left|V\right|\)</span> את גודל קבוצת המשתנים של הדקדוק. אם אצליח לגרום לכך שהמסלול העמוק ביותר בעץ יהיה בן לפחות <span class="math">\(k+1\)</span> צמתים פנימיים, זה מבטיח שיהיה משתנה שמופיע עליו פעמיים (זכרו - בעץ גזירה הצמתים הפנימיים הם משתנים, והעלים הם טרמינלים). המשתנה הזה יהיה ה-<span class="math">\(A\)</span> שלי. כדי להבטיח את הטענה על כך ש-<span class="math">\(\left|vwx\right|\le n\)</span> אני אצטרך לבחור משתנה שמופיע פעמיים והוא "נמוך ככל האפשר" בעץ (קרוב ככל האפשר לעלים). בואו עכשיו ניגש לפורמליזציה.</p>
<p>הפואנטה של שימוש בצורה הנורמלית של חומסקי היא שעץ הגזירה הוא בעל צורה מאוד ספציפית - הוא <strong>עץ בינארי</strong>, כלומר לכל צומת יש שני בנים, פרט לצמתים שהבנים שלהם הם עלים, ולצמתים כאלו יש רק בן יחיד. מה שנחמד בעצים בינאריים (ובאופן כללי, בעצים שבהם יש חסם קבוע על מספר הבנים של צומת) הוא שקל לקשור בין מספר העלים של העץ ובין העומק שלו. בואו ניקח לרגע עץ בינארי <strong>מושלם</strong>, שפירושו שכל העלים בעץ הם באותו עומק, וכל צומת שאינו עלה הוא בעל שני בנים. נניח שהעומק שלו הוא <span class="math">\(d\)</span>, כלומר שאורך המסלול מהשורש אל עלה כלשהו הוא בן <span class="math">\(d\)</span> צעדים (ולכן אנחנו רואים בדרך <span class="math">\(d+1\)</span> צמתים). כמה עלים יש לעץ? הכי קל לעבוד עם מקרים פרטיים: עבור <span class="math">\(d=0\)</span> העץ כולו כולל רק צומת יחיד. עבור <span class="math">\(d=1\)</span> יש לנו את השורש ושני בנים. עבור <span class="math">\(d=2\)</span> לכל אחד משני הבנים יש שני בנים, ולכן יש ארבעה עלים. עבור <span class="math">\(d=3\)</span> כל אחד מארבעת העלים הוא עכשיו אב גאה לשני בנים נוספים, ולכן יש שמונה עלים... הבנתם את העיקרון. בעץ בינארי מושלם מעומק <span class="math">\(d\)</span> יש בדיוק <span class="math">\(2^{d}\)</span> עלים. זה אומר שאם יש לנו עץ בינארי <strong>כלשהו</strong> (לאו דווקא מושלם) שבו יש יותר מ-<span class="math">\(2^{d}\)</span> עלים, אז בהכרח העומק שלו גדול מ-<span class="math">\(d\)</span>.</p>
<p>אז מה שנעשה, אם <span class="math">\(k\)</span> הוא מספר המשתנים של הדקדוק שלנו, נבחר <span class="math">\(n=2^{k}\)</span>. עכשיו בואו ניקח עץ גזירה כלשהו עבור <span class="math">\(z\)</span>. אם נעיף את הצמתים של הטרמינלים, נקבל עץ בינארי שבו העלים הם המשתנים שהגזירה שהם ביצעו היא גזירה של טרמינלים. מכיוון שכל משתנה כזה גזר טרמינל אחד, מספר המשתנים הללו הוא בדיוק <span class="math">\(\left|z\right|\)</span>, כלומר מספר העלים בעץ הוא לפחות <span class="math">\(2^{k}\)</span>, ולכן עומק העץ הוא לפחות <span class="math">\(k\)</span>. ניקח את המסלול הארוך ביותר בעץ - מכיוון שהעומק שלו הוא לפחות <span class="math">\(k\)</span>, הרי שכשאנחנו הולכים עליו אנחנו רואים לפחות <span class="math">\(k+1\)</span> משתנים. מסקנה - קיימים משתנים שמופיעים פעמיים על המסלול הזה. בואו נתחיל ללכת על המסלול מהעלה לכיוון השורש, ונסמן ב-<span class="math">\(A\)</span> את המשתנה הראשון שמופיע פעמיים. עכשיו אפשר לתת את פירוק המילה שלנו - נסמן ב-<span class="math">\(w\)</span> את המילה שהמופע השני, הנמוך יותר, של <span class="math">\(A\)</span> גוזר; על כן המופע הראשון של <span class="math">\(A\)</span> גוזר מילה ש-<span class="math">\(w\)</span> היא חלק ממנה, ונסמן את החלקים שלפני ואחרי <span class="math">\(w\)</span> ב-<span class="math">\(v,w\)</span> בהתאמה, כלומר <span class="math">\(A\)</span> הראשון גוזר את המילה <span class="math">\(vwx\)</span>. המילה הזו היא בתורה חלק מהמילה ש-<span class="math">\(S\)</span> גוזר (כלומר, המילה של עץ הגזירה כולו) ונסמן את הלפני ואחרי ב-<span class="math">\(u,y\)</span>, כלומר המילה כולה היא <span class="math">\(uvwxy\)</span> - הנה הפירוק שלנו. זה מאוד מבלבל אז הנה תמונה:</p>
<p><strong><a href="/img/2015/04/pumping_lemma_cf.png"><img class="aligncenter size-full wp-image-3236" alt="pumping_lemma_cf" src="/img/2015/04/pumping_lemma_cf.png" width="637" height="622" /></a></strong></p>
<p>עכשיו מגיע הטיעון העדין ביותר בהוכחה. אני טוען שמבין שני המופעים של <span class="math">\(A\)</span> שראינו, הגבוה יותר הוא כזה שתת-העץ שלו הוא מגובה <span class="math">\(k\)</span> <strong>לכל היותר</strong>. זה נובע משני דברים. ראשית, אני טוען שהגובה של ה-<span class="math">\(A\)</span> הזה <strong>על המסלול העמוק ביותר</strong> הוא לא יותר מ-<span class="math">\(k\)</span>. זה די ברור, מכיוון שאם הגובה היה יותר מ-<span class="math">\(k\)</span>, אז עוד לפני שהיינו מגיעים אל המופע הגבוה יותר של <span class="math">\(A\)</span> כבר היינו רואים <span class="math">\(k+1\)</span> משתנים, ולכן היה משתנה <strong>אחר</strong> שכבר היה מופיע פעמיים והיינו רואים אותו. כעת, בנוסף לכך, אני צריך לטעון שאין מסלול <strong>אחר</strong> שעובר דרך ה-<span class="math">\(A\)</span> הזה ומגיע לעלים, והוא ארוך יותר מ-<span class="math">\(k\)</span> - זה נובע מכך שהמסלול שלקחתי היה <strong>המסלול העמוק ביותר</strong> ולכן אין מסלול שיותר עמוק ממנו. אני מתעכב על הטיעון הזה כי זו הנקודה שבה אני טעיתי בעבר שוב ושוב כאשר הצגתי את המשפט: פשוט אמרתי משהו בסגנון "עומק העץ הוא לפחות <span class="math">\(k\)</span> אז קיים מסלול שבו יש משתנה שמופיע פעמיים". זה נכון, אבל לא מבטיח לנו שהמופע הראשון מבין השניים של המשתנה הזה יהיה נמוך יחסית - מגובה <span class="math">\(k\)</span> לכל היותר.</p>
<p>ולמה זה חשוב, שהוא מגובה <span class="math">\(k\)</span> לכל היותר? כי זה מגביל את מספר העלים בתת-העץ שלו להיות לכל היותר <span class="math">\(2^{k}\)</span>. ותת העץ הזה הוא בדיוק תת-העץ שמייצר את <span class="math">\(vwx\)</span> שלנו, כך שאנחנו מקבלים את הדרישה <span class="math">\(\left|vwx\right|\le n\)</span>. אם לא היה אכפת לנו מהדרישה הזו (שנראית קצת מלאכותית במבט ראשון) ההוכחה הייתה יותר קלה כי לא היינו צריכים את כל הנימוקים העדינים הללו, אבל הדרישה הזו מאוד מועילה לנו כשאנחנו רוצים <strong>להשתמש</strong> בלמה (כמו הדרישה הדומה ש-<span class="math">\(\left|uv\right|\le n\)</span> בלמת הניפוח לשפות רגולריות) ולכן התעקשנו עליה.</p>
<p>עדיין צריך להסביר למה <span class="math">\(\left|vx\right|\ge1\)</span> וזה לא לגמרי מובן מאליו. הטענה היא שכאשר <span class="math">\(A\)</span> הראשון גוזר את <span class="math">\(A\)</span> השני, חייב להיות משהו ש"ייגזר בצד", כלומר לא ייתכן שהגזירה היא מהצורה <span class="math">\(A\Rightarrow^{*}A\)</span>. בדקדוקים כלליים אין לנו משהו שיבטיח את זה, אבל בצורה הנורמלית של חומסקי זה קל. הגזירה שה-<span class="math">\(A\)</span> הראשון מבצע בצעד הראשון שלו חייבת להיות מהצורה <span class="math">\(A\Rightarrow BC\)</span>, ועכשיו אם (בלי הגבלת הכלליות) <span class="math">\(A\)</span> השני הוא בתת-העץ של <span class="math">\(B\)</span>, אז בתת-העץ של <span class="math">\(C\)</span> יהיה לפחות טרמינל אחד (כי <span class="math">\(C\)</span> יודע רק לגזור שני דברים: או טרמינל, או עוד משתנים שמחוייבים בתורם לגזור משתנים או טרמינלים). אין ל-<span class="math">\(C\)</span> דרך פשוט "להעלים את עצמו".</p>
<p>זה מסיים את ההוכחה של למת הניפוח לשפות חסרות הקשר. בואו נראה עכשיו דוגמה זריזה לשימוש בה, בלי להיכנס לכל הפרטים - נוכיח ש-<span class="math">\(L=\left\{ a^{n}b^{n}c^{n}\ |\ n\ge0\right\} \)</span> היא לא חסרת הקשר. לצורך כך נניח בשלילה שהיא חסרת הקשר, יהא <span class="math">\(n\)</span> שקיומו מובטח על ידי הלמה ונסתכל במילה <span class="math">\(z=a^{n}b^{n}c^{n}\)</span>. אנחנו צריכים להראות שאפשר "לקלקל" כל פירוק אפשרי שלה. הנקודה היא שפירוק <span class="math">\(z=uvwxy\)</span> כלשהו חייב להיות מאחת מחמש צורות אפשריות, בגלל המגבלה <span class="math">\(\left|vwx\right|\le n\)</span>: או ש-<span class="math">\(vwx\)</span> חי כולו בתוך אחד משלושת הרצפים <span class="math">\(a^{n},b^{n},c^{n}\)</span>, או שהוא נמצא אי שם בתוך הרצף <span class="math">\(a^{n}b^{n}\)</span> וחוצה אותו באמצע, או שהוא נמצא בתוך הרצף <span class="math">\(b^{n}c^{n}\)</span> וחוצה אותו באמצע. בכל מקרה אין ל-<span class="math">\(vwx\)</span> יכולת לכלול בתוכו גם <span class="math">\(a\)</span>-ים, גם <span class="math">\(b\)</span>-ים וגם <span class="math">\(c\)</span>-ים כי זה יצריך ממנו להכיל לפחות <span class="math">\(n+2\)</span> תווים (לפחות <span class="math">\(a\)</span> אחד, לפחות <span class="math">\(c\)</span> אחד ואת כל ה-<span class="math">\(b^{n}\)</span> שבאמצע) ולכן אם נבחר <span class="math">\(i=0\)</span> בהכרח נקבל מילה שמספר האותיות משלושת הסוגים בה לא מאוזן (כי הקטנו לפחות סוג אחד של אותיות, אבל באחד מהסוגים לא נגענו).</p>
<p>יש הכללה מאוד ברורה של הלמה שלא כל כך קשה להבין. הרעיון בה הוא שיש לנו קצת יותר שליטה על המיקום של ה-<span class="math">\(vwx\)</span>, שכרגע כל מה שאנחנו יודעים עליו זה שהוא מאורך לכל היותר <span class="math">\(n\)</span> ונמצא במקום <strong>כלשהו</strong> במילה (בניגוד ללמת הניפוח לשפות רגולריות, ששם הוא היה חייב להיות בהתחלה). הרעיון הוא שאם <span class="math">\(z\)</span> היא יותר ארוכה מ-<span class="math">\(n\)</span>, אז אין צורך להסתכל על <strong>כל</strong> <span class="math">\(z\)</span> כדי להפעיל את הלמה; מספיק להסתכל על מקום כלשהו שהוא ארוך מ-<span class="math">\(n\)</span> והלמה תפעל עליו. אבל למעשה, אפילו לא חייבים <span class="math">\(n\)</span> תווים <strong>רציפים</strong>; אפשר להסתכל על כל סדרה של <span class="math">\(n\)</span> תווים, גם לא רציפים, ולדבר על החלק מעץ הגזירה שמייצר את כל התווים בסדרה הזו. החלק הזה יהיה חייב להיות עמוק מספיק, וכן הלאה וכן הלאה. אז הנה הניסוח הפורמלי: בהינתן שפה חסרת הקשר <span class="math">\(L\)</span> קיים קבוע <span class="math">\(n\)</span> כך שלכל מילה <span class="math">\(z\in L\)</span> <strong>ולכל בחירה</strong> של לפחות <span class="math">\(n\)</span> תווים ב-<span class="math">\(z\)</span>, שנקרא להם "מסומנים", קיים פירוק <span class="math">\(z=uvwxy\)</span> כך ש-<span class="math">\(vwx\)</span> כולל לכל היותר <span class="math">\(n\)</span> תווים מסומנים, <span class="math">\(vx\)</span> כולל לפחות תו מסומן אחד, ו-<span class="math">\(uv^{i}wx^{i}z\in L\)</span> לכל <span class="math">\(i\ge0\)</span>. למת הניפוח לשפות רגולריות היא פשוט מקרה פרטי של זה כאשר כל התווים של <span class="math">\(z\)</span> הם מסומנים.</p>
<p>ההכללה הזו נקראת לפעמים "הלמה של אוגדן" - כך היא מופיעה בספר האוטומטים של הופקרופט ושות', שהוא כנראה הספר הידוע ביותר על הנושא כיום, וכך היא מופיעה גם בויקיפדיה האנגלית (כנראה בעקבות הופקרופט). אבל הניסוח במאמר המקורי של אוגדן היה שונה וחזק יותר והוא זה שאציג עכשיו (הסיבה לכך היא שאוגדן הוכיח את הלמה שלו כדי להוכיח את עניין רב המשמעות שאגיע אליו בסוף הפוסט; עד כמה שאני רואה, בניסוח של הופקרופט ושות' אי אפשר לעשות את זה, והם אפילו לא מנסים אלא סתם מזכירים את הלמה בתוך תרגיל כבדרך אגב). הטענה של אוגדן היא כזו: אם <span class="math">\(L\)</span> היא חסרת הקשר, אז קיים <span class="math">\(n\)</span> טבעי כך שלכל מילה <span class="math">\(z\in L\)</span> וסימון של לפחות <span class="math">\(n\)</span> תווים ב-<span class="math">\(z\)</span>, קיים ל-<span class="math">\(z\)</span> פירוק <span class="math">\(z=uvwxy\)</span> כך שמתקיים <span class="math">\(uv^{i}wx^{i}y\in L\)</span> כרגיל לכל <span class="math">\(i\ge0\)</span>, אבל התכונות של הפירוק יותר מורכבות: ראשית, <span class="math">\(w\)</span> מכיל לפחות תו מסומן אחד; שנית, או שגם <span class="math">\(u\)</span> וגם <span class="math">\(v\)</span> מכילים תו מסומן, או שגם <span class="math">\(x\)</span> וגם <span class="math">\(y\)</span> מכילים תו מסומן. לבסוף, כרגיל, <span class="math">\(vwx\)</span> לא מכיל יותר מ-<span class="math">\(n\)</span> תווים מסומנים.</p>
<p>הניסוח הזה שונה ממה שראינו עד כה בכך שיש דרישה כלשהי על <span class="math">\(u,w,y\)</span> - החלקים ש"לא מנפחים" - ב-<span class="math">\(w\)</span> מובטח לנו שיהיה תו מסומן, ואילו ב-<span class="math">\(u,y\)</span> מובטח לנו שלאחד מהם יהיה תו מסומן (וכך גם לחלק שכן מנפחים שנמצא יחד איתו). עוד מעט נראה למה הניסוח הזה מועיל כל כך, אבל לעת עתה בואו נבין איך מוכיחים אותו. ההוכחה אמנם היא בעלת אותו רעיון כמו למת הניפוח, אבל הטיעונים זהירים יותר.</p>
<p>כמקודם, נרצה למצוא מסלול ארוך מספיק בעץ הגזירה, עם משתנה <span class="math">\(A\)</span> שמופיע עליו פעמיים. אבל אנחנו צריכים להקפיד שתת-עץ הגזירה של <span class="math">\(A\)</span> הזה יכיל מספיק תווים מסומנים. צמתים "מוצלחים" בהיבט הזה הם צמתים שבתת-העץ של כל אחד משני הבנים שלהם יש תווים מסומנים - אוגדן קורא להם "צמתי <span class="math">\(B\)</span>". עכשיו אוגדן בוחר בתוך המסלול שלו מסלול בעץ שיש בו מספר מקסימלי של צמתי <span class="math">\(B\)</span>, ושמסתיים בתו מסומן (הסיום של המסלול יהיה בתוך ה-<span class="math">\(w\)</span> שלנו, ולכן הדרישה הזו תבטיח שב-<span class="math">\(w\)</span> יהיה תו מסומן). עכשיו, מה שאוגדן רוצה כדי שהלמה תעבוד הוא שבמסלול שלו יהיו לפחות <span class="math">\(2\left|V\right|+3\)</span> צמתי <span class="math">\(B\)</span> - זה משמעותית יותר גדול מאשר ה-<span class="math">\(\left|V\right|+1\)</span> שרצינו עבור למת הניפוח הרגילה, ולכן הבחירה של <span class="math">\(n\)</span> תהיה גדולה יותר - <span class="math">\(n=2^{2\left|V\right|+3}\)</span>. הטיעון שמסביר למה עבור <span class="math">\(n\)</span> כזה בהכרח יש לנו מספיק צמתי <span class="math">\(B\)</span> דומה לטיעון הרגיל בלמה, כשלא היו צמתים מסומנים בכלל; הרעיון הוא שרק צומת <span class="math">\(B\)</span> יגדיל את מספר התווים המסומנים במילה הסופית, בזמן שצומת שרק לאחד משני בניו יש תווים מסומנים לא הולך להגדיל את מספר התווים המסומנים הכולל. נסו להוכיח זאת לעצמכם אם אתם לא משוכנעים.</p>
<p>עכשיו החלק הטריקי. אנחנו רוצים להבטיח שיהיו מקומות מסומנים גם ב-<span class="math">\(u,v\)</span> או <span class="math">\(x,y\)</span>. בואו ניקח צומת <span class="math">\(B\)</span> שהבן הימני שלו ממשיך על גבי המסלול שבחרנו - מה קורה עם הבן השמאלי שלו? לבן השמאלי הזה יהיה תת-עץ שמכיל תו מסומן, והוא בא לפני תת-העץ של הבן השמאלי של הצומת. כלומר, אם הצומת גבוה מספיק, התו המסומן הזה יהיה בתוך משהו שבא לפני <span class="math">\(w\)</span>.</p>
<p>אז הנה מה שנעשה. נחלק את צמתי ה-<span class="math">\(B\)</span> על המסלול שלנו לשתי קבוצות, <span class="math">\(C_{L}\)</span> ו-<span class="math">\(C_{R}\)</span>, כך שכל צמתי ה-<span class="math">\(B\)</span> ב-<span class="math">\(C_{L}\)</span> הם כאלו שהבן <strong>הימני</strong> שלהם ממשיך על המסלול, ועבור הצמתים ב-<span class="math">\(C_{R}\)</span> הבן <strong>השמאלי</strong> ממשיך על המסלול. מכיוון שהיו <span class="math">\(2\left|V\right|+3\)</span> צמתי <span class="math">\(B\)</span> במסלול, בהכרח אחת משתי הקבוצות הללו כוללת לפחות <span class="math">\(\left|V\right|+2\)</span> צמתים - בואו נניח שזו <span class="math">\(C_{L}\)</span>. ניקח את הצומת הראשון ב-<span class="math">\(C_{L}\)</span> ונסמן אותו ב-<span class="math">\(D\)</span>- הצומת הזה הולך ליצור תו מסומן בתוך <span class="math">\(u\)</span> עם הבן השמאלי שלו. עכשיו נשארו לנו <span class="math">\(\left|V\right|+1\)</span> צמתים ב-<span class="math">\(C_{L}\)</span> על המסלול, שכולם באים אחרי <span class="math">\(D\)</span>, אז ניקח כמו קודם משתנה <span class="math">\(A\)</span> שמופיע פעמיים ועושה את זה הכי נמוך שרק אפשר. המשתנה הזה שייך ל-<span class="math">\(C_{L}\)</span>, ולכן הבן השמאלי של המופע הראשון שלו הולך ליצור תו מסומן אחד לפחות - התו הזה יהיה ב-<span class="math">\(v\)</span>. קיבלנו את מה שרצינו, במחיר של ניתוח עדין יותר של הלמה, ובחירה של <span class="math">\(n\)</span> גדול יותר.</p>
<p>אני רק רוצה לחדד עוד נקודה עדינה - בניסוח הלמה שלו, אוגדן לא אומר רק ש-<span class="math">\(uv^{i}wx^{i}y\in L\)</span> לכל <span class="math">\(i\ge0\)</span> - הוא אומר במפורש שקיים משתנה <span class="math">\(A\)</span> כך ש-<span class="math">\(S\Rightarrow^{*}uAy\Rightarrow^{*}uvAxy\Rightarrow^{*}uvwxy\)</span>. זה יהיה לנו חשוב בהמשך.</p>
<p>כדי להראות למה זה שימושי, בואו נדבר על רב-משמעות. כזכור, דקדוק הוא <strong>רב משמעי</strong> אם קיימת מילה אחת לפחות שיש לה שני עצי גזירה שונים. כלומר, יש שתי דרכים שונות לגזור אותה, שנבדלות לא רק בשאלה <strong>מתי</strong> מופעל כלל גזירה על משתנה, אלא גם <strong>איזה</strong> כלל גזירה הופעל. לדוגמה, שתי הגזירות <span class="math">\(A\Rightarrow BC\Rightarrow bC\Rightarrow bc\)</span> ו-<span class="math">\(A\Rightarrow BC\Rightarrow Bc\Rightarrow bc\)</span> מתאימות לאותו עץ גזירה ונבדלות רק בסדר שבו בוצעו הגזירות של המשתנים; לעומת זאת <span class="math">\(A\Rightarrow BC\Rightarrow bbC\Rightarrow bbb\)</span> ו-<span class="math">\(A\Rightarrow BC\Rightarrow Bbb\Rightarrow bbb\)</span> הן גזירות שמתאימות לעצי גזירה שונים (בראשון <span class="math">\(B\)</span> גוזר שני <span class="math">\(b\)</span>-ים, ובשני דווקא <span class="math">\(C\)</span> גוזר שני <span class="math">\(b\)</span>-ים). לכן דקדוק שמאפשר את הגזירות מהדוגמה השניה הוא רב משמעי.</p>
<p>רב משמעות היא עניין בעייתי כאשר אנחנו רוצים להשתמש בעץ הגזירה של מילה כדי להבין את המבנה שלה - למשל, להשתמש בעץ הגזירה של תוכנית מחשב כדי להבין את מבנה התוכנית, ואנחנו מן הסתם לא רוצים לאפשר שתי משמעויות שונות (ועצי גזירה שונים לאותה תוכנית מחשב אכן יובילו לרוב לשתי תוכניות שמתנהגות בצורה שונה - די אסון). זה מעלה מייד שתי שאלות - ראשית, בהינתן דקדוק, האם ניתן לבדוק האם הוא רב משמעי? ושנית, בהינתן דקדוק, האם ניתן להמיר אותו בדקדוק אחר עבור אותה שפה, שהוא כן חד משמעי?</p>
<p>באופן די עגום, התשובה לשתי השאלות הללו היא "לא", או ליתר דיוק, "לא תמיד". לא אסביר כרגע למה לא תמיד ניתן לבדוק האם דקדוק נתון הוא רב משמעי, אבל אגיע לזה בהמשך; עכשיו אסביר למה לא תמיד ניתן להמיר דקדוק רב משמעי בדקדוק חד משמעי - זה בגלל שיש שפות שהן <strong>רב משמעיות טבועות</strong>, דהיינו כל דקדוק עבורן יהיה בהכרח רב משמעי. והן לא חייבות להיות מסובכות; הדוגמה שלי היא השפה התמימה למראה <span class="math">\(L=\left\{ a^{n}b^{n}c^{k}\ |\ n,k\in\mathbb{N}\right\} \cup\left\{ a^{k}b^{n}c^{n}\ |\ n,k\in\mathbb{N}\right\} \)</span>. כלומר, אוסף כל המילים מהצורה <span class="math">\(a^{*}b^{*}c^{*}\)</span> כך שמספר ה-<span class="math">\(b\)</span>-ים שווה למספר ה-<span class="math">\(a\)</span>-ים או למספר ה-<span class="math">\(c\)</span>-ים. ברור שזו שפה חסרת הקשר כי תחשבו על אוטומט מחסנית שמקבל אותה: הוא מחליט אי דטרמיניסטית מראש למי מספר ה-<span class="math">\(b\)</span>-ים יהיה שווה ואז מתנהג כמו אוטומט עבור <span class="math">\(\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} \)</span> תוך שאת האותיות מהסוג השלישי הוא סתם קורא ולא נוגע במחסנית (תרגיל קל: כתבו דקדוק עבור השפה הזו).</p>
<p>נותר לי להוכיח שהשפה היא רב משמעית טבועה. קחו רגע ותנסו לחשוב איך מוכיחים את זה. ועוד יותר מכך - איך הלמה של אוגדן תהיה קשורה לכך. לי עצמי אין מושג, כשאני כותב את הפוסט; הספקתי כבר לשכוח איך זה עובד, ולכן זה הולך להרגיש לי (שקורא את ההוכחה תוך כדי הכתיבה) כמו קסם בדיוק כמו לכם. כרגע אני לא ממש רואה קשר.</p>
<p>אוקיי, בואו נתחיל (קראתי את ההוכחה - וואו, מגניב!). נניח ש-<span class="math">\(n\)</span> הוא הקבוע שהלמה של אוגדן מבטיחה לנו (וניקח <span class="math">\(n>3\)</span> כי נזדקק בהמשך לכך ש-<span class="math">\(2n<n!\)</span>). המילה שאראה שחייבים להיות לה שני עצי גזירה שונים תהיה באופן ממש אינטואיטיבי המילה <span class="math">\(a^{n+n!}b^{n+n!}c^{n+n!}\)</span>, כאשר <span class="math">\(n!\)</span> (<span class="math">\(n\)</span> עצרת), כזכור, הוא קיצור ל-<span class="math">\(1\cdot2\cdots n\)</span> (במבט ראשון זה נראה לא קשור בעליל, אבל עצרת היא מספר שימושי שצץ בהרבה הוכחות בגלל התכונה הנחמדה שלה שהיא מתחלקת בכל מספר מ-1 ועד <span class="math">\(n\)</span>).</p>
<p>כדי להראות את שני עצי הגזירה השונים הללו, ניקח שתי מילים שונות שהן תת-מילים של המילה שלנו, נפעיל עליהן את הלמה של אוגדן ונראה שאפשר "לנפח" אותן כדי לקבל את המילה שלנו, ושני הניפוחים חייבים להיות שונים באופיים ולכן לא יכולים להתאים לאותו עץ גזירה. נתחיל מהמילה <span class="math">\(a^{n}b^{n}c^{n+n!}\)</span>. הלמה של אוגדן מבקשת מאיתנו לסמן לפחות <span class="math">\(n\)</span> אותיות, אז בואו נסמן בדיוק את ה-<span class="math">\(a\)</span>-ים במילה. עכשיו קיבלנו פירוק <span class="math">\(uvwxy\)</span> של המילה, שבו <span class="math">\(w\)</span> כולל לפחות אות מסומנת אחת - כלומר, <span class="math">\(w\)</span> מוכל בחלק של ה-<span class="math">\(a\)</span>-ים. לכן גם <span class="math">\(u,v\)</span> שבאות לפני <span class="math">\(w\)</span> מוכלות בחלק של ה-<span class="math">\(a\)</span>-ים (אבל שימו לב - שום דבר לא מונע מ-<span class="math">\(u,v\)</span> להיות שתיהן ריקות; הלמה של אוגדן לא מבטיחה שיהיה בהן משהו).</p>
<p>בואו נבין עכשיו איך <span class="math">\(x\)</span> נראה. הוא בא אחרי <span class="math">\(w\)</span> ולכן יכול להיות בעצם בכל מקום במילה, אבל אם <span class="math">\(x\)</span> יכלול שתי אותיות שונות, <span class="math">\(uv^{2}wx^{2}y\)</span> בהכרח לא תהיה שייכת לשפה (כי השפה כוללת רק מילים שבהן קודם באים כל ה-<span class="math">\(a\)</span>-ים, אחר כך כל ה-<span class="math">\(b\)</span>-ים ובסוף כל ה-<span class="math">\(c\)</span>-ים; אם <span class="math">\(x\)</span> כולל שתי אותיות שונות ונחזור עליו פעמיים, נראה אותיות נעלמות ואז חוזרות שוב). לכן <span class="math">\(x\)</span> מורכב כולו מאחת משלוש האותיות האפשריות (וייתכן שהוא ריק).</p>
<p>עכשיו, בואו נסמן את הגדלים של החלקים המנופחים: <span class="math">\(\left|v\right|=p,\left|x\right|=q\)</span>. אז <span class="math">\(p,q\ge0\)</span> ובנוסף אנחנו יודעים ש-<span class="math">\(0<p+q\le2n&lt;n!\)</span>. כמו כן אפשר עכשיו לכתוב את המבנה של החלקים הללו: <span class="math">\(v=a^{p}\)</span> תמיד, בזמן ש-<span class="math">\(x\)</span> שייך לאחת משלוש צורות אפשריות: <span class="math">\(x=a^{q}\)</span> או <span class="math">\(x=b^{q}\)</span> או <span class="math">\(x=c^{q}\)</span>.</p>
<p>עכשיו בואו ונראה מה קורה כשמנפחים את המילה, ונבדיל בין אפשרויות שונות על בסיס הערכים הפוטנציאליים של <span class="math">\(x\)</span>.</p>
<p>אם <span class="math">\(x=a^{q}\)</span> אז <span class="math">\(uv^{2}wx^{2}y=a^{n+p+q}b^{n}c^{n+n!}\)</span> וזו בבירור לא מילה בשפה כי מספר ה-<span class="math">\(a\)</span>-ים שונה ממספר ה-<span class="math">\(b\)</span>-ים ששונה ממספר ה-<span class="math">\(c\)</span>-ים. מסקנה: <span class="math">\(x\ne a^{q}\)</span>. מכאן אנחנו לומדים משהו קריטי להמשך - <span class="math">\(x\)</span> לא כולל אותיות מסומנות, ולכן <span class="math">\(v\)</span> חייב לכלול כאלו, כלומר <span class="math">\(\left|v\right|=p>0\)</span>.</p>
<p>אם <span class="math">\(x=c^{q}\)</span> אז <span class="math">\(uv^{2}wx^{2}y=a^{n+p}b^{n}c^{n+n!+q}\)</span>. כבר ראינו ש-<span class="math">\(p>0\)</span> ולכן <span class="math">\(n+p\ne n\)</span> ושוב קיבלנו מילה שאינה בשפה.</p>
<p>המסקנה היא שבהכרח <span class="math">\(x=b^{q}\)</span>, כדי שיוכל "לאזן" את <span class="math">\(v\)</span>: <span class="math">\(uv^{2}wx^{2}y=a^{n+p}b^{n+q}c^{n+n!}\)</span>. מכיוון שהמילה הזו חייבת להיות שייכת לשפה (אחרת נגיע לסתירה כללית), בהכרח <span class="math">\(p=q\)</span>. זה אומר שכשאנחנו מנפחים את המילה, אנחנו מגדילים את מספר ה-<span class="math">\(a\)</span>-ים וה-<span class="math">\(b\)</span>-ים באותה כמות בדיוק - בואו ננפח עד שנגיע ל-<span class="math">\(n+n!\)</span>. כאן השימוש בעצרת משתלם לנו - אנחנו לא יודעים מהו <span class="math">\(p\)</span>, אבל אנחנו יודעים ש-<span class="math">\(p\le n\)</span> (כי כבר ראינו ש-<span class="math">\(v\)</span> כלול כולו ב-<span class="math">\(a\)</span>-ים ויש רק <span class="math">\(n\)</span> כאלו) ולכן <span class="math">\(p|n!\)</span>, כלומר קיים <span class="math">\(t\)</span> כך ש-<span class="math">\(pt=n!\)</span>. וכעת: <span class="math">\(uv^{t+1}wx^{t+1}y=a^{n+pt}b^{n+pt}c^{n+n!}=a^{n+n!}b^{n+n!}c^{n+n!}\)</span>. הוכחנו שהדקדוק שלנו יודע לגזור את <span class="math">\(a^{n+n!}b^{n+n!}c^{n+n!}\)</span>.</p>
<p>בואו נחדד את מה שראינו, תוך שאנו זוכרים מה אוגדן בדיוק אומר - הוא אומר שקיים משתנה <span class="math">\(A\)</span> כך ש-<span class="math">\(S\Rightarrow^{*}uAy\Rightarrow^{*}uvAxy\Rightarrow^{*}uv^{t+1}Ax^{t+1}y\Rightarrow^{*}uv^{t+1}wx^{t+1}y=a^{n+n!}b^{n+n!}c^{n+n!}\)</span>. מה שחשוב כאן הוא ש-<span class="math">\(A\)</span> מייצר את <span class="math">\(v,x\)</span> ולכן גוזר רק את האותיות <span class="math">\(a,b\)</span>.</p>
<p>עכשיו אפשר לחזור על כל מה שאמרנו עד כה אבל כשמתחילים מהמילה <span class="math">\(a^{n+n!}b^{n}c^{n}\)</span> שגם כן שייכת לשפה. הלמה של אוגדן תראה לנו בסופו של דבר שקיים משתנה <span class="math">\(A^{\prime}\)</span> כך ש-</p>
<p><span class="math">\(S\Rightarrow^{*}u^{\prime}A^{\prime}y^{\prime}\Rightarrow^{*}u^{\prime}v^{\prime}A^{\prime}x^{\prime}y^{\prime}\Rightarrow^{*}u^{\prime}\left(v^{\prime}\right)^{t+1}A^{\prime}\left(x^{\prime}\right)^{t+1}y^{\prime}\Rightarrow^{*}u^{\prime}\left(v^{\prime}\right)^{t+1}w^{\prime}\left(x^{\prime}\right)^{t+1}y^{\prime}=a^{n+n!}b^{n+n!}c^{n+n!}\)</span></p>
<p>רק שהפעם יצא ש-<span class="math">\(A^{\prime}\)</span> גוזר רק <span class="math">\(b\)</span>-ים ו-<span class="math">\(c\)</span>-ים.</p>
<p>קיבלנו שתי גזירות של <span class="math">\(a^{n+n!}b^{n+n!}c^{n+n!}\)</span> בדקדוק שלנו. אבל האם הן באמת מתאימות לעצי גזירה שונים? אינטואיטיבית כנראה כבר ברור שכן כי איכשהו <span class="math">\(A\)</span> ו-<span class="math">\(A^{\prime}\)</span> לא מסתדרים לנו טוב ביחד, אבל צריך לתת פה נימוק פורמלי יותר. ראשית נשים לב לכך ש-<span class="math">\(A\)</span> לא יודעת לגזור את <span class="math">\(A^{\prime}\)</span> וגם ההפך נכון (כי <span class="math">\(A\)</span> גוזרת רק <span class="math">\(a,b\)</span> בעץ הגזירה שלה, ולכן אם <span class="math">\(A^{\prime}\)</span> הייתה בעץ הגזירה, אז היו גם <span class="math">\(c\)</span>-ים בפנים). זה אומר שאם שתי הגזירות שלעיל הן גזירה אחת, אז על ידי כך שנבצע את הגזירה הזו אבל "נתאפק" ולא נגזור לא את <span class="math">\(A\)</span> ולא את <span class="math">\(A^{\prime}\)</span> אחרי שהן מופיעות לראשונה, נקבל את הדבר הבא: <span class="math">\(S\Rightarrow^{*}t_{1}At_{2}A^{\prime}t_{3}\)</span>. עכשיו אני יכול להמשיך ולגזור את <span class="math">\(A,A^{\prime}\)</span> כמה פעמים שנרצה לפני שנגזור אותן ל-<span class="math">\(w,w^{\prime}\)</span> - בואו נגזור את <span class="math">\(A\)</span> במשך <span class="math">\(i\)</span> פעמים ואת <span class="math">\(A^{\prime}\)</span> במשך <span class="math">\(j\)</span> פעמים, עבור <span class="math">\(i,j\)</span> שמשתלמים לנו (נראה עוד מעט מה זה אומר). נקבל את המילה הבאה, ששייכת כמובן לשפה <span class="math">\(L\)</span> כי היא נגזרה על ידי הדקדוק:</p>
<p><span class="math">\(t_{1}v^{i}wx^{i}t_{2}\left(v^{\prime}\right)^{j}w^{\prime}\left(x^{\prime}\right)^{j}t_{3}\)</span></p>
<p>מה שאני רוצה לומר הוא שעבור <span class="math">\(i,j\)</span> גדולים מספיק, מספר ה-<span class="math">\(b\)</span>-ים במילה הזו בהכרח יהיה גדול ממספר ה-<span class="math">\(a\)</span>-ים וגם ממספר ה-<span class="math">\(c\)</span>-ים, ולכן המילה לא תהיה שייכת לשפה. כדי לראות את זה, בואו נחשב כמה אותיות מכל סוג יש במילה הזו. לא נוכל לדעת במדויק, אבל נוכל לקבל חסם. למשל, אנחנו יודעים שהמקום שבו ה-<span class="math">\(a\)</span>-ים נגמרים הוא לכל היותר בתוך <span class="math">\(w\)</span>, כי כבר ראינו ש-<span class="math">\(x\)</span> חייב להכיל רק <span class="math">\(b\)</span>-ים. לכן מספר ה-<span class="math">\(a\)</span>-ים במילה חסום מלמעלה על ידי <span class="math">\(\left|t_{1}\right|+i\left|v\right|+\left|w\right|\)</span>. באופן דומה, מספר ה-<span class="math">\(c\)</span>-ים במילה חסום מלמעלה על ידי <span class="math">\(\left|t_{3}\right|+j\left|x^{\prime}\right|+\left|w^{\prime}\right|\)</span>. לעומת זאת, את מספר ה-<span class="math">\(b\)</span>-ים במילה אני יכול לחסום <strong>מלמטה</strong>: אני יודע שלכל הפחות כל <span class="math">\(x\)</span> הוא <span class="math">\(b\)</span>-ים, ושכל <span class="math">\(v^{\prime}\)</span> הוא <span class="math">\(b\)</span>-ים, ולכן גם <span class="math">\(t_{2}\)</span> שכלוא בין שניהם חייב להיות כולו <span class="math">\(b\)</span>-ים, ולכן קיבלנו שמספר ה-<span class="math">\(b\)</span>-ים הוא לפחות <span class="math">\(i\left|x\right|+\left|t_{2}\right|+j\left|v^{\prime}\right|\)</span>. ואני יודע גם קצת יותר מזה - אני יודע ש-<span class="math">\(\left|x\right|=\left|v\right|\)</span> וש-<span class="math">\(\left|v^{\prime}\right|=\left|x^{\prime}\right|\)</span>.</p>
<p>יש כאן כבר יותר מדי אותיות ותגים וסימונים, אז בואו נשנה אותם כדי שיהיה יותר קל להבין מה קורה פה. נסמן ב-<span class="math">\(f\left(\sigma\right)\)</span> את מספר המופעים של <span class="math">\(\sigma\)</span>. אז יש לנו את המשוואות הבאות:</p>
<p><span class="math">\(f\left(a\right)\le A+i\alpha\)</span></p>
<p><span class="math">\(f\left(c\right)\le C+j\beta\)</span></p>
<p><span class="math">\(f\left(b\right)\ge B+i\alpha+j\beta\)</span></p>
<p>כאשר <span class="math">\(A,B,C,\alpha,\beta\)</span> הם קבועים חיוביים כלשהם. עכשיו הרבה יותר קל לראות מה קורה פה. כך למשל נניח שאנו רוצים להבטיח ש-<span class="math">\(f\left(a\right)<f\left(b\right)\)</span>, כלומר ש-<span class="math">\(A+i\alpha<B+i\alpha+j\beta\)</span>; נעביר אגפים ונקבל שצריך להתקיים <span class="math">\(j>\frac{A-B}{\beta}\)</span>. באופן דומה כדי שיתקיים <span class="math">\(f\left(c\right)<f\left(b\right)\)</span> צריך להתקיים <span class="math">\(i>\frac{C-B}{\alpha}\)</span>. שימו לב שהחסמים הללו על הערכים של <span class="math">\(i,j\)</span> לא תלויים זה בזה, כך שאין לנו בעיה לבחור ערכים מספיק גדולים עבור שניהם, מה שיסיים את ההוכחה - הראינו שאם אין למילה שלנו שני עצי גזירה שונים אלא עץ גזירה יחיד, אז אפשר לנצל את עץ הגזירה הזה כדי לגזור מילה אחרת שהיא בבירור לא בשפה. זה מסיים את ההוכחה כולה.</p>
<p>אני מקווה שלא כולם הלכו לאיבוד בים הפרטים הטכניים. הם לא היו נוראיים כל כך, לדעתי; אולי בגלל שאני כותב את הפוסט ולכן מוכרח להרגיש "בידיים" מה הולך שם (בקריאה נטו של פרטים טכניים תמיד יותר קל ללכת לאיבוד). התוצאה אינה כה מסובכת מבחינה רעיונית - בעזרת הלמה של אוגדן יש לנו שליטה רבה יותר על האופן שבו מילים מנופחות, וכדי להראות שלא קיים דקדוק חד משמעי אנחנו מייצרים את אותה מילה בשתי דרכים שונות מהותית על ידי ניפוחים שונים של מילים פשוטות יותר. לטעמי זו הייתה תוצאה יפה מאוד.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>