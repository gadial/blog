<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>שפות חסרות הקשר - תכונות סגור - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_site/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/new_site/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/new_site/">דף הבית</a>
                <a href="/new_site/random.html">פוסט אקראי</a>
                <a href="/new_site/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_site/2015/04/16/birthday_riddle/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">חידת יום הולדת</span>
            </a>
            

            
            <a href="/new_site/2015/04/29/formal_languages_decision_problems/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">בעיות הכרעה עבור שפות פורמליות</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>שפות חסרות הקשר - תכונות סגור</h1>
            <div class="post-meta">
                <span class="date">2015-04-26</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/שפות חסרות הקשר.html">שפות חסרות הקשר</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>הפוסט הקודם שלי על שפות חסרות הקשר היה כבד יחסית, אז בואו נישאר הפעם במסגרת הדברים הקלילים. אני ממשיך עם ההקבלה שלנו לשפות רגולריות, והגענו לשלב שבו אנחנו מוכיחים כל מני תכונות סגור שונות ומשונות - פעולות שאפשר להפעיל על שפות חסרות הקשר בצורה שמבטיחה שהתוצאה היא עדיין חסרת הקשר. אלו כלים מאוד יעילים כדי להוכיח ששפה היא חסרת הקשר (או לא חסרת הקשר: מתחילים מהשפה החשודה ומגיעים מפעולות סגור לשפה שידוע שאינה חסרת הקשר, וזו הוכחה שהשפה המקורית לא הייתה חסרת הקשר).</p>
<p>הפעולות עצמן יהיו סטנדרטיות וזהות כמעט לגמרי למה שהופיע עבור שפות רגולריות, למעט הבדל מרכזי אחד שאציין כבר עכשיו: שפות חסרות הקשר <strong>אינן</strong> סגורות לחיתוך. קל מאוד לראות את זה: ראינו בפוסט הקודם ש-<span class="math">\(\left\{ a^{n}b^{n}c^{n}\ |\ n\in\mathbb{N}\right\} \)</span> אינה חסרת הקשר, אבל מאוד קל לראות ש-<span class="math">\(\left\{ a^{n}b^{n}c^{k}\ |\ n,k\in\mathbb{N}\right\} \)</span> ו-<span class="math">\(\left\{ a^{k}b^{n}c^{n}\ |\ n,k\in\mathbb{N}\right\} \)</span> שתיהן חסרות הקשר והשפה ההיא מתקבלת בתור החיתוך שלהן (למה?). עדיין, מה האינטואיציה כאן? למה מה שהייתה תכונת סגור עבור שפות רגולריות היא לא כזו עכשיו? לטעמי לב העניין בכך שהמודלים שלנו עבור שפות חסרות הקשר הם <strong>אי-דטרמיניסטיים</strong> באופיים. או שיש לנו אוטומט מחסנית אי דטרמיניסטי (עדיין צריך לדבר על מה קורה עם אוטומט מחסנית דטרמיניסטי; אגלה כבר עכשיו בסוד שהוא חלש יותר מאוטומט מחסנית אי דטרמיניסטי) או שיש לנו דקדוק, שהוא מטבעו יצור אי דטרמיניסטי (בדרך כלל לכל משתנה יש יותר מגזירה אפשרית אחת).</p>
<p>הגישה האי-דטרמיניסטית לייצור/זיהוי מילה היא "מספיק שתהיה דרך <strong>כלשהי</strong> להגיע אל המילה כדי שהיא תהיה בשפה". כלומר, מספיק שדקדוק ייצר את המילה פעם אחת כדי שהיא תהיה בשפה; ומספיק שהאוטומט האי דטרמיניסטי יקבל את המילה באחד ממסלולי החישוב שלו כדי שזה ייקרא שהיא מתקבלת. אבל כשאנחנו מדברים על חיתוך, אנחנו בעצם רוצים להגיד "אסור לקבל את המילה אלא אם אנחנו מגיעים אליה בשתי דרכים שונות", ואת זה כבר קשה לנו לעשות. תחשבו רגע איך לעשות את זה בדקדוק ותראו שזה מאתגר; אבל למה עבור אוטומט זה קשה? למה הבניה הסטנדרטית של אוטומט מכפלה לא עובדת? פשוט מאוד: כי אוטומט מכפלה יצטרך לעבוד עם <strong>שתי</strong> מחסניות, אחת לכל אוטומט שהוא מסמלץ, אבל המודל שלנו מאפשר לעבוד רק עם מחסנית אחת (בהמשך נראה שאם מרשים שתי מחסניות הכוח של המודל קופץ בצורה קיצונית, הכי גבוה שרק אפשר - אל מכונת טיורינג). עם זאת, לא הכל אבוד: עדיין אפשר לבנות אוטומט מכפלה אם אחת משתי השפות <strong>אינה</strong> דורשת את המחסנית; במילים אחרות, אם אחת מהשפות היא רגולרית. לכן אמנם חיתוך של שתי שפות חסרות הקשר כלליות אינו תכונת סגור, אבל חיתוך של שפה חסרת הקשר עם שפה רגולרית היא כן תכונת סגור (ותכונה מועילה למדי).</p>
<p>אוטוטו נראה שאיחוד הוא כן תכונת סגור, ולכן מכך שחיתוך אינו תכונת סגור אנחנו לומדים גם שמשלים אינו יכול להיות תכונת סגור (כי אפשר לקבל חיתוך בעזרת משלים ואיחוד - כללי דה-מורגן). לכן אפשר להשתמש גם במשלים כדי לקבל אינטואיציה, אולי אפילו חזקה יותר (למשל, עבור מכונות טיורינג אי דטרמיניסטיות דווקא כן יש סגירות לחיתוך, אבל אין סגירות למשלים - בלשון פורמלית, <span class="math">\(\text{RE}\ne\text{coRE}\)</span>). הבעיה במשלים היא דווקא לא בצורך שלנו לדחות מילים שהיו שייכות לשפה שאנחנו משלימים - את זה קל לעשות - הקושי הוא בלקבל דווקא את המילים שקודם לא היו בשפה (ולכן בדקדוק אין שום דבר שמייצר אותן, ובאוטומט מחסנית אין להן אף מסלול מקבל, אבל הרי גם למילים בשפה יכולים להיות מסלולים דוחים רבים אז סתם להחליף בין המצב המקבל והדוחה לא יעבוד).</p>
<p>אוקיי, אז זה מה ש<strong>אינו</strong> תכונת סגור ושונה מאשר בשפות רגולריות. מה עם מה שכן?</p>
<p>שלוש הפעולות החביבות עלינו בשפות רגולריות היו איחוד, שרשור וסגור קלייני שכן משפט קלייני הראה שבעזרתן אפשר לבנות את כל השפות הרגולריות מתוך כל השפות הסופיות. נניח שיש לנו שתי שפות חסרות הקשר <span class="math">\(L_{1},L_{2}\)</span> עם דקדוקים שמייצרים אותן <span class="math">\(G_{1}=\left(V_{1},T,S_{1},P_{1}\right)\)</span> ו-<span class="math">\(G_{2}=\left(V_{2},T,S_{2},P_{2}\right)\)</span> בהתאמה (אני מניח שקבוצת הטרמינלים <span class="math">\(T\)</span> משותפת לשתי השפות, אחרת לוקחים את קבוצת האיחוד של הטרמינלים של שתיהן). אז דקדוק עבור האיחוד ייבנה על ידי הוספת משתנה התחלתי חדש <span class="math">\(S\)</span> עם כללי הגזירה <span class="math">\(S\to S_{1}|S_{2}\)</span> ולקיחת כל המשתנים וכללי הגזירה של שני הדקדוקים; דקדוק עבור השרשור ייבנה על ידי הוספת משתנה התחלתי חדש <span class="math">\(S\)</span> וכלל הגזירה <span class="math">\(S\to S_{1}S_{2}\)</span>; ודקדוק עבור סגור קלייני של <span class="math">\(L_{1}\)</span> ייבנה על ידי <span class="math">\(S\to SS_{1}|\varepsilon\)</span>. כבר עשיתי את זה בפוסט הפותח שלי על שפות חסרות הקשר אבל למה לא לעשות שוב. תרגיל נחמד זה להוכיח את הסגירויות הללו עם אוטומט מחסנית במקום עם דקדוק (מהר מאוד תגלו שקבלה על ידי ריקון מחסנית נוחה יותר מאשר קבלה עם מצבים מקבלים כשרוצים לכתוב את זה פורמלית).</p>
<p>התכונה הבאה היא הומומורפיזם. עבור שפות רגולריות הוכחתי אותה באינדוקציית מבנה כי היה לשפות הרגולריות מבנה אינדוקטיבי פשוט. אני לא מכיר מבנה דומה עבור שפות חסרות הקשר, אבל למרבה המזל, עם דקדוקים ההוכחה ממש קלה. נניח ש-<span class="math">\(h:\Sigma\to\Gamma\)</span> הוא הומומורפיזם וניקח דקדוק <span class="math">\(G=\left(V,\Sigma,S,P\right)\)</span>. נבנה דקדוק <span class="math">\(G^{\prime}=\left(V\cup\Sigma,\Gamma,S,P\cup P^{\prime}\right)\)</span> שהתעלול בו הוא שמי שהיו טרמינלים בדקדוק הקודם הם עכשיו גם כן משתנים, ונוסיף להם כללי גזירה: לכל <span class="math">\(\sigma\in\Sigma\)</span> נוסיף את כלל הגזירה <span class="math">\(\sigma\to h\left(\sigma\right)\)</span>. עכשיו, קחו את עץ הגזירה של מילה בדקדוק הזה, והסירו ממנו את העלים - קיבלתם עץ גזירה של מילה בדקדוק המקורי. יחד עם העלים, מה שקורה הוא שכל טרמינל מוחלף בערך ההומומורפיזם עליו - מה שצריך להיות.</p>
<p>ההוכחה עבור הצבה דומה מאוד. כזכור, הצבה היא מעין הרחבה של הומומורפיזם כך שלכל אות מתאימים שפה, לא מילה. לכל <span class="math">\(\sigma\in\Sigma\)</span> נסמן את השפה שההצבה מעבירה את <span class="math">\(\sigma\)</span> אליה ב-<span class="math">\(L_{\sigma}\)</span>. כדי שתהיה לנו תקווה כלשהי לכך שהצבה תהיה תכונת סגור אנחנו חייבים לדרוש ש-<span class="math">\(L_{\sigma}\)</span> תהיה חסרת הקשר (למה?) ולכן יש לה דקדוק <span class="math">\(\left(V_{\sigma},T_{\sigma},S_{\sigma},P_{\sigma}\right)\)</span>. נוסיף לדקדוק שלנו את כל המשתנים, הטרמינלים וכללי הגזירה של כל דקדוק כזה, ואת כלל הגזירה <span class="math">\(\sigma\to S_{\sigma}\)</span>. עכשיו תסבירו לעצמכם למה זה עובד.</p>
<p>עוד תכונת סגור של שפות רגולריות הייתה היפוך. לא קשה להראות (באינדוקציה...) שאם ניקח דקדוק ונהפוך את הכללים שלו (כלומר, נחליף כל כלל <span class="math">\(A\to\alpha\)</span> ב-<span class="math">\(A\to\alpha^{R}\)</span>) נקבל דקדוק עבור השפה ההפוכה. זה מעניין, כי קשה לי לראות דרך טובה להוכיח את התכונה הזו בעזרת אוטומט מחסנית (אני מניח שאפשר להפוך חישובים עם אוטומט מחסנית, אבל בגלל הצורך להתעסק עם המחסנית זה הופך להיות מאוד טרחני ומעצבן).</p>
<p>התכונה הבאה היא הומומורפיזם הפוך, וכאן העניינים קצת מסתבכים. כזכור, אם <span class="math">\(h:\Sigma\to\Delta\)</span> הוא הומומורפיזם ו-<span class="math">\(L\subseteq\Delta^{*}\)</span>, אז מגדירים <span class="math">\(h^{-1}\left(L\right)=\left\{ w\in\Sigma:h\left(w\right)\in L\right\} \)</span>. המטרה שלנו היא להראות שאם <span class="math">\(L\)</span> חסרת הקשר, כך גם <span class="math">\(h^{-1}\left(L\right)\)</span>. אבל את זה אני לא יודע לעשות עם דקדוקים, לשם שינוי. הומומורפיזם היה קל, כי כל אות גזרה את התמונה של האות הזו; אבל בהומומורפיזם הפוך אני צריך איכשהו לקבץ אותיות לקבוצות ולהמיר את כולן למקור שלהן, וזה כבר נשמע כמו דקדוק תלוי הקשר ולא חסר הקשר. נו טוב, לא חייבים ללכת עם הראש בקיר - אפשר במקום זה להשתמש באוטומט מחסנית.</p>
<p>עבור שפות רגולריות, ההוכחה הייתה ממש קלה. לקחנו אוטומט עבור <span class="math">\(L\)</span> ובנינו אוטומט חדש עבור <span class="math">\(h^{-1}\left(L\right)\)</span> שפעל כך - על כל אות <span class="math">\(\sigma\)</span> הוא ביצע "סימולציה" של האוטומט המקורי על <span class="math">\(h\left(\sigma\right)\)</span>. זה היה קל במיוחד, כי לא באמת היה צריך לבצע את צעדי הסימולציה במפורש - כבר בזמן בניית האוטומט ידענו בודאות לאן הם יביאו אותנו והגדרנו את פונקציית המעברים בהתאם, כלומר הגדרנו <strong><span class="math">\(\delta^{\prime}\left(q,\sigma\right)=\hat{\delta}\left(q,h\left(\sigma\right)\right)\)</span>. </strong>האם זה עדיין יעבוד? לא. למה לא? כי עכשיו תוצאת הסימולציה תלוייה בשני דברים: גם במצב שבו האוטומט נמצא, אבל גם בתוכן המחסנית. ותוכן המחסנית זה משהו שלא ידוע מראש כשבונים את קידוד האוטומט, ויש אינסוף תכנים אפשריים למחסנית כך שאי אפשר לכסות את כל המקרים. לא, הפעם הסימולציה תהיה חייבת להתבצע "צעד צעד". אם זה עדיין לא ברור למה, חשבו על הסיטואציה הבאה: <span class="math">\(h\left(0\right)=aaa\)</span>. אנחנו רוצים להריץ סימולציה על <span class="math">\(0\)</span>, כלומר להזין לאוטומט שאנחנו מסמלצים את <span class="math">\(aaa\)</span> ולראות מה קורה, על ה-<span class="math">\(a\)</span> הראשון האוטומט מרוקן את הסימן שהיה בראש המחסנית. זה אומר שהמשך החישוב תלוי לא רק ב-<span class="math">\(0\)</span> שקראנו, במצב שהיינו בו ובמה שהיה אז בראש המחסנית, אלא גם במה שהיה <strong>מתחת</strong> לראש המחסנית. ומי יודע מה האוטומט עושה הלאה - אולי הוא מרוקן את המחסנית עם מסעי-<span class="math">\(\varepsilon\)</span> עד שהוא מגיע בה לתו מסויים? כלומר, מה שיקרה הלאה תלוי ב<strong>כל</strong> תוכן המחסנית, ואי אפשר להתכונן מראש לכל אינסוף המקרים האפשריים.</p>
<p>יש בעיה קטנה עם לבצע את הסימולציה "צעד צעד" - בכל צעד אנחנו קוראים לכל היותר תו קלט אחד, ואם עכשיו אני אמור לרוץ על <span class="math">\(aaa\)</span>, אני צריך "לזכור" את התווים הללו, ולהזין אותם אחד-אחד לאוטומט שאני מסמלץ. למרבה המזל, קל מאוד לעשות את זה - כל מה שאני צריך פה הוא כמות סופית של זכרון (עוד מעט אסביר למה, אם זה לא ברור) ולכן המצבים שלי יכולים לקודד את המידע הזה. באופן אינטואיטיבי, הסימולציה שלי תכלול את הרכיבים הבאים: את קבוצת המצבים של האוטומט שאני מסמלץ; המחסנית שלי גם כן תשמש את האוטומט הזה ואני לא אגע בה; ובנוסף לכך יהיה לי מין "חוצץ" בצד שזוכר מה מילת הקלט הנוכחית שאני רוצה להזין לסימולציה. אם החוצץ ריק, אני קורא אות חדשה מהקלט האמיתי שלי, מחשב את <span class="math">\(h\)</span> עליה ומכניס לחוצץ. בפועל, החוצץ הזה ממומש עם קבוצת המצבים של האוטומט שאני בונה.</p>
<p>קרוב לודאי שאיבדתם אותי, אז בואו נסתכל על הבניה הפורמלית - אני מקווה שהיא תהיה ברורה יותר. בואו ניקח <span class="math">\(L\subseteq\Delta^{*}\)</span> ואוטומט מחסנית בשבילה שמקבל על ידי ריקון: <span class="math">\(M=\left(Q,\Delta,\Gamma,q_{0},\perp,\delta,\emptyset\right)\)</span>. אני אבנה אוטומט חדש <span class="math">\(M^{\prime}\)</span> שקבוצת המצבים שלו מוגדרת בצורה קצת מוזרה: <span class="math">\(\left\{ \left(q,w\right)\ |\ \exists\sigma\in\Sigma,u\in\Delta^{*}:h\left(\sigma\right)=uw\right\} \)</span>. פורמלית, המצבים שלי הם כל הזוגות של מצב מ-<span class="math">\(Q\)</span> ומילה <span class="math">\(w\in\Delta^{*}\)</span> שהיא סיפא של תמונה של <span class="math">\(h\)</span> על אות כלשהי מ-<span class="math">\(\Sigma\)</span>. למה סיפות? הכי פשוט לראות דוגמה. נניח ש-<span class="math">\(h\left(0\right)=abca\)</span>. אז אחרי שהאוטומט שלי קורא <span class="math">\(0\)</span>, הוא יודע שהוא צריך להזין לאוטומט שהוא מסמלץ את <span class="math">\(abca\)</span>. עכשיו, אחרי שהוא מזין לאוטומט הזה את ה-<span class="math">\(a\)</span> הראשון, הוא עדיין צריך לזכור את יתר הדברים שהוא רוצה להזין אליו - כלומר, המחרוזת <span class="math">\(bca\)</span>, שהיא סיפא של <span class="math">\(abca\)</span>. אחרי שהוא הזין את ה-<span class="math">\(b\)</span> הוא נשאר עם <span class="math">\(ca\)</span>, וכן הלאה - הבנתם את העיקרון. בסופו של דבר הוא יישאר עם <span class="math">\(\varepsilon\)</span> (שגם היא סיפא, של כל מילה) ואז הוא ידע שהגיע הזמן לקרוא אות חדשה מהקלט האמיתי שלו (או לסיים).</p>
<p>הנה פונקציית המעברים שלנו, כאשר אני מבדיל בין שני סוגי מעברים - כזה שבו "מטעינים את החוצץ" וכזה שבו מבצעים צעד סימולציה.</p>
<ol>
    <li><span class="math">\(\delta^{\prime}\left(\left(q,\varepsilon\right),a,A\right)=\left\{ \left(\left(q,h\left(a\right)\right),A\right)\right\} \)</span> - שימו לב שלא נוגעים כאן במחסנית ושהצעד הזה מתקיים רק כאשר החוצץ ריק.</li>
    <li><span class="math">\(\delta^{\prime}\left(\left(q,aw\right),\varepsilon,A\right)=\left\{ \left(\left(p,w\right),\alpha\right)\ |\ \left(p,\alpha\right)\in\delta\left(q,a,A\right)\right\} \)</span> - שימו לב שכאן <span class="math">\(a\in\Gamma\cup\left\{ \varepsilon\right\} \)</span>, כלומר ייתכן לבצע צעד סימולציה של מסע-<span class="math">\(\varepsilon\)</span> שלא משנה את תוכן החוצץ.</li>
</ol>
<p>בואו נרפרף גם על ההוכחה שזה עובד, למרות שאני חושב שהבניה (אחרי שמבינים אותה) היא די משכנעת. הרעיון בהוכחה, כמו כמעט כל הוכחת "בניה" אחרת בנושא הזה, היא להראות שהסימולציה "מתנהגת כמו שאנחנו מצפים בכל הצעדים שלה". פורמלית, ש-<span class="math">\(\left[\left(q,\varepsilon\right),w,\alpha\right]\vdash_{M^{\prime}}^{*}\left[\left(p,\varepsilon\right),\varepsilon,\beta\right]\)</span> אם ורק אם <span class="math">\(\left[q,h\left(w\right),\alpha\right]\vdash_{M}^{*}\left[p,\varepsilon,\beta\right]\)</span> (כאן אני שם את שמו של האוטומט ליד ה-<span class="math">\(\vdash\)</span> כדי שנדע על חישוב באיזה מהם מדובר). אם הראינו את זה, העובדה ש-<span class="math">\(L\left(M^{\prime}\right)=h^{-1}\left(L\left(M\right)\right)\)</span> מתקבלת מייד על ידי בחירת <span class="math">\(\alpha=\perp,\beta=\varepsilon,q=q_{0}\)</span>, כי מצד אחד אם <span class="math">\(w\in L\left(M^{\prime}\right)\)</span> אז נקבל ש-<span class="math">\(h\left(w\right)\in L\left(M\right)\)</span> ולכן <span class="math">\(w\in h^{-1}\left(L\left(M\right)\right)\)</span>; ומצד שני אם <span class="math">\(w\in h^{-1}\left(L\left(M\right)\right)\)</span> זה אומר ש-<span class="math">\(h\left(w\right)\in L\left(M\right)\)</span> ולכן קיימת ריצה מקבלת של <span class="math">\(h\left(w\right)\)</span> ב-<span class="math">\(L\left(M\right)\)</span> וממנה אפשר לקבל ריצה מקבלת של <span class="math">\(w\)</span> ב-<span class="math">\(L\left(M^{\prime}\right)\)</span>.</p>
<p>ההוכחה היא באינדוקציה על האורך של <span class="math">\(w\)</span>. עבור <span class="math">\(\left|w\right|=0\)</span> נקבל שצריך להוכיח כי <span class="math">\(\left[\left(q,\varepsilon\right),\varepsilon,\alpha\right]\vdash_{M^{\prime}}^{*}\left[\left(p,\varepsilon\right),\varepsilon,\beta\right]\)</span> אם ורק אם <span class="math">\(\left[q,\varepsilon,\alpha\right]\vdash_{M}^{*}\left[p,\varepsilon,\beta\right]\)</span> - זה נראה אולי טריוויאלי, אבל בעצם זה לא ממש טריוויאלי - זה אומר ש-<span class="math">\(M^{\prime}\)</span> מסמלץ כמו שצריך את מסעי ה-<span class="math">\(\varepsilon\)</span> של <span class="math">\(M\)</span>. רק כדי להוכיח את הטענה הזו נצטרך עוד אינדוקציה, על אורך החישוב. אבל למי יש כוח אז נעזוב את זה.</p>
<p>עכשיו, נניח נכונות עבור מילים מאורך <span class="math">\(n\)</span> ונוכיח עבור מילים מאורך <span class="math">\(n+1\)</span>. כאן ישתלם לנו לפרק חישובים לפי הצעד הראשון וכל מה שאחריו. כלומר, נניח ש-<span class="math">\(\left[\left(q,\varepsilon\right),aw,\alpha\right]\vdash_{M^{\prime}}^{*}\left[\left(p,\varepsilon\right),\varepsilon,\beta\right]\)</span> עבור מילה <span class="math">\(aw\)</span> כלשהי. מכיוון שבהתחלה החוצץ ריק, הצעד הראשון חייב להיות מהצורה 1. כלומר, אפשר לפרק את החישוב כך: <span class="math">\(\left[\left(q,\varepsilon\right),aw,\alpha\right]\vdash\left[\left(q,h\left(a\right)\right),w,\alpha\right]\vdash^{*}\left[\left(p,\varepsilon\right),\varepsilon,\beta\right]\)</span>. היינו רוצים להשתמש בהנחת האינדוקציה שלנו על <span class="math">\(\left[\left(q,h\left(a\right)\right),w,\alpha\right]\vdash^{*}\left[\left(p,\varepsilon\right),\varepsilon,\beta\right]\)</span>, אבל אי אפשר - כי הנחת האינדוקציה מתבססת על כך שהחוצץ ריק בקונפיגורציה השמאלית. לכן צריך להוכיח - שוב, באינדוקציה על אורך החישוב - ש-<span class="math">\(\left[\left(q,h\left(a\right),\varepsilon,\alpha\right)\right]\vdash_{M^{\prime}}^{*}\left[\left(p,\varepsilon\right),\varepsilon,\beta\right]\)</span> אם ורק אם <span class="math">\(\left[q,h\left(a\right),\alpha\right]\vdash_{M}^{*}\left[p,\varepsilon,\beta\right]\)</span>. זה לא עד כדי כך קשה, כי המעברים היחידים האפשריים כל עוד החוצץ לא התרוקן הם מעברי <span class="math">\(\varepsilon\)</span> (כי אין קלט). אחרי שסיימנו עם זה, ההמשך טבעי: נפרק את החישוב הראשוני שלנו לארבעה חלקים:</p>
<p><span class="math">\(\left[\left(q,\varepsilon\right),aw,\alpha\right]\vdash\left[\left(q,h\left(a\right)\right),w,\alpha\right]\vdash^{*}\left[\left(s,\varepsilon\right),w,\gamma\right]\vdash^{*}\left[\left(p,\varepsilon\right),\varepsilon,\beta\right]\)</span></p>
<p>ובעזרת טענות העזר והנחת האינדוקציה רואים שזה מתקיים אם ורק אם ב-<span class="math">\(M\)</span> מתקיים:</p>
<p><span class="math">\(\left[q,aw,\alpha\right]\vdash^{*}\left[s,w,\gamma\right]\vdash^{*}\left[p,\varepsilon,\beta\right]\)</span></p>
<p>כפי שרצינו.</p>
<p>בפוסט הבא נגיע אל מה שהוא סיום חומר הבסיס שבדרך כלל מציגים בנושאים הללו - בעיות הכרעה!</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_site/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>