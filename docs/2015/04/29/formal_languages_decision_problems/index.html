<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>בעיות הכרעה עבור שפות פורמליות - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2015/04/29/formal_languages_decision_problems/">
    <meta property="og:title" content="בעיות הכרעה עבור שפות פורמליות">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2015/04/29/formal_languages_decision_problems/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="בעיות הכרעה עבור שפות פורמליות">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2015/04/26/cf_languages_closure_properties/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">שפות חסרות הקשר - תכונות סגור</span>
            </a>
            

            
            <a href="/2015/05/07/automata_minimization/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">משפט מייהיל-נרוד - נקודת מבט נוספת, ואלגוריתמי מינימיזציה</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>בעיות הכרעה עבור שפות פורמליות</h1>
            <div class="post-meta">
                <span class="date">2015-04-29</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/בעיית ההתאמה של פוסט.html">בעיית ההתאמה של פוסט</a>
                    
                    <a href="/tags/שפות פורמליות.html">שפות פורמליות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>כל מה שעשיתי עד כה בפוסטים על שפות פורמליות היה, במובן מסויים, "בתוך" המודלים שהצגתי - זה של אוטומט סופי עבור שפות רגולריות, וזה של דקדוקים חסרי הקשר ואוטומטי מחסנית עבור שפות חסרות הקשר. כל הדברים שעשיתי נעשו בעזרת המודלים הללו. אבל זה לא מה שקורה בעולם האמיתי - בעולם האמיתי, כשאנחנו באים להתעסק עם שפה רגולרית, אנחנו עושים את זה באמצעות שפת התכנות החביבה עלינו, מה שאומר שיש לנו יכולת להשתמש באלגוריתמים כלליים (בלשון פורמלית תיאורטית - יש לנו <strong>מכונת טיורינג</strong>). האוטומט הסופי הוא עבורנו דרך<strong> לייצג</strong> את השפה, ואנחנו מסוגלים להריץ אלגוריתמים ומניפולציות <strong>עליו</strong> כדי להפיק מידע על השפה. בדברים הללו אנחנו הולכים להתעסק בפוסט הזה.</p>
<p>נניח ש-<span class="math">\(L\)</span> היא שפה פורמלית כלשהי (רגולרית או חסרת הקשר), אז הנה דברים שמעניין אותנו לדעת. האם <span class="math">\(L\)</span> ריקה? האם <span class="math">\(L\)</span> אינסופית? האם מילה <span class="math">\(w\)</span> ספציפית שייכת ל-<span class="math">\(L\)</span>? ונניח שנתונה שפה גם <span class="math">\(L^{\prime}\)</span>, האם <span class="math">\(L=L^{\prime}\)</span>?</p>
<p>לפני שניגשים לפתור את הבעיות הללו צריך להבין איך <span class="math">\(L\)</span> נתונה לנו בכלל. קלטים, במחשב, הם בסך הכל סדרה סופית של ביטים, שאנחנו מפענחים בצורה מסויימת. אנחנו צריכים ייצוג שהמחשב יודע לעבוד איתו, ולכן ייצוג של שפה באמצעות תיאור מילולי לא פורמלי ("<span class="math">\(L\)</span> היא שפת כל המילים מאורך זוגי מעל <span class="math">\(\left\{ a,b\right\} \)</span>") יהיה משהו שלמחשב יהיה קשה מאוד לעבוד איתו. אז בדרך כלל אנחנו מניחים שאם <span class="math">\(L\)</span> רגולרית היא נתונה לנו בעזרת אוטומט סופי <span class="math">\(A\)</span> (שמיוצג באופן דומה לזה שמייצגים בו גרף במחשב), ואם היא חסרת הקשר היא נתונה בעזרת דקדוק חסר הקשר <span class="math">\(G\)</span>. אפשר כמובן גם להציע דרכי תיאור אחרות, למשל ביטוי רגולרי; אבל אנחנו יודעים שאפשר להמיר כל ביטוי רגולרי לאוטומט מתאים, אז על פניו אנחנו לא מגבילים את הכלליות (כמובן שיש שאלה של סיבוכיות ההמרה של הביטוי הרגולרי לאוטומט וכדומה אבל לא אכנס לזה הפעם).</p>
<p>אני אנסה עכשיו לתת סיפור קונקרטי על משהו ספציפי אחד שיתן לנו תחושה כללית של למה מעניין לדבר על בעיות הכרעה, ומה הסכנות שצריך להיות מודעים להן. אני רוצה לדבר ספציפית על בעיית הריקנות של שפות רגולריות, בהקשר של <strong>אימות חומרה</strong>. אחת מהגישות שבהן נוקטים באימות חומרה היא מה שנקרא "בדיקות מודל" (Model Checking). בשיטה הזו, לוקחים רכיב חומרה כלשהו וממירים אותו לאוטומט סופי דטרמיניסטי; ה"מצבים" של האוטומט הם כל ההשמות האפשריות לרגיסטרים של רכיב החומרה (רגיסטר כאן הוא יחידת זכרון כלשהי שנמצאת בתוך הרכיב). ה"אותיות" שאותן קוראים הן ההשמות האפשריות לקלטים לרכיב החומרה הזה. אני לא אכנס להסברים יותר מפורטים כי זה ראוי לפוסט משל עצמו; השורה התחתונה היא שבסופו של דבר יש לנו ייצוג כלשהו של אוטומט שהמצבים שלו מתאימים למצבים שבהם הרכיב יכול להיות. עכשיו, אנחנו לרוב רוצים לבדוק תכונה כלשהי של הרכיב - למשל, "אם התקבל סיגנל של "בקשה", אז אחרי שלושה מחזורי שעון לכל היותר ייפלט סיגנל של "אישור". אחת הדרכים לעשות זאת היא כך: כותבים את הדרישה באמצעות לוגיקה פורמלית (נהוג להשתמש בסוג מסויים של לוגיקה טמפורלית לשם כך; זה נושא מעניין מאוד, כאמור). את הפסוק הלוגי הזה ממירים לאוטומט קטן שמצליח לתאר אותו בצורה כלשהי, ובונים מכפלה של האוטומט הקטן הזה יחד עם האוטומט שמתאר את כל המערכת. בסופו של דבר מתקבל אוטומט עם מצב מקבל יחיד, שכניסה אליו פירושו שהתכונה <strong>מופרת</strong>. עכשיו אנחנו לוקחים את האוטומט הזה ומריצים עליו בדיקת ריקנות. אם השפה של האוטומט ריקה, זה אומר שלא משנה מה הקלטים שהמעגל מקבל, התכונה שאנחנו בודקים לא מופרת בו; ואם השפה לא ריקה, אז כל מילה בה מהווה דוגמה נגדית לנכונות של התכונה, שעוזרת למתכנני המעגל להבין מה השתבש ומה לתקן.</p>
<p>זו דוגמה יפה מאוד, לטעמי, אבל היא גם שקר גדול, כי אלגוריתם הריקנות שאראה בהמשך לא יכול לטפל בה ביעילות. העניין הוא שהאוטומטים שנבנים באימות חומרה הם <strong>גדולים</strong>. ממש ממש גדולים. במובן זה שאוטומט עם <span class="math">\(2^{100}\)</span> מצבים הוא משהו לא חריג ואפילו לא גדול במיוחד. מן הסתם הייצוג שלנו של האוטומטים הללו הוא קומפקטי בצורה כלשהי, אבל אלגוריתמים שזמן הריצה שלהם הוא, למשל, לינארי במספר מצבי האוטומט יהיו חסרי ערך עבור אוטומט כזה. לכן משתמשים בשיטות אחרות, שהן יותר היוריסטיות באופיין ולא תמיד עובדות, אבל בפועל מספקות תוצאות טובות. אני לא הולך לדבר על זה בכלל בפוסט הזה.</p>
<p>אוקיי, בואו נעבור עכשיו לפתרון בעיות.</p>
<p>אם <span class="math">\(A\)</span> הוא אוטומט סופי דטרמיניסטי ונתונה לנו מילה כלשהי <span class="math">\(w\)</span>, אז אין דבר קל יותר מלבדוק אם <span class="math">\(w\in L\left(A\right)\)</span>: פשוט מבצעים סימולציה של ריצת <span class="math">\(A\)</span> על <span class="math">\(w\)</span> ובודקים אם הגענו למצב מקבל. אם <span class="math">\(A\)</span> אינו דטרמיניסטי אפשר לבצע לו דטרמיניזציה (להמיר אותו לאוטומט דטרמיניסטי; אדבר בפוסט אחר על איך עושים את זה יעיל יחסית), אבל גם אפשר להריץ אותו כמו שהוא על המילה, כשבמקום לזכור את המצב שבו אנחנו נמצאים כרגע, אנחנו זוכרים את קבוצת המצבים שבהם אנחנו נמצאים כרגע בכל הריצות האפשריות של האוטומט. כבר דיברתי על זה בשעתו.</p>
<p>עבור דקדוק חסר הקשר <span class="math">\(G\)</span> המצב קשה הרבה יותר. דקדוק שכזה הוא אי-דטרמיניסטי בצורה הרבה פחות נוחה - אם ננסה לבצע את כל הריצות האפשריות שלו ביחד נצטרך לזכור כמות הולכת וגדלה של דברים ונסתבך חיש קל. בעיה דומה תהיה גם אם ננסה לבצע את כל הריצות של אוטומט מחסנית - כמות התכנים האפשריים של המחסנית תלך ותגדל באופן לא בהכרח חסום. אז צריך לעשות משהו אחר. המשהו האחר הכללי הסטנדרטי נקרא אלגוריתם CYK ואתאר אותו בהמשך הפוסט, אחרי שנסיים עם הדברים הפשוטים.</p>
<p>נעבור אל בעיית הריקנות. כשחושבים על אוטומט בתור גרף, זו בעיה פשוטה למדי, כל עוד מספר מצבי האוטומט הוא סביר - אנחנו פשוט מבצעים אלגוריתם חיפוש רגיל בגרף (DFS או BFS) החל מהמצב ההתחלתי של האוטומט ובודקים אם אפשר להגיע אל מצב מקבל כלשהו. כאמור, אם יש יותר מדי מצבים באוטומט מכדי שאפשר יהיה לנקוט בגישה הזו אנחנו נזקקים לשיטות היוריסטיות מחוכמות יותר שלא אדבר עליהן פה.</p>
<p>ומה קורה בדקדוקים? המצב לא שונה בהרבה. האתגר פה הוא למצוא <strong>משתנים טרמינליים</strong> - משתנים שגוזרים מילה טרמינלית. למשתנים כאלו יש הגדרה רקורסיבית פשוטה: <span class="math">\(A\)</span> הוא טרמינלי אם קיים כלל גזירה <span class="math">\(A\to\alpha\)</span> כך ש-<span class="math">\(\alpha\)</span> מורכבת כולה מטרמינלים וממשתנים טרמינליים. הגדרה כזו נותנת לנו מייד אלגוריתם איטרטיבי למציאת כל המשתנים הטרמינליים: מתחזקים קבוצה <span class="math">\(X\)</span> של משתנים טרמינליים, שבהתחלה היא ריקה; בכל איטרציה עוברים על כל הגזירות <span class="math">\(A\to\alpha\)</span> בדקדוק ובודקים אם <span class="math">\(\alpha\in\left(X\cup T\right)^{*}\)</span>. אם כן, מוסיפים את <span class="math">\(A\)</span> ל-<span class="math">\(X\)</span>. ממשיכים כך עד שמגיעים לאיטרציה שבה לא התווסף כלום ל-<span class="math">\(X\)</span>, ואז מסיימים. עכשיו, כדי לבדוק אם שפת הדקדוק ריקה, פשוט בודקים אם <span class="math">\(S\)</span> טרמינלי או לא.</p>
<p>נעבור לבעיית האינסופיות. מתי שפה של אוטומט היא אינסופית? ובכן, ברור שאם יש בשפה מילה שאפשר "לנפח" על פי למת הניפוח לשפות רגולריות אז השפה אינסופית כי היא כוללת את אינסוף הניפוחים של המילה. מתי מילה כזו קיימת באוטומט? כאשר יש ריצה על מילה ששייכת לשפה שמגיעה לאותו מצב פעמיים. אם ננסה לזקק מזה את המהות, נגיע לאבחנה הבאה: אם קיים בגרף של האוטומט מעגל שהוא מצד אחד ישיג מתוך המצב ההתחלתי, ומצב שני יש מצב מקבל שישיג ממנו - אז שפת האוטומט אינסופית. קל לראות שגם הכיוון ההפוך נכון, כי אם שפת האוטומט אינסופית יש בה מילים גדולות כרצוננו, ולכן תהיה מילה שאפשר להפעיל עליה את למת הניפוח.</p>
<p>עבור דקדוקים חסרי הקשר הסיטואציה דומה, אבל צריך להיות קצת יותר זהירים. אנחנו עדיין רוצים, באופן בסיסי, לחפש מעגל בגרף. נבנה גרף שצמתיו הם המשתנים של הדקדוק ויש קשת מ-<span class="math">\(A\)</span> אל <span class="math">\(B\)</span> אם קיימת בדקדוק גזירה <span class="math">\(A\to\alpha B\beta\)</span>. מעגל בגרף הזה פירושו שיש לנו משתנה שגוזר את עצמו: <span class="math">\(A\Rightarrow^{*}\gamma A\delta\)</span>. אבל גם אם מצאנו סיטואציה כזו, זה עדיין לא מבטיח לנו אינסוף מילים בשפה - אנחנו צריכים לדעת ש-<span class="math">\(A\)</span> מסוגל לגזור מילה טרמינלית (אחרת חישוב ש-<span class="math">\(A\)</span> משתתף בו לא הולך לייצר מילים בכלל), וש-<span class="math">\(\left|\gamma\delta\right|\ge1\)</span> (אחרת <span class="math">\(A\)</span> עשוי לגזור את עצמו שוב ושוב, אבל זה החישוב איתו ייצר רק מילה אחת). כדי להבטיח את אלו, אנחנו מראש מבטיחים שהדקדוק שלנו הוא "נקי" - מעיפים ממנו משתנים טרמינליים, וגם מסלקים ממנו כללי יחידה כמו <span class="math">\(A\to B\)</span> וכללים מהצורה <span class="math">\(A\to\varepsilon\)</span>, כך שאנו מבטיחים שכל גזירה <span class="math">\(A\to\alpha B\beta\)</span> היא כזו שגם מייצרת מסביב ל-<span class="math">\(B\)</span> משהו שהולך להפוך לטרמינלים בסופו של דבר. זו המחשה טובה לכך שנוח הרבה יותר להפעיל אלגוריתמים אם אפשר להניח שהדקדוק שפועלים עליו עבר פישוט מתאים.</p>
<p>בואו נעבור עכשיו למי שהיא אולי הבעיה המרתקת ביותר מבין כל בעיות ההכרעה שאדבר עליהן בפוסט הזה - בעיית השקילות. נתונים שני אוטומטים <span class="math">\(A_{1},A_{2}\)</span> ואנחנו רוצים לדעת האם <span class="math">\(L\left(A_{1}\right)=L\left(A_{2}\right)\)</span>. זה לחלוטין לא טריוויאלי. חשבו על סיטואציה שבה אנחנו רוצים לבנות רכיב חומרה; מצד אחד, יש לנו מודל <span class="math">\(A_{1}\)</span> מאוד פשוט של הרכיב שמתאר את הפונקציה שהוא צריך לחשב, אבל ייתכן מאוד שמכל בחינה מעשית, המימוש של הרכיב הוא מאוד לא יעיל (מבחינת מספר שערים; מיקום שערים; צריכת חשמל; זמן ביצוע החישוב ועוד אינסוף שיקולים מורכבים שמהנדסי חומרה חייבים להתחשב בהם). מצד שני, יש לנו מימוש בפועל <span class="math">\(A_{2}\)</span> שמהנדס חומרה עבד עליו מאוד קשה, אבל לכו תדעו עד אם הוא לא פספס משהו ואם אין באגים וכדומה. ועכשיו תחשבו שבלחיצת כפתור היה אפשר לבדוק אם <span class="math">\(A_{1}\)</span> שקול ל-<span class="math">\(A_{2}\)</span>. זה סוג הקושי שמדובר עליו כאן. עבור תוכניות מחשב כלליות זה פשוט לא עובד - אין אלגוריתם שמסוגל לבדוק אם שתי תוכניות מחשב הן שקולות. אבל עבור אוטומטים זה כן עובד, ואפילו עובד בצורה פשוטה להחריד, מבחינה רעיונית (מבחינת החישוב - שוב, זה ייקח יותר מדי זמן בפועל בסיטואציות אמיתיות של בדיקת רכיבי חומרה, אבל זה לא אומר שזה לא מועיל בהקשרים אחרים).</p>
<p>איך אנחנו עושים את הקסם הזה? פשוט מאוד - רדוקציה לבעיה של בדיקת ריקנות. אם <span class="math">\(L_{1}=L\left(A_{1}\right)\)</span> ו-<span class="math">\(L_{2}=L\left(A_{2}\right)\)</span>, נבנה אוטומט עבור <strong>ההפרש הסימטרי</strong> של <span class="math">\(L_{1}\)</span> ו-<span class="math">\(L_{2}\)</span> - אוסף המילים ששייכות לשפה אחת אבל לא לשניה. מן הסתם ההפרש הסימטרי ריק אם ורק אם השפות שוות. פורמלית, ההפרש הסימטרי הוא <span class="math">\(\left(L_{1}\backslash L_{2}\right)\cup\left(L_{2}\backslash L_{1}\right)=\left(L_{1}\cap\overline{L_{2}}\right)\cup\left(L_{2}\cap\overline{L_{1}}\right)\)</span>, ואלו תכונות סגור; בפועל פשוט בונים אוטומט מכפלה עם מצבים מקבלים <span class="math">\(\left(F_{1}\times\left(Q_{2}\backslash F_{2}\right)\right)\cup\left(\left(Q_{1}\backslash F_{1}\right)\times F_{2}\right)\)</span>.</p>
<p>האם אפשר לעשות משהו דומה עבור שפות חסרות הקשר? ובכן, התשובה היא חד משמעית <strong>לא</strong>. לא קיים אלגוריתם שבודק שקילות של שני דקדוקים חסרי הקשר. אבל למה? איך מוכיחים את זה? כאן אני חייב לגלוש קצת לתורה של בעיות לא כריעות. ספציפית, אני אציג בעיה לא כריעה אחת שבעזרתה אוכיח שהבעיות הקשורות לדקדוקים אינן כריעות. הבעיה הזו נקראת "בעיית ההתאמה של פוסט" ובקיצור PCP ויש לי עליה <a href="http://www.gadial.net/2014/04/14/post_correspondence_problem/">פוסט ייעודי</a> שגם מוכיח שהיא לא כריעה. בפוסט הזה לא רק שלא אוכיח שהבעיה הזו לא כריעה, אלא גם לא אכנס לתיאור עמוק שלה, אלא ההפך - אציג ניסוח שקול שלה שהוא מאוד פשוט אבל עושה שימוש בטרמינולוגיה שאנחנו כבר מכירים ולא הנחתי אותה בפוסט ההוא. בניסוח שלי, בעיית ההתאמה של פוסט היא הדבר הבא: נתון לנו אלפבתים סופיים <span class="math">\(\Sigma\)</span> ו-<span class="math">\(\Delta\)</span> ונתונים שני הומומורפיזמים <span class="math">\(h:\Sigma\to\Delta^{*}\)</span> ו-<span class="math">\(g:\Sigma\to\Delta^{*}\)</span>. השאלה: האם קיימת מילה <span class="math">\(w\in\Sigma^{*}\)</span> כך ש-<span class="math">\(h\left(w\right)=g\left(w\right)\)</span>? וזו, כאמור, בעיה לא כריעה.</p>
<p>כעת, בואו נתעסק בבעיה הבאה: נתונות שתי שפות חסרות הקשר <span class="math">\(L_{1},L_{2}\)</span> (נתונות באמצעות דקדוקים, כרגיל). האם <span class="math">\(L_{1}\cap L_{2}=\emptyset\)</span>? כלומר, האם יש מילה משותפת כלשהי לשתי השפות? אני אראה שאם אנחנו יודעים לפתור את הבעיה הזו באופן כללי, אז אנו גם יודעים לפתור את PCP. הרדוקציה היא פשוטה מאוד, למעשה - קחו רגע וראו אם תצליחו לחשוב עליה.</p>
<p>האלפבית שמעליו השפות שלו יוגדר יסומן בתור <span class="math">\(\Gamma=\Sigma\cup\Delta\)</span>, כלומר הוא כולל גם את האותיות של <span class="math">\(\Sigma\)</span> וגם של <span class="math">\(\Delta\)</span>, ואני אניח בלי הגבלת הכלליות ש-<span class="math">\(\Sigma\cap\Delta=\emptyset\)</span>. עכשיו, אגדיר <span class="math">\(L_{1}=\left\{ w\#w^{R}\ |\ w\in\Gamma^{*}\right\} \)</span> (אני מניח ש-<span class="math">\(\#\notin\Gamma\)</span>) - מה שנקרא "שפת ראי מסומנת". קל לראות שזו שפה חסרת הקשר - כללי הדקדוק הם פשוט <span class="math">\(\left\{ S\to\sigma S\sigma\ |\ \sigma\in\Gamma\right\} \cup\left\{ S\to\#\right\} \)</span>. עכשיו, נגדיר את <span class="math">\(L_{2}\)</span> כך: <span class="math">\(L_{2}=\left\{ u^{R}h\left(u\right)\#\left(v^{R}g\left(v\right)\right)^{R}\ |\ u,v\in\Sigma^{*}\right\} \)</span>. גם זו שפה חסרת הקשר, וקל לראות את זה עם תכונות סגור. ראשית, <span class="math">\(L=\left\{ w^{R}w^{\prime}\ |\ w\in\Sigma^{*}\right\} \)</span> היא שפה חסרת הקשר עם דקדוק <span class="math">\(S\to\sigma S\sigma^{\prime}|\varepsilon\)</span>. שנית, נפעיל על <span class="math">\(L\)</span> הומומורפיזם שעל אותיות ללא תג מחזיר את עצמן, ועל אותיות עם תג מחזיר את מה ש-<span class="math">\(h\)</span> מחזירה על האות ללא תג, ונקבל את השפה <span class="math">\(\left\{ w^{R}h\left(w\right)\ |\ w\in\Sigma^{*}\right\} \)</span>. לבסוף נשרשר עם השפה הזו עם השפה שמכילה רק את <span class="math">\(\#\)</span> ואת זה עם השפה שעליה עשינו את אותו תעלול רק עם <span class="math">\(g\)</span>.</p>
<p>קחו רגע לשכנע את עצמכם שאכן <span class="math">\(L_{1}\cap L_{2}\ne\emptyset\)</span> אם ורק אם קיים <span class="math">\(w\)</span> כך ש-<span class="math">\(h\left(w\right)=g\left(w\right)\)</span>; זה מסיים את ההוכחה.</p>
<p>עכשיו, בעזרת כללי דה-מורגן נקבל ש-<span class="math">\(L_{1}\cap L_{2}\ne\emptyset\)</span> אם ורק אם <span class="math">\(\overline{L_{1}}\cup\overline{L_{2}}\ne\Sigma^{*}\)</span>. באופן כללי דבר כזה לא יעזור לנו במיוחד, כי זה ש-<span class="math">\(L_{1},L_{2}\)</span> הן חסרות הקשר לא אומר שגם המשלימות שלהן כאלו, אבל במקרה שלנו זה דווקא נכון. אולי הדרך הקלה ביותר לראות זאת היא באמצעות האבחנה שאת <span class="math">\(L_{1},L_{2}\)</span> אפשר לקבל עם אוטומט מחסנית דטרמיניסטי (מושג שטרם הגדרתי), אבל אפשר גם סתם לחשוב כמה דקות על איך לבנות אוטומטי מחסנית שמקבלים את <span class="math">\(\overline{L_{1}},\overline{L_{2}}\)</span>.</p>
<p>המסקנה? אם <span class="math">\(\overline{L_{1}},\overline{L_{2}}\)</span> הן חסרות הקשר כך גם <span class="math">\(\overline{L_{1}}\cup\overline{L_{2}}\)</span>, ולכן קיבלנו שהבעיה הבאה אינה כריעה: בהינתן שפה חסרת הקשר <span class="math">\(L\)</span>, יש לבדוק האם <span class="math">\(L=\Sigma^{*}\)</span>. הבעיה הזו מכונה "בעיית האוניברסליות". העובדה שהיא לא כריעה מראה מייד שגם בדיקת שקילות של דקדוקים היא בעיה לא כריעה - כי אם בהינתן <span class="math">\(G_{1},G_{2}\)</span> היינו יכולים לבדוק האם <span class="math">\(L\left(G_{1}\right)=L\left(G_{2}\right)\)</span> היינו פותרים את בעיית האוניברסליות על ידי בדיקת שקילות לדקדוק שאנחנו יודעים שמייצר את <span class="math">\(\Sigma^{*}\)</span>. בעיה נוספת שמייד רואים שהיא לא כריעה היא בעיית ההכלה: בהינתן <span class="math">\(L_{1},L_{2}\)</span>, אם הייתה לנו דרך לבדוק האם <span class="math">\(L_{1}\subseteq L_{2}\)</span> היינו יכולים לפתור את בעיית האוניברסליות על ידי בדיקה האם <span class="math">\(\Sigma^{*}\subseteq L\)</span> (או לחילופין, היינו יכולים לבדוק האם <span class="math">\(L_{1}=L_{2}\)</span> על ידי בדיקה האם <span class="math">\(L_{1}\subseteq L_{2}\)</span> וגם <span class="math">\(L_{2}\subseteq L_{1}\)</span>).</p>
<p>חוב אחד שלי שעדיין נשאר מפוסט קודם הוא השאלה האם בהינתן דקדוק <span class="math">\(G\)</span> ניתן לקבוע אם הוא חד משמעי, או שקיימת מילה שקיימים לה שני עצי גזירה. בעיית ההתאמה של פוסט יכולה להיפתר גם על ידי אלגוריתם כזה: בהינתן <span class="math">\(h,g\)</span> נבנה את הדקדוק <span class="math">\(G\)</span> הבא: <span class="math">\(S\to A|B\)</span> ו-<span class="math">\(A\to\sigma Ah\left(\sigma\right)|\varepsilon\)</span> ו-<span class="math">\(B\to\sigma Bg\left(\sigma\right)|\varepsilon\)</span>. הדקדוק הזה מייצר מילים מהצורה <span class="math">\(w^{R}h\left(w\right)\)</span> ו-<span class="math">\(w^{R}g\left(w\right)\)</span>. כל מילה מהצורה <span class="math">\(w^{R}h\left(w\right)\)</span> נוצרת בצורה יחידה (ה-<span class="math">\(w^{R}\)</span> שבהתחלה מבטיח את זה) וכך גם עבור <span class="math">\(w^{R}g\left(w\right)\)</span>; לכן הסיכוי היחיד של הדקדוק להיות רב-משמעי הוא שיתקיים <span class="math">\(w^{R}h\left(w\right)=w^{R}g\left(w\right)\)</span> עבור <span class="math">\(w\)</span> כלשהו, מה שגורר <span class="math">\(h\left(w\right)=g\left(w\right)\)</span>.</p>
<p>אם כן, אלו היו שלל בעיות הכרעה לא כריעות, וכעת אני רוצה לחזור ולסיים בנימה אופטימית - אלגוריתם CYK שבודק בהינתן <span class="math">\(w\)</span> האם <span class="math">\(w\in L\)</span> עבור שפה חסרת הקשר <span class="math">\(L\)</span> כלשהי.</p>
<p>נתחיל מזה שלא סתם לוקחים דקדוק כלשהו עבור <span class="math">\(L\)</span> - לוקחים דקדוק <span class="math">\(G\)</span> בצורה הנורמלית של חומסקי, שכבר הזכרתי בעבר ואזכיר שוב - בצורה הנורמלית הזו כל כללי הגזירה בדקדוק הם מהצורה <span class="math">\(A\to a\)</span> או <span class="math">\(A\to BC\)</span>. לכל שפה חסרת הקשר <span class="math">\(L\)</span> קיים דקדוק בצורה הנורמלית של חומסקי שמקיים <span class="math">\(L\left(G\right)=L\backslash\left\{ \varepsilon\right\} \)</span> (כלומר, אם המילה הריקה הייתה שייכת ל-<span class="math">\(L\)</span>, אז הדקדוק לא ידע לייצר אותה כי הצורה הנורמלית של חומסקי לא מאפשרת את זה). זה אומר שאם אנחנו רוצים לבדוק אם <span class="math">\(\varepsilon\in L\)</span> צריך לבדוק באמצעות אלגוריתם אחר, אבל זה יחסית קל (זה שקול לבדיקה האם המשתנה <span class="math">\(S\)</span> <strong>אפיס</strong>, כלומר יש לו סדרת גזירה שמסתיימת ב-<span class="math">\(\varepsilon\)</span>, וזו בדיקה דומה לבדיקה האם משתנה הוא טרמינלי).</p>
<p>אם כן, אנו מניחים ש-<span class="math">\(w\)</span> הוא מאורך 1 לפחות. והנה הרעיון של האלגוריתם: אם <span class="math">\(A\Rightarrow^{*}w\)</span> אז מתקיים בדיוק אחד משני דברים - או ש-<span class="math">\(\left|w\right|\)</span> מאורך 1 וקיימת גזירה <span class="math">\(A\to w\)</span> בדקדוק; או שקיים פירוק <span class="math">\(w=uv\)</span> וגזירה <span class="math">\(A\to BC\)</span> כך ש-<span class="math">\(B\Rightarrow^{*}u\)</span> וגם <span class="math">\(C\Rightarrow^{*}v\)</span>. על בסיס האבחנה הזו אפשר לתת אלגוריתם רקורסיבי שבודק את התנאי הזה, על ידי בדיקת כל הפירוקים האפשריים של <span class="math">\(w\)</span> מהצורה <span class="math">\(w=uv\)</span>, ועם תנאי עצירה עבור הסיטואציה שבה <span class="math">\(\left|w\right|=1\)</span>.</p>
<p>רק מה, האלגוריתם הרקורסיבי הזה עשוי לעשות עבודה כפולה, ולא מעט ממנה. לכן אנחנו נוקטים בגישה שמכונה <strong>תכנון דינמי</strong>, והיא בעצם שם מפוצץ ל"תזכור את תוצאות חישובי הביניים שלך ותשתמש בהן שוב אם צריך". לצורך כך, בואו נניח ש-<span class="math">\(w=\sigma_{1}\sigma_{2}\dots\sigma_{n}\)</span>. כעת אפשר לתאר תת-מילים של <span class="math">\(w\)</span> באמצעות שני מספרים טבעיים - האורך שלה <span class="math">\(l\)</span>, והאינדקס שבו היא מתחילה <span class="math">\(i\)</span>. כעת אגדיר משתנים בוליאניים <span class="math">\(P_{l,i}^{\left(A\right)}\)</span> שהרעיון הוא שהם יקבלו "אמת" אם ורק אם <span class="math">\(A\Rightarrow^{*}\sigma_{i}\sigma_{i+1}\dots\sigma_{i+\left(l-1\right)}\)</span>. אם <span class="math">\(S\)</span> הוא המשתנה ההתחלתי של הדקדוק, הרי שהשאלה האם <span class="math">\(w\in L\)</span> זהה לשאלה אם <span class="math">\(P_{n,1}^{\left(S\right)}\)</span> הוא "אמת", אז מה שאנחנו רוצים הוא אלגוריתם לחישוב ה-<span class="math">\(P\)</span>-ים הללו.</p>
<p>לא אתן כאן פסאודו-קוד מלא של האלגוריתם (אבל למי שזה מעניין אותו אני ממליץ לתכנת אותו), אבל הרעיון הכללי פשוט: ראשית נותנים את הערך "שקר" לכל ה-<span class="math">\(P\)</span>-ים. כעת עוברים על כל הגזירות מהצורה <span class="math">\(A\to a\)</span> בדקדוק ומשנים את <span class="math">\(P_{1,i}^{\left(A\right)}\)</span> ל"אמת" לכל אינדקס <span class="math">\(i\)</span> כך ש-<span class="math">\(\sigma_{i}=a\)</span>. זה תנאי ההתחלה שלנו.</p>
<p>עכשיו, לכל <span class="math">\(1<r\le n\)</span> באופן סדרתי, ולכל משתנה <span class="math">\(A\)</span>, ולכל <span class="math">\(1\le i\le n-r\)</span> אנחנו רוצים לחשב מהו <span class="math">\(P_{r,i}^{\left(A\right)}\)</span> - כלומר, האם <span class="math">\(A\)</span> יודע לגזור את תת-המילה <span class="math">\(\sigma_{i}\sigma_{i+1}\dots\sigma_{i+\left(r-1\right)}\)</span>. לצורך כך אנחנו עוברים על כל הגזירות מהצורה <span class="math">\(A\to BC\)</span> של המשתנה <span class="math">\(A\)</span>; כעת, לכל אינדקס <span class="math">\(i\le j<n-r\)</span> אנחנו בודקים האם שני המשתנים <span class="math">\(P_{j-i+1,i}^{\left(B\right)}\)</span> ו-<span class="math">\(P_{n-r-j,j+1}^{\left(C\right)}\)</span> הם "אמת" בו זמנית - אם כן, אז הופכים את <span class="math">\(P_{r,i}^{\left(A\right)}\)</span> לאמת בעצמו. זה הסוף.</p>
<p>מה הסיבוכיות של האלגוריתם? מכיוון שכל <span class="math">\(P\)</span> מחושב בדיוק פעם אחת, הקריאה ה"רקורסיבית" שדיברתי עליה לא באה לידי ביטוי באלגוריתם כלל (האלגוריתם הוא למעשה איטרטיבי, לא רקורסיבי). זה אומר שצריך בעיקר לבדוק כמה לולאות יש בו. שאלה אחרת היא <strong>ביחס למה</strong> מודדים את הסיבוכיות - כאן יש שני גורמים שונים. אחד הוא אורך המילה <span class="math">\(w\)</span>, שסימנו <span class="math">\(n\)</span>, והשני הוא גודל הדקדוק <span class="math">\(\left|G\right|\)</span> (למשל, מספר כללי הגזירה שלו).</p>
<p>ובכן, אנחנו עוברים על כל ה"רמות" של ה-<span class="math">\(P\)</span>-ים, החל מ-<span class="math">\(r=1\)</span> ועד <span class="math">\(r=n\)</span>, כך שזו לולאה אחת מאורך <span class="math">\(n\)</span>; בכל מעבר כזה, אנחנו עוברים על כל ה-<span class="math">\(i\)</span>-ים בתחום מ-1 ועד <span class="math">\(n-r\)</span> - זו לולאה שניה שמספר האיטרציות בה חסום על ידי <span class="math">\(n\)</span>. כעת אנחנו עוברים על כל הגזירות הקיימות בדקדוק לכל המשתנים - חסום על ידי <span class="math">\(\left|G\right|\)</span>, ולכל גזירה כזו אנו מבצעים בדיקה שתלויה בבחירה של האינדקס <span class="math">\(i\le j<n-r\)</span> - גם כן חסום על ידי <span class="math">\(n\)</span>. קיבלנו זמן ריצה של <span class="math">\(O\left(n^{3}\left|G\right|\right)\)</span>. שזה לא רע, גם אם לא נפלא כמו זמן הריצה <span class="math">\(O\left(n\right)\)</span> של אוטומט סופי דטרמיניסטי על מילה. כמובן, במרבית היישומים הפרקטיים זה לא מספיק טוב, ומשתמשים באלגוריתמים פחות כלליים שמותאמים לדקדוקים יותר ספציפיים ויעילים - אבל זה נושא לדיון כשמדברים על פרסור שפות חסרות הקשר (למשל, בקומפילציה).</p>
<p>סיימנו! לטעמי עם הפוסט הזה גמרתי לכסות את נושאי הבסיס שבדרך כלל מציגים כמבוא לתורת השפות הפורמליות (אם כי דילגתי על דברים פה ושם - למשל צורות נורמליות). עם זאת, אני עדיין לא רוצה להיפרד; בפוסטים הבאים אדבר קצת על נושאים מתוחכמים יותר, ואחזור למשפטים קיימים ואתן להם הרחבות ועוד נקודות מבט. לדעתי החלק המגניב באמת רק מתחיל.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>