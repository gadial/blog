<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט קוק-לוין - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2015/07/23/cook_levin_theorem/">
    <meta property="og:title" content="משפט קוק-לוין">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2015/07/23/cook_levin_theorem/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="משפט קוק-לוין">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2015/07/09/the_boy_and_the_museum/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">התעלומה המסתורית של הנער המבריק, יחס הזהב והנוסחה השגויה במוזיאון</span>
            </a>
            

            
            <a href="/2015/08/19/multivariable_derivative_properties/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">אנליזה וקטורית - תכונות בסיסיות של הנגזרת</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט קוק-לוין</h1>
            <div class="post-meta">
                <span class="date">2015-07-23</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/NP-שלמות.html">NP-שלמות</a>
                    
                    <a href="/tags/משפט קוק-לוין.html">משפט קוק-לוין</a>
                    
                    <a href="/tags/שאלת P=NP.html">שאלת P=NP</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>חור מטריד שקיים בבלוג ואני מתכוון להשלים כעת הוא תיאור והוכחה של אחד מהמשפטים הבסיסיים והחשובים ביותר בתורת הסיבוכיות - משפט קוק-לוין. אף שכבר תיארתי את הבסיס לתורת הסיבוכיות בעבר, וגם הראיתי תוצאות מסובכות יותר מקוק-לוין, איכשהו המשפט הזה חמק ממני והגיע הזמן להשלים את החסר. בפוסט הזה לא רק אתאר את המשפט ואת הרקע שלו אלא גם אתאר את כל ההוכחה; מכיוון שזה לרוב המשפט בעל ההוכחה המסובכת ביותר שסטודנטים נתקלים בו בקורס המבוא לנושאים הללו, אני מקווה שהפוסט יתגלה כמועיל למדי. אני בעיקר רוצה להבהיר שההוכחה הזו <strong>אינה</strong> קשה ו<strong>אינה</strong> מפחידה כפי שהרושם הראשון שלה עשוי להצטייר (בפעם הראשונה שבה ראיתי הוכחה לא הבנתי כלום).</p>
<p>קל מאוד לנסח את המשפט: "השפה SAT היא NP-שלמה". אני מניח שאתם מכירים את המושגים הללו, כי אין טעם לקרוא ישר על משפט קוק-לוין בלי להכיר אותם, ובכל זאת תזכורת קטנה למי ששמע את המושגים ואין לו כוח לחזור עליהם: אנחנו מתעסקים פה ב<strong>בעיות הכרעה</strong> של <strong>שפות פורמליות</strong>, כלומר בהינתן מחרוזת <span class="math">\(w\)</span> כלשהי אנחנו שואלים האם היא שייכת או לא לקבוצה <span class="math">\(L\)</span> - קבוצה כזו נקראת "שפה".</p>
<p>השפה SAT היא דוגמה אחת לשפה שכזו, מאוד מעניינת: המחרוזות ששייכות אליה מקודדות פסוקים מתחשיב הפסוקים, שהם מהצורה הנורמלית CNF. כלומר, כל פסוק הוא מהצורה <span class="math">\(\varphi=C_{1}\wedge C_{2}\wedge\dots\wedge C_{n}\)</span> כך שכל <span class="math">\(C_{i}\)</span> כזו נקראת <strong>פסוקית</strong> והיא מהצורה <span class="math">\(C=\left(l_{1}\vee l_{2}\vee\dots\vee l_{k}\right)\)</span> כאשר כל <span class="math">\(l_{j}\)</span> כזה נקרא <strong>ליטרל</strong> והוא או משתנה או שלילה של משתנה (או מהצורה <span class="math">\(x\)</span> או מהצורה <span class="math">\(\neg x\)</span> עבור משתנה <span class="math">\(x\)</span> כלשהו). שימו לב שמספר הליטרלים בכל פסוקית יכול להיות שונה; פסוק CNF פשוט לדוגמה הוא <span class="math">\(\left(x\vee\neg y\right)\wedge\left(\neg x\vee y\vee z\right)\)</span>.</p>
<p>פסוק CNF נקרא ספיק אם קיימת השמה של <strong>ערכי אמת</strong> למשתנים שלו שמספקת אותו. כדי לספק פסוק CNF צריך לספק בו זמנית את <strong>כל</strong> הפסוקיות שלו; כדי לספק פסוקית צריך לספק <strong>לפחות</strong> ליטרל אחד. כדי לספק משתנה צריך להציב בו את הערך True, וכדי לספק שלילה של משתנה צריך להציב באותו משתנה את הערך False. זה הכל. בפועל אני מייצג את True ו-False בעזרת 1 ו-0, בהתאמה.</p>
<p>הבעיה של הכרעה האם פסוק CNF כלשהו שייך ל-SAT היא בעיה קשה, מבחינה חישובית: אם יש לפסוק <span class="math">\(n\)</span> משתנים בסך הכל (פזורים לכל רוחב הפסוקיות שלו, לפעמים עם שלילה) אז יש <span class="math">\(2^{n}\)</span> השמות אפשריות לפסוק, ולעבור אחת אחת ולבדוק את כולן - זה פתרון שהוא לא <strong>יעיל מבחינה חישובית</strong>. זה לא אומר שאין שיטות מתוחכמות יותר, אבל אין שיטה שמבטיחה תמיד, גם במקרה הגרוע ביותר, זמן ריצה שנחשב "יעיל" (פולינומי). עם זאת, ל-SAT יש גם תכונה נחמדה מאוד: אם נתון לכם פסוק <span class="math">\(\varphi\)</span> שאכן שייך ל-SAT, אז אפשר <strong>לשכנע</strong> אתכם יחסית בקלות בכך אם נותנים לכם <strong>הוכחה</strong> מתאימה לכך - במקרה הזה, ה"הוכחה" היא פשוט השמה מספקת עבור הפסוק; אתם בודקים בעצמכם שההשמה אכן מספקת ולא מרמים אתכם, ואם היא מספקת, השתכנעתם שהפסוק שייך ל-SAT.</p>
<p>הרעיון הזה, של שפות שקל <strong>לבדוק הוכחה</strong> לשייכות של מילה אליהן מגדיר את המחלקה NP. פורמלית, <span class="math">\(L\in\text{NP}\)</span> אם קיים <strong>מוודא</strong> שהוא מכונת טיורינג פולינומית (אחזור על הפורמליזם שמגדיר מכונות טיורינג בהמשך, כשאזדקק לכך) <span class="math">\(M\)</span> כך ש-<span class="math">\(M\)</span> רצה על <strong>זוג</strong> קלטים, <span class="math">\(x,y\)</span>; הרעיון הוא ש-<span class="math">\(x\)</span> הוא המילה שאת שייכותה ל-<span class="math">\(L\)</span> בודקים, ו-<span class="math">\(y\)</span> הוא "הצעת הוכחה" לשייכות הזו. זמן הריצה הפולינומי של <span class="math">\(M\)</span> נמדד רק ביחס ל-<span class="math">\(x\)</span>, או לחילופים דורשים שהגודל של <span class="math">\(y\)</span> יהיה פולינומי בגודל של <span class="math">\(x\)</span>, אחרת במקום "הוכחה" היינו יכולים פשוט לדחוף <span class="math">\(y\)</span> ג'יברישי ארוך מאוד ובכך לאפשר ל-<span class="math">\(M\)</span> לרוץ המון זמן ולבדוק את שייכות <span class="math">\(x\)</span> לשפה באופן ישיר, מה שכמובן מפספס את הפואנטה. עכשיו, אם <span class="math">\(x\in L\)</span> הדרישה שלנו היא ש<strong>קיים <span class="math">\(y\)</span> </strong>כך ש-<span class="math">\(M\)</span> מסיימת את ריצתה על הזוג <span class="math">\(x,y\)</span> ואומרת "כן", ואילו אם <span class="math">\(x\notin L\)</span> אז <strong>לכל</strong> <span class="math">\(y\)</span>, <span class="math">\(M\)</span> תסיים את ריצתה על <span class="math">\(x,y\)</span> עם אמירת "לא". שימו לב לחוסר הסימטריה פה ("קיים" אל מול "לכל"). זו כל ההגדרה. יש הגדרה שקולה, שמדברת על מכונת טיורינג אי דטרמיניסטית (וגם את ההגדרה שלי אפשר לנסח בצורה שונה, בעזרת יחסים) אבל אני לא אכנס לזה כרגע - ההוכחה שלי תהיה עבור ההגדרה שנתתי, והוכחות אחרות הן אותו הדבר בערך.</p>
<p>שפות ב-NP יש המון. המון המון המון. עשרות אלפי בעיות מעניינות במדעי המחשב הן בעלות התכונה היפה של NP. ולכן היה מעניין, במידת מה, לגלות שיש שפה ב-NP שמסוגלת <strong>לקודד את כולן</strong>. השפה הזו הייתה SAT, וזה התוכן של משפט קוק-לוין. למה אני מתכוון ב"לקודד"? בואו ניקח שפה <span class="math">\(L\in\text{NP}\)</span> כלשהי; הטענה היא שלכל <span class="math">\(x\)</span> (בין אם הוא ב-<span class="math">\(L\)</span> ובין אם לאו) ניתן לבנות בזמן יעיל (פולינומי) פסוק CNF <span class="math">\(\varphi_{x}\)</span> כך ש-<span class="math">\(\varphi_{x}\in\text{SAT}\)</span> אם ורק אם <span class="math">\(x\in L\)</span>. לבניה כזו קוראים <strong>רדוקציה</strong> פולינומית. לכן, ניסוח אחר למשפט קוק-לוין הוא: SAT היא בעלת התכונה שכל שפה ב-NP ניתנת לרדוקציה פולינומית אליה. שפה עם תכונה שכזו נקראת NP-קשה; השם "NP-שלמה" בא להעיד על כך שזו שפה שהיא גם NP-קשה וגם שייכת בעצמה ל-NP.</p>
<p>את המשפט פרסם סטיבן קוק בארה"ב ב-1971. ב-1973 התפרסמה בבריה"מ גרסה אחרת של המשפט שהוכיח לאוניד לוין. זו הייתה אחת מתופעות הלוואי העגומות של המלחמה הקרה - תורת הסיבוכיות התפתחה בארה"ב ובברה"מ באופן בלתי תלוי, וגם הזמנים המדויקים לא ברורים לי (לוין כנראה הוכיח את המשפט הרבה לפני 1973). הניסוח של לוין היה שונה ומה שאני מציג הוא את הניסוח של קוק; אבל מה שלוין עשה עדיין תפס את לב העניין ולכן אני מעדיף לקרוא למשפט על שם שניהם.</p>
<p>משפט קוק היה אמנם מעניין, אבל על פניו הוא לא הוכיח משהו מרגש במיוחד - ניתן ללא קושי מהותי לייצר שפה מלאכותית שהיא NP-שלמה. אבל זה לב העניין - זו תהיה שפה מלאכותית ולא מעניינת, וההוכחה תהיה פשוטה בהתאם. לעומת זאת, קוק תפס שפה חשובה ושימושית, אבל לאף אחד כנראה לא היה ברור <strong>עד כמה</strong> היא שימושית עד שריצ'ארד קארפ בא בשנת 1972 והציג רשימה של 21 בעיות ב-NP - בעיות מרכזיות ומעניינות במדעי המחשב - ש-SAT ניתנת לרדקוציה <strong>אליהן</strong> בדרך זו או אחרת. עכשיו, די קל לראות שניתן להרכיב רדוקציות; לכן אם <span class="math">\(L_{1}\)</span> ניתנת לרדוקציה אל SAT, ואילו SAT ניתנת לרדוקציה אל <span class="math">\(L_{2}\)</span>, אז <span class="math">\(L_{1}\)</span> ניתנת לרדוקציה אל <span class="math">\(L_{2}\)</span>. המשמעות: קארפ הוכיח שעוד 21 בעיות הן NP-שלמות (יום אחד אני ארצה לתאר את כל המאמר שלו בבלוג - זו יצירת מופת של רדוקציות יצירתיות ופשוטות). מכאן כבר הזרם היה בלתי ניתן לעצירה. כדי להוכיח שבעיה היא NP-שלמה, כל מה שצריך לעשות הוא לרדקץ אליה בעיה אחרת, שאנחנו כבר יודעים שהיא NP-שלמה, וככל שאנחנו מכירים יותר כאלו, כך יהיה לנו קל יותר לרדקץ; כיום יש אלפי בעיות שאנו יודעים שהן NP-שלמות. וכל זה נובע מהבסיס, שהוא SAT, דהיינו משפט קוק-לוין.</p>
<p>האנלוגיה הנכונה למשפט קוק-לוין היא בעיית העצירה של טיורינג, השייכת לתורת החישוביות. טיורינג הוכיח עבור בעיה קונקרטית שאין אלגוריתם שמסוגל לפתור אותה; ומכאן ואילך נפתחה הדרך להוכיח עבור שלל בעיות אחרות שאין דרך לפתור אותן, על ידי הצגה של רדוקציה מבעיית העצירה אליהן. כעת, בעיות NP-שלמות הן בוודאי בעיות ש<strong>ניתן</strong> לפתור, פשוט לא בהכרח ביעילות; האנלוגיה הנכונה היא לטעון שאם בעיה היא NP-שלמה אז היא בודאות לא שייכת ל-P. לרוע המזל, איננו יכולים להגיד זאת גם כיום. אנחנו יכולים להגיד שאם בעיה NP-שלמה כלשהי שייכת ל-P, אז ינבע מכך מייד ש<strong>כל</strong> הבעיות ב-NP שייכות ל-P (כי בהינתן בעיית NP כלשהו, נרדקץ אותה בזמן פולינומי לבעיה NP-שלמה ששייכת ל-P ואז נפתור את הבעיה הזו). כלומר, <strong>אם</strong> P שונה מ-NP אז כל הבעיות ה-NP-שלמות הן בודאות לא ב-P. השאלה הזו - האם P שונה מ-NP - היא אולי השאלה הפתוחה המרכזית במדעי המחשב התיאורטיים. כך היא הייתה בפעם הראשונה שכתבתי עליה בבלוג, וכך לצערי נשאר המצב גם כיום.</p>
<p>יפה, אז זה מה שהמשפט אומר; וקרוב לודאי שחידשתי מעט מאוד למי שכבר הכיר את ההגדרות. אז בואו נעבור למנה העיקרית שלנו - איך מוכיחים את המשפט?</p>
<p>הרעיון האינטואיטיבי הוא זה: נתונה לנו שפה <span class="math">\(L\in\text{NP}\)</span>. ניקח מכונת טיורינג <span class="math">\(M\)</span> עבורה. כעת, בהינתן <span class="math">\(x\)</span> כלשהו, נבנה פסוק <span class="math">\(\varphi_{x}\left(y\right)\)</span> שבצורה מחוכמת כלשהי יקודד בתוכו <strong>חישוב</strong> של <span class="math">\(M\)</span> על <span class="math">\(x,y\)</span>. שימו לב: כאן <span class="math">\(y\)</span> מייצגים את <strong>המשתנים</strong> של הפסוק; הרעיון הוא שאנחנו יכולים להזין לפסוק ערכים שונים של <span class="math">\(y\)</span>, ושהפסוק יסתפק או לא יסתפק בהתאם לשאלה האם <span class="math">\(M\)</span> מחזירה "כן" על <span class="math">\(x,y\)</span> או "לא". אבל זה רק הרעיון האינטואיטיבי. הביצוע יהיה קצת יותר מסובך. בפועל לקודד חישובים עם CNF זה לא טריוויאלי, אז אנחנו נשתמש גם ב<strong>משתני עזר</strong> שאסמן <span class="math">\(z\)</span>, והפסוק יסומן <span class="math">\(\varphi_{x}\left(y,z\right)\)</span>. שימו לב - גם <span class="math">\(y\)</span> וגם <span class="math">\(z\)</span> מייצגים <strong>וקטורים</strong> של משתנים, לא משתנים בודדים; כלומר, אני משתמש בכתיב הזה בתור קיצור לכתיב <span class="math">\(\varphi_{x}\left(y_{1},\dots,y_{n},z_{1},\dots,z_{k}\right)\)</span> שתסכימו איתי שהוא מסורבל יותר. הרעיון הוא שלמשתני העזר הללו <strong>לא יהיה חופש בחירה</strong>: בהינתן השמה כלשהי ל-<span class="math">\(y\)</span>-ים, תהיה בדיוק דרך אחת שבה אפשר לתת ערכים ל-<span class="math">\(z\)</span>-ים אם אנחנו מקווים להצליח לספק את הפסוק; כל דרך אחרת שבה נציב ערכים ב-<span class="math">\(z\)</span>-ים אוטומטית תגרום לכך שהפסוק לא יסתפק על ידי ההשמה הזו.</p>
<p>כדי להבין איך נראה חישוב של <span class="math">\(M\)</span> צריך להיזכר בפרטים הטכניים של איך נראית מכונת טיורינג. יש למכונה <strong>סרט</strong> אינסופי שמחולק לתאים, כשבכל תא יכול להיות סימבול מתוך קבוצת סימבולים שנקראית <strong>אלפבית הסרט</strong>, <span class="math">\(\Gamma\)</span>. בנוסף יש למכונה <strong>ראש קורא וכותב</strong> שבכל רגע נתון נמצא מעל תא אחד בסרט, ומחובר למערכת בקרה שיכולה להימצא ב<strong>מצבים פנימיים</strong> שונים ומשונים מתוך קבוצה סופית <span class="math">\(Q\)</span> של מצבים. כל רגע נתון בחישוב ניתן לתיאור מלא באמצעות שלושה פרטים: המצב הפנימי הנוכחי של המכונה; המיקום של הראש; התוכן הנוכחי של הסרט. שלשה כזו נקראת <strong>קונפיגורציה</strong> וחישוב של מכונת טיורינג הוא סדרה של קונפיגורציות, שכל אחת מתקבלת מקודמתה בהתאם ל<strong>פונקצית המעברים</strong> של המכונה; זו פונקציה <span class="math">\(\delta:Q\times\Gamma\to Q\times\Gamma\times\left\{ L,R,S\right\} \)</span> שלכל זוג <span class="math">\(\left(q,\sigma\right)\)</span> של "המצב הפנימי הנוכחי <span class="math">\(q\)</span> והתו <span class="math">\(\sigma\)</span> שהראש כרגע קורא" מתאימה שלשה <span class="math">\(\left(p,\tau,X\right)\)</span> שמשמעותה "עבור למצב <span class="math">\(p\)</span>; כתוב <span class="math">\(\tau\)</span> על הסרט במקום <span class="math">\(\sigma\)</span>; והזז את הראש בהתאם ל-<span class="math">\(X\)</span> (כאשר ימינה זה <span class="math">\(R\)</span>, שמאלה זה <span class="math">\(L\)</span> והישארות במקום זה <span class="math">\(S\)</span>)".</p>
<p>מכונה יכולה להיכנס למצב פנימי מיוחד שמסומן ב-<span class="math">\(q_{acc}\)</span> שמשמעותו שהיא עצרה ואמרה "כן"; באופן דומה המצב <span class="math">\(q_{no}\)</span> אומר שהמכונה עצרה ואמרה "לא". קונפיגורציה שבה זה המצב הפנימי של המכונה נקראת <strong>קונפיגורציה סופית</strong>. פרט לכך יש גם <strong>קונפיגורציה התחלתית</strong> מוסכמת - זו שבה כל הסרט ריק פרט לקלט של המכונה (במקרה שלנו, הזוג <span class="math">\(x,y\)</span>), הראש הקורא נמצא בקצה השמאלי של הסרט (הקצה הימני לא קיים; זו המשמעות של האינסופית של הסרט) והמצב הפנימי של המכונה הוא איבר מיוחד של <span class="math">\(Q\)</span> שמסומן לרוב ב-<span class="math">\(q_{0}\)</span>.</p>
<p>אז השאלה שלנו היא זו: האם קיימת למכונה סדרת קונפיגורציות חוקיות כך שהקונפיגורציה ההתחלתית מתאימה לקלט <span class="math">\(x,y\)</span>, והסדרה מסתיימת בקונפיגורציה סופית מקבלת? המשתנים <span class="math">\(z\)</span> שלנו הולכים לקודד את סדרת הקונפיגורציות הזו.</p>
<p>עכשיו, לכאורה יש לנו בעיה כאן - איך נייצג קונפיגורציה, שהרי היא אינסופית? וכמו כן, גם סדרת הקונפיגורציות עשויה להיות באורך לא חסום. כאן נחלצת לעזרתנו העובדה ש-<span class="math">\(M\)</span> היא פולינומית. זה אומר שקיים פולינום <span class="math">\(p\left(n\right)\)</span> כך שמספר הצעדים המקסימלי ש-<span class="math">\(M\)</span> מבצעת על <span class="math">\(x,y\)</span> הוא <span class="math">\(p\left(\left|x\right|\right)\)</span>. זה אומר שמספיק לנו להסתכל על <span class="math">\(p\left(\left|x\right|\right)+1\)</span> התאים הראשונים של הסרט, כי <span class="math">\(M\)</span> לא תגיע רחוק יותר, ועל סדרת קונפיגורציות מאורך <span class="math">\(p\left(\left|x\right|\right)+1\)</span> כי <span class="math">\(M\)</span> לא תבצע חישוב ארוך יותר. בואו נסמן <span class="math">\(m=p\left(\left|x\right|\right)+1\)</span> אם כך.</p>
<p>כדי לעשות לעצמי את החיים קלים יותר, אני הולך להניח כמה הנחות מקלות על <span class="math">\(M\)</span>. ראשית, שהיא מבצעת <strong>בדיוק</strong> <span class="math">\(p\left(\left|x\right|\right)\)</span> צעדים, בלי תלות בערך של <span class="math">\(y\)</span>, ובצעד האחרון עוברת לקונפיגורציה סופית. זה יחסוך לי את הטורח של לבדוק האם המכונה נעצרה בקונפיגורציה מוקדמת יותר מהאחרונה (זה לא טורח גדול, ועדיין). למה אפשר להניח את זה? כי קל לקחת את <span class="math">\(M\)</span> שנתונה לי ולשנות קצת את הקידוד שלה כך שאם היא התכוונה להיכנס למצב סופי, היא "תתאפק קצת" ותחכה. לשם כך היא צריכה לתחזק מונה שסופר את הצעדים שלה וכדומה, אבל אפשר לעשות דברים כאלו עם מכונות טיורינג. זה מגדיל קצת את זמן הריצה - משנה את הפולינום <span class="math">\(p\)</span> - אבל זמן הריצה עדיין יהיה פולינומי. באופן דומה, אני אניח שה-<span class="math">\(y\)</span>-ים שהמכונה יכולה לקבל יחד עם <span class="math">\(x\)</span> לא ארוכים מדי הם כולם מאותו האורך (אם זה מטריד אתכם תחשבו על כך שהמכונה יכולה לרוץ על כל הרישות של ה-<span class="math">\(y\)</span> שקיבלה) וש-<span class="math">\(p\)</span> גדול דיו כך שיש מקום ל-<span class="math">\(x,y\)</span> על <span class="math">\(m\)</span> התאים הראשונים של הסרט (על פניו הרשיתי ל-<span class="math">\(y\)</span> להיות ארוך יותר, אבל אם המכונה לא תספיק לקרוא את כל התאים של <span class="math">\(y\)</span> אפשר להחליף אותו ברישא של עצמו).</p>
<p>האינטואיציה עכשיו היא שלכל <span class="math">\(1\le i,j\le m\)</span> יהיה לנו משתנה <span class="math">\(z_{i,j}\)</span> שאומר מה נמצא בתא ה-<span class="math">\(j\)</span> בסרט בקונפיגורציה ה-<span class="math">\(i\)</span>-ית; חשבו על זה בתור טבלה גדולה שבה השורות הן הקונפיגורציות, והעמודות הן התאים האינדיבידואליים בסרט. אני ארצה לכתוב דברים כמו <span class="math">\(z_{i,j}=\sigma\)</span> כדי לומר שיש את האות <span class="math">\(\sigma\)</span> בתא הזה. והנה מגיע טריק נחמד: אני יכול "לדחוף פנימה" גם את שני הפרמטרים הנוספים של הקונפיגורציה - המיקום של הראש והמצב הפנימי של המכונה. אם, למשל, בקונפיגורציה <span class="math">\(i\)</span> הראש מצביע על התא <span class="math">\(j\)</span>, המצב הפנימי הוא <span class="math">\(q\)</span> ותוכן התא הזה הוא <span class="math">\(\sigma\)</span>, אז במקום <span class="math">\(z_{i,j}=\sigma\)</span> המשתנה יגיד <span class="math">\(z_{i,j}=\left(q,\sigma\right)\)</span>. כלומר, הטבלה בגודל <span class="math">\(m\times m\)</span> שלי מקודדת את כל המידע הדרוש על הקונפיגורציות.</p>
<p>אבל הנה בעיה: המשתנים שיש לי בפסוק CNF לא יכולים לקודד סימבולים מסובכים. הם בסך הכל יכולים לקבל ערכים של T ו-F. אלו משתנים בוליאניים. אז מה עושים? הפתרון לא מסובך במיוחד וסטנדרטי עבור מי שרגיל לקודד דברים עם CNF-ים; חלק מהקושי בהוכחה של משפט קוק-לוין ללא ספק נובע מכך שרוב מי שרואים אותו לא רגילים עדיין לשום דבר מסוג זה.</p>
<p>פתרון אחד הוא להתייאש ולתהות למה קוק טרח מלכתחילה להתעסק עם SAT ולא עם שפה גמישה קצת יותר. זו תשובה לגיטימית ויש ספרי לימוד שאכן משתמשים בוריאציה יותר מתוחכמת על השפה לצורך המשפט. אבל אני חושב שכדאי להישאר עם SAT כי זה לא כזה נורא. הרעיון הוא כזה: עבור כל ערך אפשרי <span class="math">\(\gamma\)</span> שעשוי להתקבל על ידי המשתנה <span class="math">\(z_{i,j}\)</span> שלנו (כלומר, תו <span class="math">\(\sigma\)</span> או ביטוי מסובך יותר כמו <span class="math">\(\left(q,\sigma\right)\)</span>) יהיה לנו משתנה בוליאני <span class="math">\(z_{i,j}^{\gamma}\)</span>. הרעיון הוא איכשהו להבטיח שלכל <span class="math">\(i,j\)</span>, <strong>בדיוק אחד</strong> מבין המשתנים <span class="math">\(z_{i,j}^{\gamma}\)</span> יקבל את הערך T, והמשמעות של זה תהיה <span class="math">\(z_{i,j}=\gamma\)</span>.</p>
<p>כדי להבטיח ש<strong>לפחות אחד</strong> מבין המשתנים יקבל T, אנחנו מוסיפים לפסוק שאנו בונים את הפסוקית <span class="math">\(\bigvee_{\gamma}z_{i,j}^{\gamma}\)</span>, כלומר הפסוקית תכיל את כל המשתנים מהצורה <span class="math">\(z_{i,j}^{\gamma}\)</span> עבור <span class="math">\(i,j\)</span> קבוע וכל ה-<span class="math">\(\gamma\)</span> האפשריים.</p>
<p>כדי להבטיח ש<strong>לכל היותר אחד</strong> מבין המשתנים יקבל T, אני מוסיף הרבה פסוקיות מהצורה <span class="math">\(\neg z_{i,j}^{\gamma}\vee\neg z_{i,j}^{\gamma^{\prime}}\)</span>, לכל זוג <span class="math">\(\gamma\ne\gamma^{\prime}\)</span> של ערכים אפשריים. פסוקית כזו אומרת "או ש-<span class="math">\(z_{i,j}\ne\gamma\)</span> או ש-<span class="math">\(z_{i,j}\ne\gamma^{\prime}\)</span>", כלומר, באופן שקול, "לא ייתכן שגם <span class="math">\(z_{i,j}=\gamma\)</span> וגם <span class="math">\(z_{i,j}=\gamma^{\prime}\)</span>".</p>
<p>יפה. אז מעכשיו אני יכול להשתמש בחופשיות בסימון <span class="math">\(z_{i,j}=\gamma\)</span> כשבעצם ברור שהכוונה היא למשתנה <span class="math">\(z_{i,j}^{\gamma}\)</span>. מה שהשגתי עד כה הוא שבניתי פסוק שכל השמה שמספקת אותו מגדירה סדרה של <span class="math">\(m\)</span> קונפיגורציות מאורך <span class="math">\(m\)</span>. מה נשאר לי לעשות? את הדברים הבאים:</p>
<ol>
    <li>להבטיח שהקונפיגורציה הראשונה בסדרה היא הקונפיגורציה ההתחלתית של <span class="math">\(M\)</span> על <span class="math">\(x,y\)</span>.</li>
    <li>להבטיח שהקונפיגורציה האחרונה בסדרה היא מקבלת.</li>
    <li>להבטיח שהמעבר בין כל שתי קונפיגורציות סמוכות הוא חוקי.</li>
</ol>
<p>את <span class="math">\(1\)</span> קל להבטיח. נסמן <span class="math">\(x=x_{1}\cdots x_{k}\)</span> ו-<span class="math">\(y=y_{1}\cdots y_{n}\)</span>, ונוסיף לפסוק שלנו פסוקיות שאומרות <span class="math">\(z_{1,1}=\left(q_{0},x_{1}\right)\)</span> (כן, יש כאן מקרה קצה אם <span class="math">\(x\)</span> ריק; אני בטוח שתדעו להתמודד איתו בעצמכם) ו-<span class="math">\(z_{1,i}=x_{i}\)</span> עבור <span class="math">\(i>1\)</span> ו-<span class="math">\(z_{1,k+1}=,\)</span> (שווה לסימן פסיק, או מה שזה לא יהיה שנשתמש בו בתור מפריד בין <span class="math">\(x\)</span> ו-<span class="math">\(y\)</span>) ו-<span class="math">\(z_{1,k+1+i}=y_{i}\)</span>. האחרון מעניין, כי ה-<span class="math">\(y_{i}\)</span>-ים הם לא קבועים - הם בעצמם משתנים. איך מקודדים את זה? ובכן, אם תזכרו שניה מה הקיצורים שלי מסמנים, אני בעצם מוסיף את הפסוקיות שמקודדות את הטענות הבאות: <span class="math">\(z_{1,k+1+i}^{1}=y_{i}\)</span> ו-<span class="math">\(z_{1,k+1+i}^{0}=\neg y_{i}\)</span> (שימו לב שמספיק לטפל בערכים 0 ו-1 כי זה כל מה ש-<span class="math">\(y\)</span> יודע לקבל). אז יש לנו כאן שאלה כללית יותר של קידוד CNF-ים - איך מקודדים <span class="math">\(x=y\)</span>? בקלות, הפסוקיות <span class="math">\(\left(x\vee\neg y\right)\wedge\left(\neg x\vee y\right)\)</span>. ואיך מקודדים <span class="math">\(x=\neg y\)</span>? בקלות, וזה נובע ממה שכבר ראינו: <span class="math">\(\left(x\vee y\right)\wedge\left(\neg x\vee\neg y\right)\)</span>.</p>
<p>את 2 גם כן קל להבטיח על ידי פסוקית ענק שבודקת אם במקרה יש לנו מצב מקבל בקונפיגורציה האחרונה: <span class="math">\(\bigvee_{i,\sigma}z_{m,i}=\left(q_{acc},\sigma\right)\)</span> כאשר כאן אנחנו רצים גם על כל <span class="math">\(1\le i\le m\)</span> וגם על כל <span class="math">\(\sigma\)</span> אפשרי. יכלנו להניח עוד הנחות על המכונה כדי לפשט את החיים (למשל, שהיא חוזרת לתא הראשון בסרט ומרוקנת אותו לפני שהיא עוברת למצב מקבל) אבל הנוסחה פשוטה מספיק גם ככה לטעמי.</p>
<p>נשאר לנו רק 3, שהוא לב העניין. שימו לב שעד עכשיו הפסוק שבנינו היה פולינומי בגודלו - הוספנו רק מספר פולינומי של פסוקיות מגודל פולינומי (פולינומי בגודל של <span class="math">\(x\)</span>). האתגר מגיע כשאנחנו רוצים להבטיח שכל שתי קונפיגורציות סמוכות מייצגות מעבר חוקי. על פניו יש המוני אפשרויות לזוגות כאלו ולכו תבדקו אותם ומהומה והצילו ולא מובטח על פניו שנקבל פסוק פולינומי שמקודד את כל המהומה הזו. לב לבו של העניין ושל כל המשפט נעוץ בכך שמכונת טיורינג היא מודל חישובי שמבצע שינויים <strong>לוקליים</strong> - בכל צעד חישוב, השינוי שעובר על תא אחד בקונפיגורציה לא מושפע מ<strong>כל</strong> הקונפיגורציה הקודמת, אלא רק מכמה תאים בקונפיגורציה הקודמת. זה אומר שאם אני רוצה לכתוב את הערך של <span class="math">\(z_{i+1,t}\)</span>, אני צריך לכתוב פסוקיות שמחשבות כפונקציה של מספר מצומצם של משתנים <span class="math">\(z_{i,r}\)</span>. אם לחדד, כל תא יכול להיות מושפע רק מהתא שבשורה הקודמת ומשני שכניו של התא הזה. הנה דוגמה שתמחיש את זה.</p>
<p>נניח שאני תא מס' 8 בשורה 5 ואני רוצה לדעת מה אמור להיות הערך שלי, על פי מה שקורה בשורה 4. הנה התרחישים שאני צריך להתחשב בהם:</p>
<ol>
    <li>הראש של המכונה היה בתא 8 בשורה 4. במקרה הזה, לא משנה מה הראש מחליט לעשות, תא 8 בשורה 5 יהיה פונקציה בלעדית של תא 8 בשורה 4.</li>
    <li>הראש של המכונה היה בתא 7 בשורה 4. במקרה הזה, ייתכן שהראש יחליט לפנות ימינה (להגדיל את מס' התא שלו ב-1) ואז תא 8 יפסיק להכיל <span class="math">\(\sigma\)</span> ויעבור להכיל <span class="math">\(\left(q,\sigma\right)\)</span> עבור <span class="math">\(q\)</span> כלשהו.</li>
    <li>הראש של המכונה היה בתא 9 בשורה 4. במקרה הזה, ייתכן שהראש יחליט לפנות שמאלה וזה כמו במקרה הקודם.</li>
    <li>כל מיקום אחר של הראש גורר שהוא לא יוכל להשפיע בשום צורה על תא 8.</li>
</ol>
<p>אם כן, לכל <span class="math">\(\gamma\)</span>, הערך של המשתנה <span class="math">\(z_{i,j}^{\gamma}\)</span> נקבע לכל היותר על ידי המשתנים <span class="math">\(z_{i-1,j-1}^{\gamma^{\prime}}\)</span>, <span class="math">\(z_{i-1,j}^{\gamma^{\prime}}\)</span> ו-<span class="math">\(z_{i-1,j+1}^{\gamma^{\prime}}\)</span> עבור כל <span class="math">\(\gamma^{\prime}\)</span> אפשרי. זו קבוצה לא קטנה של משתנים, אבל גם לא גדולה יותר מדי. יש בה שלושה איברים כפול מספר ה-<span class="math">\(\gamma^{\prime}\)</span> האפשריים. כזכור, <span class="math">\(\gamma\)</span> הוא או תו מאלפבית הסרט <span class="math">\(\Gamma\)</span> או שהוא זוג של תו מאלפבית הסרט ומצב פנימי <span class="math">\(Q\)</span> של המכונה. אז יש לנו בסך הכל <span class="math">\(\left|\Gamma\right|+\left|\Gamma\right|\left|Q\right|\)</span> אפשרויות כאלו. לכן כל משתנה תלוי לכל היותר ב-<span class="math">\(3\left(\left|\Gamma\right|+\left|\Gamma\right|\left|Q\right|\right)\)</span> משתנים אחרים. עכשיו מגיע נפנוף הידיים היחיד שאני מרשה לעצמי בהוכחה, כי הוא ברור לכל מי שמכיר קצת CNF-ים: <strong>כל</strong> קשר מהצורה <span class="math">\(a=f\left(b_{1},b_{2},\dots,b_{n}\right)\)</span> כאשר <span class="math">\(f\)</span> היא פונקציה בולינאנית אפשר לתאר באמצעות CNF, במובן זה שלכל הצבה אפשרית של ערכים ל-<span class="math">\(b_{1},\dots,b_{n}\)</span>, הפסוק מסתפק אם ורק אם מציבים ב-<span class="math">\(a\)</span> את <span class="math">\(f\left(b_{1},\dots,b_{n}\right)\)</span>. מה שעשיתי קודם, עם <span class="math">\(x=y\)</span> היה מקרה פרטי פשוט של זה.</p>
<p>בכל זאת, אם אתם סקרנים, הנה הרעיון הכללי. <span class="math">\(a=f\left(b_{1},b_{2},\dots,b_{n}\right)\)</span> זו פשוט דרך אחרת לכתוב פונקציה כללית יותר, <span class="math">\(g\left(a,b_{1},\dots,b_{n}\right)\)</span>, שמקבלת 1 כאשר <span class="math">\(a=f\left(b_{1},b_{2},\dots,b_{n}\right)\)</span> ו-<span class="math">\(0\)</span> אחרת. אז האתגר שלנו הוא רק לדעת איך כותבים CNF עבור פונקציה בוליאנית כללית. לצורך כך קל יותר לחשוב על איך כותבים DNF, שהוא המושג הדואלי ל-CNF: זה פסוק מהצורה <span class="math">\(C_{1}\vee\dots\vee C_{n}\)</span> כאשר כל פסוקית היא מהצורה <span class="math">\(\left(l_{1}\wedge\dots\wedge l_{k}\right)\)</span>. פסוק כזה מקבל 1 אם ורק אם לפחות אחת מהפסוקיות מסתפקת; הרעיון הוא שכל פסוקית תתאים לשורה בטבלת האמת של <span class="math">\(g\)</span>. תוכן הפסוקית יתאים לערכים שהמשתנים של <span class="math">\(g\)</span> מקבלים באותה שורה. למשל, אם <span class="math">\(g\left(x,y,z\right)\)</span> היא פונקציה כך ש-<span class="math">\(g\left(1,0,1\right)=1\)</span> אז הפסוקית שתתאים להשמה הזו תהיה <span class="math">\(x\wedge\neg y\wedge z\)</span>.</p>
<p>כעת, קל לראות שאם <span class="math">\(\varphi\)</span> הוא פסוק DNF אז <span class="math">\(\neg\varphi\)</span> הוא בעצם פסוק CNF בתחפושת - רק צריך להשתמש בכללי דה-מורגן כדי לדחוף את ה-<span class="math">\(\neg\)</span> פנימה. למשל, בואו נכתוב DNF עבור <span class="math">\(x=y\)</span>: בבירור זה ה-DNF <span class="math">\(\left(x\wedge y\right)\vee\left(\neg x\wedge\neg y\right)\)</span>. עכשיו נפעיל <span class="math">\(\neg\)</span> על הכל ונקבל:</p>
<p><span class="math">\(\neg\left[\left(x\wedge y\right)\vee\left(\neg x\wedge\neg y\right)\right]\equiv\neg\left(x\wedge y\right)\wedge\neg\left(\neg x\wedge\neg y\right)\equiv\left(\neg x\vee\neg y\right)\wedge\left(\neg\neg x\vee\neg\neg y\right)\equiv\left(\neg x\vee\neg y\right)\wedge\left(x\vee y\right)\)</span></p>
<p>וקיבלנו CNF עבור <strong>השלילה</strong> של <span class="math">\(x=y\)</span>, כלומר עבור <span class="math">\(x\ne y\)</span>. המסקנה: אם אני רוצה למצוא CNF עבור <span class="math">\(g\)</span>, בואו נמצא DNF עבור <span class="math">\(\neg g\)</span> ואז נפעיל עליו <span class="math">\(\neg\)</span>.</p>
<p>כמובן, נשאלת השאלה מה <strong>גודל</strong> ה-CNF הזה. התשובה היא שהוא עשוי להיות ענקי. אקספוננציאלי במספר המשתנים של <span class="math">\(g\)</span>. כך גם אצלנו - הגודל של הפסוקיות שאני מוסיף עבור כל תא <span class="math">\(z_{i,j}\)</span> שאני רוצה לתאר את הפונקציה שלו עשוי להיות אקספוננציאלי. אבל <strong>אקספוננציאלי במה</strong>? במספר שחישבתי קודם, <span class="math">\(3\left(\left|\Gamma\right|+\left|\Gamma\right|\left|Q\right|\right)\)</span>. המספר הזה <strong>אינו תלוי בגודל הקלט</strong> <span class="math">\(x\)</span> שאנחנו עושים עבורו את הרדוקציה; זה קבוע שמתאר את המורכבות של המכונה עבור <span class="math">\(L\)</span> ותו לא.</p>
<p>מכאן אנחנו לומדים שני דברים: ראשית, שהרדוקציה של משפט קוק-לוין היא פולינומית; שנית, שזה לא אומר שיהיה קל לממש אותה בפועל עבור מכונות מסובכות; ה-CNF המתקבל עשוי להיות מפלצתי בגודלו למרות זאת.</p>
<p>האם סיימנו את ההוכחה? באופן מפתיע למדי, כן! קיבלנו פסוק <span class="math">\(\varphi_{x}\left(y,z\right)\)</span> כך שלכל הצבה של ערכים ל-<span class="math">\(y\)</span>, מתקיים אחד משניים: אם <span class="math">\(M\)</span> מקבלת את <span class="math">\(x,y\)</span>, אז קיימת הצבה (יחידה) של ערכים ל-<span class="math">\(z\)</span> שמספקת את <span class="math">\(\varphi_{x}\left(y,z\right)\)</span>; ואם <span class="math">\(M\)</span> דוחה את <span class="math">\(x,y\)</span> אז כל הצבה של ערכים ל-<span class="math">\(z\)</span>-ים לא תספק את <span class="math">\(\varphi_{x}\)</span>. כלומר, <span class="math">\(\varphi_{x}\)</span> הוא ספיק אם ורק אם <span class="math">\(x\in L\)</span>. יותר מכך - יוצא שמספר ההשמות המספקות של <span class="math">\(\varphi_{x}\)</span> שווה למספר ה-<span class="math">\(y\)</span>-ים שעבורם <span class="math">\(M\)</span> מקבלת את <span class="math">\(x,y\)</span> (מספר ה"הוכחות" השונות של <span class="math">\(x\)</span>). השוויון הזה מעניין כי הוא מצביע על השימושיות האפשרית של משפט קוק-לוין גם בטענות מתוחכמות יותר מסתם "SAT היא NP-שלמה", ואכן בנושאים מתקדמים יותר בסיבוכיות עושים וריאציות שכאלו על קוק-לוין כל הזמן; אבל אני אסתפק במה שהראיתי ואעצור כאן.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>