<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט מייהיל-נרוד - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2015/02/11/myhill_nerode_theorem/">
    <meta property="og:title" content="משפט מייהיל-נרוד">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2015/02/11/myhill_nerode_theorem/">
    <meta name="twitter:title" content="משפט מייהיל-נרוד">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2015/02/03/pumping_lemma_regular_languages/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">למת הניפוח לשפות רגולריות</span>
            </a>
            

            
            <a href="/2015/03/05/context_free_grammars_intro/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">מבוא לדקדוקים חסרי הקשר</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט מייהיל-נרוד</h1>
            <div class="post-meta">
                <span class="date">2015-02-11</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אוטומטים.html">אוטומטים</a>
                    
                    <a href="/tags/יחסי שקילות.html">יחסי שקילות</a>
                    
                    <a href="/tags/משפט מייהיל-נרוד.html">משפט מייהיל-נרוד</a>
                    
                    <a href="/tags/שפות רגולריות.html">שפות רגולריות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>עבורי, משפט מייהיל-נרוד הוא המשפט האולטימטיבי בכל הנוגע להבנה של מה בעצם הופך שפה לרגולרית או ללא רגולרית, איך "אמור" להיראות אוטומט עבורה, ובכלל איך עובד הקטע הזה של אוטומטים. לטעמי זה המשפט היפה ביותר בחומר הזה. אבל אני לא רוצה להציג אותו מהר מדי. בספרי לימוד לרוב פשוט נותנים את הניסוח שלו, אחרי קצת עבודת הכנה נדרשת שבה מציגים עוד כמה מושגים. בפוסט הזה אני לא רצה לעשות את זה - אני רוצה לנסות ו"לגלות" אותו מחדש, כדי שנבין קצת יותר טוב מאיפה הוא מגיע ולמה הוא (והטרמינולוגיה שמתלווה אליו) הגיוניים.</p>
<p>השאלה שהולכת להנחות אותנו בפוסט הזה היא זו: <strong>איך בונים אוטומט מינימלי עבור שפה רגולרית? </strong>כאשר "מינימלי" כאן פירושו מבחינת מספר המצבים שלו, ו"אוטומט" הולך להיות סופי דטרמיניסטי.</p>
<p>אם כן, הבעיה היא זו: נתונה לנו שפה <span class="math">\(L\)</span>, ואנחנו רוצים לבנות עבורה אוטומט עם מספר מצבים מינימלי. בעצם מתחבאות כאן שתי בעיות שונות: האחת, אם <span class="math">\(L\)</span> נתונה לנו על ידי אוטומט <span class="math">\(A\)</span> כך ש-<span class="math">\(L\left(A\right)=L\)</span>. במקרה כזה, אנחנו רוצים לבצע מעין אופטימיזציה של <span class="math">\(A\)</span> ולקבל ממנו אוטומט שקול עם מספר מצבים מינימלי. אתייחס לבעיה הזו בהמשך אבל אני מעדיף להתחיל דווקא מהבעיה השניה - כאן <span class="math">\(L\)</span> נתונה לנו בניסוח מילולי, ואנחנו רוצים לבנות ידנית את האוטומט עבורה כך שהוא יהיה המינימלי. באיזו גישה כדאי לנקוט לשם כך?</p>
<p>בואו נתחיל עם דוגמה פשוטה. השפה <span class="math">\(L=\left\{ w\in\left\{ a,b\right\} ^{*}\ |\ \left|w\right|\equiv_{2}0\right\} \)</span> של כל המילים מאורך זוגי. אני רוצה לבנות אוטומט לשפה. ממה מתחילים? ובכן, ממה שחייבים. לאוטומט חייב להיות מצב התחלתי <span class="math">\(q_{0}\)</span>, אז אני מוסיף אותו לקבוצת המצבים של האוטומט. עכשיו אני שואל את עצמי - האם זה יהיה מצב מקבל או לא? התשובה לשאלה הזו נקבעת על פי השאלה האם <span class="math">\(\varepsilon\)</span> שייכת לשפה או לא. אם היא כן - אז <span class="math">\(q_{0}\)</span> חייב להיות מקבל אחרת אין שום סיכוי שנקבל את <span class="math">\(\varepsilon\)</span>; אם היא לא, אז אסור ל-<span class="math">\(q_{0}\)</span> להיות מקבל. במקרה שלנו המסקנה היא ש-<span class="math">\(q_{0}\)</span> יהיה מצב מקבל.</p>
<p>עכשיו, מה אני עוד חייב לעשות? להגדיר את פונקציית המעברים של האוטומט. אני לוקח את <span class="math">\(a\)</span> ומנסה להבין איך אני רוצה להגדיר את <span class="math">\(\delta\left(q_{0},a\right)\)</span>. יש לי שתי אפשרויות: או שזה יהיה <span class="math">\(q_{0}\)</span>, או שזה יהיה מצב חדש. האם זה יכול להיות <span class="math">\(q_{0}\)</span>? ובכן, כבר הסכמנו ש-<span class="math">\(q_{0}\)</span> הוא מצב מקבל, ולכן אם <span class="math">\(\delta\left(q_{0},a\right)=q_{0}\)</span> ינבע מכך ש-<span class="math">\(a\in L\)</span>, מה שלא נכון. מכאן שאין לי ברירה - <strong>אסור</strong> להגדיר <span class="math">\(\delta\left(q_{0},a\right)=q_{0}\)</span> ואני חייב להכניס מצב חדש למשחק.</p>
<p>בואו נעצור שניה ונתאר בצורה קצת אחרת את מה שראינו כרגע. לפני דקה החלטתי ש-<span class="math">\(q_{0}\)</span> יהיה מצב מקבל בגלל ש-<span class="math">\(\varepsilon\in L\)</span> . רגע אחר כך החלטתי שאסור לי להגדיר <span class="math">\(\delta\left(q_{0},a\right)=q_{0}\)</span> בגלל ש-<span class="math">\(a\notin L\)</span>. כלומר, מה שראיתי הוא שיש <strong>הפרדה</strong> בין <span class="math">\(\varepsilon\)</span> ובין <span class="math">\(a\)</span> - שתי המילים הללו שונות בצורה מהותית בכך שהאחת שייכת לשפה והשניה לא. המסקנה שלי הייתה שלא ייתכן שפונקציית המעברים <span class="math">\(\delta\)</span> תעביר את שתיהן לאותו מקום - שחייב להתקיים <span class="math">\(\hat{\delta}\left(q_{0},\varepsilon\right)\ne\hat{\delta}\left(q_{0},a\right)\)</span>. זה אולי נשמע טריוויאלי בינתיים, אבל זה תופס את הרעיון הבסיסי שמאחורי מייהיל-נרוד.</p>
<p>טוב, חזרה לבניית האוטומט. הגענו למסקנה שאנחנו צריכים מצב חדש - נקרא לו <span class="math">\(q_{1}\)</span> - כך ש-<span class="math">\(\delta\left(q_{0},a\right)=q_{1}\)</span>. כמו כן בהכרח <span class="math">\(q_{1}\)</span> אינו מצב מקבל, אחרת הייתי מקבל את <span class="math">\(a\)</span> ושוב היינו בצרות. האם סיימנו? לא! כי ראשית כל עדיין לא טיפלתי ב-<span class="math">\(\delta\left(q_{0},b\right)\)</span>; ושנית, עכשיו אני צריך לטפל גם במעברים של <span class="math">\(q_{1}\)</span>.</p>
<p>עבור <span class="math">\(\delta\left(q_{0},b\right)\)</span> שוב ברור שאסור שיתקיים <span class="math">\(\delta\left(q_{0},b\right)=q_{0}\)</span>. אז יש לי שתי אפשרויות: או ש-<span class="math">\(\delta\left(q_{0},b\right)=q_{1}\)</span> או ש-<span class="math">\(\delta\left(q_{0},b\right)=q_{2}\)</span> עבור מצב חדש, <span class="math">\(q_{2}\)</span>. עכשיו, לנו ברור אינטואיטיבית שאני יכול להגדיר <span class="math">\(\delta\left(q_{0},b\right)=q_{1}\)</span> כי מה כבר ההבדל בין <span class="math">\(a\)</span> ו-<span class="math">\(b\)</span> בכל הנוגע לשפה <span class="math">\(L\)</span>. זה ברור לכם? אינטואיטיבית? יופי, כי זה בדיוק מה שמייהיל-נרוד בא לפרמל - את ההבנה האינטואיטיבית הזו. בינתיים בואו נניח שאני מגדיר <span class="math">\(\delta\left(q_{0},b\right)=q_{1}\)</span> ועכשיו בואו נדבר על המעברים שיוצאים מ-<span class="math">\(q_{1}\)</span>. מה יהיה <span class="math">\(\delta\left(q_{1},a\right)\)</span>? ובכן, המצב שאליו נעבור הוא המצב שאליו מגיעים באוטומט אם קוראים את <span class="math">\(aa\)</span>, וזו מילה מאורך זוגי ולכן זה צריך להיות מצב מקבל. לכן יש לנו שתי אפשרויות: או להוסיף מצב מקבל חדש <span class="math">\(q_{2}\)</span> ולהעביר אליו, או להגדיר <span class="math">\(\delta\left(q_{1},a\right)=q_{0}\)</span> ובדומה גם <span class="math">\(\delta\left(q_{1},b\right)=q_{0}\)</span> מה שיסיים את בניית האוטומט כי כעת הוא "סגור" (טיפלנו בכל זוג של מצב וקלט). ושוב מגיעה לעזרתנו ה"אינטואיציה" שלנו שאומרת שאכן אפשר להגדיר <span class="math">\(\delta\left(q_{1},a\right)=q_{0}\)</span> ולא תהיה עם זה בעיה. אבל אנחנו רוצים להיות פורמליים, ולכן השאלה המרכזית ביותר כאן היא - איזו בעיה עלולה להתעורר, ולמה?</p>
<p>בואו נבין מה המשמעות של הגדרת <span class="math">\(\delta\left(q_{1},a\right)=q_{0}\)</span>. זה אומר שיתקיים <span class="math">\(\hat{\delta}\left(q_{0},\varepsilon\right)=\hat{\delta}\left(q_{0},aa\right)\)</span>. כלומר, קיבלנו שתי מילים שהאוטומט מעביר לאותו מצב בדיוק. זה דורש שהן שתיהן יהיו בשפה ביחד, או ששתיהן לא יהיו בשפה ביחד, אחרת יש לנו בעיה ברורה. אבל קורה יותר מזה. אוטומט הוא הרי <strong>חסר זכרון</strong>. הוא לא יודע מה המילה שהביאה אותו למצב נתון. אם הוא הגיע לאותו מצב אחרי קריאת <span class="math">\(\varepsilon\)</span> ואחרי קריאת <span class="math">\(aa\)</span>, אז <strong>המשך החישוב</strong> שלו יהיה זהה ולא משנה איזו מילה הביאה אותו למצב הזה.</p>
<p>זה אומר ש<strong>לכל</strong> מילה <span class="math">\(z\)</span> שאותה אנחנו קוראים החל מהרגע שבו הגענו למצב הזה, התשובה שהאוטומט יחזיר אחרי קריאת <span class="math">\(z\)</span> הזו לא תהיה תלויה במה שהביא אותו אל המצב מלכתחילה. ולכן האוטומט צריך לענות את אותה תשובה על <span class="math">\(\varepsilon\cdot z\)</span> ועל <span class="math">\(aa\cdot z\)</span>, וזאת לכל <span class="math">\(z\)</span>. האבחנה הזו היא לב העניין.</p>
<p>בואו נראה דוגמה אחרת. הפעם השפה תהיה <span class="math">\(L=\left\{ w\in\left\{ a,b\right\} ^{*}\ |\ \left|w\right|\not\equiv_{3}0\right\} \)</span> - שפת כל המילים שאורכן <strong>אינו</strong> מתחלק ב-3. חיש קל ברור ש-<span class="math">\(\delta\left(q_{0},a\right)=q_{1}\)</span> כך ש-<span class="math">\(q_{1}\)</span> מקבל ו-<span class="math">\(q_{0}\)</span> אינו מקבל (מדוע?), וכעת השאלה היא מה לעשות עם <span class="math">\(\delta\left(q_{1},a\right)\)</span>. מצד אחד, גם <span class="math">\(a\)</span> וגם <span class="math">\(aa\)</span> שניהם בשפה, ולכן ברמה העקרונית אם נגדיר <span class="math">\(\delta\left(q_{1},a\right)=q_{1}\)</span> (ולכן <span class="math">\(\hat{\delta}\left(q_{0},aa\right)=\hat{\delta}\left(q_{0},a\right)\)</span>) זה לא יגרום לשגיאה מיידית; אבל השגיאה חייבת להגיע בצעד הבא, כי <span class="math">\(aa\cdot a\notin L\)</span> אבל <span class="math">\(a\cdot a\in L\)</span> ולכן <span class="math">\(z=a\)</span> היא מילה ש"מפרידה" בין <span class="math">\(a\)</span> ובין <span class="math">\(aa\)</span>. המסקנה היא שאנחנו חייביים מצב מקבל חדש <span class="math">\(q_{2}\)</span> כך ש-<span class="math">\(\delta\left(q_{1},a\right)=q_{2}\)</span>.</p>
<p>אם כן, מצאנו תכונה שמתארת האם זוג מילים הן כאלו שהאוטומט שבונים עבור השפה יכול להעביר לאותו מצב, או שאסור לו. אני אשתמש בסימון <span class="math">\(uR_{L}v\)</span> כדי לתאר את הסיטואציה שבה <span class="math">\(u,v\)</span> מקיימות את התכונה הזו; זה סימון מקובל לכך ששני איברים נמצאים יחד ב<strong>יחס</strong>. תזכורת קצרה לגבי מהו יחס, פורמלית: פשוט אוסף של זוגות. אני כותב <span class="math">\(uR_{L}v\)</span> במקום לכתוב <span class="math">\(\left(u,v\right)\in R_{L}\)</span> פשוט כי זה יותר קומפקטי.</p>
<p>הנה ההגדרה הפורמלית, שבשלב הזה אני מקווה שכבר תהיה ברורה וכך גם המוטיבציה אליה: <span class="math">\(uR_{L}v\)</span> אם ורק אם <strong>לכל</strong> <span class="math">\(z\in\Sigma^{*}\)</span> מתקיים ש-<span class="math">\(uz\in L\iff vz\in L\)</span>.</p>
<p>עכשיו, היחס הזה מקיים שלוש תכונות נחמדות: ראשית, <span class="math">\(uR_{L}u\)</span> לכל <span class="math">\(u\in\Sigma^{*}\)</span> - זה די מובן מאליו למה. גם מובן מאליו למה אם <span class="math">\(uR_{L}v\)</span> אז גם <span class="math">\(vR_{L}u\)</span>. התכונה השלישית יותר מעניינת: אם <span class="math">\(uR_{L}v\)</span> וגם <span class="math">\(vR_{L}w\)</span> אז <span class="math">\(uR_{L}w\)</span>. למה? פשוט, כי לכל <span class="math">\(z\)</span> מתקיים ש-<span class="math">\(uz\in L\iff vz\in L\iff wz\in L\)</span>. שלוש התכונות הללו נקראות, בהתאמה, <strong>רפלקיסיבות, סימטריות וטרנזיטיביות</strong>, ויחס שמקיים את שלוש התכונות הללו נקרא <strong>יחס שקילות</strong>. המהות של יחס שקילות היא שהוא מעין הכללה של מושג השוויון - הוא אומר "שני האובייקטים הללו אמנם לא חייבים להיות זהים, אבל באספקט אחד שלהם שמעניין אותנו הם שווים".</p>
<p>בהינתן איבר <span class="math">\(w\)</span>, אפשר להסתכל על קבוצת כל האיברים ששקולים לו על פי היחס, כלומר הקבוצה <span class="math">\(\left[w\right]_{R_{L}}\triangleq\left\{ u\in\Sigma^{*}\ |\ wR_{L}u\right\} \)</span>. לקבוצה כזו קוראים <strong>מחלקת השקילות </strong>של <span class="math">\(w\)</span>. זו תמיד קבוצה לא ריקה, כי <span class="math">\(w\in\left[w\right]_{R_{L}}\)</span> (כי רפלקסיביות). יותר מזה, אם <span class="math">\(u\in\left[w\right]_{R_{L}}\)</span> אז <span class="math">\(w\in\left[u\right]_{R_{L}}\)</span> (כי סימטריות) ואם <span class="math">\(v\in\left[w\right]_{R_{L}}\cap\left[u\right]_{R_{L}}\)</span> אז <span class="math">\(uR_{L}w\)</span> (כי טרנזיטביות). המסקנה מכל אלו: אוסף מחלקות השקילות של כל המילים ב-<span class="math">\(\Sigma^{*}\)</span>, דהיינו <span class="math">\(\left\{ \left[w\right]_{R_{L}}\ |\ w\in\Sigma^{*}\right\} \)</span> הוא <strong>חלוקה</strong> של <span class="math">\(\Sigma^{*}\)</span> לתת-קבוצות שהן זרות זו לזו, לא ריקות, ואיחודן נותן את כל <span class="math">\(\Sigma^{*}\)</span>. את האוסף הזה נהוג לסמן <span class="math">\(\Sigma^{*}/R_{L}\triangleq\left\{ \left[w\right]_{R_{L}}\ |\ w\in\Sigma^{*}\right\} \)</span>. קוראים לאוסף הזה לפעמים "קבוצת המנה" של יחס השקילות. הגודל שלו הולך להיות חשוב מאוד בהמשך אז בואו ניתן לו סימון: <span class="math">\(\text{index}\left(R_{L}\right)=\left|\Sigma^{*}/R_{L}\right|\)</span>.</p>
<p>עכשיו אפשר לנסח את משפט מייהיל-נרוד פורמלית: שפה <span class="math">\(L\)</span> היא רגולרית אם ורק אם <span class="math">\(\text{index}\left(R_{L}\right)\)</span> סופי. יותר מכך: במקרה שבו <span class="math">\(L\)</span> רגולרית, אז <span class="math">\(\text{index}\left(R_{L}\right)\)</span> הוא מספר המצבים של אוטומט <strong>מינימלי</strong> עבור השפה <span class="math">\(L\)</span>. זה גם נותן אינטואיציה לגבי הסיבה שבגללה אין אוטומט לשפה לא רגולרית <span class="math">\(L\)</span>: מכיוון ש-<span class="math">\(\text{index}\left(R_{L}\right)=\infty\)</span> לשפות כאלו, אז מספר המצבים באוטומט מינימלי עבורן היה אינסופי - וזה כמובן לא חוקי.</p>
<p>בואו נעבור להוכיח את המשפט. יש לנו שני כיוונים להוכיח. ראשית כל אני אראה שאם <span class="math">\(\text{index}\left(R_{L}\right)\)</span> סופי אז קיים אוטומט סופי דטרמיניסטי שמקבל את <span class="math">\(L\)</span>, ואני אעשה את זה בצורה הכי ישירה שיש - אציג אוטומט עבור <span class="math">\(L\)</span>. ההוכחה הזו מקסימה מאוד, לטעמי, כי אנחנו הולכים לבנות את האוטומט הזה <strong>מתוך</strong> מחלקות השקילות של <span class="math">\(R_{L}\)</span>. לי זה קצת מזכיר את ההוכחה של משפט השלמות של גדל, אבל לא ארחיב על כך יותר מדי.</p>
<p>לפני שאציג את הבניה התקינה, בואו נחשוב על הבעיה מכיוון שונה שיתן לנו (לדעתי) אינטואיציה חזקה מאוד לגבי מדוע המשפט נכון ואיך בכלל יכולים להגיע אליו. בואו נניח לרגע שאני מסיר את המגבלה המעצבנת הזו ש-<span class="math">\(Q\)</span> חייב להיות סופי, ובוא ניקח שפה <span class="math">\(L\)</span> כלשהי. אני טוען שעכשיו אפשר לבנות אוטומט שמקבל את <span class="math">\(L\)</span>. איך הוא ייראה?</p>
<p>הדרך הכי טבעית לבנות אוטומט כזה היא לבנות את קבוצת המצבים כך שיש מצב לכל מילה, והקריאה של המילה מביאה את האוטומט אל המצב הזה. כלומר, נגדיר <span class="math">\(Q=\left\{ q_{w}\ |\ w\in\Sigma^{*}\right\} \)</span>. המצב ההתחלתי שלנו יהיה <span class="math">\(q_{\varepsilon}\)</span>, ואנחנו רוצים שיתקיים <span class="math">\(\hat{\delta}\left(q_{\varepsilon},w\right)=q_{w}\)</span>. די ברור שהדרך הנכונה להגדיר את פונקציית המעברים שלנו היא זו: <span class="math">\(\delta\left(q_{w},\sigma\right)=q_{w\sigma}\)</span>. כעת, מי יהיו המצבים המקבלים? בדיוק כאלו שמתאימים למילים שבשפה, כלומר <span class="math">\(F=\left\{ q_{w}\ |\ w\in L\right\} \)</span>. קחו רגע ותסבירו לעצמכם למה הבניה הזו באמת עובדת - הבעיה ה"קטנה" היחידה היא ש-<span class="math">\(Q\)</span> היא אינסופית.</p>
<p>אז מה אומרים מייהיל-נרוד? פשוט מאוד - קחו את האוטומט הנאיבי הזה, ותנסו <strong>לצמצם</strong> אותו כך שנישאר רק עם מספר סופי של מצבים. המפתח לצמצום של אוטומט הוא יחס השקילות <span class="math">\(R_{L}\)</span>. מה הוא אומר? אם שתי מילים שקולות ב-<span class="math">\(R_{L}\)</span>, זה אומר שמרגע שהאוטומט סיים לקרוא אותן, המשך החישוב שלו יכול להיות זהה. כלומר, <strong>אין סיבה</strong> ששתי המילים הללו יובילו למצבים שונים; הן יכולות להוביל לאותו מצב בדיוק. לכן אם <span class="math">\(uR_{L}v\)</span> אנחנו רוצים שהמצבים <span class="math">\(q_{u},q_{v}\)</span> יהיו אותו מצב - <strong>לאחד</strong> אותם. אבל זה נכון לא רק לזוגות של מצבים - באופן כללי, לכל מחלקת שקילות של <span class="math">\(R_{L}\)</span>, כל המילים שבמחלקה יכולות להוביל לאותו מצב. לכן יהיה לנו <strong>מצב לכל מחלקת שקילות</strong>. שאר ההגדרות של האוטומט הן מה שקורה כשלוקחים את הבניה שלמעלה ומחליפים את המצבים במחלקות שקילות.</p>
<p>אם כן, אני מגדיר <span class="math">\(Q=\Sigma^{*}/R_{L}=\left\{ \left[w\right]_{R_{L}}\ |\ w\in\Sigma^{*}\right\} \)</span>. שימו לב לדמיון ל-<span class="math">\(\left\{ q_{w}\ |\ w\in\Sigma^{*}\right\} \)</span> שלמעלה, רק שהחלפתי את <span class="math">\(q_{w}\)</span> ב-<span class="math">\(\left[w\right]_{R_{L}}\)</span>. במקום מצב לכל מילה, אני לוקח מצב לכל <strong>מחלקת שקילות</strong> של מילים. בכתיב שלי אני כותב את אותה מחלקת שקילות הרבה פעמים (למשל, אם <span class="math">\(uR_{L}v\)</span> אז <span class="math">\(\left[u\right]_{R_{L}}=\left[v\right]_{R_{L}}\)</span> ולכן מחלקת השקילות הזו תופיע לפחות פעמיים) - אבל זכרו שכאשר כותבים קבוצה וחוזרים על אותו איבר כמה פעמים, הוא "נחשב" רק פעם אחת. אז אין לי חזרות מיותרות ואם מספר מחלקות השקילות סופי, מספר המצבים של האוטומט סופי. כמו קודם, מה שאנחנו רוצים שיתקיים הוא ש-<span class="math">\(\hat{\delta}\left(q_{0},w\right)=\left[w\right]\)</span></p>
<p>מה יהיה המצב ההתחלתי שלנו? כמובן, <span class="math">\(q_{0}=\left[\varepsilon\right]\)</span> (בלי זה לא היה סיכוי שיתקיים השוויון על פונקציית המעברים לעיל).</p>
<p>ומה יהיו המצבים המקבלים? כמובן, <span class="math">\(F=\left\{ \left[w\right]\ |\ w\in L\right\} \)</span>.</p>
<p>אויך נגדיר את פונקציית המעברים? שוב, זה לא חכם יותר מאשר לקחת את מה שתיארתי באוטומט האינסופי: <span class="math">\(\delta\left(\left[w\right],\sigma\right)=\left[w\sigma\right]\)</span>. מצד שני, ההגדרה הזו יותר טריקית ממה שנראה במבט ראשון כי יש כאן סכנה כללית שיש כשמתעסקים עם יחסי שקילות - אם אני מגדיר פונקציה על מחלקת שקילות <strong>באמצעות נציגים</strong>, אני צריך להוכיח שההגדרה לא תלויה בנציג, אחרת ההגדרה שלי לא שווה כלום.</p>
<p>בואו נסביר את זה יותר בפירוט. הפחד שלי הוא שקיימות מילים <span class="math">\(u,v\)</span> כך ש-<span class="math">\(uR_{L}v\)</span> ולכן <span class="math">\(\left[u\right]=\left[v\right]\)</span>, אבל משום מה <strong>לא</strong> יתקיים ש-<span class="math">\(u\sigma R_{L}v\sigma\)</span>. כלומר, נקבל <span class="math">\(\left[u\sigma\right]\ne\left[v\sigma\right]\)</span>. זה אומר שההגדרה <span class="math">\(\delta\left(\left[w\right],\sigma\right)=\left[w\sigma\right]\)</span> היא <strong>תלויה בנציג</strong> שאני בוחר למחלקת השקילות: אם אני אבחר לייצג את המחלקה עם <span class="math">\(u\)</span> אני אקבל פלט אחד, ואם אני אייצג אותה עם <span class="math">\(v\)</span> אני אקבל פלט אחר. זה בלתי נסבל בהגדרה של פונקציה: הרעיון הבסיסי בפונקציה הוא שלכל קלט קיים פלט יחיד. לא ייתכן שלאותו קלט יהיו כמה פלטים שתלויים באופן שבו אנחנו מסמנים את הקלט. הוכחה כזו מראה שהפונקציה כפי שהגדרתי אותה היא <strong>מוגדרת היטב</strong>.</p>
<p>אז מה עושים? מוכיחים שזה לא יכול לקרות. נניח ש-<span class="math">\(\left[u\right]=\left[v\right]\)</span> ונוכיח ש-<span class="math">\(\left[u\sigma\right]=\left[v\sigma\right]\)</span> פשוט על פי הגדרה. לצורך כך צריך להיזכר בהגדרה של <span class="math">\(R_{L}\)</span>: צריך להראות שלכל <span class="math">\(z\)</span> מתקיים <span class="math">\(u\sigma\cdot z\in L\iff v\sigma\cdot z\in L\)</span>. לצורך כך, נשתמש בנשק שלנו: ידוע ש-<span class="math">\(uR_{L}v\)</span> ולכן לכל <span class="math">\(z^{\prime}\)</span> מתקיים <span class="math">\(u\cdot z^{\prime}R_{L}v\cdot z^{\prime}\)</span>. אם כן, פשוט נבחר <span class="math">\(z^{\prime}=\sigma z\)</span> וסיימנו.</p>
<p>בעצם הראינו כאן תכונה מעניינת נוספת של היחס <span class="math">\(R_{L}\)</span> - תכונה שאקרא לה <strong>אינוריאנטיות מימין</strong>. הנה הגדרה כללית שלה: יחס <span class="math">\(R\)</span> הוא אינוריאנטי מימין אם לכל <span class="math">\(u,v\)</span> המקיימים <span class="math">\(uRv\)</span> ולכל <span class="math">\(\sigma\in\Sigma\)</span> מתיים ש-<span class="math">\(u\sigma Rv\sigma\)</span> - גם אם אנחנו מאריכים לצד ימין את המילים <span class="math">\(u,v\)</span> <strong>על ידי אותה אות</strong> אנחנו עדיין נשארים ביחס (ההפך לא נכון - ייתכנו שתי מילים לא שקולות שאחרי שמחברים להן עוד אות מימין הופכות לשקולות). התכונה הזו עוד תועיל לנו בהמשך.</p>
<p>בואו נוכיח שהבניה שלנו עובדת. ראשית כל, נוכיח באינדוקציה ש-<span class="math">\(\hat{\delta}\left(q_{0},w\right)=\left[w\right]\)</span>. זו הוכחה קלה כי הבניה מיועדת לכך שהיא תעבוד: עבור הבסיס <span class="math">\(w=\varepsilon\)</span> זה נובע מייד מההגדרה - <span class="math">\(\hat{\delta}\left(q_{0},\varepsilon\right)=q_{0}=\left[\varepsilon\right]\)</span>; עבור צעד האינדוקציה, ניקח מילה מהצורה <span class="math">\(w\sigma\)</span> כך שניתן להשתמש באינדוקציה על <span class="math">\(w\)</span>, וכעת <span class="math">\(\hat{\delta}\left(q_{0},w\sigma\right)=\delta\left(\hat{\delta}\left(q_{0},w\right),\sigma\right)=\delta\left(\left[w\right],\sigma\right)=\left[w\sigma\right]\)</span> - שוב, נובע ישירות מהבניה.</p>
<p>עכשיו כמעט סיימנו, אבל יש נקודה טריקית אחת שעוד יהיה צורך להתייחס אליה. אנחנו רוצים להראות ש-<span class="math">\(w\in L\iff\hat{\delta}\left(q_{0},w\right)\in F\)</span>. לפי מה שראינו כבר, זה שקול להוכחה ש-<span class="math">\(w\in L\iff\left[w\right]\in F\)</span>. כיוון אחד הוא ברור: אם <span class="math">\(w\in L\)</span> אז <span class="math">\(\left[w\right]\in F\)</span> על פי בניית האוטומט. אבל הכיוון השני קצת פחות ברור - אם <span class="math">\(\left[w\right]\in F\)</span> זה <strong>לא אומר</strong> מיידית ש-<span class="math">\(w\in L\)</span>: מה שזה אומר הוא שקיים <span class="math">\(u\in L\)</span> כך ש-<span class="math">\(\left[w\right]=\left[u\right]\)</span>. אבל כל מה שצריך לעשות הוא להיזכר שוב בהגדרה <span class="math">\(R_{L}\)</span>: אם <span class="math">\(wR_{L}u\)</span> אז לכל <span class="math">\(z\)</span> מתקיים <span class="math">\(wz\in L\iff uz\in L\)</span> ובפרט עבור <span class="math">\(z=\varepsilon\)</span>. מכיוון ש-<span class="math">\(u\in L\)</span> נקבל ש-<span class="math">\(w\in L\)</span> וסיימנו.</p>
<p>סיכום ביניים: הראינו שאם <span class="math">\(\text{index}\left(R_{L}\right)\)</span> סופי אז <span class="math">\(L\)</span> רגולרית. עכשיו אני רוצה להראות את הכיוון השני: שאם <span class="math">\(L\)</span> רגולרית אז <span class="math">\(\text{index}\left(R_{L}\right)\)</span> סופי. ואני הולך לעשות את זה על ידי כך שאוכיח ש-<span class="math">\(\text{index}\left(R_{L}\right)\)</span> הוא מספר המצבים באוטומט מינימלי עבור <span class="math">\(L\)</span> - מן הסתם זה גם מוכיח מייד שהמספר הזה סופי (כי <span class="math">\(L\)</span> רגולרית אז קיים לה אוטומט עם מספר מצבים סופי).</p>
<p>לצורך כך, בואו ניקח אוטומט <span class="math">\(A\)</span> כלשהו עבור <span class="math">\(L\)</span>. האבחנה המרכזית כאן הוא שגם <span class="math">\(A\)</span> מגדיר יחס שקילות משל עצמו - שתי מילים הן שקולות אם אחרי קריאתן האוטומט מגיע לאותו המצב. זה מעין היפוך רעיוני של <span class="math">\(R_{L}\)</span> - במקרה של <span class="math">\(R_{L}\)</span> הרעיון היה ש<strong>אם</strong> שתי מילים הן שקולות, אז <strong>אפשר</strong> להביא את שתיהן לאותו מצב; עכשיו אנחנו אומרים שאם כבר ראינו ששתי מילים מגיעות לאותו מצב, אז בואו נגדיר שהן שקולות.</p>
<p>פורמלית נגדיר <span class="math">\(uR_{A}v\)</span> אם ורק אם <span class="math">\(\hat{\delta}\left(q_{0},u\right)=\hat{\delta}\left(q_{0},v\right)\)</span> באוטומט <span class="math">\(A\)</span>. קל מאוד להוכיח שזה יחס שקילות. עוד דבר שקל מאוד לראות הוא ש-<span class="math">\(\text{index}\left(R_{A}\right)\le\left|Q\right|\)</span>. מדוע? כי אפשר להגדיר התאמה חח"ע מקבוצת מחלקות השקילות של <span class="math">\(R_{A}\)</span> אל קבוצת המצבים של <span class="math">\(A\)</span>: לכל <span class="math">\(\left[w\right]\)</span> נתאים את המצב <span class="math">\(\hat{\delta}\left(q_{0},w\right)\)</span>. קל לראות שההתאמה הזו מוגדרת היטב והיא חח"ע. ולמה ייתכן שאין שוויון, כלומר ש-<span class="math">\(\text{index}\left(R_{A}\right)&lt;\left|Q\right|\)</span>? כי ב-<span class="math">\(A\)</span> עשויים להיות מצבים "מיותרים" שאי אפשר להגיע אליהם על ידי קריאת אף מילה.</p>
<p>כל מה שנשאר לי להראות, אם כן, הוא ש-<span class="math">\(\text{index}\left(R_{L}\right)\le\text{index}\left(R_{A}\right)\)</span> לכל <span class="math">\(A\)</span> המקיים <span class="math">\(L\left(A\right)=L\)</span>. אני אוכיח משהו קצת יותר חזק מכך - שכל מחלקת שקילות של <span class="math">\(R_{L}\)</span> היא <strong>איחוד</strong> של מחלקת שקילות אחת או יותר של <span class="math">\(R_{A}\)</span>. כלומר, אם <span class="math">\(R_{L}\)</span> מחלק לנו את <span class="math">\(\Sigma^{*}\)</span> לתת-קבוצות, הרי ש-<span class="math">\(R_{A}\)</span> לוקח את תת הקבוצות הללו ולכל היותר מחלק אותן עוד קצת (במקום לבצע חלוקה שונה לגמרי שמניבה חתיכות שאי אפשר לחבר כדי לקבל את החתיכות של <span class="math">\(R_{L}\)</span>). פורמלית, מה שאני רוצה להראות הוא שלכל <span class="math">\(u\in\Sigma^{*}\)</span> מתקיים ש-<span class="math">\(\left[u\right]_{R_{A}}\subseteq\left[u\right]_{R_{L}}\)</span> (ולכן <span class="math">\(\left[u\right]_{R_{L}}=\bigcup_{w\in\left[u\right]_{R_{L}}}\left[w\right]_{R_{A}}\)</span> - נסו להוכיח זאת!). על סיטואציה כזו אומרים ש-<span class="math">\(R_{A}\)</span> "מעדן" את <span class="math">\(R_{L}\)</span> - כי החלוקה ש-<span class="math">\(R_{A}\)</span> מגדיר היא כמו זו של <span class="math">\(R_{L}\)</span> רק יותר "עדינה".</p>
<p>אם כן, בואו ניקח <span class="math">\(v\in\left[u\right]_{R_{A}}\)</span> ונוכיח ש-<span class="math">\(v\in\left[u\right]_{R_{L}}\)</span>. כלומר, אנחנו יודעים ש-<span class="math">\(uR_{A}v\)</span> ורוצים להוכיח ש-<span class="math">\(uR_{L}v\)</span>. אם כן, ניקח <span class="math">\(z\in\Sigma^{*}\)</span> כלשהי ונוכיח ש-<span class="math">\(uz\in L\iff vz\in L\)</span>. אבל, אם אתם עדיין נושמים בכלל, זה ממש קל! מכיוון ש-<span class="math">\(uR_{A}v\)</span> אנחנו יודעים ש-<span class="math">\(\hat{\delta}\left(q_{0},u\right)=\hat{\delta}\left(q_{0},v\right)\)</span> ועל כן <span class="math">\(\hat{\delta}\left(q_{0},uz\right)=\hat{\delta}\left(q_{0},vz\right)\)</span> ומכאן התוצאה נובעת מאליה.</p>
<p>סיימנו, אבל אפשר להכליל את התוצאה הזו עוד קצת. בואו ננסה להבין באילו תכונות של <span class="math">\(A\)</span> ושל <span class="math">\(R_{A}\)</span> השתמשנו בהוכחה. ראשית, השתמשנו בכך שאם <span class="math">\(uR_{A}v\)</span> אז <span class="math">\(uzR_{A}vz\)</span> - זו מעין הכללה של מה שקראתי לו "אינוריאנטיות מימין" כי כאן אנחנו משרשרים מצד ימין מילה ולא אות בודדת, אבל די ברור ששתי ההגדרות הללו שקולות (כי אפשר לשרשר את כל <span class="math">\(z\)</span> "אות-אות". כלומר, השתמשנו בכך ש-<span class="math">\(R_{A}\)</span> הוא יחס <strong>אינוריאנטי מימין</strong>. בתכונה השניה של <span class="math">\(R_{A}\)</span> השתמשתי בצורה קצת יותר מובלעת - אמרתי שאם <span class="math">\(uR_{A}v\)</span> אז <span class="math">\(u\in L\iff v\in L\)</span> (איפה?) מכיוון שאפשר לחשוב על <span class="math">\(L\)</span> בתור מגדירה יחס שקילות משל עצמה (שכולל בדיוק שתי מחלקות - <span class="math">\(L\)</span> והמשלימה של <span class="math">\(L\)</span>) נוח לקרוא לתכונה הזו "<span class="math">\(R_{A}\)</span> מעדן את <span class="math">\(L\)</span>".</p>
<p>כעת אני רוצה להכליל את התוצאה שזה עתה הוכחתי: לא רק ש-<span class="math">\(R_{A}\)</span> מעדן את <span class="math">\(R_{L}\)</span>, אלא <strong>כל</strong> יחס שקילות אינוריאנטי מימין שמעדן את <span class="math">\(L\)</span>, מעדן את <span class="math">\(R_{L}\)</span>. למעשה, מן הסתם גם <span class="math">\(R_{L}\)</span> מקיים את אותן שתי תכונות - הוא אינוריאנטי מימין ומעדן את <span class="math">\(L\)</span>. לכן אפשר לומר "<span class="math">\(R_{L}\)</span> הוא יחס השקילות המקסימלי מבין היחסים שהם אינוריאנטיים מימין ומעדנים את <span class="math">\(L\)</span>", כאשר "מקסימלי" הוא ביחס לעידון.</p>
<p>ההוכחה של התוצאה הזו זהה להוכחה שכבר ראינו. אם <span class="math">\(R\)</span> הוא יחס שקילות אינוריאנטי מימין שמעדן את <span class="math">\(L\)</span> אז ניקח <span class="math">\(uRv\)</span> ונוכיח ש-<span class="math">\(uR_{L}v\)</span>: ניקח <span class="math">\(z\)</span>, אז <span class="math">\(uzRvz\)</span> בגלל האינוריאנטיות מימין, ולכן <span class="math">\(uz\in L\iff vz\in L\)</span>, בגלל ש-<span class="math">\(R\)</span> מעדן את <span class="math">\(L\)</span>. למרות שזו הוכחה מגוחכת של שורה אחת אני חושב שהיא מצויינת, כי היא מאפשרת לנו "להרגיש" מה בעצם כל כך מיוחד ביחס <span class="math">\(R_{L}\)</span> ולמה הוא הדבר שהכי טבעי לדבר עליו בהקשר הזה.</p>
<p>כל הדיון הזה היה מופשט למדי, אז בואו נדבר על התכל'ס. נתונה לי שפה <span class="math">\(L\)</span>. מה שמשפט מייהיל-נרוד מאפשר לי לעשות בצורה נוחה הוא להוכיח <strong>חסמים</strong> על מספר המצבים שדרוש לאוטומט סופי דטרמיניסטי כדי לקבל את <span class="math">\(L\)</span>. מצד אחד, אפשר לקבל חסם עליון בצורה הבאה: נותנים יחס שקילות כלשהו שהוא אינוריאנטי מימין ומעדן את <span class="math">\(L\)</span>, ואז מספר מחלקות השקילות שלו הוא חסם עליון שכזה (ובפרט אם הוא סופי זה מוכיח שהשפה רגולרית). מצד שני, אפשר לקבל חסם תחתון על המספר הזה אם מציגים מספר כלשהו של מחלקות שקילות <strong>שונות</strong> של היחס <span class="math">\(R_{L}\)</span> - ואז המספר הזה הוא חסם תחתון, ובפרט אם הצגנו אינסוף מחלקות שקילות אז <span class="math">\(L\)</span> אינה רגולרית.</p>
<p>בואו נתעכב על הכיוון הזה. אני אפילו לא חייב לתת במפורש מחלקות שקילות - מספיק שאתן קבוצה כלשהי של מילים כך שאף זוג מילים מביניהן אינן שקולות, וזה יתן לי את החסם התחתון שלי. זה כלי שימושי מאוד לקבלת הערכה מהירה של כמה מסובך אוטומט עבור שפה כלשהי חייב להיות.</p>
<p>בואו נראה איך את <span class="math">\(L=\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} \)</span> המשפט אוכל בלי מלח. פשוט נסתכל על קבוצת המילים <span class="math">\(\left\{ a^{n}\ |\ n\in\mathbb{N}\right\} \)</span>. זו קבוצה אינסופית. קל לראות שאין בה זוג מילים שקולות: ניקח <span class="math">\(a^{n},a^{k}\)</span> כך ש-<span class="math">\(n\ne k\)</span>, ואז קל להציג <span class="math">\(z\)</span> שמפריד ביניהן: <span class="math">\(z=b^{n}\)</span>, כי <span class="math">\(a^{n}b^{n}\in L\)</span> אבל <span class="math">\(a^{k}b^{n}\notin L\)</span>. זהו.</p>
<p>גם את <span class="math">\(L=\left\{ ww\ |\ w\in\left\{ a,b\right\} ^{*}\right\} \)</span> המשפט אוכל בקלות. נבחר את קבוצת המילים <span class="math">\(\left\{ a^{n}b\ |\ n\in\mathbb{N}\right\} \)</span> ועבור <span class="math">\(a^{n}b,a^{k}b\)</span> מילה מפרידה תהיה <span class="math">\(z=a^{n}b\)</span>, כי בבירור <span class="math">\(a^{k}ba^{n}b\)</span> היא לא מהצורה <span class="math">\(ww\)</span> (כי אם היא כן, אז <span class="math">\(w\)</span> מסתיימת ב-<span class="math">\(b\)</span> כי <span class="math">\(ww\)</span> מסתיימת ב-<span class="math">\(b\)</span>, אבל זה גורר ש-<span class="math">\(w=a^{n}b\)</span> וגם <span class="math">\(w=a^{k}b\)</span>).</p>
<p>נעבור עכשיו לדוגמת הראשוניים, <span class="math">\(L=\left\{ a^{p}\ |\ p\text{ is prime}\right\} \)</span>. מה יוכיח במקרה הזה שהשפה לא רגולרית? קבוצה אינסופית <span class="math">\(A\)</span> של מספרים טבעיים כך שלכל <span class="math">\(a,b\in A\)</span> שונים זה מזה, קיים <span class="math">\(d\)</span> טבעי כך שבדיוק אחד מבין <span class="math">\(a+d,b+d\)</span> הוא מספר ראשוני.</p>
<p>למצוא קבוצה כזו - זה קל. אפילו כל הטבעיים מקיימים את התכונה הזו. אבל להוכיח את זה - זה כבר פחות טריוויאלי. הנה הוכחה אפשרית אחת. ראשית, נניח בלי הגבלת הכלליות ש-<span class="math">\(a<b\)</span>. כעת נמצא ראשוני <span class="math">\(p>b\)</span> כך שכל <span class="math">\(b-1\)</span> המספרים שבאים אחרי <span class="math">\(p\)</span> הם בודאות לא ראשוניים. אם מצאנו כזה, סיימנו, כי אז נסמן <span class="math">\(d=p-a\)</span> ונקבל ש-<span class="math">\(a+d\)</span> ראשוני אבל <span class="math">\(b+d=p+\left(b-a\right)\le p+\left(b-1\right)\)</span> לא ראשוני. למה קיים <span class="math">\(p\)</span> כזה? ובכן, בואו ונסתכל על הקבוצה <span class="math">\(\left\{ b!+2,b!+3,\dots,b!+b\right\} \)</span>. המספר הראשון בקבוצה מתחלק ב-2, השני ב-3 וכן הלאה, ויש בקבוצה בסך הכל <span class="math">\(b-1\)</span> איברים. ניקח את <span class="math">\(p\)</span> להיות הראשוני הגדול ביותר שקטן מ-<span class="math">\(b!+2\)</span> וסיימנו.</p>
<p>מה שנחמד פה הוא שאפשר להפוך את היוצרות: אנחנו כבר יודעים ששפת הראשוניים לא רגולריים כי הוכחנו את זה עם למת הניפוח. אם כן, משפט מייהיל-נרוד מראה ש<strong>קיימת</strong> קבוצה אינסופית של טבעיים שלכל זוג איברים מתוכם קיים <span class="math">\(d\)</span> כך שבדיוק אחד מבין <span class="math">\(a+d,b+d\)</span> הוא ראשוני. והמשפט מראה את זה בצורה שהיא לא קונסטרוקטיבית למדי. כמובן, כאן זה משפט שהוא פשוט בפני עצמו, אבל בכלל לא חשבתי עליו עד שלא נתקלתי בו כתוצאה של מייהיל-נרוד כאן. מתמטיקה זה כיף.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>