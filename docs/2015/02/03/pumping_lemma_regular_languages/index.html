<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>למת הניפוח לשפות רגולריות - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2015/01/29/regular_expressions/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">ביטויים רגולריים</span>
            </a>
            

            
            <a href="/2015/02/11/myhill_nerode_theorem/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">משפט מייהיל-נרוד</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>למת הניפוח לשפות רגולריות</h1>
            <div class="post-meta">
                <span class="date">2015-02-03</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/למת הניפוח.html">למת הניפוח</a>
                    
                    <a href="/tags/שפות רגולריות.html">שפות רגולריות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>עד עכשיו בסדרת הפוסטים שלי על שפות רגולריות נראה לי שהצלחנו לקבל מושג לא רע לגבי מה הן: ראינו מצד אחד אפיון שלהן בתור שפות שניתנות לזיהוי על ידי מספר מודלי חישוב (אוטומטים), ומצד שני אפיון שלהן בתור קבוצה אינדוקטיבית של שפות שניתן להרכיב מתוך השפות הסופיות על ידי איחוד, שרשור וסגור-קלייני, והאפיון הזה גם נתן לנו שיטת תיאור נוחה לשפות כאלו - ביטויים רגולריים. ראינו שהן מקיימות שלל תכונות סגור נוספות. מה שלא באמת ראינו עד עכשיו הוא שיטה שתאפשר לנו לזהות מתי שפה <strong>איננה </strong>רגולרית.</p>
<p>להראות ששפה נתונה איננה רגולרית זה עניין מורכב. נניח שאנחנו מנסים לבנות אוטומט לשפה הזו ולא מצליחים - האם זה אומר שהשפה לא רגולרית? לאו דווקא - אולי אנחנו פשוט גרועים בבניית אוטומטים. כדי להראות שהשפה אינה רגולרית צריך להוכיח ש<strong>כל</strong> בניה של אוטומט, ולא משנה כמה מתוחכם בונה האוטומטים יהיה, תיכשל. ואיך ייראה "כישלון" שכזה? ובכן, רמז אפשר למצוא בהוכחה שכן הראיתי בעבר לכך ש-<span class="math">\(L=\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} \)</span> אינה רגולרית - שם הראיתי שאם אוטומט מקבל מילה ארוכה דיו ששייכת לשפה, אז הוא בהכרח "יתבלבל" ויקבל גם מילה אחרת שאינה שייכת לשפה.</p>
<p>את ההוכחה שהראיתי אז אפשר להכליל בקלות רבה ולקבל כלי נשק מועיל מאוד בהוכחה כללית ששפות אינן רגולריות, מבלי לטרוח ולחזור שוב ושוב על הטיעון מבוסס האוטומטים. בניסוח "נקי" בכלל לא צריך לדבר על אוטומטים. כדי לא להשאיר אתכם במתח אציג את הניסוח הזה עכשיו, אבל אזהיר מראש שהוא לא טריוויאלי להבנה אז לא לדאוג - הכל יתברר בהמשך.</p>
<p>אם כן, הנה למת הניפוח לשפות רגולריות: אם <span class="math">\(L\)</span> אם היא שפה רגולרית אז קיים קבוע <span class="math">\(n\ge1\)</span> כך שלכל <span class="math">\(z\in L\)</span> מאורך <span class="math">\(\left|z\right|\ge n\)</span> קיים פירוק <span class="math">\(z=uvw\)</span> המקיים ש-<span class="math">\(\left|uv\right|\le n\)</span>, ו-<span class="math">\(\left|v\right|\ge1\)</span> ולכל <span class="math">\(i\ge0\)</span> מתקיים <span class="math">\(uv^{i}w\in L\)</span>.</p>
<p>אני חושב שיהיה הרבה יותר קל להבין את הלמה אחרי שנראה את ההוכחה. אז בואו נתחיל. מכיוון ש-<span class="math">\(L\)</span> רגולרית אז קיים אוטומט סופי דטרמיניסטי <span class="math">\(A\)</span> כך ש-<span class="math">\(L\left(A\right)=L\)</span>. נסמן <span class="math">\(\left|Q\right|=n\)</span>, דהיינו הקבוע <span class="math">\(n\)</span> שלנו יהיה מספר מצבי האוטומט. כעת ניקח מילה <span class="math">\(z\in L\)</span> המקיימת <span class="math">\(\left|z\right|\ge n\)</span>. מהנתון הראשון עולה ש-<span class="math">\(\hat{\delta}\left(q_{0},z\right)\in F\)</span> - קריאת המילה מביאה אותנו למצב מקבל. הנתון השני אומר שריצת <span class="math">\(A\)</span> על <span class="math">\(z\)</span> כוללת לפחות <span class="math">\(n\)</span> צעדים. אחרי שביצענו <span class="math">\(k\)</span> צעדים, האוטומט כבר ביקר ב-<span class="math">\(k+1\)</span> מצבים, לאו דווקא שונים (כי יש את המצב שבו הוא התחיל, ואחרי כל צעד הוא משנה את המצב שלו). לכן אחרי קריאת <span class="math">\(n\)</span> התווים הראשונים של <span class="math">\(z\)</span>, מעקרון שובך היונים נקבל ש-<span class="math">\(A\)</span> היה במצב כלשהו פעמיים. נסמן את המצב הזה ב-<span class="math">\(p\)</span>, וכעת נפרק את <span class="math">\(z\)</span> לשלושה חלקים <span class="math">\(z=uvw\)</span> באופן הבא: <span class="math">\(u\)</span> היא תת-המילה שהביאה את האוטומט אל <span class="math">\(p\)</span> בפעם הראשונה; <span class="math">\(v\)</span> היא תת המילה שהביאה אותו אל <span class="math">\(p\)</span> בפעם השניה; ו-<span class="math">\(w\)</span> זה כל היתר.</p>
<p>מייד ברור שאכן מתקיים <span class="math">\(\left|uv\right|\le n\)</span> מהנימוק שנתתי קודם - אחרי <span class="math">\(n\)</span> הצעדים הראשונים כבר היה מצב שהופיע פעמיים, ולכן כל המילה שאנחנו מספיקים לקרוא עד הפעם השניה שבה הגענו למצב הזה לא ארוכה מ-<span class="math">\(n\)</span>. גם ברור ש-<span class="math">\(\left|v\right|\ge1\)</span> כי אחרת היינו מקבלים ש"הפעם הראשונה" ו"הפעם השניה" שבה האוטומט מבקר ב-<span class="math">\(p\)</span> הן אותה פעם, בסתירה לכך שזה מצב שאנחנו רואים פעמיים. נשאר רק להוכיח שהדבר הזה עם ה-<span class="math">\(uv^{i}w\)</span> מתקיים. זה פשוט למדי אחרי שמסכמים את מה שאנחנו כבר יודעים באיור הזה, שהוא וריאציה על האיור מהפוסט הראשון עם <span class="math">\(\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} \)</span>:</p>
<p><strong><a href="/img/2015/02/pumping_lemma2.png"><img class="aligncenter size-large wp-image-3221" alt="pumping_lemma2" src="/img/2015/02/pumping_lemma2.png" width="584" height="159" /></a></strong></p>
<p>מה שקורה פה הוא פשוט שלא משנה כמה פעמים נחזור על הלולאה באמצע או נוותר עליה בכלל - בסוף עדיין נגיע למצב מקבל. כמובן, הוכחה באמצעות איור אינה לגיטימית, אז הנה הפורמליזם למי שזה באמת חשוב לו:</p>
<p><span class="math">\(\hat{\delta}\left(q_{0},u\right)=p\)</span></p>
<p><span class="math">\(\hat{\delta}\left(p,v\right)=p\)</span></p>
<p><span class="math">\(\hat{\delta}\left(p,w\right)\in F\)</span></p>
<p>טריוויאלי להוכיח ש-<span class="math">\(\hat{\delta}\left(p,v^{i}\right)=p\)</span> לכל <span class="math">\(i\ge0\)</span> (באינדוקציה, כמובן), ומכאן זה סתם משחק בסימבולים:</p>
<p><span class="math">\(\hat{\delta}\left(q_{0},uv^{i}w\right)=\hat{\delta}\left(\hat{\delta}\left(\hat{\delta}\left(q_{0},u\right),v^{i}\right),w\right)=\hat{\delta}\left(\hat{\delta}\left(p,v^{i}\right),w\right)=\hat{\delta}\left(p,w\right)\in F\)</span></p>
<p>ועל כן <span class="math">\(uv^{i}w\in L\left(A\right)=L\)</span>. הוכחה קלה ופשוטה ואלגנטית ויפה מאוד.</p>
<p>אבל איך זה עוזר לנו להוכיח ששפה היא <strong>לא</strong> רגולרית?</p>
<p>אפשר לחשוב על הלמה בתור סוג של משחק לשני שחקנים, אליס ובוב. המשחק מתנהל עבור שפה מסויימת <span class="math">\(L\)</span> שבוב טוען שאינה רגולרית ואליס מנסה להקשות עליו את החיים (אני בכוונה לא כותב "ואליס טוענת שהיא כן רגולרית" כי כלל לא ניתן לטעון את זה, ואני אחזור לנקודה הזו בפירוט בהמשך). המשחק מתנהל כך: ראשית כל אליס אומרת מספר טבעי <span class="math">\(n\)</span> כלשהו. עכשיו בוב מגיב למהלך של אליס בכך שהוא מספק מילה <span class="math">\(z\in L\)</span> שמקיימת <span class="math">\(\left|z\right|\ge n\)</span> (שימו לב שהמהלכים הללו אינם בלתי תלויים - המילה שבוב נותן תלויה ב-<span class="math">\(n\)</span> שאליס אמרה). כעת אליס מציעה פירוק <span class="math">\(z=uvw\)</span> כלשהו, ולכך בוב משיב עם מספר טבעי <span class="math">\(i\ge0\)</span>. ואז בודקים מה קורה. אם <span class="math">\(uv^{i}w\in L\)</span> אז אליס ניצחה, ואחרת בוב ניצח.</p>
<p>הטענה שלי היא שאם <span class="math">\(L\)</span> היא שפה רגולרית אז אליס תמיד יכולה להבטיח את הנצחון שלה במשחק אם תשחק היטב. את הטענה הזו ניתן לנסח באופן שקול, שלילי באופיו: אם אליס <strong>אינה</strong> יכולה להבטיח את הנצחון שלה במשחק, אז <span class="math">\(L\)</span> בודאות אינה רגולרית. כלומר, כשאנחנו באים להראות ששפה אינה רגולרית אנחנו בעד בוב ואנחנו צריכים להסביר איך הוא יוכל להביס את אליס. לשם כך, בואו ננסח מחדש את הלמה בגרסה ה"שלילית" שלה (שהיא שקולה לוגית לגרסה שנתתי):</p>
<p>עבור שפה <span class="math">\(L\)</span> כלשהי, אם <strong>לכל</strong> קבוע <span class="math">\(n\ge1\)</span> <strong>קיימת</strong> מילה <span class="math">\(z\in L\)</span> עם <span class="math">\(\left|z\right|\ge n\)</span> כך ש<strong>לכל</strong> פירוק <span class="math">\(z=uvw\)</span> המקיים <span class="math">\(\left|uv\right|\le n\)</span> ו-<span class="math">\(\left|v\right|\ge1\)</span><strong>קיים</strong> <span class="math">\(i\ge0\)</span> כך ש-<span class="math">\(uv^{i}w\notin L\)</span> - אם זה קורה, אז <span class="math">\(L\)</span> אינה רגולרית.</p>
<p>בואו נשחק את המשחק עבור <span class="math">\(L=\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} \)</span> הישנה והטובה. את המשחק מתחילה אליס, בכך שהיא זורקת קבוע <span class="math">\(n\)</span> כלשהו לחלל האוויר. אני לא מניח שום דבר על <span class="math">\(n\)</span> פרט לכך שזה מספר טבעי חיובי. עכשיו אני צריך להסביר איך בוב יכול להגיב ל-<span class="math">\(n\)</span> הזה של אליס בצורה שעדיין תאפשר לו לנצח במשחק. למרבה המזל, במשחק על השפה <span class="math">\(L\)</span> שלנו קל לתת תשובה כללית, שאמנם תלויה ב-<span class="math">\(n\)</span> אבל מתאימה לתבנית פשוטה - בוב פשוט יגיד את המילה <span class="math">\(z=a^{n}b^{n}\)</span>. בוודאי שמתקיים <span class="math">\(\left|z\right|\ge n\)</span> (למעשה, <span class="math">\(\left|z\right|=2n\)</span>; אין שום בעיה עם כך שהאורך של <span class="math">\(z\)</span> <strong>גדול</strong> מ-<span class="math">\(n\)</span> ובקרוב נראה שזה אפילו מועיל מאוד) ובוודאי שמתקיים <span class="math">\(z\in L\)</span>.</p>
<p>עכשיו אליס מגיבה בפירוק כלשהו של <span class="math">\(z\)</span>: <span class="math">\(z=uvw\)</span>. כמקודם, אנחנו לא יכולים להניח שום דבר על הפירוק, <strong>פרט לכך</strong> שהוא מציית לתנאי הלמה. אבל אלו תנאים <strong>לא טריוויאליים</strong>: ראשית, <span class="math">\(\left|v\right|\ge1\)</span>, אבל שנית וחשוב בהרבה מכך, <span class="math">\(\left|uv\right|\le n\)</span>. התנאי הקטן הזה הוא שמאפשר לבוב להביס את אליס - בלעדיו, לא הייתה לו תקווה לנצח במשחק, כפי שאראה עוד רגע. כדי להבין למה הוא כל כך מועיל, בואו נראה את המשמעות שלו - המשמעות היא ש-<span class="math">\(uv\)</span> נמצאת כולה <strong>בחצי הראשון</strong> של <span class="math">\(a^{n}b^{n}\)</span>; כלומר, <span class="math">\(uv\)</span> כוללים רק <span class="math">\(a\)</span>-ים. לכן אפשר לסמן <span class="math">\(u=a^{k},v=a^{t}\)</span> עם הנתון <span class="math">\(t\ge1\)</span>, ולכן. וכעת מגיע מהלך הניצחון של בוב: הוא יבחר <span class="math">\(i=0\)</span> ונקבל ש-<span class="math">\(uv^{i}w=uv^{0}w=uw=a^{n-t}b^{n}\)</span> (למה <span class="math">\(n-t\)</span>? כי הורדנו מ-<span class="math">\(a^{n}\)</span> בדיוק את ה-<span class="math">\(a\)</span>-ים שהיו שייכים ל-<span class="math">\(v\)</span>, וכאלו יש <span class="math">\(t\)</span>). מכיוון ש-<span class="math">\(t\ge1\)</span> הרי ש-<span class="math">\(n-t\ne n\)</span>, ולכן <span class="math">\(a^{n-t}b^{n}\notin L\)</span>, ובוב ניצח. הוכחנו שהשפה לא רגולרית.</p>
<p>עכשיו, מה היה קורה אם אליס לא הייתה מוגבלת על ידי האילוץ <span class="math">\(\left|uv\right|\le n\)</span>? היא תמיד הייתה מנצחת במשחק עם המהלך המבריק הבא: לא משנה איזו מילה <span class="math">\(z=a^{n}b^{n}\)</span> בוב זרק לחלל האוויר, היא תבחר את הפירוק <span class="math">\(u=a^{n-1},v=ab,w=b^{n-1}\)</span>. קל לראות ש-<span class="math">\(uv^{i}w=a^{n-1+i}b^{n-1+i}\in L\)</span> תמיד. לכן למת הניפוח בלי <span class="math">\(\left|uv\right|\le n\)</span> הייתה <strong>חסרת ערך</strong> כבר נגד שפה פשוטה כמו <span class="math">\(L\)</span>. חשוב לי להדגיש את הנקודה הזו כי האילוץ <span class="math">\(\left|uv\right|\le n\)</span> נראה קצת מלאכותי כשקוראים לראשונה את תיאור הלמה - לא ברור למה מתעקשים להתעסק איתו, כשיותר "טבעי" פשוט לא לדבר עליו. אז זו הסיבה - בלעדיו הלמה <strong>לא שימושית</strong>. כמובן, אני מניח שדי ברור לנו שהאילוץ הזה הוא לא הדבר הכי חזק שיכלנו לדרוש ואפשר להכליל אותו עוד קצת - נדבר על זה בסוף, אחרי שנראה דברים שעליהם הלמה כושלת.</p>
<p>בואו נראה עכשיו עוד שימוש של הלמה, הפעם עבור <span class="math">\(L=\left\{ ww\ |\ w\in\Sigma^{*}\right\} \)</span> (כאשר <span class="math">\(\left|\Sigma\right|\ge2\)</span> - למשל, <span class="math">\(\Sigma=\left\{ a,b\right\} \)</span>). כמקודם, אליס נותנת <span class="math">\(n\)</span> ובוב נותן מילה. מפתה אולי לתת את המילה <span class="math">\(a^{n}b^{n}\)</span> שבה השתמשנו קודם, אבל <span class="math">\(a^{n}b^{n}\notin L\)</span> כי היא לא בנויה מחזרה על אותה תת-מילה פעמיים. אז אפשר פשוט להכפיל אותה: נגדיר <span class="math">\(z=a^{n}b^{n}a^{n}b^{n}\)</span>. עכשיו, כמו קודם, כל פירוק שאליס תיתן יהיה בהכרח מהצורה <span class="math">\(u=a^{k},v=a^{t}\)</span> ולכן עבור <span class="math">\(i=0\)</span> נקבל ש-<span class="math">\(uv^{i}w=uw=a^{n-t}b^{n}a^{n}b^{n}\)</span>. צריך עכשיו לתת עוד נימוק קצר שמסביר למה לא קיימת <span class="math">\(w\)</span> כך ש-<span class="math">\(ww=a^{n-t}b^{n}a^{n}b^{n}\)</span>, אבל זה די ברור (יש בדיוק אפשרות אחת ל-<span class="math">\(w\)</span> כזו - שאורכה הוא בדיוק <span class="math">\(\frac{4n-t}{2}\)</span>, וקל לראות שהיא לא תעבוד).</p>
<p>בינתיים אולי מתקבל הרושם שכל הקטע הזה עם <span class="math">\(i\)</span> מיותר ושתמיד אפשר לבחור <span class="math">\(i=0\)</span>. אז בואו נסתכל על דוגמה נחמדה יותר וכנראה שגם מעניינת יותר. הפעם <span class="math">\(\Sigma=\left\{ a\right\} \)</span> ולכן אפשר לחשוב על כל שפה בתור אוסף של מספרים טבעיים בייצוג אונרי. בואו נסתכל על שפת כל הראשוניים: <span class="math">\(L=\left\{ a^{p}\ |\ p\text{ is prime}\right\} \)</span>. איך נפיל אותה?</p>
<p>אליס נותנת <span class="math">\(n\)</span>. בוב, בתגובה, נותן <span class="math">\(z=a^{p}\)</span> כאשר <span class="math">\(p\)</span> ראשוני המקיים <span class="math">\(p\ge n\)</span>. כבר יש לנו טענה עם תחכום מתמטי לא טריוויאלי - איך אנחנו יודעים שראשוני כזה קיים? התשובה היא שקימים אינסוף ראשוניים. ההוכחה הסטנדרטית (של אוקלידס) לטענה הזו היא פשוטה - נניח שיש מספר סופי של ראשוניים, אז נכפול את כולם ונחבר 1 לתוצאה, והנה קיבלנו מספר שאינו מתחלק על ידי אף אחד מהראשוניים הללו אבל חייב להיות ראשוני כלשהו שמחלק אותו, או שהוא בעצמו יהיה ראשוני. יש עוד הוכחות משעשעות - <a href="http://www.gadial.net/2009/05/17/euler_proof_infinity_of_primes/">הנה</a> אחת עם אנליזה, והנה <a href="http://www.gadial.net/2009/03/16/topological_proof_infinity_of_primes/">אחת</a> עם טופולוגיה.</p>
<p>אליס, בתגובה, נותנת פירוק <span class="math">\(z=uvw\)</span>. מכיוון ש-<span class="math">\(z\)</span> מורכבת כולה מ-<span class="math">\(a\)</span>-ים, אפשר לתאר את הפירוק הזה בתור <span class="math">\(u=a^{k},v=a^{t},w=a^{p-\left(k+t\right)}\)</span>, כאשר <span class="math">\(k+t\le n\)</span> ו-<span class="math">\(t\ge1\)</span>. וכעת עולה השאלה - איזה <span class="math">\(i\)</span> כדאי לבוב לבחור?</p>
<p>מה שאנחנו רוצים לעשות הוא לבחור <span class="math">\(i\)</span> כזה שעבורו <span class="math">\(uv^{i}w\notin L\)</span>. כעת, <span class="math">\(uv^{i}w=a^{k}a^{it}a^{p-\left(k+t\right)}=a^{p+\left(i-1\right)t}\)</span>. לכן אנחנו רוצים לבחור <span class="math">\(i\)</span> שעבורו <span class="math">\(p+\left(i-1\right)t\)</span> בודאות אינו ראשוני. אם נבחר <span class="math">\(i=0\)</span> זה לא יבטיח זאת; למשל, אם <span class="math">\(p=17\)</span> ו-<span class="math">\(t=4\)</span> אז <span class="math">\(p+\left(0-1\right)t=13\)</span> וגם <span class="math">\(13\)</span> ראשוני.</p>
<p>אז מה עושים? פשוט מאוד: בוחרים <span class="math">\(i=p+1\)</span> ומקבלים ש-<span class="math">\(p+\left(i-1\right)t=p+pt=p\left(t+1\right)\)</span>, וזה בבירור לא מספר ראשוני כי הוא שווה למכפלה של <span class="math">\(p\)</span> ושל <span class="math">\(t+1\)</span> שהוא לפחות 2.</p>
<p>נראה לי שאלו מספיק דוגמאות כדי שנבין את הרעיון הכללי ועד כמה הלמה הזו נוחה. עכשיו בואו נעבור לחדשות המצערות - היא לא תמיד עובדת. דהיינו, היא לא משפט של "אם ורק אם" - ייתכנו שפות לא רגולריות שעדיין מקיימות את תנאי הלמה - כלומר, שאליס מנצחת במשחק עליהן. בואו נראה איך אפשר לבנות כזו.</p>
<p>נתחיל משפה שאנחנו כבר יודעים שהיא קשה - נאמר, שפת הראשוניים <span class="math">\(L\)</span>. אם אנחנו רוצים "לנטרל" את למת הניפוח, נוכל לתקוע בהתחלה של מילים איזור שנראה כמו שפה רגולרית, ורק אחרי האיזור הזה יגיע החלק הלא רגולרי. אז נעשה את התעלול הבא: נסתכל על השפה <span class="math">\(b^{*}L\)</span>, כלומר כל המילים שמתחילות ברצף מאורך כלשהו של <span class="math">\(b\)</span>-ים ואז <span class="math">\(a\)</span> בחזקת מספר ראשוני. כעת, אם בוב נותן לנו מילה מהצורה <span class="math">\(z=bz^{\prime}\)</span>, ולא משנה בכלל איך <span class="math">\(z^{\prime}\)</span> נראה, אליס תמיד תוכל לבחור <span class="math">\(u=\varepsilon,v=b,w=z^{\prime}\)</span> ונקבל ש-<span class="math">\(uv^{i}w\)</span> שייך לשפה החדשה שלנו.</p>
<p>למה זה עדיין לא עובד? כי בוב יכול לתת לנו מילה שלא מתחילה ב-<span class="math">\(b\)</span> בכלל. לכן נשתמש בעוד תעלול: "נטביע" את <span class="math">\(L\)</span> בתוך <span class="math">\(a^{*}\)</span>. כלומר, השפה שאני בונה היא השפה <span class="math">\(a^{*}\cup b^{*}L\)</span>. כעת, אם בוב יתן בתור <span class="math">\(z\)</span> מילה כלשהי שכוללת רק <span class="math">\(a\)</span>-ים, אז לא משנה בכלל איזה פירוק נבחר עבורה - עדיין נקבל משהו ששייך ל-<span class="math">\(a^{*}\)</span> לכל <span class="math">\(i\)</span> שבוב יבחר. ניצחון קל של אליס.</p>
<p>השפה הזו עדיין נותרת לא רגולרית, כמובן, למרות המניפוליצות שעשינו לה, כי המרכיב ה"קשה" שלה נותר בצורה שאפשר לשחזר אותו: <span class="math">\(L=h\left(\left(a^{*}\cup b^{*}L\right)\cap b\Sigma^{*}\right)\)</span> כאשר <span class="math">\(h\)</span> הוא הומומורפיזם המקיים <span class="math">\(h\left(b\right)=\varepsilon\)</span> ו-<span class="math">\(h\left(a\right)=a\)</span>. זו סיבה עיקרית למה הגרסה של הלמה כפי שהצגתי אותה היא מספיקה לרוב הצרכים שלנו, במקום הגרסה הכללית יותר שאציג עוד מעט - בגלל שכדי להוכיח ששפה אינה רגולרית לא חייבים להשתמש עליה בלמה; מספיק להעביר אותה באמצעות תכונות סגור לשפה שכן פגיעה ללמה (ואפילו אם השפה המקורית פגיעה ללמה בעצמה, לפעמים יותר קל לטפל בשפה שמתקבלת ממנה אחרי הפעלת כמה תכונות סגור). הנשק העיקרי שלנו בהתמודדות עם שפות הוא תכונות סגור, כי הן מאפשרות לנו לפשט אותן במאמץ כמעט אפסי, וזה ניכר כאן.</p>
<p>בואו נעבור לדבר עכשיו על הגרסה הכללית של הלמה. הצבעתי על כך שהאילוץ <span class="math">\(\left|uv\right|\le n\)</span> הוא האילוץ הקריטי כדי שהלמה תהיה שימושית. עכשיו, כדאי לשים לב לכך שבמובן מסויים האילוץ הזה הוא עדיין די חלש. אם נתבונן על ההוכחה של הלמה, היינו יכולים לעשות תעלול דומה עבור <strong>סוף</strong> המילה ולא תחילתה. כלומר, במקום <span class="math">\(\left|uv\right|\le n\)</span> היינו מקבלים את התנאי <span class="math">\(\left|vw\right|\le n\)</span>. זה היה מחסל, למשל, את השפה <span class="math">\(a^{*}\cup b^{*}L\)</span>. אבל זה כמובן לא הסוף - אפשר לבנות שפה חדשה, שתהיה חסינה גם לגרסה הזו של הלמה - <span class="math">\(a^{*}\cup b^{*}Lc^{*}\)</span>. כאן ריפדנו גם את ההתחלה וגם את הסוף של <span class="math">\(L\)</span> בג'יבריש שמונע מהלמה - שמתמקדת בקצוות - לתפוס את החלק האמצעי ה"לא רגולרי".</p>
<p>אז איך מתמודדים עם זה? אם חושבים קצת על ההוכחה של הלמה ברור שהדבר היחיד שמעניין אותנו הוא שיש שלב <strong>כלשהו</strong> בריצת האוטומט שבו הוא מבצע לפחות <span class="math">\(n\)</span> צעדים. אלו לא חייבים להיות <span class="math">\(n\)</span> הצעדים הראשונים או האחרונים. די בבירור אפשר לנסח את הלמה בתור: לכל <span class="math">\(z\in L\)</span> כך ש-<span class="math">\(\left|z\right|\ge n\)</span> קיים פירוק <span class="math">\(z=uvwxy\)</span> כך ש-<span class="math">\(\left|vw\right|\le n\)</span> או <span class="math">\(\left|wx\right|\le n\)</span> ו-<span class="math">\(\left|w\right|\ge1\)</span> ו-<span class="math">\(uvw^{i}xy\in L\)</span> לכל <span class="math">\(i\ge0\)</span>. כאן <span class="math">\(u\)</span> זה החלק של תחילת המילה שעליו אנחנו רוצים לדלג לפני שאנחנו מתחילים לספור <span class="math">\(n\)</span> צעדים, אם סופרים מההתחלה לסוף; ו-<span class="math">\(y\)</span> זה החלק בסוף שעליו אנחנו רוצים לדלג אם סופרים מהסוף להתחלה.</p>
<p>אבל הניסוח הזה לא טוב לנו בכלל, כי צריך לזכור שוב מה המטרה שלנו עם הלמה - להוכיח ששפות הן לא רגולריות. אם אנחנו נותנים <strong>יותר</strong> גמישות בבחירת פירוקים, אנחנו עוזרים דווקא לאליס, ולא לבוב. למשל, את המילה <span class="math">\(a^{n}b^{n}\)</span> בדוגמה הראשונה שלי אליס תוכל עכשיו לפרק בתור <span class="math">\(u=a^{n-1},v=\varepsilon,w=ab,x=\varepsilon,u=b^{n-1}\)</span>, ואז בוב אכל אותה. כלומר, הניסוח ה"כללי" של הלמה הוא שימושי <strong>פחות</strong>. ועם זאת ברור שצריכה להיות דרך להכליל את הלמה כדי שתוכל לתפוס דווקא יותר מקרים. אז מה עושים?</p>
<p>התשובה היא שעושים משהו טיפה מחוכם. במקום לתת לאליס לבחור את <span class="math">\(u,v\)</span> נותנים ל<strong>בוב</strong> לבחור אותם, כבר כשהוא נותן את המילה <span class="math">\(z\)</span>. הביטו בניסוח הבא:</p>
<p>אם <span class="math">\(L\)</span> רגולרית אז קיים <span class="math">\(n\ge1\)</span> כך שלכל מילה <span class="math">\(z\)</span> ופירוק שלה <span class="math">\(z=uvw\)</span>, קיים פירוק <span class="math">\(v=xy\)</span> כך ש-<span class="math">\(\left|xy\right|\le n\)</span> ו-<span class="math">\(\left|y\right|\ge1\)</span> ו-<span class="math">\(uxy^{i}w\in L\)</span> לכל <span class="math">\(i\ge0\)</span>.</p>
<p>זה גם כן לא הניסוח הכי כללי, כי אפשר גם להחליף את תפקידי <span class="math">\(x,y\)</span> כך ש-<span class="math">\(x\)</span> יהיה זה שמנפחים, אבל נעזוב את זה. אני חושב שהרעיון הכללי כבר ברור. לרוע המזל, גם בניסוח הכללי ביותר למת הניפוח היא עדיין לא משפט של "אם ורק אם" - יש שפות לא רגולריות שמקיימות את תנאי הלמה. עוד יותר לרוע המזל אני לא מכיר אף דוגמה פשוטה, כך שלא אציג כאן דוגמאות.</p>
<p>לסיום, טיזר: הנושא של למת הניפוח מביא אותנו באופן טבעי אל משפט ש<strong>כן</strong> נותן אפיון של "אם ורק אם" לשפות הרגולריות - ועושה את זה בעזרת כלים חדשים ולא צפויים, שנותנים תובנה יפה ביותר לגבי "מה בעצם הולך שם" ומה המשמעות הפורמלית של זה ששפה לא רגולרית היא כזו שדורשת "זכרון לא חסום", ומה האוטומט ה<strong>מינימלי</strong> עבור שפה נתונה. המשפט הזה נקרא משפט מייהיל-נרוד והוא יהיה נושא הפוסט הבא.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>