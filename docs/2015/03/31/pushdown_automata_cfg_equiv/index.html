<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>שקילות אוטומט מחסנית ודקדוק חסר הקשר - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2015/03/31/pushdown_automata_cfg_equiv/">
    <meta property="og:title" content="שקילות אוטומט מחסנית ודקדוק חסר הקשר">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2015/03/31/pushdown_automata_cfg_equiv/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="שקילות אוטומט מחסנית ודקדוק חסר הקשר">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <a href="/lecture_notes.html">סיכומי הרצאות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2015/03/22/pushdown_automata/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">אוטומט מחסנית</span>
            </a>
            

            
            <a href="/2015/04/15/pumping_lemma_cf/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">שפות חסרות הקשר - למת הניפוח, הלמה של אוגדן ושפות רב משמעיות</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>שקילות אוטומט מחסנית ודקדוק חסר הקשר</h1>
            <div class="post-meta">
                <span class="date">2015-03-31</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אוטומט מחסנית.html">אוטומט מחסנית</a>
                    
                    <a href="/tags/דקדוק חסר הקשר.html">דקדוק חסר הקשר</a>
                    
                    <a href="/tags/שפות חסרות הקשר.html">שפות חסרות הקשר</a>
                    
                    <a href="/tags/שפות פורמליות.html">שפות פורמליות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p><a href="http://www.gadial.net/2015/03/22/pushdown_automata/">בפוסט הקודם</a> הצגתי את המודל של <strong>אוטומט מחסנית</strong>. המטרה הייתה להציג מודל של אוטומט שמחלקת השפות שמתאימה לו היא בדיוק מחלקת השפות חסרות ההקשר. לצורך זה, חשבתי על אלגוריתם פשוט לזיהוי שפה של דקדוק חסר הקשר כלשהו, ואז לקחתי מודל של אוטומט שמסוגל לממש בקלות את האלגוריתם הזה. בכך הוכחתי את הכיוון ה"קל" - שאוטומט מחסנית מקבל כל שפה חסרת הקשר. עכשיו הגיע הזמן לכיוון הקשה יותר - שהשפה של אוטומט מחסנית היא תמיד חסרת הקשר - דהיינו, שבהינתן אוטומט מחסנית <span class="math">\(M\)</span> קיים דקדוק חסר הקשר <span class="math">\(G\)</span> כך ש-<span class="math">\(L\left(G\right)=L\left(M\right)\)</span>. זה קשה, כי אנחנו צריכים איכשהו "לסמלץ" אוטומט עם דקדוק, מה שנראה לא קשור בעליל במבט ראשון ואכן ידרוש מאיתנו בניה חכמה למדי - כנראה הדבר הכי מסובך שראינו עד כה בסדרת הפוסטים על שפות פורמליות, אבל עדיין לא משהו <strong>עד כדי כך</strong> מסובך, לא לדאוג.</p>
<p>בואו ניסגר מראש על הפורמליסטיקה. ניקח אוטומט מחסנית <span class="math">\(M=\left(Q,\Sigma,\Gamma,q_{0},\bot,\delta,\emptyset\right)\)</span> עם קבוצת מצבים <span class="math">\(Q\)</span>, א"ב קלט ומחסנית <span class="math">\(\Sigma,\Gamma\)</span> בהתאמה, מצב התחלתי <span class="math">\(q_{0}\)</span> וסימן תחתית מחסנית <span class="math">\(\bot\)</span> ופונקציית מעברים <span class="math">\(\delta\)</span>, כך ש-<span class="math">\(\delta\left(q,\sigma,A\right)\)</span>, עבור <span class="math">\(\sigma\in\Sigma\cup\left\{ \varepsilon\right\} \)</span> ו-<span class="math">\(A\in\Gamma\)</span>, היא קבוצה של זוגות <span class="math">\(\left(p,\beta\right)\)</span> שפירושם "במצב <span class="math">\(q\)</span> אחרי קריאת <span class="math">\(\sigma\)</span> ועם <span class="math">\(A\)</span> בראש המחסנית אפשר לעבור למצב <span class="math">\(p\)</span> ולדחוף <span class="math">\(\beta\)</span> במקום <span class="math">\(A\)</span>". קבוצת המצבים המקבלים תהיה ריקה כי אני אתעניין רק באוטומט שמקבל על ידי ריקון (לכל אוטומט שמקבל על ידי מצבים מקבלים יש אוטומט שקול שמקבל על ידי ריקון). כלומר, שפת האוטומט מוגדרת כך:</p>
<p><span class="math">\(L\left(M\right)=\left\{ w\in\Sigma^{*}\ |\ \exists p\in Q:\left[q_{0},w,\bot\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\right\} \)</span></p>
<p>כאשר <span class="math">\(\left[q,w,\alpha\right]\)</span> היא <strong>קונפיגורציה</strong> של האוטומט שמתארת את המצב הנוכחי <span class="math">\(q\)</span>, הקלט שנותר <span class="math">\(w\)</span> ותוכן המחסנית <span class="math">\(\alpha\)</span>, והסימן <span class="math">\(\vdash^{*}\)</span> אומר "אפשר לעבור מהקונפיגורציה השמאלית לימנית ב-0 או יותר צעדים".</p>
<p>עכשיו, איך ניגשים לבניה שלנו? במבט ראשון זה נראה מפחיד ואין לנו מושג מאיפה להתחיל, כי דקדוק זה משהו שמייצר מילים על ידי כך שהוא משליך הרבה אותיות לפה ולשם ופתאום יש מילה מוגמרת, ולעומת זאת אוטומט עובר סדרתית על אותיות ועושה חישובים וכדומה. אבל בעצם, אם חושבים על זה, כבר ראינו משהו דומה - דקדוק שמסמלץ אוטומט סופי דטרמיניסטי. שם הרעיון היה כזה: משתני הדקדוק היו <span class="math">\(Q\)</span>, הטרמינלים היו <span class="math">\(\Sigma\)</span> ולכל מעבר <span class="math">\(\delta\left(q,\sigma\right)=p\)</span> היה לנו את כלל הגזירה <span class="math">\(q\to\sigma p\)</span>. כך הדקדוק יצר את המילה "אות אחרי אות" כשהסימן הימני ביותר בתבנית הפסוקית שבמהלך הבניה תמיד תיאר את המצב הנוכחי של האוטומט - בעצם, אם חושבים על זה, זה סוג של תיאור של ה<strong>קונפיגורציה</strong> שלו (רק בלי "מה שנשאר מהקלט").</p>
<p>אז למה לא לעשות בניה דומה עבור אוטומט מחסנית? הרי ההבדל היחיד הוא שעכשיו יש לנו גם מחסנית. למה לא לתאר את הקונפיגורציה הנוכחית של האוטומט בלי שארית הקלט בתור זוג <span class="math">\(\left(q,\alpha\right)\)</span> כאשר <span class="math">\(\alpha\in\Gamma^{*}\)</span> ולכל מעבר <span class="math">\(\left(p,\beta\right)\in\delta\left(q,\sigma,A\right)\)</span> להוסיף את הגזירה הבאה בדקדוק: <span class="math">\(\left(q,A\alpha\right)\to\sigma\left(p,\beta\alpha\right)\)</span>?</p>
<p>התשובה פשוטה מאוד - כי הדקדוק שנקבל יהיה בעל <strong>אינסוף משתנים</strong> - כי הרי יש לנו אינסוף זוגות <span class="math">\(\left(q,\alpha\right)\)</span> עם <span class="math">\(\alpha\in\Gamma^{*}\)</span> שהרי הגודל של המחסנית של האוטומט לא חסום. הכשלון הזה לא מפתיע במיוחד כי אם הוא היה מצליח, מה שהיינו בונים הוא <strong>דקדוק לינארי ימני</strong>, מה שהיה מוכיח שהשפה שלנו היא בכלל רגולרית, דהיינו היינו מוכיחים שכל שפה חסרת הקשר היא רגולרית, וזה בוודאי לא נכון. אם כן, אין לנו תקווה לדקדוק שיהיה <strong>עד כדי כך</strong> פשוט.</p>
<p>עדיין, מה שעשינו הוא התחלה טובה שתוביל אותנו בסופו של דבר אל הבניה שעובדת. בואו ננסה להציע לה תיקון נאיבי ונראה מה יקרה: מכיוון שהבעיה שלנו היא עם כך ש-<span class="math">\(\alpha\)</span> הוא לא חסום באורכו, הנה הצעה: פשוט נפרוט אותו לפרוטות. נוסיף את כל <span class="math">\(\Gamma\)</span> לקבוצת המשתנים של הדקדוק שלנו, ועכשיו תבנית פסוקית אופיינית תיראה, נאמר, כך: <span class="math">\(aabqABB\)</span>. התבנית הזו אומרת "עד כה הסימולציה של האוטומט שלנו קראה את <span class="math">\(aab\)</span>; עכשיו אנחנו במצב <span class="math">\(q\)</span>; תוכן המחסנית הוא <span class="math">\(ABB\)</span>". זה נראה מאוד מבטיח כי האוטומט פועל רק על פי התו העליון במחסנית, שממילא צמוד ל-<span class="math">\(q\)</span>, אז נראה שאפשר לעשות כאן משהו.</p>
<p>למה הבניה הזו נכשלת? כי הדקדוק שלנו צריך להיות <strong>חסר הקשר</strong>. כאשר אני גוזר את המשתנה <span class="math">\(q\)</span>, המשתנה לא יודע מי נמצא מימינו ומשמאלו והגזירה לא תהיה מושפעת מזה. במילים אחרות, אין ל-<span class="math">\(q\)</span> דרך "להכיר" את ה-<span class="math">\(A\)</span> שמימינו. תגידו, אוקיי - בואו נחבר את שניהם מראש לזוג, כלומר התבנית תיראה כך: <span class="math">\(aab\left(q,A\right)BB\)</span>. זה טוב ויפה, אבל אחרי ש-<span class="math">\(\left(q,A\right)\)</span> נגזר למשהו, איך אותו משהו יתחבר אל ה-<span class="math">\(B\)</span>-ים שמשמאל?</p>
<p>בקיצור, גם זה לא יעבוד. אני לא יכול שיהיו לי משתנים שהם "מצב לבד" ו"אות מחסנית לבד" - אני חייב שהמשתנים שלי יכללו מידע גם עבור המצב וגם עבור האות במחסנית. איך נעשה את זה? בואו ננסה פשוט לחבר אותם לזוגות ונראה איך זה עובד בדוגמה שלעיל: <span class="math">\(\left(q_{3},B\right)\)</span><span class="math">\(aab\left(q_{1},A\right)\left(q_{2},B\right)\)</span>. כאשר כאן <span class="math">\(q_{1},q_{2},q_{3}\)</span> הם מצבים כלשהם. מה שאני מצפה מ-<span class="math">\(\left(q_{1},A\right)\)</span> לגזור זה את "החלק במילה שעליו האוטומט רץ עד לשלב שבו הוא מגיע למצב <span class="math">\(q_{2}\)</span> ובמחסנית נשארו רק <span class="math">\(BB\)</span>", ומה שאני מצפה מ-<span class="math">\(\left(q_{2},B\right)\)</span> לגזור זה את "החלק במילה שעליו האוטומט רץ עד לשלב שבו הוא מגיע למצב <span class="math">\(q_{3}\)</span> ובמחסנית נשאר רק <span class="math">\(B\)</span>" ו-<span class="math">\(\left(q_{3},B\right)\)</span> אמור לגזור את "החלק המילה שעליו האוטומט רץ עד שהמחסנית מתרוקנת". משהו כאן עדיין לא עובד, אבל אני חושב שאנחנו כבר רואים שזה מתחמם ואנחנו מתקרבים לבניה שתעבוד.</p>
<p>הבעיה בבניה הנוכחית היא שהיא עדיין תלוית הקשר במובן מסויים - מה זאת אומרת, אני מצפה מ-<span class="math">\(\left(q_{1},A\right)\)</span> לגזור את החלק במילה שעליו האוטומט רץ עד שהוא מגיע ל-<span class="math">\(q_{2}\)</span> ובמחסנית יש <span class="math">\(BB\)</span>? איך הוא יודע מ-<span class="math">\(q_{2}\)</span> ומ-<span class="math">\(BB\)</span>? כרגע הוא לא. אבל שימו לב - הוא בעצם לא באמת מתעניין ב-<span class="math">\(BB\)</span>. אפשר לנסח את זה מחדש: <span class="math">\(\left(q_{1},A\right)\)</span> אמור לגזור את החלק במילה שעליו האוטומט רץ עד שהוא מגיע ל-<span class="math">\(q_{2}\)</span> והמחסנית מגיעה למצב שבו מה שהיה מתחת ל-<span class="math">\(A\)</span> נחשף לראשונה. הקטע הזה עם ה"נחשף לראשונה" נראה לי כמו הדבר הכי מבלבל כאן, אז בואו נפרט קצת: על פי ההגדרה שלו, הדבר הראשון שהאוטומט עושה כשהוא מבצע צעד זה להסיר את <span class="math">\(A\)</span> מהמחסנית. אבל מייד אחר כך הוא דוחף במקום <span class="math">\(A\)</span> מילה <span class="math">\(\beta\)</span> כלשהי. אם <span class="math">\(\beta\)</span> היא המילה הריקה, אז מה שהיה מתחת ל-<span class="math">\(A\)</span> נחשף; אחרת, <span class="math">\(A\)</span> הוחלף על ידי תווים נוספים (אולי יותר מ-1) ומה שהיה קבור מתחת ל-<span class="math">\(A\)</span> נשאר קבור ונצטרך לטפל בכל מה שמעליו לפני שנגיע אליו.</p>
<p>אם כן, לא באמת אכפת לנו מה-<span class="math">\(BB\)</span>, אבל כן אכפת לנו מ-<span class="math">\(q_{2}\)</span>. אבל כאן אין בעצם בעיה, כי <span class="math">\(q_{2}\)</span> הוא מצב בודד ואפשר לזכור אותו - זו כבר לא סדרה בלתי חסומה של תווים. זה מוביל אותנו אל הרעיון שמאחורי הבניה האמיתית שבה נשתמש: המשתנים שלנו יהיו שלשות <span class="math">\(\left(q,A,p\right)\)</span> כך שהמילים ששלשות כאלו גוזרות הן בדיוק המילים שמאפשרות לאוטומט לעבור מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span> כאשר בהתחלה <span class="math">\(A\)</span> בראש המחסנית ובסיום נחשף מה שהיה מתחתיו.</p>
<p>בואו נכתוב את זה בצורה פורמלית. אני רוצה לבנות את הדקדוק בצורה כזו שיתקיים הדבר הבא:</p>
<p><span class="math">\(\left(q,A,p\right)\Rightarrow^{*}w\iff\left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\)</span></p>
<p>כאן צד שמאל הוא גזירה בדקדוק, וצד ימין הוא חישוב של האוטומט. שימו לב לאופן הפשוט שבו כל הסיבוך של "הפעם הראשונה שבה מה שמתחת ל-<span class="math">\(A\)</span> נחשף" מבוטא כאן - אני פשוט מתאר את החישוב כאילו הוא מתחיל ממחסנית שבה אין כלום מתחת ל-<span class="math">\(A\)</span>, ובצעד האחרון המחסנית מתרוקנת. לא ייתכן שהמחסנית גם לפני הצעד האחרון כי אז האוטומט היה נתקע. לא קשה להוכיח שאם <span class="math">\(\left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\)</span> אז גם <span class="math">\(\left[q,w,A\beta\right]\vdash^{*}\left[p,\varepsilon,\beta\right]\)</span> לכל <span class="math">\(\beta\)</span> אפשרי, כך שאנחנו לא מגבילים את הכלליות בכך שאנחנו מדברים רק על מה שקורה שהמחסנית ריקה. מעכשיו, לצורך פשטות, אני אדבר על סדרת מעברים כזו פשוט בתור "מעברים שמרוקנים את <span class="math">\(A\)</span>" למרות שפורמלית זה לא ממש נכון (כי <span class="math">\(A\)</span> יכול לעוף במעבר הראשון אבל מה שמתחתיו לא ייחשף מייד, או ש-<span class="math">\(A\)</span> יישאר למשך הרבה זמן, וכו').</p>
<p>אם אני אצליח לבנות דקדוק שאלו משתניו, זה מסיים כמעט מייד את ההוכחה - שימו לב כמה צד ימין של השקילות דומה להגדרת הקבלה באמצעות ריקון מחסנית. כדי לסיים את הבניה אני אוסיף לדקדוק משתנה התחלתי <span class="math">\(S\)</span> (חייב להיות משתנה התחלתי וטרם ציינתי כזה) ולכל מצב <span class="math">\(p\in Q\)</span> אוסיף את הגזירה <span class="math">\(S\to\left(q_{0},\bot,p\right)\)</span>, וסיימנו: <span class="math">\(w\in L\left(M\right)\)</span> אם ורק אם קיים <span class="math">\(p\in Q\)</span> כך ש-<span class="math">\(\left[q_{0},w,\bot\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\)</span>, כלומר אם ורק אם קיים <span class="math">\(p\in Q\)</span> כך ש-<span class="math">\(\left(q_{0},\bot,p\right)\Rightarrow^{*}w\)</span>, כלומר אם ורק אם <span class="math">\(S\Rightarrow^{*}w\)</span> (למה? זה דורש טיפה נימוק), כלומר אם ורק אם <span class="math">\(w\in L\left(G\right)\)</span>.</p>
<p>אז נשאר רק להבין איך לבנות את הדקדוק כך שהשקילות תתקיים. מה זה אומר "לבנות את הדקדוק"? את המשתנים כבר ציינתי - אלו כל השלשות <span class="math">\(\left(q,A,p\right)\)</span>; רק נשאר להציג את כללי הגזירה שלהם. פורמלית, הדקדוק שלי הוא <span class="math">\(G=\left(\left\{ S\right\} \cup Q\times\Gamma\times Q,\Sigma,S,P\right)\)</span> ורק נותר לי לתאר את <span class="math">\(P\)</span>.</p>
<p>הבניה תתבסס, מן הסתם, על המעברים של האוטומט. אפשר לחלק את המעברים לשני סוגים: כאלו ש<strong>מפשטים</strong> לנו את הסיטואציה, וכאלו ש<strong>מסבכים</strong> אותה (או לכל הפחות משאירים אותה ללא שינוי), וזאת בהתאם לשאלה מה קורה למחסנית. צעד שמסיר את התו מהמחסנית ולא דוחף כלום במקומו עושה לנו את החיים פשוטים יותר; צעד שלא מקטין את המחסנית מסבך אותנו.</p>
<p>המקרה הראשון הוא מעבר מהצורה <span class="math">\(\left(p,\varepsilon\right)\in\delta\left(q,\sigma,A\right)\)</span>. שימו לב מה מעבר כזה עושה: הוא מעביר אותנו מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span> תוך שהוא מרוקן את <span class="math">\(A\)</span> מהמחסנית - בדיוק מה שהמשתנה <span class="math">\(\left(q,A,p\right)\)</span> בא לתאר. מכיוון שהמעבר הזה משתמש ב-<span class="math">\(\sigma\)</span> לצורך כך (ייתכן ש-<span class="math">\(\sigma\)</span> היא המילה הריקה), אז אנחנו מקבלים את הגזירה <span class="math">\(\left(q,A,p\right)\to\sigma\)</span>.</p>
<p>ועכשיו לסיטואציה המסובכת - מעבר מהצורה <span class="math">\(\left(p,B_{1}B_{2}\dots B_{n}\right)\in\delta\left(q,\sigma,A\right)\)</span>. כאן <span class="math">\(A\)</span> הוחלף על ידי <span class="math">\(B_{1}\dots B_{n}\)</span> ולכן כדי להשיג את האפקט של ריקון <span class="math">\(A\)</span> מהמחסנית, אנחנו צריכים לרוקן את <span class="math">\(B_{1},\dots,B_{n}\)</span>. זה מזמין את הגזירה הבאה:</p>
<p><span class="math">\(\left(q,A,q_{n+1}\right)\to\sigma\left(q_{1},B_{1},q_{2}\right)\left(q_{2},B_{2},q_{3}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\)</span></p>
<p>שמתארת את הסיפור הבא: קודם כל עברנו מ-<span class="math">\(q\)</span> אל <span class="math">\(q_{1}\)</span> תוך קריאת <span class="math">\(\sigma\)</span> והחלפת <span class="math">\(A\)</span> ב-<span class="math">\(B_{1}\cdots B_{n}\)</span>; אחר כך נעבור מ-<span class="math">\(q_{1}\)</span> אל <span class="math">\(q_{2}\)</span> ונרוקן את <span class="math">\(B_{1}\)</span> תוך כדי; מ-<span class="math">\(q_{2}\)</span> נעבור אל <span class="math">\(q_{3}\)</span> תוך ריקון <span class="math">\(B_{2}\)</span> וכן הלאה, עד אשר נעבור מ-<span class="math">\(q_{n}\)</span> אל <span class="math">\(q_{n+1}\)</span> תוך ריקון <span class="math">\(B_{n}\)</span>.</p>
<p>הכל טוב ויפה חוץ מדבר אחד - מי לכל הרוחות הם המצבים <span class="math">\(q_{1},q_{2},\dots,q_{n+1}\)</span>? מאיפה הם באו? כל מי שהיו לי במעבר המקורי באוטומט היו <span class="math">\(q,p\)</span>, ולאן <span class="math">\(p\)</span> נעלם באמת?</p>
<p>אז בבירור <span class="math">\(q_{1}=p\)</span>, אבל זה עדיין לא מסביר מיהם המצבים <span class="math">\(q_{2},\dots,q_{n+1}\)</span>. התשובה היא ש<strong>אני לא יודע</strong>. המטרה של הגזירה של <span class="math">\(\left(q,A,q_{n+1}\right)\)</span> היא לתאר את <strong>כל</strong> הריצות האפשריות שבהן יסירו את <span class="math">\(B_{1}\cdots B_{n}\)</span> מהמחסנית, ואני לא יודע מה מצבי הביניים בהן יהיו. אז מה שאני עושה הוא <strong>לכסות את כל האפשרויות</strong>. כלומר, אני הולך להוסיף את הגזירה</p>
<p><span class="math">\(\left(q,A,q_{n+1}\right)\to\sigma\left(q_{1},B_{1},q_{2}\right)\left(q_{2},B_{2},q_{3}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\)</span></p>
<p>עבור <strong>כל </strong>בחירת ערכים אפשרית ל-<span class="math">\(q_{2},\dots,q_{n+1}\)</span>. ומה קורה אם, למשל, אין דרך להגיע מ-<span class="math">\(q_{1}\)</span> אל <span class="math">\(q_{2}\)</span> תוך הסרת <span class="math">\(B_{1}\)</span> עבור בחירה מסויימת של <span class="math">\(q_{2}\)</span>? אין בעיה. אז הגזירה הזו "תיתקע" כי המשתנה <span class="math">\(\left(q_{1},B_{1},q_{2}\right)\)</span> לא יצליח לגזור מילה טרמינלית. לא נורא - אני לא חייב שכל נסיון גזירה יצליח.</p>
<p>קרוב לודאי שחלק מכם תוהים עכשיו למה טרחתי לפצל את כללי הגזירה לשניים, כשבעצם יש לי רק כלל גזירה אחד בשני המקרים - ה"פשוט" וה"מסובך": הכלל <span class="math">\(\left(q,A,q_{n+1}\right)\to\sigma\left(q_{1},B_{1},q_{2}\right)\left(q_{2},B_{2},q_{3}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\)</span> עם האילוץ ש-<span class="math">\(p=q_{1}\)</span>. המקרה ה"פשוט" מתקבל כאשר <span class="math">\(n=0\)</span>. ובכן, אפשר לעשות את זה כך, אבל לדעתי זה פשוט מבלבל יותר ואני לא רואה בזה טעם. כדאי להזכיר למי ששכח או לא יודע שהרעיון במתמטיקה הוא להיות ברור; לא להיות מינימליסטי. מינימליזם הוא טוב אם הוא מפשט עניינים, אבל אני לא חושב שהוא מטרה בפני עצמה.</p>
<p>בואו נעבור עכשיו להוכחה חצי פורמלית לכך שהבניה עובדת. אני חושב שכאן מאוד מועיל לראות הוכחה כזו כי למרות שאני מקווה שכבר יש לנו אינטואיציה לא רעה לגבי מה הבניה הזו ומאיפה היא הגיעה, עדיין חסר משהו כדי להשתכנע שזה אכן עובד. כזכור, כל מה שנשאר לי להוכיח הוא את הטענה <span class="math">\(\left(q,A,p\right)\Rightarrow^{*}w\iff\left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\)</span>. זו טענת אם-ורק-אם כך שאני צריך להוכיח שני כיוונים. נטפל בכל אחד מהם בנפרד.</p>
<p>נתחיל מכך שנתון <span class="math">\(\left(q,A,p\right)\Rightarrow^{*}w\)</span> ונוכיח ש-<span class="math">\(\left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\)</span>. כלומר, אם המשתנה <span class="math">\(\left(q,A,p\right)\)</span> גוזר מילה כלשהי, אז המילה הזו מעבירה את האוטומט מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span> תוך סילוק <span class="math">\(A\)</span> מהמחסנית. נוכיח את זה באינדוקציה, וזו הזדמנות טובה לשאול את עצמנו - אינדוקציה על מה? כלל האצבע הוא זה - נסתכל על האובייקט שאת קיומו אנחנו מניחים וממנו אנחנו רוצים להסיק דברים, ונבצע אינדוקציה על מאפיין כלשהו שלו שהולך ונעשה מורכב יותר. כאן האובייקט הנתון הוא <strong>הגזירה</strong> של <span class="math">\(w\)</span> מתוך המשתנה; הפרמטר יהיה אורך הגזירה. הבסיס הוא גזירה בת צעד אחד, וזה קל - בגזירה בת צעד אחד שגוזרת מילה טרמינלית ממשתנה, צעד הגזירה חייב להיות כזה שלא יוצר משתנים אלא רק טרמינלים, כלומר הוא חייב להיות גזירה מהצורה ה"פשוטה", <span class="math">\(\left(q,A,p\right)\to\sigma\)</span>. מכאן אנחנו לומדים שני דברים: ש-<span class="math">\(w=\sigma\)</span>, וש-<span class="math">\(\left(p,\varepsilon\right)\in\delta\left(q,\sigma,A\right)\)</span>. מסקנה: <span class="math">\(\left[q,w,A\right]=\left[q,\sigma,A\right]\vdash\left[p,\varepsilon,\varepsilon\right]\)</span>.</p>
<p>נעבור אל צעד האינדוקציה. כאן אנחנו מניחים שהטענה נכונה לכל גזירה מאורך קטן מ-<span class="math">\(k\)</span> (עבור <span class="math">\(k\ge2\)</span>) ומוכיחים עבור <span class="math">\(\left(q,A,p\right)\Rightarrow^{k}w\)</span>. התעלול הוא לרוב לפרק את הגזירה לצעד ראשון או אחרון, ו"כל היתר" שעליהם אפשר להפעיל את הנחת האינדוקציה. כאן יהיה לנו נוח לפרק לפי הצעד הראשון, שחייב להיות גזירה מהצורה ה"מסובכת", כי אחרת נקבל מילה טרמינלית אחרי הצעד הראשון ולכן לא ייתכן שהגזירה היא בת שני צעדים או יותר.</p>
<p>כלומר, מתקיים <span class="math">\(\left(q,A,p\right)\Rightarrow\sigma\left(p,B_{1},q_{2}\right)\left(q_{2},B_{2},q_{3}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\Rightarrow^{*}w\)</span> וזה נובע מכך שבאוטומט קיים המעבר <span class="math">\(\left(p,B_{1}B_{2}\dots B_{n}\right)\in\delta\left(q,\sigma,A\right)\)</span>. בגזירה שמתוארת כאן, כל אחד מהמשתנים מתישהו נגזר לגמרי למילה טרמינלית כלשהי; בואו נסמן אותן באופן הבא: <span class="math">\(\left(q_{i},B_{i},q_{i+1}\right)\Rightarrow^{*}w_{i}\)</span>. המסקנה היא ש-<span class="math">\(w=\sigma w_{1}\cdots w_{n}\)</span>, ושניתן להפעיל את הנחת האינדוקציה על כל גזירה מהצורה <span class="math">\(\left(q_{i},B_{i},q_{i+1}\right)\Rightarrow^{*}w_{i}\)</span> (כי הן בנות פחות מ-<span class="math">\(k\)</span> צעדים) ולקבל <span class="math">\(\left[q_{i},w_{i},B\right]\vdash^{*}\left[q_{i+1},\varepsilon,\varepsilon\right]\)</span>.</p>
<p>עכשיו נחבר את כל אלו כדי לקבל הוכחה לכך ש-<span class="math">\(\left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\)</span>:</p>
<p><span class="math">\(\left[q,w,A\right]=\left[q,\sigma w_{1}\cdots w_{n},A\right]\vdash\left[p,w_{1}\cdots w_{n},B_{1}\dots B_{n}\right]\vdash^{*}\)</span></p>
<p><span class="math">\(\vdash^{*}\left[q_{2},w_{2}\cdots w_{n},B_{2}\cdots B_{n}\right]\vdash^{*}\left[q_{n},w_{n},B_{n}\right]\vdash^{*}\left[q_{n+1},\varepsilon,\varepsilon\right]\)</span></p>
<p>וקיבלנו את המבוקש. זה מסיים את הכיוון הזה של ההוכחה.</p>
<p>הכיוון השני דומה באופיו אבל אני אנפנף בו קצת יותר בידיים. הפעם נתון לי <span class="math">\(\left[q,w,A\right]\vdash^{*}\left[p,\varepsilon,\varepsilon\right]\)</span> ואני רוצה להוכיח ש-<span class="math">\(\left(q,A,p\right)\Rightarrow^{*}w\)</span> - ושוב, אעשה זאת באינדוקציה, הפעם על אורך החישוב באוטומט. אם החישוב הוא בן צעד בודד, אז הצעד הזה חייב להיות מהצורה <span class="math">\(\left(p,\varepsilon\right)\in\delta\left(q,\sigma,A\right)\)</span> (אחרת לא היה אפשר לרוקן את <span class="math">\(A\)</span> מהמחסנית) ו-<span class="math">\(w=\sigma\)</span>. מסקנה: בדקדוק שבנינו קיים הכלל <span class="math">\(\left(q,A,p\right)\rightarrow\sigma\)</span> וקיבלנו ש-<span class="math">\(\left(q,A,p\right)\Rightarrow^{*}\sigma=w\)</span>. יופי, זה היה קל.</p>
<p>עכשיו לצעד: נניח שהטענה נכונה לכל חישוב מאורך קטן מ-<span class="math">\(k\)</span>. ונוכיח עבור חישוב באורך <span class="math">\(k\)</span> כאשר <span class="math">\(k\ge2\)</span>. אם <span class="math">\(\left[q,w,A\right]\vdash^{k}\left[p,\varepsilon,\varepsilon\right]\)</span> אז נוח לפרק על פי הצעד הראשון, שחייב להיות כזה ש<strong>לא</strong> מרוקן את המחסנית (אחרת לא היה אחריו עוד צעד). כלומר, הצעד הראשון משתמש במעבר מהצורה <span class="math">\(\left(q_{1},B_{1}B_{2}\dots B_{n}\right)\in\delta\left(q,\sigma,A\right)\)</span>, ולכן החישוב מתחיל כך: <span class="math">\(\left[q,w,A\right]\vdash\left[q_{1},w^{\prime},B_{1}\cdots B_{n}\right]\)</span>, כאשר <span class="math">\(w=\sigma w^{\prime}\)</span>. כאן מגיע נפנוף הידיים.</p>
<p>מה שאני אומר הוא זה: אני יודע שמהקונפיגורציה <span class="math">\(\left[q_{1},w^{\prime},B_{1}\cdots B_{n}\right]\)</span> החישוב נמשך עד שהוא מסתיים בקונפיגורציה <span class="math">\(\left[p,\varepsilon,\varepsilon\right]\)</span>. בפרט, המחסנית ריקה בסוף וסיימנו לקרוא את כל <span class="math">\(w^{\prime}\)</span>. מכיוון שהמחסנית ריקה, היה חייב להיות רגע שבו <span class="math">\(B_{2}\)</span> נחשף לראשונה (כלומר, בניסוח הלא פורמלי שהשתמשתי בו עד כה, רגע שבו "<span class="math">\(B_{1}\)</span> מוסר מהמחסנית"). וכמו כן חייב להיות רגע שבו <span class="math">\(B_{3}\)</span> נחשף, וכן הלאה, עד הרגע האחרון, שבו המחסנית מתרוקנת.</p>
<p>אם כן, אני אפרק את <span class="math">\(w^{\prime}\)</span> בהתאם לרגעים הללו: <span class="math">\(w_{1}\)</span> הוא כל מה שהאוטומט קרא עד לרגע שבו <span class="math">\(B_{2}\)</span> נחשף, ו-<span class="math">\(w_{2}\)</span> הוא כל מה שהאוטומט קרא עד לרגע שבו <span class="math">\(B_{3}\)</span> נחשף, וכן הלאה. כמו כן, אני אקרא בשם <span class="math">\(q_{2}\)</span> למצב שאליו מגיעים בדיוק כש-<span class="math">\(B_{2}\)</span> נחשף, וכן הלאה. שימו לב לכך ש-<span class="math">\(w^{\prime}=w_{1}\cdots w_{n}\)</span>.</p>
<p>אם כן, הסימונים שנתתי מתארים את הסיטואציה הבאה: <span class="math">\(\left[q_{i},w_{i}w_{i+1}\cdots w_{n},B_{i}B_{i+1}\cdots B_{n}\right]\vdash^{*}\left[q_{i+1},w_{i+1}\cdots w_{n},B_{i+1}\cdots B_{n}\right]\)</span>. כעת לנפנוף הידיים האחרון: מכיוון שבחישוב הזה אין ל-<span class="math">\(w_{i+1}\cdots w_{n}\)</span> שום השפעה (כי עוד לא הגענו לחלק הזה בקלט) וכמו כן גם ל-<span class="math">\(B_{i+1}\cdots B_{n}\)</span> אין שום השפעה (כי האוטומט לא רואה אותם בשום שלב של החישוב - כאן קריטית לגמרי העובדה שאני מסיים את החלק הזה של החישוב בדיוק כאשר <span class="math">\(B_{i+1}\)</span> נחשף <strong>לראשונה</strong>), הרי שאפשר פשוט להתעלם מהם - כלומר, מתקיים <span class="math">\(\left[q_{i},w_{i},B_{i}\right]\vdash^{*}\left[q_{i+1},\varepsilon,\varepsilon\right]\)</span>. וזה מצויין עבורי, כי על הדבר הזה אפשר להשתמש בהנחת האינדוקציה - הוא מהצורה המתאימה (אני מסיים בקונפיגורציה שבה הקלט שנותר והמחסנית שניהם ריקים) והוא מתאר חישוב באורך קטן מ-<span class="math">\(k\)</span> (כי הוא חלק מחישוב באורך <span class="math">\(k\)</span> בלי הצעד הראשון של אותו חישוב). קיבלנו ש-<span class="math">\(\left(q_{i},B_{i},q_{i+1}\right)\Rightarrow^{*}w_{i}\)</span> לכל <span class="math">\(1\le i\le n\)</span>.</p>
<p>כעת אפשר לסיים על ידי הצגת גזירה של <span class="math">\(w\)</span>:</p>
<p><span class="math">\(\left(q,A,p\right)\Rightarrow\sigma\left(q_{1},B_{1},q_{2}\right)\cdots\left(q_{n},B_{n},q_{n+1}\right)\Rightarrow^{*}\sigma w_{1}w_{2}\cdots w_{n}=\sigma w^{\prime}=w\)</span></p>
<p>וזה מסיים את הכיוון השני של ההוכחה, ואת ההוכחה כולה.</p>
<p>לסיכום, עכשיו יש לנו שתי דרכים שונות לתאר בהן שפות חסרות הקשר - או על ידי דקדוק, או על ידי אוטומט. באופן לא מפתיע, אני הולך להמשיך להשתמש בדקדוקים רוב הזמן כי זה יותר נוח, אבל פה ושם יש דברים שאוטומט יותר נוח עבורם וטוב שיש לנו בחירה. בפרט, כשאתם נתקלים בשפה ותוהים בינכם לבין עצמכם אם היא חסרת הקשר או לא (ולמי מאיתנו זה לא קרה?), הרבה פעמים במקום לנסות להמציא דקדוק עבור השפה נוח לחשוב בצורה "אלגוריתמית" על האופן שבו אוטומט מחסנית יקבל אותה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>