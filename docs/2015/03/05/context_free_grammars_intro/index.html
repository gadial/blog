<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מבוא לדקדוקים חסרי הקשר - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2015/03/05/context_free_grammars_intro/">
    <meta property="og:title" content="מבוא לדקדוקים חסרי הקשר">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2015/03/05/context_free_grammars_intro/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="מבוא לדקדוקים חסרי הקשר">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2015/02/11/myhill_nerode_theorem/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">משפט מייהיל-נרוד</span>
            </a>
            

            
            <a href="/2015/03/15/context_free_grammars_and_gf/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">אז מה הקשר בין דקדוקים חסרי הקשר ופונקציות יוצרות?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מבוא לדקדוקים חסרי הקשר</h1>
            <div class="post-meta">
                <span class="date">2015-03-05</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/דקדוקים.html">דקדוקים</a>
                    
                    <a href="/tags/שפות חסרות הקשר.html">שפות חסרות הקשר</a>
                    
                    <a href="/tags/שפות רגולריות.html">שפות רגולריות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>הפוסט על משפט נרוד מהווה לטעמי סיום הולם לנושא של שפות רגולריות, אבל מהנושא הזה יש קפיצה טבעית מאוד אל נושא קרוב ברוחו - שפות חסרות הקשר. בזמן שהכלי העיקרי שבו השתמשנו כדי לתאר שפות רגולריות היה אוטומטים, עבור שפות חסרות הקשר הכלי הזה הוא דקדוקים. באופן כללי דקדוקים הם דבר מאוד מועיל ומעניין שכדאי להציג ואפשר לגשת אליו בכמה דרכים שונות; בפוסט הזה אנקוט בדרך קצת מוזרה יחסית (אבל נחמדה, לטעמי, אחרת לא הייתי מציג אותה) שבה נגיע אל המושג של דקדוק מתוך המושג של ביטוי רגולרי.</p>
<p>בואו ניזכר מה זה ביטוי רגולרי. זה סימון שבא לתאר שפות, באופן הבא: <span class="math">\(\emptyset\)</span> מסמן את השפה הריקה; <span class="math">\(\varepsilon\)</span> מסמן שפה שהאיבר היחיד שלה הוא המילה הריקה, <span class="math">\(\sigma\)</span> מסמן שפה שהאיבר היחיד שלה הוא המילה בעלת האות הבודדת <span class="math">\(\sigma\)</span>, ואם <span class="math">\(r_{1},r_{2}\)</span> הם ביטויים רגולריים אז <span class="math">\(\left(r_{1}+r_{2}\right)\)</span> מסמן את איחוד השפות שלהם, <span class="math">\(\left(r_{1}\cdot r_{2}\right)\)</span> את שרשור השפות שלהם ו-<span class="math">\(\left(r_{1}^{*}\right)\)</span> את סגור קלייני של שפת <span class="math">\(r_{1}\)</span> - אוסף כל השרשורים של אפס או יותר מילים מהשפה של <span class="math">\(r_{1}\)</span>.</p>
<p>למשל, אם <span class="math">\(\Sigma=\left\{ a,b\right\} \)</span> הוא האלפבית שלנו, אז שפת כל המילים מאורך זוגי מעל האלפבית הזה מתוארת על ידי הביטוי הרגולרי <span class="math">\(\left(\left(a+b\right)\left(a+b\right)\right)^{*}\)</span>. כאן כבר הרשיתי לעצמי להשמיט סוגריים ואת הסימן <span class="math">\(\cdot\)</span>.</p>
<p>עד עכשיו חשבנו על ביטויים רגולריים בתור כלי לתיאור של שפה, ואולי גם בתור מין "מתכון" לבניית אוטומט שמזהה אותה. עכשיו אני רוצה להציג דרך טיפה שונה להתבונן עליהן - בתור מתכון עבור אלגוריתם ל<strong>ייצור</strong> של מילים בשפה של הביטוי. האלגוריתם הולך לייצר את כל המילים בשפה, ורק אותן. כל הרצה שלו תסתיים אחרי מספר סופי של צעדים עם פלט שהוא אחת מהמילים בשפה, או שתודיע "נתקעתי" ולא תייצר מילה בריצה הזו, וריצות שונות ייבדלו זו מזו על ידי בחירות שונות שהאלגוריתם יכול לבצע בחלק משלביו.</p>
<p>כדי להבין איך זה הולך, בואו ניקח את הביטוי הרגולרי לשפת המילים מאורך זוגי ונחשוב על האופן שבו אפשר לייצג אותו במחשב, בצורה שהיא קצת יותר חכמה מסתם מחרוזת אלא כוללת מידע על המבנה שלו. אפשר לומר שיש משתנה כלשהו, נסמן אותו <span class="math">\(S\)</span>, שמייצג את כל הביטוי; ושיש משתנה <span class="math">\(A\)</span> שמייצג את החלק שבין הסוגריים החיצוניים, כלומר <span class="math">\(S=A^{*}\)</span>. גם את <span class="math">\(A\)</span> נוכל להציג בעזרת משתנה אחר, <span class="math">\(A=BB\)</span>; ואת <span class="math">\(B\)</span> אפשר להציג בתור <span class="math">\(B=C+D\)</span>, כאשר <span class="math">\(C=a\)</span> ו-<span class="math">\(D=b\)</span>.</p>
<p>כעת האלגוריתם פועל כך: התחילו עם <span class="math">\(S\)</span>. כעת, בחרו <span class="math">\(n\ge0\)</span> טבעי והחליפו את <span class="math">\(S\)</span> ב-<span class="math">\(A^{n}\)</span> (אם <span class="math">\(n=0\)</span> אז מחליפים את <span class="math">\(S\)</span> ב-<span class="math">\(\varepsilon\)</span>). כעת, לכל מופע של <span class="math">\(A\)</span>, החליפו אותו ב-<span class="math">\(BB\)</span>; כעת, לכל מופע של <span class="math">\(B\)</span>, החליפו אותו ב-<span class="math">\(C\)</span> או החליפו אותו ב-<span class="math">\(D\)</span>. לבסוף, החליפו כל מופע של <span class="math">\(C\)</span> ב-<span class="math">\(a\)</span> וכל מופע של <span class="math">\(D\)</span> ב-<span class="math">\(b\)</span>, והופה - קיבלתם מילה.</p>
<p>מה בעצם עשינו כאן? התחלנו מאיזה משתנה <span class="math">\(S\)</span> וביצענו עליו <strong>פעולת שכתוב</strong> שהחליפה אותו במשתנים אחרים. גם עליהם הפעלנו פעולות שכתוב וכן הלאה וכן הלאה עד אשר קיבלנו אותיות ששייכות לאלפבית שלנו, ואותן כבר לא שכתבנו יותר. זה הרעיון הבסיסי מאחורי דקדוקים: יש לנו אוסף של <strong>משתנים</strong>, ואנחנו מבצעים עליהם פעולות שכתוב, עד שכל מה שנשאר לנו הוא רק אותיות-שאינן-משתנים. נכניס כבר עכשיו קצת טרמינולוגיה: לאותיות-שאינן-משתנים אני קורא <strong>טרמינלים</strong> ("טרמינלי" - סופי, שכן האותיות הללו מסיימות את סדרת פעולות השכתוב שלנו) ולפעולת השכתוב אני קורא "גזירה". <strong>דקדוק </strong>מורכב מארבעה רכיבים - קבוצת משתנים, קבוצת טרמינלים, משתנה ספציפי שמתפקד בתור <strong>משתנה התחלתי</strong> (אצלנו זהו <span class="math">\(S\)</span>) וקבוצת <strong>כללי גזירה</strong> אפשריים. עוד מעט יגיעו גם הגדרות פורמליות יותר.</p>
<p>יש נקודה מעניינת אחת שטרם התייחסתי אליה - מה קורה אם <span class="math">\(\emptyset\)</span> מופיע כחלק מהביטוי הרגולרי? מה עושה המשתנה שלו? פשוט מאוד - למשתנה הזה לא יהיו כללי גזירה, ולכן אם הוא מופיע משהו במהלך גזירת מילה, "נתקענו" והאלגוריתם שלנו יעצור ויגיד "נתקעתי" (לא סתם הצעתי את האפשרות הזו קודם!). זכרו שביטוי כמו <span class="math">\(\emptyset^{*}\)</span> לא מגדיר שפה ריקה, אלא את השפה שיש בה רק את <span class="math">\(\varepsilon\)</span>. זה מתאים לכך שאם <span class="math">\(A=B^{*}\)</span> כך ש-<span class="math">\(B=\emptyset\)</span> אז <span class="math">\(A\)</span> יוכל לגזור את <span class="math">\(\varepsilon\)</span> או את <span class="math">\(B^{n}\)</span> עבור <span class="math">\(n\ge1\)</span>, כשכל הגזירות מהצורה <span class="math">\(B^{n}\)</span> "ייתקעו" ולכן נישאר רק עם <span class="math">\(\varepsilon\)</span>.</p>
<p>עכשיו, כשיש לנו פורמליזציה חדשה כלשהי, אפשר גם לבחון את הדרכים השרירותיות שבהן אנחנו מגבילים אותה ולראות מה קורה אם מסירים את המגבלות. במקרה שלנו המגבלות מגיעות בצורה כמעט סמויה מהאופן שבו אנחנו "מסיקים" את הדקדוק מתוך ביטוי רגולרי. ראשית, כל משתנה יכול לעשות בדיוק אחד מבין הדברים הבאים: או לגזור אחד מבין שני משתנים (אם <span class="math">\(A=B+C\)</span>), או לגזור שני משתנים ברצף (עבור <span class="math">\(A=BC\)</span>) או לגזור משתנה אחד <span class="math">\(n\ge0\)</span> פעמים (עבור <span class="math">\(A=B^{*}\)</span>), או לגזור אות בודדת, או את המילה הריקה. או כלום. למה לא להרשות לו לעשות הרבה דברים שונים? מה רע בלגזור <strong>שלושה</strong> משתנים ברצף, למשל? או שתהיה יכולת לבחור בין גזירה של משתנה אחד לבין גזירה של שרשור של <strong>שני</strong> משתנים? אם נחשוב על זה קצת נראה שאפשר "לסמלץ" את היכולות הללו גם בעזרת הכללים הקיימים. למשל, אם אני רוצה ש-<span class="math">\(A\)</span> יוכל לגזור את <span class="math">\(BCD\)</span> אני יכול להוסיף "משתנה עזר" <span class="math">\(E\)</span>, את הגזירה שבה <span class="math">\(A\)</span> גוזר את <span class="math">\(BE\)</span> וגזירה שבה <span class="math">\(E\)</span> גוזר את <span class="math">\(CD\)</span>. אם כן, ההגבלה האמיתית היא לא כאן. איפה היא כן?</p>
<p>אם אני מתחיל מלדבר על משתנים שגוזרים משתנים אחרים, אני לא אומר במפורש שום מגבלה על <strong>אילו משתנים</strong> יכול משתנה כלשהו לגזור. למשל, אני לא אוסר על משתנה לגזור את עצמו. ואני לא אוסר על סיטואציה שבה <span class="math">\(A\)</span> גוזר את <span class="math">\(B\)</span> ו-<span class="math">\(B\)</span> גוזר את <span class="math">\(A\)</span> בחזרה, וכדומה. כלומר, אני מאפשר "מעגלים". במשתנים שמגיעים מביטוי רגולרי זה לא יכול לקרות, כי כל משתנה מייצג תת-ביטוי-רגולרי, כאשר <span class="math">\(B\)</span> יכול להיגזר מ-<span class="math">\(A\)</span> רק אם הביטוי של <span class="math">\(B\)</span> <strong>קטן ממש</strong> מהביטוי של <span class="math">\(A\)</span>. זו המגבלה הקריטית. נניח לרגע שאני מעיף אותה - בואו תראו איך אני בונה בלי בעיה דקדוק עבור <span class="math">\(L=\left\{ a^{n}b^{n}\ |\ n\ge0\right\} \)</span>, שהיא הדוגמה לשפה לא רגולרית שאני משתמש בה כל הזמן. הדקדוק שלי יכלול משתנה יחיד <span class="math">\(S\)</span>, שגוזר את המילה <span class="math">\(aSb\)</span> או את המילה <span class="math">\(\varepsilon\)</span>, וזהו. תנסו לפרמל אותו באמצעות סוגי כללי הגזירה שהצגתי - אני תכף אעשה את זה, אחרי שאציג את ההגדרות הפורמליות סוף כל סוף.</p>
<p>ובכן, מספיק עם המוטיבציה הרעיונית, בואו נעבור לניסוח המלא. <strong>דקדוק חסר הקשר</strong> הוא רביעייה <span class="math">\(G=\left(V,T,S,P\right)\)</span> שכוללת קבוצה סופית של <strong>משתנים</strong> <span class="math">\(V\)</span>, קבוצה סופית של <strong>טרמינלים</strong> <span class="math">\(T\)</span>, <strong>משתנה התחלתי</strong> <span class="math">\(S\in V\)</span> וקבוצה סופית של<strong> כללי גזירה</strong> <span class="math">\(P\)</span>, כאשר <strong>כלל גזירה</strong> הוא מחרוזת מהצורה <span class="math">\(A\to\alpha\)</span> כאשר <span class="math">\(\alpha\in\left(V\cup T\right)^{*}\)</span> הוא סדרה כלשהי של משתנים וטרמינלים. למשתנה יכולים להיות כמה כללי גזירה שונים שבהם הוא מופיע באגף שמאל, ולפעמים נוח לכתוב כמה מהם בבת אחת כשהם מופרדים על ידי קו אנכי. למשל, הדקדוק עבור <span class="math">\(\left\{ a^{n}b^{n}\ |\ n\ge0\right\} \)</span> נכתב כך: <span class="math">\(S\to aSb|\varepsilon\)</span>. כאן <span class="math">\(V=\left\{ S\right\} \)</span> ו-<span class="math">\(T=\left\{ a,b\right\} \)</span> אבל לרוב אני לא אציין את הקבוצות הללו במפורש אלא רק אתן את כללי הגזירה של הדקדוק.</p>
<p>עכשיו צריך להסביר מהי גזירה - איך מילים מתקבלות על ידי הדקדוק. הרעיון בגזירה הוא שמתחילים מ-<span class="math">\(S\)</span> ובכל צעד מבצעים <strong>שכתוב</strong> שבו עבור משתנה <span class="math">\(A\)</span> כלשהו אנחנו בוחרים כלל גזירה כלשהו מהצורה <span class="math">\(A\to\alpha\)</span> ומחליפים את <span class="math">\(A\)</span> ב-<span class="math">\(\alpha\)</span>. פורמלית, אנחנו אומרים ש-<span class="math">\(\alpha\Rightarrow\beta\)</span> אם <span class="math">\(\alpha=\gamma A\delta\)</span> עבור <span class="math">\(A\in V\)</span> כלשהו ו-<span class="math">\(\gamma,\delta\in\left(V\cup T\right)^{*}\)</span>, ו-<span class="math">\(\beta=\gamma\lambda\delta\)</span> כך ש-<span class="math">\(A\to\lambda\in P\)</span>. זה פורמליזם קצת מתוסבך אבל הרעיון הוא בדיוק מה שאמרתי במילים לפני רגע.</p>
<p>כפי שאתם רואים, אני משתמש די הרבה בביטויים שהם סדרה כלשהי של משתנים וטרמינלים. אני אקרא להם בשם <strong>תבנית פסוקית</strong>, ובכך אני טיפה מרמה כי בכל מני מקומות משתמשים במילה הזו כדי לתאר רק סדרות של משתנים וטרמינלים שיכולות להופיע במהלך גזירה חוקית מדקדוק כלשהו. אני גם אשתמש באותיות יווניות קטנות כדי לתאר אותן, כך שאפשר יהיה להבין מההקשר למה אני מתכוון בלי שאומר זאת במפורש.</p>
<p>כעת, הגדרנו יחס <span class="math">\(\alpha\Rightarrow\beta\)</span> בין שתי תבניות פסוקיות, שאומר שבדקדוק <span class="math">\(G\)</span> אפשר לגזור את <span class="math">\(\beta\)</span> מתוך <span class="math">\(\alpha\)</span>. בואו ניקח את <strong>הסגור הרפלקסיבי-טרנזיטיבי</strong> של היחס הזה ונסמן אותו ב-<span class="math">\(\Rightarrow^{*}\)</span>. זה נשמע מפוצץ, אבל המשמעות של <span class="math">\(\alpha\Rightarrow^{*}\beta\)</span> היא מאוד פשוטה - קיים <span class="math">\(n\ge0\)</span> טבעי כך ש-<span class="math">\(\alpha\Rightarrow^{n}\beta\)</span> כאשר <span class="math">\(\Rightarrow^{n}\)</span> מציין בדיוק <span class="math">\(n\)</span> צעדי גזירה (ב-0 צעדי גזירה תבנית פסוקית כלשהי "גוזרת" את עצמה). כעת אפשר להגדיר את השפה של דקדוק בתור אוסף כל המילים שמורכבות מטרמינלים בלבד שהדקדוק גוזר: <span class="math">\(L\left(G\right)=\left\{ w\in T^{*}\ |\ S\Rightarrow^{*}w\right\} \)</span>.</p>
<p>למה מה שהגדרתי נקרא "דקדוק חסר הקשר" ולא סתם "דקדוק"? ובכן, כי יש סוגים כלליים יותר של דקדוקים. באופן הכי כללי, כללי הגזירה של דקדוק לא חייבים להיות מהצורה <span class="math">\(A\to\alpha\)</span> אלא מהצורה <span class="math">\(\alpha\to\beta\)</span> כאשר <span class="math">\(\alpha\)</span> היא תבנית פסוקית כלשהי שהדרישה היחידה שלנו עליה היא שהיא תכיל משתנה <strong>כלשהו</strong> (אפשר כמה). זה בעצם אומר שהאופן שבו משתנים נגזרים יכול להיות תלוי ב<strong>הקשר</strong> שלהם (האותיות שנמצאות "סביבן" במילה). אני לא אציג את הדקדוקים הללו כרגע כי הם מעניינים מספיק כדי להצדיק דיון נפרד, שיגיע יותר מאוחר, אחרי שכבר נתרגל לדקדוקים חסרי הקשר.</p>
<p>עכשיו בואו נחזור לביטויים הרגולריים שלנו. הפורמליזם של דקדוק שהגדרתי מאפשר לנו לטפל ב-<span class="math">\(A=B+C\)</span>: זה יתורגם לכללי הגזירה <span class="math">\(A\to B|C\)</span>. כמובן שגם <span class="math">\(A=BC\)</span> מטופל על ידי הגזירה <span class="math">\(A\to BC\)</span>. אבל מה עם <span class="math">\(A=B^{*}\)</span>? על פניו אין לי משהו שיודע "לסמלץ" אותו בפורמליזם שלי. אבל בפועל כמובן שיש, כל עוד אין לי איסור על כך שמשתנה יגזור את עצמו: כללי הגזירה <span class="math">\(A\to BA|\varepsilon\)</span> מסמלצים בדיוק את הקטע הזה של לגזור את <span class="math">\(B\)</span> 0 או יותר פעמים. אם כן, כבר אנחנו רואים שבהינתן ביטוי רגולרי, קל לבנות דקדוק חסר הקשר שמייצר את אותה שפה כמוהו, ולכן השפות שמיוצרות על ידי דקדוקים חסרי הקשר מכילות את כל השפות הרגולריות - אבל יש עוד שפות, למשל <span class="math">\(\left\{ a^{n}b^{n}\ |\ n\ge0\right\} \)</span>. זה מצדיק מתן שם נפרד למחלקה הזו: <strong>מחלקת השפות חסרות ההקשר</strong> כוללת את כל השפות שקיים דקדוק חסר הקשר שמייצר אותן. בהמשך נראה ש-<span class="math">\(\left\{ a^{n}b^{n}c^{n}\ |\ n\ge0\right\} \)</span> <strong>אינה</strong> שפה חסרת הקשר, כך שלמרות שקיבלנו מחלקה גדולה יותר מהשפות הרגולריות, היא עדיין לא גדולה <strong>מדי</strong> ויש שפות פשוטות יחסית שאינן שם.</p>
<p>דקדוקים חסרי הקשר הם דרך מאוד נוחה לתאר שפות בצורה יחסית קריאה וברורה - שפות תכנות מתוארות לרוב בצורה פורמלית באמצעות דקדוק, והמהדר שממיר קוד בשפת התכנות לשפת מכונה משתמש בדקדוק הזה כדי להבין מה התוכנית אומרת. זה רומז לנו שדקדוק לא סתם מתאר מילה אלא גם אומר לנו משהו על ה<strong>מבנה</strong> של המילה הזו - מן הסתם מכאן השם "דקדוק" מגיע מלכתחילה; אבל מכיוון שההבנה שלי בלשונאות ובדקדוקים לשפות טבעיות היא אפסית, אני לא אדבר על דקדוקים "אמיתיים" בכלל אלא אדבוק באלו הפורמליים. ויש לי דוגמה פשוטה שאני חושב שתבהיר היטב את עניין המבנה הזה - ביטויים חשבוניים. ביטוי חשבוני לדוגמה הוא <span class="math">\(5+3\times8\)</span>, שערכו המספרי הוא 29. הביטוי הזה הוא גם מילה, כשה"אותיות" שלנו הם מספרים וסימני החשבון. בואו ניתן דקדוק פשוט עבור השפה הזו. כדי לייצר מספרים אני אשתמש במשתנה <span class="math">\(V\)</span> עם הגזירות <span class="math">\(V\to VV|0|1|2|3|4|5|6|7|8|9\)</span> - הבהירו לעצמכם למה זה מספיק כדי לייצר כל מספר (וגם יכול לייצר מספרים מהצורה 0013 אבל זה מספיק לא בעייתי כדי שלא אטרח לתקן את זה - וכמובן שקל לתקן, עם עוד משתנה עזר). כעת, כדי לייצר ביטוי חשבוני, נשתמש בהגדרה כמו-רקורסיבית: ראשית, כל מה ש-<span class="math">\(V\)</span> יכול לייצר הוא ביטוי חשבוני; שנית, אם <span class="math">\(E\)</span> הוא ביטוי חשבוני ו-<span class="math">\(\oplus\)</span> היא פעולה חשבונית כלשהי, אז <span class="math">\(E\oplus E\)</span> גם הוא ביטוי חשבוני. אם כן, נוסיף משתנה <span class="math">\(E\)</span> שיהיה גם המשתנה ההתחלתי שלנו, ואת כללי הגזירה <span class="math">\(E\to V|E+E|E\times E|E-E|E\div E\)</span>.</p>
<p>ועכשיו, כיצד ניתן לגזור את <span class="math">\(5+3\times8\)</span>? הנה דרך אחת לעשות את זה (אני קופץ על כמה צעדים כשנוח לי):</p>
<p><span class="math">\(E\Rightarrow E+E\Rightarrow E+E\times E\Rightarrow^{*}V+V\times V\Rightarrow^{*}5+3\times8\)</span></p>
<p>אבל יש עוד דרך לעשות את זה! דרך שהיא בבירור שונה:</p>
<p><span class="math">\(E\Rightarrow E\times E\Rightarrow E+E\times E\Rightarrow^{*}V+V\times V\Rightarrow^{*}5+3\times8\)</span></p>
<p>ההבדל הוא שבדרך הראשונה התחלנו עם החיבור, ובדרך השניה התחלנו עם הכפל. על פניו זה לא נראה כזה שונה, אבל באופן ציורי קל לראות את ההבדל. אני הולך לצייר את <strong>עץ הגזירה</strong> של שתי הגזירות הללו. עץ גזירה הוא דרך גרפית נאה לצייר גזירות בצורה קומפקטית - בלי להיכנס לפורמליזם, זה עץ שבו כל צומת פנימי מתאים למשתנה שהופיע מתישהו בגזירה, והבנים שלו הם התווים שהוא גזר. כפי שתוכלו לראות, לשתי הגזירות השונות הללו יש עצי גזירה שונים:</p>
<p><strong><a href="/img/2015/03/diagram004.png"><img class="aligncenter size-full wp-image-3228" alt="diagram004" src="/img/2015/03/diagram004.png" width="347" height="251" /></a></strong></p>
<p>עץ גזירה הוא מה שמתאר את ה"מבנה" של המילה שנגזרה. במקרה של ביטוי חשבוני, אפשר לחשב את הערך של הביטוי עם עץ הגזירה, בצורה מתבקשת: הערך של עלה הוא ערך המספר שלו (אצלי זה טיפה יותר מסובך כי מספר יכול להיות מיוצג על ידי כמה עלים, אבל תתעלמו מזה או תחשבו על המקרה שבו כל המספרים הם בני ספרה אחת). הערך של צומת פנימי מתקבל מהפעלת האופרטור שכתוב באותו צומת פנימי על שני הבנים שלו. קל לראות שבעץ הגזירה הימני הערך שנקבל הוא <span class="math">\(29\)</span>, אבל בעץ הגזירה השמאלי הערך שנקבל הוא בכלל <span class="math">\(64\)</span>. מה הלך פה? ובכן, ראינו שאת הביטוי <span class="math">\(5+3\times8\)</span> יש <strong>שתי דרכים שונות מהותית</strong> לקרוא - זאת על פי <strong>סדר הקדימויות</strong> שאנחנו נותנים לאופרטורים - האם כפל בא קודם (השמאלי) או חיבור (הימני).</p>
<p>הסיטואציה הזו, של דקדוק שבו קיימת מילה עם שני עצי גזירה שונים או יותר, נקראת <strong>רב-משמעות</strong> של דקדוק והיא לרוב לא רצויה. תחשבו על זה בשפת תכנות - זה אומר שאותה תוכנית מחשב יכולה לעבור הידור לשתי תוכניות שעושות דברים שונים, בהתאם למוזריות של המהדר הספציפי. לכן לרוב משתדלים לבנות דקדוק שיהיה חד משמעי ולא רב משמעי - עבור שפת הביטויים החשבוניים יש כזה, ואציג אותו בפוסט נפרד, מאוחר יותר, שיעסוק קצת יותר בענייני הרב משמעויות הללו.</p>
<p>בואו נחזור לדבר עכשיו על ביטויים רגולריים. ראינו שאפשר לחשוב על ביטויים רגולריים בתור בערך דקדוק עם כל מני הגבלות מוזרות שלא נעים לנסח. האם אפשר למצוא מחלקה פשוטה יותר לתיאור של דקדוקים שהשפות שלהם הן בדיוק כל השפות הרגולריות? כמובן. והדקדוקים הללו יפעלו בצורה שמאוד דומה לסימולציה של אוטומט סופי דטרמיניסטי. אכנה את הדקדוקים הללו <strong>דקדוקים לינאריים ימניים</strong>. דקדוק הוא לינארי ימני אם כל כללי הגזירה שלו הם מהצורה <span class="math">\(A\to aB\)</span> או <span class="math">\(A\to\varepsilon\)</span> כאשר <span class="math">\(a\)</span> הוא טרמינל ו-<span class="math">\(B\)</span> הוא משתנה. כלומר, בכל צעד גזירה המשתנה הנוכחי גוזר אות אחת ומשתנה אחד, או מחליט שהספיק לו ומתפוגג (גוזר את <span class="math">\(\varepsilon\)</span>) גזירה בדקדוק הזה נראית כמו כתיבה משמאל לימין של המילה (ומכאן שם הדקדוק - לינארי, כלומר בקו ישר, וימני, כלומר הולך ימינה):</p>
<p><span class="math">\(S\Rightarrow aA\Rightarrow abB\Rightarrow abc\)</span></p>
<p>האם אתם רואים את הדמיון לאוטומט סופי דטרמיניסטי? הרי גם אוטומט כזה קורא את המילה שלו מימין לשמאל, ויש לו "מצב" שמשתנה בכל צעד, כמו שלדקדוק הלינארי הימני יש "מצב" שמשתנה בכל צעד ומתבטא בזהות המשתנה היחיד שנמצא בקצה הימני של המילה. ההבדל העקרוני הוא שאוטומטים <strong>מזהים</strong> מילים (רצים על כל המילה ואז עונים כן או לא) ואילו דקדוקים <strong>מייצרים</strong> מילים. אבל קל לגשר על ההבדלים הללו ולכל אוטומט סופי דטרמיניסטי <span class="math">\(A\)</span> לבנות דקדוק לינארי ימני שקול <span class="math">\(G\)</span>, וההפך. בואו נראה את הבניות הללו.</p>
<p>נתחיל מבניה של אוטומט <span class="math">\(A\)</span> עבור דקדוק <span class="math">\(G=\left(V,T,S,P\right)\)</span> נתון. הרעיון יהיה לנסות ולסמלץ גזירה בדקדוק תוך כדי קריאת המילה. המצב של האוטומט יהיה המשתנה של הדקדוק, והאוטומט יבחר באופן אי דטרמיניסטי גזירה כלשהי שאפשרית מהמשתנה הנוכחי ומייצרת את האות שהוא כרגע קורא. הנה האוטומט: <span class="math">\(A=\left(V,T,S,\delta,F\right)\)</span>. כלומר, <span class="math">\(Q=V\)</span> ו-<span class="math">\(\Sigma=T\)</span> ו-<span class="math">\(q_{0}=S\)</span>, אם להשתמשב בסימנים שאנחנו רגילים אליהם מאוטומטים.</p>
<p>נותר רק לתאר את <span class="math">\(\delta\)</span> ואת <span class="math">\(F\)</span>. ראשית, <span class="math">\(\delta\left(A,a\right)=\left\{ B\in V\ |\ A\to aB\in P\right\} \)</span>; ושנית, <span class="math">\(F=\left\{ A\in V\ |\ A\to\varepsilon\in P\right\} \)</span>. עכשיו צריך להוכיח זה עובד, ועושים את זה בצורה סטנדרטית: מוכיחים שמתקיים <span class="math">\(\hat{\delta}\left(A,w\right)=B\)</span> אם ורק אם <span class="math">\(A\Rightarrow^{*}wB\)</span>, באינדוקציה על אורך <span class="math">\(w\)</span>, ולכן <span class="math">\(\hat{\delta}\left(S,w\right)=B\)</span> כאשר <span class="math">\(B\in F\)</span> אם ורק אם <span class="math">\(S\Rightarrow^{*}wB\Rightarrow w\)</span>, כלומר <span class="math">\(w\in L\left(A\right)\)</span> אם ורק אם <span class="math">\(w\in L\left(G\right)\)</span>.</p>
<p>בכיוון השני, נניח שיש לנו אוטומט סופי דטרמיניסטי <span class="math">\(A=\left(Q,\Sigma,q_{0},\delta,F\right)\)</span>. נבנה דקדוק שמחקה ריצה של האוטומט על מילה כלשהי, וגוזר אפסילון רק אם האוטומט הגיע למצב מקבל. כלומר, <span class="math">\(G=\left(Q,\Sigma,q_{0},P\right)\)</span> כאשר לכל <span class="math">\(q\in Q\)</span> ו-<span class="math">\(\sigma\in\Sigma\)</span> נסמן <span class="math">\(\delta\left(q,\sigma\right)=p\)</span> ונוסיף את כלל הגזירה <span class="math">\(q\to\sigma p\)</span>, וכמו כן אם <span class="math">\(q\in F\)</span> נוסיף את הגזירה <span class="math">\(q\to\varepsilon\)</span>. גם כאן הוכחת הנכונות דומה.</p>
<p>לסיום המבוא הזה, בואו נציג עוד דוגמה לדקדוק שסוגרת את המעגל שהתחלנו ממנו. התחלנו מביטויים רגולריים? אז בואו נציג דקדוק שגוזר ביטויים רגולריים! המבנה הרקורסיבי שלהם הופך את העניין לפשוט מאוד, כמובן: <span class="math">\(S\to\emptyset|\varepsilon|\sigma_{1}|\dots|\sigma_{n}|\left(S+S\right)|\left(S\cdot S\right)|\left(S^{*}\right)\)</span>.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>