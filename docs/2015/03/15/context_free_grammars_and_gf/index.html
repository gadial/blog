<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אז מה הקשר בין דקדוקים חסרי הקשר ופונקציות יוצרות? - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2015/03/15/context_free_grammars_and_gf/">
    <meta property="og:title" content="אז מה הקשר בין דקדוקים חסרי הקשר ופונקציות יוצרות?">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2015/03/15/context_free_grammars_and_gf/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="אז מה הקשר בין דקדוקים חסרי הקשר ופונקציות יוצרות?">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <a href="/lecture_notes.html">סיכומי הרצאות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2015/03/05/context_free_grammars_intro/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">מבוא לדקדוקים חסרי הקשר</span>
            </a>
            

            
            <a href="/2015/03/22/pushdown_automata/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">אוטומט מחסנית</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>אז מה הקשר בין דקדוקים חסרי הקשר ופונקציות יוצרות?</h1>
            <div class="post-meta">
                <span class="date">2015-03-15</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/קומבינטוריקה.html">קומבינטוריקה</a>
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/דקדוקים חסרי הקשר.html">דקדוקים חסרי הקשר</a>
                    
                    <a href="/tags/פונקציות יוצרות.html">פונקציות יוצרות</a>
                    
                    <a href="/tags/שפות חסרות הקשר.html">שפות חסרות הקשר</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>תכירו - מסלולי מוצקין. <strong>מסלול מוצקין</strong> מאורך <span class="math">\(n\)</span> הוא מסלול ב-<span class="math">\(\mathbb{Z}^{2}\)</span> שמתחיל ב-<span class="math">\(\left(0,0\right)\)</span> ומסתיים ב-<span class="math">\(\left(n,0\right)\)</span> ומורכב משלושה סוגים אפשריים של צעדים: ימינה, למעלה-ימינה ולמטה-ימינה. כלומר, אנחנו כרגע ב-<span class="math">\(\left(x,y\right)\)</span> אז אנחנו יכולים לעבור אל <span class="math">\(\left(x+1,y+\delta\right)\)</span> כאשר <span class="math">\(\delta\in\left\{ -1,0,1\right\} \)</span>. והנה העלילה מסתבכת: אסור למסלול לרדת מתחת לציר <span class="math">\(x\)</span>, דהיינו אם אנחנו ב-<span class="math">\(\left(x,0\right)\)</span> אסור לנו לבצע צעד ימינה-למטה. אין עוד מגבלות, פרט למגבלה שאנחנו חייבים לסיים ב-<span class="math">\(\left(n,0\right)\)</span>.</p>
<p>בואו ניתן שמות לצעדים האפשריים: לימינה-למעלה אקרא U, לימינה למטה אקרא D ולסתם ימינה אקרא S (מלשון Up, Down, Stay שמתארים מה קורה מבחינת הגובה של המסלול). אם כן, מסלול מוצקין הוא סדרה מאורך <span class="math">\(n\)</span> של התווים U,D,S שגם מקיימים עוד כמה כללים - כלומר, זו <strong>שפה פורמלית</strong> מעל הא"ב <span class="math">\(\Sigma=\left\{ \text{U, D, S}\right\} \)</span>. כך שאם לשניה פחדתם שאתם בפוסט הלא נכון - לא לדאוג, אנחנו עדיין מדברים על שפות פורמליות פה. ספציפית, על שפות חסרות הקשר, כי אני רוצה לטעון ששפת כל מסלולי מוצקין החוקיים היא שפה חסרת הקשר.</p>
<p>בואו נראה דוגמה למסלולים מאורך 3, חוקיים ולא חוקיים: מסלול חוקי פשוט הוא SSS שלא עולה למעלה ולא יורד למטה. עוד מסלול חוקי הוא USD שעולה, נשאר רגע למעלה ואז יורד. גם UDS (עולה, יורד, נשאר) הוא חוקי. לעומת זאת, USS לא חוקי כי הוא מסיים ב-<span class="math">\(\left(3,1\right)\)</span>; ו-DUS לא חוקי כי אחרי הצעד הראשון הוא יורד אל <span class="math">\(\left(1,-1\right)\)</span>; ו-UUD גם כן לא חוקי כי הוא מסיים שוב ב-<span class="math">\(\left(3,1\right)\)</span>. כבר מתעוררת מאליה השאלה - האם שפת מסלולי המוצקין היא שפה <strong>רגולרית</strong>? קל לראות שלא, כי היא בעצם כוללת בתוכה את <span class="math">\(\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} \)</span> בתור מין מקרה פרטי. פורמלית, קחו את כל המילים מהצורה <span class="math">\(\text{U}^{n}\)</span>; עבור כל זוג מילים כאלו, <span class="math">\(\text{U}^{k},\text{U}^{t}\)</span> כך ש-<span class="math">\(k\ne t\)</span> קל לראות ש-<span class="math">\(\text{U}^{k}\text{D}^{k}\)</span> מגדירה מסלול מוצקין חוקי אבל <span class="math">\(\text{U}^{t}\text{D}^{k}\)</span> לא, כך ש-<span class="math">\(\text{D}^{k}\)</span> היא מה שקראתי לו <strong>מילה מפרידה</strong> בפוסט על משפט נרוד, שמוכיח שהשפה של מסלולי מוצקין אינה רגולרית.</p>
<p>כדי לראות שהשפה כן חסרת הקשר, אציג דקדוק שמייצר אותה. הדקדוק יהיה פשוט למדי - רק משתנה התחלתי בודד, <span class="math">\(A\)</span>, ועוד הטרמינלים שלנו U,S,D (בדרך כלל טרמינלים הם באותיות קטנות אבל כאן זה יהיה שונה, ולכן גם בחרתי לסמן את המשתנה ההתחלתי ב-<span class="math">\(A\)</span> ולא ב-<span class="math">\(S\)</span> כרגיל). כדי להבין מה יהיו כללי הגזירה, בואו ננסה להבין איך מסלול מוצקין בנוי. ראשית, נסכים שמסלול "ריק" הוא מסלול מוצקין חוקי, ולכן יהיה לנו את כלל הגזירה <span class="math">\(A\to\varepsilon\)</span> (אם לא מסכימים שמסלול ריק הוא חוקי השיקולים בהמשך יעבדו אבל יהיו מסורבלים יותר וזה לא יהיה כיף).</p>
<p>בואו ניקח מסלול מוצקין כלשהו מאורך <span class="math">\(n\)</span>. האות הראשונה לא יכולה להיות <span class="math">\(\text{D}\)</span> כי זה יוריד את המסלול אל <span class="math">\(\left(1,-1\right)\)</span>. לכן יש שתי אפשרויות. באפשרות הראשונה, המסלול מתחיל ב-<span class="math">\(\text{S}\)</span>. אם מנתקים את ה-<span class="math">\(\text{S}\)</span> הזו מהמשך המסלול, המילה מאורך <span class="math">\(n-1\)</span> שנקבל תתאר מסלול מ-<span class="math">\(\left(1,0\right)\)</span> אל <span class="math">\(\left(n,0\right)\)</span> שמקיים את החוקיות של מסלולי מוצקין - דהיינו, היא תהווה מסלול מוצקין חוקי בעצמה. אז הנה כלל גזירה שמתאים לסיטואציה הזו: <span class="math">\(A\to\text{S}A\)</span>.</p>
<p>הסיטואציה האפשרית השניה היא זו שבה המסלול מתחיל ב-<span class="math">\(\text{U}\)</span>. כאן העסק קצת יותר טריקי. מכיוון שהמסלול הגיע אל <span class="math">\(\left(1,1\right)\)</span> אחרי הצעד הראשון שלו, והוא מסיים ב-<span class="math">\(\left(n,0\right)\)</span>, חייב להיות צעד כלשהו במסלול (אולי האחרון) שבו יורדים לראשונה לגובה 0. הצעד הזה הוא כמובן D כי שאר הצעדים לא מורידים אותנו. בואו נסמן את המקום שבו הגענו לגובה 0 בתור <span class="math">\(\left(k,0\right)\)</span>. עכשיו, ראשית כל שימו לב לכך שהחל מ-<span class="math">\(\left(k,0\right)\)</span> ועד ל-<span class="math">\(\left(n,0\right)\)</span> יש לנו עוד מסלול מוצקין, מאורך <span class="math">\(n-k\)</span> (אולי מאורך 0). וכמו כן, מה קורה <strong>בין</strong> צעד ה-U בהתחלה וצעד ה-D שמוריד אותנו ל-<span class="math">\(\left(k,0\right)\)</span>? יש לנו מסלול שמתחיל מ-<span class="math">\(\left(1,1\right)\)</span> ומסתיים ב-<span class="math">\(\left(k-1,1\right)\)</span> (המקום שאליו הגענו צעד לפני ה-D). יתר על כן - המסלול הזה לא יורד מתחת לגובה 1, מכיוון ש-<span class="math">\(\left(k,0\right)\)</span> הוא המקום הראשון שבו חזרנו לגובה 0 אחרי ההתחלה. מסקנה: המסלול מ-<span class="math">\(\left(1,1\right)\)</span> עד ל-<span class="math">\(\left(k-1,1\right)\)</span> הוא גם כן מסלול מוצקין חוקי, מאורך <span class="math">\(k-2\)</span>. זה מוביל אותנו אל כלל הגזירה הבא: <span class="math">\(A\to\text{U}A\text{D}A\)</span>. האם ברור לכם למה הוא נכון?</p>
<p>כלומר, הדקדוק המלא שמייצר את כל מסלולי מוצקין האפשריים הוא <span class="math">\(A\to\text{U}A\text{D}A|\text{S}A|\varepsilon\)</span>. הנה למשל גזירה פשוטה עבור USD: <span class="math">\(A\Rightarrow\text{U}A\text{D}A\Rightarrow\text{U}\text{S}A\text{D}A\Rightarrow\text{USD}A\Rightarrow\text{USD}\)</span>.</p>
<p>מה שנחמד בדוגמה הזו הוא שסוף סוף אנחנו רואים שפה פורמלית שבאמת מייצגת משהו "אמיתי" - ועוד כזה שלאו דווקא חושבים עליו מלכתחילה בהקשר של שפות פורמליות. באופן דוגמה הרבה אובייקטים קומבינטוריים ניתן לייצג באמצעות מילים מעל א"ב סופי, ואז אובייקט כמו אוטומט או דקדוק עבור השפה עוזר לנו להבין את המבנה שלה. בפרט, אני לא מכיר תיאור יותר פשוט למסלולי מוצקין מאשר הדקדוק שנתתי.</p>
<p>עכשיו, מכיוון שמסלולי מוצקין הם אובייקט קומבינטורי, אפשר לשאול עליהם שאלות קומבינטוריות. השאלה הראשונה על אובייקטים מסוג זה היא "כמה מסלולים מאורך <span class="math">\(n\)</span> קיימים?". התקווה היא תמיד שתהיה לנו נוסחה סגורה פשוטה, אבל בעולם האמיתי דברים כאלו לא קורים - לרוב האובייקטים הקומבינטוריים הלא טריוויאליים אין נוסחה פשוטה שמתארת את מספרם. אז מסתפקים בשיטות ייצוג עקיפות יותר, כששיטת הייצוג המקובלת ביותר היא <strong>פונקציה יוצרת</strong>. פונקציה יוצרת היא אובייקט מאוד מוזר במבט ראשון: אם יש לנו <span class="math">\(a_{n}\)</span> אובייקטים מגודל <span class="math">\(n\)</span>, ולכן יש לנו סדרה אינסופית <span class="math">\(a_{0},a_{1},a_{2},\dots\)</span> של מספר האובייקטים מכל גודל, אז הפונקציה היוצרת שלהם היא הטור הפורמלי <span class="math">\(\sum a_{n}x^{n}\)</span>. לפעמים אפשר למצוא לטור הזה ייצוגים סימבוליים פשוטים יותר (למשל, <span class="math">\(f\left(x\right)=\frac{1}{1-x}\)</span> הוא ייצוג סימבולי פשוט של הטור <span class="math">\(\sum x^{n}\)</span> שמתאים לסדרה <span class="math">\(1,1,1,\dots\)</span>) ואפשר להיעזר בייצוגים הסימבוליים הללו כדי להפיק מידע על הסדרה - למשל, קצב הגידול שלה - וכדי למצוא פונקציות יוצרות לסדרות נוספות שמתכתבות איכשהו עם הסדרה המקורית.</p>
<p>על כל זה יש לי כבר <a href="http://www.gadial.net/2009/09/08/generating_functions/">פוסט</a>, ומסלולי מוצקין מופיעים שם בתור דוגמה - ולא במקרה, אני מאוד אוהב את מסלולי מוצקין. בפוסטים פיתחתי במפורש את הפונקציה היוצרת שלהם, ועכשיו אחזור על אותו פיתוח, אבל בניסוח טיפה שונה - ניסוח באמצעות הכלי של הדקדוקים שלא השתמשתי בו בפוסט ההוא. אין לכם ממש צורך לקרוא את הפוסט ההוא, אבל אם המושג של פונקציות יוצרות עדיין נשמע לכם מוזר או לא הגיוני או הזוי או מה זה פה תפסיק לרמות אותנו (ואם אין לכם היכרות סבירה עם פונקציות יוצרות אתם <strong>אמורים </strong>לחשוב ככה)<strong> </strong>- יש לי גם <a href="http://www.gadial.net/2011/08/07/generating_functions_hardcore_1/">פוסטים</a> שמציגים את התורה של פונקציות יוצרות יותר לעומק, ובתקווה ישכנעו אתכם.</p>
<p>הנה כמה עובדות שכן יהיו רלוונטיות לנו. אם <span class="math">\(f\left(x\right),g\left(x\right)\)</span> הן פונקציות יוצרות שמתאימות לסדרות <span class="math">\(a_{n},b_{n}\)</span> אז הפונקציה <span class="math">\(f\left(x\right)+g\left(x\right)\)</span> מתאימה לסדרה <span class="math">\(a_{n}+b_{n}\)</span>. כמו כן, <span class="math">\(xf\left(x\right)\)</span> מתאימה לסדרה שמתקבלת מ-<span class="math">\(a_{n}\)</span> אחרי "הזזה" ימינה של כל האיברים ודחיפת 0 בהתחלה - פורמלית, <span class="math">\(c_{n}=a_{n-1}\)</span> כאשר <span class="math">\(c_{0}=0\)</span>. כמו כן, <span class="math">\(f\left(x\right)g\left(x\right)\)</span> מתאימה לסדרה <span class="math">\(c_{n}=\sum_{k=0}^{n}a_{k}b_{n-k}\)</span>, שמתארת את מספר האפשרויות לבנות אובייקט מגודל <span class="math">\(n\)</span> מתוך זוג של אובייקט מגודל <span class="math">\(k\)</span> מתוך הסדרה הראשונה ואובייקט מגודל <span class="math">\(n-k\)</span> מתוך הסדרה השניה, עבור כל <span class="math">\(0\le k\le n\)</span>.</p>
<p>עכשיו, בואו ניקח את הדקדוק <span class="math">\(A\to\text{U}A\text{D}A|\text{S}A|\varepsilon\)</span>. מה שצריך להבין הוא שהדקדוק הזה בעצם מתאר לנו <strong>משוואה</strong>: אם נסמן ב-<span class="math">\(L_{A}\)</span> את השפה שנוצרת על ידי המשתנה <span class="math">\(A\)</span>, אז הדקדוק אומר שמתקיים השוויון</p>
<p><span class="math">\(L_{A}=\left\{ \text{U}\right\} \cdot L_{A}\cdot\left\{ \text{D}\right\} \cdot L_{A}\cup\left\{ \text{S}\right\} \cdot L_{A}\cup\left\{ \varepsilon\right\} \)</span></p>
<p>אני רוצה להפוך את המשוואה הזו למשוואה עבור פונקציות יוצרות. נסמן ב-<span class="math">\(f_{A}\left(x\right)\)</span> את הפונקציה היוצרת של הסדרה <span class="math">\(a_{n}=\left|\left\{ w\in L_{A}\ |\ \left|w\right|=n\right\} \right|\)</span>. באופן דומה אפשר להגדיר פונקציה יוצרת לכל שפה שהיא. שימו לב גם לכך שהפונקציה היוצרת שמתאימה לשפה <span class="math">\(\left\{ \varepsilon\right\} \)</span> היא 1 (כי יש לנו אובייקט אחד מגודל 0 בשפה, ו-0 אובייקטים מכל גודל אחר) והפונקציה היוצרת שמתאימה ל-<span class="math">\(\left\{ \text{U}\right\} \)</span> היא <span class="math">\(x\)</span> (אובייקט אחד מגודל 1 ו-0 מכל גודל אחר) וכך גם עבור <span class="math">\(\left\{ \text{S}\right\} \)</span> ו-<span class="math">\(\left\{ \text{D}\right\} \)</span>.</p>
<p>עכשיו, נניח שיש לי שלוש שפות, <span class="math">\(L_{A}=L_{B}\cup L_{C}\)</span>, כך ש-<span class="math">\(L_{B}\cap L_{C}=\emptyset\)</span> עם פונקציות יוצרות מתאימות <span class="math">\(f_{A},f_{B},f_{C}\)</span>. אני טוען ש-<span class="math">\(f_{A}=f_{B}+f_{C}\)</span> מהסיבה שציינתי קודם (כי מספר האובייקטים מגודל <span class="math">\(n\)</span> ב-<span class="math">\(L_{A}\)</span> הוא בדיוק סכום מספרי האובייקטים מגודל זה ב-<span class="math">\(L_{B},L_{C}\)</span>). קצת יותר טריקי לראות שאם <span class="math">\(L_{A}=L_{B}\cdot L_{C}\)</span> אז <span class="math">\(f_{A}=f_{B}\cdot f_{C}\)</span>, אבל גם זה נובע ממה שאמרתי קודם (חשבו על זה קצת אם אתם לא משוכנעים). השתכנעתם בשני אלו? יופי, אז בואו נחזור למשוואה שלנו:</p>
<p><span class="math">\(L_{A}=\left\{ \text{U}\right\} \cdot L_{A}\cdot\left\{ \text{D}\right\} \cdot L_{A}\cup\left\{ \text{S}\right\} \cdot L_{A}\cup\left\{ \varepsilon\right\} \)</span></p>
<p>אם נתרגם אותה לפונקציות יוצרות ונשתמש בכללים שקיבלנו, הרי שנקבל</p>
<p><span class="math">\(f_{A}=x\cdot f_{A}\cdot x\cdot f_{A}+x\cdot f_{A}+1=x^{2}f_{A}^{2}+xf_{A}+1\)</span></p>
<p>אחרי העברת אגפים נקבל <strong>משוואה ממעלה שניה</strong>: <span class="math">\(x^{2}f_{A}^{2}+\left(x-1\right)f_{A}+1=0\)</span>. אפשר "לפתור" את המשוואה עם נוסחת השורשים הרגילה (כמובן, צריך להצדיק את זה, אבל אני לא אעשה את זה כאן) ולקבל את הפתרון</p>
<p><span class="math">\(f_{A}=\frac{1-x-\sqrt{\left(x-1\right)^{2}-4x^{2}}}{2x^{2}}=\frac{1-x-\sqrt{1-2x-3x^{2}}}{2x^{2}}\)</span></p>
<p>נוסחת השורשים מניבה שני פתרונות, וכאן לקחתי רק אחד - זה לא פוסט על קומבינטוריקה אז לא אסביר את השיקולים שבגללם יודעים שהפתרון שלקחתי הוא הנכון; זה מופיע בפוסט על פונקציות יוצרות ומסלולי מוצקין שקישרתי אליו. כאן מסלולי מוצקין מופיעים רק בתור דוגמה. הפואנטה היא שונה לחלוטין: התהליך שבו קיבלתי את הפונקציה היוצרת של <span class="math">\(L_{A}\)</span> היה כמעט <strong>מכני:</strong> בהינתן הדקדוק שמייצר את <span class="math">\(L_{A}\)</span>, קיבלתי ממנו באופן <strong>אוטומטי לגמרי</strong> משוואה עבור <span class="math">\(f_{A}\)</span>. כדי לחלץ ממנה את <span class="math">\(f_{A}\)</span> השתמשתי בידע כללי שיש לי על פתרון משוואות פונקציונליות שכאלו; לא תמיד אפשר לפתור את המשוואה בצורה נחמדה שכזו, אבל לפעמים כבר מערכת המשוואות עצמה היא מועילה.</p>
<p>בואו נראה עוד דוגמאות כדי להבין עד כמה חזק הכלי שכרגע קיבלנו. נתחיל מ-<span class="math">\(L=\left\{ a^{n}b^{n}\ |\ n\ge0\right\} \)</span> ידידתנו משכבר הימים. זו שפה שלכל <span class="math">\(n\)</span> זוגי יש בה בדיוק מילה אחת מאורך זה, ולכל <span class="math">\(n\)</span> אי זוגי יש בה 0 איברים מאורך זה. הפונקציה היוצרת באה מאליה: הדקדוק הוא <span class="math">\(S\to aSb|\varepsilon\)</span> ולכן המשוואה היא <span class="math">\(f=x^{2}f+1\)</span>, ואחרי חילוץ נקבל <span class="math">\(f=\frac{1}{1-x^{2}}=\sum x^{2n}\)</span> - בדיוק מה שהיינו אמורים לקבל. כמובן, זו בכל מקרה שפה פשוטה כי "קל לראות" מההגדרה שלה את העניין הזה של הזוגיים והאי זוגיים, אבל צריך להבין שאם השפה הזו נתונה למחשב, אז הייצוג שהמחשב הולך לקבל ככל הנראה יהיה הדקדוק, כי <strong>זה הייצוג הכי פשוט של השפה</strong>, ומהייצוג הזה הוא יכול להסיק את הפונקציה היוצרת (ובמקרה הזה, את מספר האיברים המפורש לכל <span class="math">\(n\)</span>) בקלות.</p>
<p>עוד דוגמה - <strong>מספרי קטלן</strong>. סדרת המספרים הזו היא פתרון לשלל בעיות ספירה מעניינות שלא נראות קשורות במבט ראשון. אציג כאן שתיים מהן - ראשית, מספר קטלן <span class="math">\(C_{n}\)</span> הוא מספר הסדרות מאורך <span class="math">\(2n\)</span> שמורכבות מסוגריים ימניים ושמאליים, כך שסדרת הסוגריים היא "חוקית" - מה שאומר שאם קוראים את המילה משמאל לימין אין רגע שבו מספר הסוגריים השמאליים גדול ממספר הסוגריים הימניים, ושבסוף המילה מספר הסוגריים משני הסוגים מתאזן. תחשבו על זה שניה ותבינו למה זה בדיוק אותו דבר כמו מספר המסלולים מ-<span class="math">\(\left(0,0\right)\)</span> אל <span class="math">\(\left(2n,0\right)\)</span> עם צעדי U ו-D אבל בלי צעדי S הפעם, כך שלא יורדים מתחת לציר <span class="math">\(x\)</span> (כלומר - זה דומה למסלולי מוצקין אבל זה לא באמת אותו דבר). דקדוק עבור השפה הזו נובע כמעט מאליו: <span class="math">\(A\to\text{U}A\text{D}A|\varepsilon\)</span>. ומכאן המשוואה <span class="math">\(f=x^{2}f^{2}+1\)</span> והפונקציה היוצרת <span class="math">\(f\left(x\right)=\frac{1-\sqrt{1-4x^{2}}}{2x^{2}}\)</span>. אבל רגע, זהירות, זו לא הפונקציה היוצרת של מספרי קטלן, כי <span class="math">\(C_{n}\)</span> מיוצג על ידי סדרה מאורך <span class="math">\(2n\)</span>. כדי לפתור את הבעיה הזו, אנחנו "מוציאים שורש". פורמלית, אם <span class="math">\(f\left(x\right)=\sum_{n=0}^{\infty}a_{2n}x^{2n}\)</span> (כלומר, מספר האיברים מגודל אי זוגי הוא תמיד אפס), אז אפשר להגדיר סדרה חדשה <span class="math">\(c_{n}=a_{2n}\)</span> עם פונקציה יוצרת <span class="math">\(g\left(x\right)=\sum c_{n}x^{n}\)</span> ונקבל ש-<span class="math">\(g\left(x^{2}\right)=f\left(x\right)\)</span>. לכן אם <span class="math">\(g\left(x^{2}\right)=\frac{1-\sqrt{1-4x^{2}}}{2x^{2}}\)</span> קיבלנו שהפונקציה היוצרת של מספרי קטלן היא <span class="math">\(g\left(x\right)=\frac{1-\sqrt{1-4x}}{2x}\)</span> (לא הבנתם את התעלולים הללו? לא נורא, זו לא מטרת הפוסט).</p>
<p>עכשיו, אחרי שנהנינו קצת, הגיע הזמן לחשוף את האמת המכוערת - אני קצת משקר לכם. בואו ניקח דקדוק אחר עבור <span class="math">\(\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} \)</span> כדי לראות את זה: <span class="math">\(S\to aSb|aaSbb|\varepsilon\)</span>. מה עשינו כאן? כמעט שום דבר - פשוט אפשרנו ל-<span class="math">\(S\)</span> לקצר עניינים וליצור יותר תווים בגזירה אחת. זה הופך את הדקדוק שלנו ל<strong>רב משמעי</strong>, כי הנה למשל שתי גזירות שונות מהותית של <span class="math">\(aabb\)</span>: <span class="math">\(S\Rightarrow aaSbb\Rightarrow aabb\)</span> ו-<span class="math">\(S\Rightarrow aSb\Rightarrow aaSbb\Rightarrow aabb\)</span>.</p>
<p>אם ננסה להפעיל את השיטה שראינו על הדקדוק הזה, נקבל כמובן <span class="math">\(f=1+x^{2}f+x^{4}f\)</span> שמוביל אותנו אל <span class="math">\(f=\frac{1}{1-x^{2}-x^{4}}\)</span> - וזו פונקציה שונה מ-<span class="math">\(\frac{1}{1-x^{2}}\)</span>. מה קרה? ההנחה הסמויה שלי הייתה שהדקדוק שלי הוא חד משמעי. אחרת, משוואה כמו <span class="math">\(L=aLb\cup aaLbb\cup\left\{ \varepsilon\right\} \)</span> כבר לא ניתנת לתרגום ישיר לפונקציות יוצרות כי האיחוד הראשון בה איננו איחוד זר. אני לא אוכיח כאן שאם הדקדוק חד משמעי אז לא יכולה להיווצר בעיה עם השיטה, אבל זה נכון. כמובן, להוכיח שדקדוק הוא חד משמעי זה לאו דווקא טריוויאלי וזה מקטין את השימושיות של השיטה.</p>
<p>בואו נעבור עכשיו לדבר על שפות רגולריות. הסיבה שמלכתחילה תיארתי בבלוג פונקציות יוצרות הייתה כדי <a href="http://www.gadial.net/2009/09/10/automata_and_generating_functions/">להראות תוצאה</a> שאני מאוד מחבב - שאפשר למצוא את הפונקציה היוצרת עבור שפה רגולרית מתוך כל אוטומט עבור השפה. אני רוצה להראות עכשיו שהתוצאה הזו היא בעצם מקרה פרטי של מה שאנחנו עושים כאן.</p>
<p>בפוסט הקודם אמרתי שאם יש לנו אוטומט סופי דטרמיניסטי <span class="math">\(A\)</span>, אז אפשר לבנות דקדוק עבור השפה שלו. הרעיון היה להתאים משתנה דקדוקי לכל מצב של האוטומט, ואת הגזירה <span class="math">\(q\to\sigma p\)</span> אם באוטומט יש את המעבר <span class="math">\(\delta\left(q,\sigma\right)=p\)</span>. וכמו כן את הגזירה <span class="math">\(q\to\varepsilon\)</span> אם <span class="math">\(q\in F\)</span>. עכשיו, הדקדוק הזה הוא כן חד משמעי, וזה נובע מכך ש-<span class="math">\(A\)</span> דטרמיניסטי; אם אתם לא משוכנעים, נסו לחשוב איך ייראו שתי גזירות שונות לאותה מילה - קל לראות שברגע שבו הן מתחילות "להתנהג שונה" הן גם יהיו חייבות ליצור אותיות שונות, ולכן מילים שונות.</p>
<p>עכשיו, בדקדוק שלנו יש הרבה משתנים, ולכן אנחנו לא מקבלים משוואה אחת; אנחנו מקבלים <strong>מערכת משוואות</strong>. אבל משוואות פשוטות במיוחד - לינאריות: לכל מצב <span class="math">\(q\)</span> תהיה לנו משוואה מהצורה</p>
<p><span class="math">\(f_{q}=\sum_{p}a_{p}^{q}xf_{p}+\delta_{q}\)</span></p>
<p>כאשר <span class="math">\(a_{p}^{q}\)</span> הוא מספר המעברים מ-<span class="math">\(q\)</span> אל <span class="math">\(p\)</span> - פורמלית, <span class="math">\(a_{p}^{q}=\left|\left\{ \sigma\in\Sigma\ |\ \delta\left(q,\sigma\right)=p\right\} \right|\)</span>. כמו כן, <span class="math">\(\delta_{q}=\begin{cases}1 & q\in F\\0 & q\notin F\end{cases}\)</span>. למה המשוואה הזו נכונה? אין כאן שום דבר חדש, זו הפעלה של הכללים שכבר ראינו.</p>
<p>מה שיפה במשוואה הזו היא שמדובר על משוואה <strong>לינארית</strong> - אין ל-<span class="math">\(f\)</span>-ים חזקות גבוהות שם. זה מאפשר לנו להשתמש בעולם המושגים של האלגברה הלינארית: נגדיר מטריצה <span class="math">\(A\)</span> כך ש-<span class="math">\(A_{qp}=a_{p}^{q}\)</span> ונגדיר וקטורים <span class="math">\(\overline{f},\overline{\delta}\)</span> שמייצגים את ה-<span class="math">\(f_{q}\)</span> וה-<span class="math">\(\delta_{q}\)</span>-ים, וקיבלנו שאפשר לכתוב את מערכת המשוואות כולה במשוואה קומפקטית אחת:</p>
<p><span class="math">\(\overline{f}=xA\cdot\overline{f}+\overline{\delta}\)</span></p>
<p>ואחרי חילוץ של <span class="math">\(\overline{f}\)</span>:</p>
<p><span class="math">\(\overline{f}=\left(I-xA\right)^{-1}\overline{\delta}\)</span></p>
<p>זו נוסחה פרקטית שממנה אפשר (אם יש לכם כלי שיודע לבצע אלגברה של מטריצות שאבריהן הם פולינומים) לחלץ את הפונקציות היוצרות - כבר הראיתי אותה בפוסט המקורי שלי, אבל הנה אנחנו מקבלים אותה שוב בקלות, מתוך השיטה הכללית עבור דקדוקים.</p>
<p>אם כן, זו המחשה לאופן שבו דקדוקים הם דרך מעניינת ומועילה לתאר שפות; בפוסטים הבאים נמשיך לחקור את מחלקת השפות שאפשר לתאר באמצעותם.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>