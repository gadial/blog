<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>כלל ה-0-1 של גרפים - ההוכחה - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2009/11/04/01_graph_law_proof/">
    <meta property="og:title" content="כלל ה-0-1 של גרפים - ההוכחה">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    

<meta property="og:image" content="http://gadial.net/img/main/default-card.png" />


        
    <!-- Twitter -->
    

<meta name="twitter:card" content="summary">


    <meta name="twitter:url" content="https://gadial.net/2009/11/04/01_graph_law_proof/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="כלל ה-0-1 של גרפים - ההוכחה">
    

<meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />


    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="/css/main.css">

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <a href="/lecture_notes.html">סיכומי הרצאות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2009/11/02/01_graph_law_intro/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">כלל ה-0-1 של גרפים - הקדמה</span>
            </a>
            

            
            <a href="/2009/11/27/quine_and_recursion_theorem/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">הפוסט שיודע להדפיס את עצמו</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>כלל ה-0-1 של גרפים - ההוכחה</h1>
            <div class="post-meta">
                <span class="date">2009-11-04</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                    <a href="/categories/קומבינטוריקה.html">קומבינטוריקה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/גרפים.html">גרפים</a>
                    
                    <a href="/tags/הוכחות.html">הוכחות</a>
                    
                    <a href="/tags/השיטה ההסתברותית.html">השיטה ההסתברותית</a>
                    
                    <a href="/tags/לוגיקה.html">לוגיקה</a>
                    
                    <a href="/tags/משפטי אי השלמות של גדל.html">משפטי אי השלמות של גדל</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p><a href="http://www.gadial.net/2009/11/02/01_graph_law_intro/">בפעם הקודמת</a> ניסחתי את כלל ה-0-1, ולכן עכשיו אגש להוכחה שלו בלי שהיות. הרעיון הבסיסי בהוכחה הוא פשוט מאוד, אבל גם מקסים: הבה ונתבונן בתורה <span class="math">\(T\)</span>, שהפסוקים שלה הם בדיוק אותם פסוקים שמתארים תכונות <span class="math">\(\mathcal{P}\)</span> עם הסתברות 1. למשל, הפסוק <span class="math">\(\exists v_{1},v_{2},v_{3}\left(E\left(v_{1},v_{2}\right)\wedge E\left(v_{2},v_{3}\right)\wedge E\left(v_{3},v_{1}\right)\right)\)</span> שמתאר את "בגרף קיים משולש" שראינו בפוסט הקודם נמצא בתורה זו. את ההוכחה כעת ניתן לסכם, למי שבקיא במושגים, בתור "התורה הזו עקבית ושלמה, ולכן כל תכונה שניתן לנסח בשפה או נובעת ממנה ואז הסתברותה 1, או ששלילתה נובעת ממנה ואז הסתברותה 0". כעת ניגש לפרטים ובראש ובראשונה למה שאני מתכוון אליו ב"תורה שלמה".</p>
<p><a href="http://www.gadial.net/2009/05/03/godel_incompleteness_yes/">לפני מספר פוסטים </a>דיברתי על שני מושגים שונים - "שלמות סמנטית" ו"שלמות סינטקטית". המושג של "שלמות סמנטית" התייחס לשלמות של מערכת ההוכחה שלנו, שבאופן אינטואיטיבי ניתן לנסח כ"כל מה שנכון - ניתן להוכחה". זו לא השלמות שאני מדבר עליה כאן - בפרט, מדובר בשלמות של מערכת הוכחה וכאן אני מדבר על שלמות של תורה. אם כן, אני מתכוון למה שכיניתי אז "שלמות סינטקטית"; תורה <span class="math">\(T\)</span> היא שלמה סינטקטית אם כל פסוק <span class="math">\(\varphi\)</span> ניתן להוכחה ממנה, או ששלילתו <span class="math">\(\neg\varphi\)</span> ניתנת להוכחה ממנה. גם כאן אני משתמש במושג ה"הוכחה" אך אין לי בו צורך של ממש; מכיוון שמערכת ההוכחה שלנו היא שלמה (סמנטית) ונאותה אז "אפשר להוכיח את <span class="math">\(\varphi\)</span> מ-<span class="math">\(T\)</span>" שקול ל"<span class="math">\(T\)</span> גוררת לוגית את <span class="math">\(\varphi\)</span>" שהגדרתי בפוסט הקודם ופירושו היה "כל מודל של <span class="math">\(T\)</span> הוא גם מודל של <span class="math">\(\varphi\)</span>" (סימנתי זאת <span class="math">\(T\vdash\varphi\)</span> - וכזכור, זה לא הסימן המקובל ואני משתמש בו כי את הסימן הנכון יותר אני לא מצליח להציג כאן).</p>
<p>אם כן, סיכום: אם <span class="math">\(T\)</span> היא עקבית ושלמה, אז אפשר להראות כי נובע מכך ש<strong>כל</strong> פסוק <span class="math">\(\varphi\)</span> שייך לה, או ש-<span class="math">\(\neg\varphi\)</span> שייך לה. זה מסיים את העניין מייד, כי אז לכל תכונה של גרף - שכזכור, מוגדרת באמצעות פסוק <span class="math">\(\varphi\)</span> - או ש-<span class="math">\(\varphi\in T\)</span> ואז הסתברות התכונה היא 1, או ש-<span class="math">\(\neg\varphi\in T\)</span> ואז ההסתברות שהתכונה לא מתקיימת היא 1, כלומר הסתברות התכונה היא 0. שימו לב לקשר היפה שיש כאן בין לוגיקה וקומבינטוריקה - כדי להוכיח את טענת ה-0-1 הקומבינטורית, הכל מצטצמם בסופו של דבר להוכחה שתורה מסויימת היא שלמה. זו גם דוגמה נאה לתורה "מעניינת" שאינה נופלת קורבן ל<a href="http://www.gadial.net/2009/05/03/godel_incompleteness_yes/">משפט אי השלמות של גדל</a>; הסיבה לכך שהיא חומקת ממנו היא שלא מדובר בתורה אריתמטית, כלומר היא אינה ממדלת את המספרים הטבעיים עם פעולת החיבור והכפל. זו כמובן לא התורה המעניינת היחידה שעושה זאת, אך עוד דוגמה לאוסף כדי להשתיק את מי שאומר "משפט גדל מראה שכל תורה מתמטית איננה שלמה" היא תמיד דבר טוב.</p>
<p>ראשית אני רוצה לטפל בשאלה מדוע אם <span class="math">\(T\)</span> עקבית ושלמה נובע מכך שכל פסוק נמצא בה או ששלילתו נמצאת בה. לשם כך מספיק להראות שהתורה היא "סגורה" במובן זה שאם <span class="math">\(T\vdash\varphi\)</span>, אז <span class="math">\(\varphi\in T\)</span>. הנה נימוק פשוט לכך: אם <span class="math">\(T\vdash\varphi\)</span> נובע מכך שקיימת קבוצה סופית של פסוקים <span class="math">\(\psi_{1},\dots,\psi_{n}\in T\)</span> כך ש-<span class="math">\(\left\{ \psi_{1},\dots,\psi_{n}\right\} \vdash\varphi\)</span> (למה? ההוכחה שאני חושב עליה היא "אם <span class="math">\(T\vdash\varphi\)</span> אז קיימת הוכחה ל-<span class="math">\(\varphi\)</span> עם אקסיומות מ-<span class="math">\(T\)</span>. מכיוון שזו הוכחה סופית, יש בה רק מספר סופי של אקסיומות <span class="math">\(\psi_{1},\dots,\psi_{n}\)</span>, ומכיוון שהן מוכיחות את <span class="math">\(\varphi\)</span> הן גם גוררות אותו לוגית" - אבל אני בטוח שיש עוד הוכחות). כלומר, כל מודל של הפסוק <span class="math">\(\psi_{1}\wedge\dots\wedge\psi_{n}\)</span> הוא גם מודל של <span class="math">\(\varphi\)</span>, ולכן ההסתברות ש-<span class="math">\(\varphi\)</span> יתקיים גדולה לפחות כמו ההסתברות ש-<span class="math">\(\psi_{1}\wedge\dots\wedge\psi_{n}\)</span> יתקיים (כי כל גרף שנגריל ויקיים את התכונה <span class="math">\(\psi_{1}\wedge\dots\wedge\psi_{n}\)</span> יקיים גם את התכונה <span class="math">\(\varphi\)</span>). לא קשה להראות שההסתברות ש-<span class="math">\(\psi_{1}\wedge\dots\wedge\psi_{n}\)</span> יתקיים היא 1, כי ההסתברות של כל <span class="math">\(\psi_{i}\)</span> היא 1 (נסו להוכיח זאת - זה תרגיל קצר ונחמד).</p>
<p>כעת לשאלה העיקרית - מדוע <span class="math">\(T\)</span> שלמה? התשובה הקצרה היא שקיים לה מודל בן מניה יחיד. כאן אנחנו מתפצלים לשתי שאלות - ראשית, איך קיום מודל בן מניה יחיד מבטיח שתורה היא שלמה (וזה מקרה פרטי של תוצאה סטנדרטית בלוגיקה) ושנית, איך מראים של-<span class="math">\(T\)</span> יש מודל בן מניה יחיד ומהו המודל הזה בכלל (זו עיקר העבודה ועיקר היופי).</p>
<p>ובכן, <a href="http://en.wikipedia.org/wiki/Categorical_theory">מה שמראה</a> ש-<span class="math">\(T\)</span> שלמה הוא מבחן Los-Vaught. לצורך כך, הגדרה: תורה נקראת <span class="math">\(\kappa\)</span>-קטגורית אם כל שני מודלים שלה שהן מעוצמה <span class="math">\(\kappa\)</span> הם איזומורפיים. מי שאינו מכיר עוצמות ("גודל אינסופי") או מבין את הכוונה המדוייקת ב"איזומורפיים" ("הם אותו דבר פרט אולי לשינוי הסימונים") - לא נורא. מה שהמבחן אומר הוא שאם תורה היא <span class="math">\(\kappa\)</span>-קטגורית, לא משנה עבור איזה <span class="math">\(\kappa\)</span>, ואין לה מודלים סופיים - אז היא שלמה. ההוכחה לטענה הזו מתבססת על משפט לוונהיים-סקולם, שכבר הזכרתי פעם, שמראה שאם לתורה (מסדר ראשון, כאן זה חשוב) יש מודל אינסופי, אז יש לה מודל אינסופי מכל עוצמה אינסופית (כלומר, שפות מסדר ראשון לא מסוגלות "להבדיל" בין עוצמות שונות של מודלים אינסופיים).</p>
<p>כעתת נניח כי <span class="math">\(T\)</span> אינה שלמה. אז יש פסוק <span class="math">\(\varphi\)</span> שאינו נובע ממנה, וגם <span class="math">\(\neg\varphi\)</span> אינו נובע ממנה. אז אפשר לבנות שתי תורות חדשות, <span class="math">\(T_{1}=T\cup\left\{ \varphi\right\} \)</span> ו-<span class="math">\(T_{2}=T\cup\left\{ \neg\varphi\right\} \)</span> שיהיו שתיהן עקביות (אם אחת מהן לא הייתה עקבית, פירוש הדבר היה ש-<span class="math">\(\varphi\)</span> או <span class="math">\(\neg\varphi\)</span> נובע מ-<span class="math">\(T\)</span>). לכן יש לשתיהן מודל אינסופי (כי אין ל-<span class="math">\(T\)</span> מודלים סופיים, וכל מודל של <span class="math">\(T_{1}\)</span>ושל <span class="math">\(T_{2}\)</span> הוא גם מודל של <span class="math">\(T\)</span>) ועל פי לוונהיים סקולם, לשתיהן יש מודל מעוצמה <span class="math">\(\kappa\)</span>; אבל אמרנו ש-<span class="math">\(T\)</span> היא <span class="math">\(\kappa\)</span>-קטגורית, ולכן שני המודלים הללו (שהם, כאמור, מודלים גם של <span class="math">\(T\)</span>) הם איזומורפיים. זה בלתי אפשרי שכן הם שונים מהותית - באחד <span class="math">\(\varphi\)</span> מתקיים, ובשני <span class="math">\(\neg\varphi\)</span> מתקיים. סתירה.</p>
<p>אם כן, סיימנו את המבוא הלוגי הכללי, ואפשר סוף סוף לגשת ל"בשר" של ההוכחה - האופן שבו מראים שיש ל-<span class="math">\(T\)</span> מודל בן מניה יחיד, ואין לה מודלים סופיים. בתור התחלה כדאי לעצור ולחשוב לרגע - מה זה בכלל אומר, "מודל ל-<span class="math">\(T\)</span>"? הרי <span class="math">\(T\)</span> מלכתחילה היא אוסף של פסוקים, שכל אחד בנפרד אמור להגדיר לנו גרפים; אם <span class="math">\(\varphi\in T\)</span> אז המודלים של <span class="math">\(\varphi\)</span> שהיו לנו בראש מלכתחילה היו של גרפים - וגרפים סופיים. אם כך, איך פתאום נכנסים מודלים אינסופיים לתמונה?</p>
<p>ובכן, די בבירור ל-<span class="math">\(T\)</span> פשוט לא יכול להיות מודל סופי. זאת מכיוון שהתכונה "בגרף יש לפחות <span class="math">\(n\)</span> צמתים" ניתנת לתיאור בלוגיקה מסדר ראשון, ובוודאי שיש לה הסתברות 1 (כזכור, ההסתברות נלקחת על גרף "אקראי" כשמספר הצמתים שואף לאינסוף). הפסוק <span class="math">\(\varphi_{n}\)</span> המתאים הוא פשוט <span class="math">\(\exists v_{1},\dots,v_{n}\left(\bigwedge_{i\ne j}v_{i}\ne v_{j}\right)\)</span>. אם ל-<span class="math">\(T\)</span> היה מודל סופי, עם נניח <span class="math">\(n\)</span> איברים, הוא לא היה יכול לספק את <span class="math">\(\varphi_{n+1}\in T\)</span> - סתירה. אז ל-<span class="math">\(T\)</span> אין מודל סופי. לכן היצורים היחידים שכן מספקים את כל הפסוקים שב-<span class="math">\(\varphi\)</span> בו זמנית הם גרפים אינסופיים. אין קושי רעיוני במושג כזה - אנחנו פשוט לא מגבילים את קבוצת הצמתים להיות סופית, וגרפים אינסופיים הם יצורים מאוד נפוצים במתמטיקה. עם זאת, המעורבות שלהם כאן היא עדיין מעניינת - אנחנו מראים שקיים גרף בן מניה יחיד שמקיים בו זמנית את כל התכונות שמתקיימות "כמעט בכל הגרפים הסופיים", וזה מראה לנו את נכונות כלל ה-0-1.</p>
<p>כדי לראות שהמודל בן המניה הוא יחיד, אנחנו רוצים לפשפש בתוך <span class="math">\(T\)</span> ולשלוף ממנה תכונות מאפיינות שהן מאוד חזקות, עד שהן מגבילות בצורה קיצונית את המודלים האינסופיים שיכולים להיות ל-<span class="math">\(T\)</span>. כאן אפשר לעשות אחד משניים - או להציג את התכונות הללו מייד ואז לראות שהן מסייעות, או לחכות טיפה עם החיפוש, לנסות ולהתחיל את ההוכחה שכל שני מודלים בני מנייה של <span class="math">\(T\)</span> הם איזומורפיים, ולראות מה אנחנו צריכים. אני מעדיף לפעול בדרך השניה, שהיא יותר "מחקרית" ואולי גם מקלה קצת על העיכול של מה שיקרה בהמשך.</p>
<p>איך מוכיחים ששני מודלים הם איזומורפיים? לצורך הפשטות מספיק לדבר על שני גרפים אינסופיים (בני מניה) <span class="math">\(A,B\)</span> ולא להיכנס לתורה הכללית. מה שצריך להראות הוא פשוט התאמה של אחד-לאחד בין הצמתים של <span class="math">\(A\)</span> והצמתים של <span class="math">\(B\)</span> שמשמרים את הקשתות. כלומר, אם <span class="math">\(V_{A}=\left\{ a_{1},a_{2},a_{3},\dots\right\} \)</span> הם צמתי <span class="math">\(A\)</span> ואילו <span class="math">\(V_{B}=\left\{ b_{1},b_{2},b_{3},\dots\right\} \)</span> הם צמתי <span class="math">\(B\)</span> אנחנו רוצים למצוא פונקציה <span class="math">\(f:V_{A}\to V_{B}\)</span> שהיא חד חד ערכית ועל, ומקיימת ש-<span class="math">\(\left(a_{i},a_{j}\right)\in E_{A}\)</span> אם ורק אם <span class="math">\(\left(f\left(a_{i}\right),f\left(a_{j}\right)\right)\in E_{B}\)</span>.</p>
<p>מה שנעשה הוא לשחק משחק באופן הבא. ראשית, נתאים את <span class="math">\(a_{1}\)</span> ל-<span class="math">\(b_{1}\)</span>, פשוט כי לעת עתה אין שום מהלך נבון יותר שניתן לעשות. כעת, למי נתאים את <span class="math">\(a_{2}\)</span>? זה כבר נהיה מורכב מעט יותר - אם <span class="math">\(a_{1}\)</span> מחובר ל-<span class="math">\(a_{2}\)</span>, נרצה לבחור <span class="math">\(b_{i}\in V_{B}\)</span> שמחובר ל-<span class="math">\(b_{1}\)</span>. מה מבטיח לנו שקיים כזה? ובכן, אם לא היה קיים כזה, אז <span class="math">\(B\)</span> לא היה מודל טוב עבור התכונה "לכל צומת יש לפחות שכן אחד", שלא קשה לראות שניתן לנסח בשפה מסדר ראשון ושיש לו הסתברות 1 (בגרף עם <span class="math">\(n+1\)</span> צמתים, לכל צומת יש <span class="math">\(n\)</span> שכנים פוטנציאליים, ולכן ההסתברות שלא יהיה לו אף שכן היא <span class="math">\(\frac{1}{2^{n}}\)</span> - שואפת לאפס).</p>
<p>בואו נעבור לדבר על משהו כללי יותר. נניח שעד כה טיפלתי בכל הצמתים <span class="math">\(a_{1},a_{2},\dots,a_{n}\)</span> ועכשיו אני תוהה לאן להעביר את <span class="math">\(a_{n+1}\)</span>. בואו נניח לצורך נוחות ש-<span class="math">\(a_{1}\)</span> עבר ל-<span class="math">\(b_{1}\)</span>, ש-<span class="math">\(a_{2}\)</span> עבר ל-<span class="math">\(b_{2}\)</span> וכן הלאה (אם לא, פשוט נשנה את המספור של הצמתים של <span class="math">\(B\)</span>). עכשיו, הצומת החדש <span class="math">\(a_{n+1}\)</span> הולך להיות מחובר לחלק מהצמתים הקיימים, ולחלק מהם - לא. נסמן ב-<span class="math">\(S_{A}\)</span> את קבוצת הצמתים שאליהם <span class="math">\(a_{n+1}\)</span> מחובר, וב-<span class="math">\(S_{B}\)</span> את קבוצת ה"תמונות" שלהם (ה-<span class="math">\(b_{i}\)</span>-ים שמחוברים לאיברים של <span class="math">\(S_{A}\)</span>). מה שאנחנו רוצים לעשות הוא למצוא צומת כלשהו ב-<span class="math">\(V_{B}\)</span> שמחובר לכל הצמתים ב-<span class="math">\(S_{B}\)</span>, ולא מחובר לאף צומת מבין <span class="math">\(b_{1},\dots,b_{n}\)</span> שאיננו ב-<span class="math">\(S_{B}\)</span>. האם קיים צומת שכזה? אנחנו חייבים שהתשובה תהיה חיובית כדי שהשיטה תצליח; וזה מוביל אותנו לניסוח התכונות שב-<span class="math">\(T\)</span> שיעניינו אותנו, שהן בדיוק התכונות שאומרות "כן! בכל תרחיש דוגמת זה שתיארת למעלה, אפשר למצוא צומת <span class="math">\(b_{n+1}\)</span> מתאים". מה שצריך להראות הוא שהתכונות הללו ניתנות לניסוח בשפה מסדר ראשון שלנו, ושההסתברות לכך שהן יתקיימו בגרף היא 1. ברגע שהראנו זאת, סיימנו; כי אז התהליך שתיארתי לעיל, אחרי שמכלילים אותו עוד טיפה, מגדיר באופן מושלם את האיזומורפיזם (אם רוצים לדעת לאן <span class="math">\(a_{n}\)</span> עבר, "מריצים" את התהליך במשך <span class="math">\(n\)</span> צעדים ורואים מה קורה; כדי להבטיח שגם כל ה-<span class="math">\(b_n\)</span>-ים יותאמו לאחד מה-<span class="math">\(a_n\)</span>-ים צריך לבחור גם עבורם איברים, לסירוגין).</p>
<p>הבה ננסח במפורש את התכונות שאנחנו רוצים. נסמן ב-<span class="math">\(\text{EA}_{n,m}\)</span> את התכונה "לכל קבוצה <span class="math">\(X\)</span> מגודל <span class="math">\(n\)</span> ותת קבוצה <span class="math">\(Y\)</span> מגודל <span class="math">\(m\)</span> שלה, קיים איבר שאינו ב-<span class="math">\(X\)</span> שמחובר לכל אברי <span class="math">\(Y\)</span> ואינו מחובר לאף איבר ב-<span class="math">\(X\)</span> שאינו ב-<span class="math">\(Y\)</span>" (למה <span class="math">\(\text{EA}\)</span>? מלשון Extension Axiom, שכן זוהי אקסיומה שאומרת שניתן "להרחיב" את הקבוצה <span class="math">\(X\)</span> באופן שמעניין אותנו - דהיינו, חיבור בדיוק לצמתי <span class="math">\(Y\)</span>). את התכונה הזו אפשר לכתוב בקלות יחסית בשפה מסדר ראשון:</p>
<p><span class="math">\(\forall v_{1},\dots,v_{n}\)</span><br />
<span class="math">\(\left[\left(\bigwedge_{i\ne j}v_{i}\ne v_{j}\right)\to\exists u\left(\bigwedge_{i}^{n}u\ne v_{i}\wedge\bigwedge_{i\le m}E\left(u,v_{i}\right)\wedge\bigwedge_{i&gt;m}^{n}\neg E\left(u,v_{i}\right)\right)\right]\)</span></p>
<p>אז נשאר רק להראות שכל תכונה כזו מתקיימת בהסתברות 1 בכל גרף. האינטואיציה ברורה - <span class="math">\(n,m\)</span> הם קבועים, ואנחנו שואלים את עצמנו מה קורה בגרפים אקראיים שגודלם שואף לאינסוף. אם נקבע את <span class="math">\(X,Y\)</span>, בגרפים כאלו יש כמעט "אינסוף" צמתים <span class="math">\(u\)</span> פוטנציאליים להתאים ל-<span class="math">\(X,Y\)</span>, ולכן צומת שכזה אכן יופיע. כך זה בתורת הגרפים (ובמקומות רבים אחרים...) - ברגע שהמבנה שלך גדול מספיק, כל מה שתוכל להעלות על דעתך יווצר בתוכו, כל עוד מה שמעניין אותך הוא תכונה <strong>מקומית</strong>.</p>
<p>כדי להקל על החישוב נפשט קצת עניינים. אין צורך לדבר על <span class="math">\(\text{EA}_{n,m}\)</span> עבור <span class="math">\(n,m\)</span> כלליים - שימו לב שאם <span class="math">\(\text{EA}_{2m,m}\)</span> מתקיים בהסתברות 1, אז בוודאי גם <span class="math">\(\text{EA}_{n,m}\)</span> מתקיים בהסתברות 1 עבור <span class="math">\(m\le n\le2m\)</span>, כי אנחנו מקלים קצת על הדרישות - הקבוצה <span class="math">\(Y\)</span> נותרת זהה, ואנחנו פשוט דורשים פחות דרישות על שאר האיברים ב-<span class="math">\(X\)</span> (כלומר, מעיפים לכל הרוחות את חלקם). לכן די להוכיח כי <span class="math">\(\text{EA}_{2m,m}\)</span> מתקיים בהסתברות 1. נקבע את מספר הצמתים בגרף כולו להיות <span class="math">\(n\)</span> (כי השתמשנו ב-<span class="math">\(n\)</span> עד כה למטרה זו וחבל להפסיק - רק צריך לזכור שזה לא אותו <span class="math">\(n\)</span> שהופיע ב-<span class="math">\(\text{EA}_{n,m}\)</span>).</p>
<p>מכאן זו באמת קומבינטוריקה פשוטה וקצת אינפי. ניקח צומת שאיננו ב-<span class="math">\(X\)</span>. מה ההסתברות שהוא מחובר לכל <span class="math">\(m\)</span> צמתי <span class="math">\(Y\)</span>, ואינו מחובר לכל הצמתים של <span class="math">\(X\)</span> שאינם ב-<span class="math">\(Y\)</span>? בדיוק <span class="math">\(\frac{1}{2^{2m}}\)</span>, כי יש <span class="math">\(2m\)</span> הגרלות של קשתות שבכל אחת אנחנו צריכים שתתקבל תוצאה ספציפית. אם כן, ההסתברות שצומת כלשהו <strong>לא</strong> יקיים את התכונה הרצויה היא <span class="math">\(1-\frac{1}{2^{2m}}\)</span>. על פניו הסתברות גדולה - אבל כאמור, יש <strong>המון</strong> צמתים שונים. כמה המון? <span class="math">\(n-2m\)</span> צמתים שבגרף אך אינם ב-<span class="math">\(X\)</span>. ההסתברות ש<strong>אף אחד</strong> מהם לא יהיה בסדר היא מכפלת ההסתברויות של כל אחד להיות לא בסדר, כלומר <span class="math">\(\left(1-\frac{1}{2^{2m}}\right)^{n}\)</span>. זה בפני עצמו שואף לאפס כשמשאיפים את <span class="math">\(n\)</span> לאינסוף, אבל צריך לשים לב שלא סיימנו - אנחנו לא טוענים טענה על קבוצה <span class="math">\(X\)</span> ספיצפית, אלא על <strong>כל</strong> קבוצה <span class="math">\(X\)</span> מגודל <span class="math">\(2m\)</span> וכל תת קבוצה <span class="math">\(Y\)</span> שלה מגודל <span class="math">\(m\)</span>. אז ההסתברות שמשהו ישתבש הוא שתהיה קבוצה <span class="math">\(X\)</span> כלשהי ותת קבוצה <span class="math">\(Y\)</span> שלה שעבורן האירוע ה"רע" שהסתברותו <span class="math">\(\left(1-\frac{1}{2^{2m}}\right)^{n}\)</span> מתרחש. ההסתברות לכל זה חסומה על ידי מספר תת הקבוצות הללו כפול <span class="math">\(\left(1-\frac{1}{2^{2m}}\right)^{n}\)</span> (בהינתן קבוצת מאורעות, ההסתברות שאחד מהם יתרחש חסומה על ידי סכום ההסתברויות שלהם - זה מה שנקרא Union bound).</p>
<p>אז הסתברות הכישלון שלנו חסומה על ידי <span class="math">\({n \choose 2m}{2m \choose m}\left(1-\frac{1}{2^{2m}}\right)^{n}\)</span>. את כל זה אפשר לחסום על ידי <span class="math">\(n^{2m}\cdot c^{n}\)</span> כש-<span class="math">\(c\)</span> הוא קבוע קטן מ-1. המסקנה ברורה - פולינום כמו <span class="math">\(n^{2m}\)</span> גדל הרבה יותר לאט מאשר פונקציה אקספוננציאלית כמו <span class="math">\(c^{n}\)</span> גדלה, ומכיוון ש-<span class="math">\(c<1\)</span>, <span class="math">\(c^{n}\)</span> שואף לאפס, ולכן <span class="math">\(n^{2m}\cdot c^{n}\)</span> כולו שואף לאפס כש-<span class="math">\(n\)</span> שואף לאינסוף, כלומר ההסתברות ש"משהו יתקלקל" שואפת לאפס, ולכן ההסתברות שהתכונה תתקיים שואפת ל-1. זהו.</p>
<p>אם כן, החלק האחרון של ההוכחה היה כולו קומבינטוריקה, מה שמראה שהמשפט הזה הוא שילוב מקסים של רעיונות משני התחומים גם יחד. אני מקווה שנהניתם.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>