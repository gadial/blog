<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט אי השלמות הראשון של גדל - איך (בערך) מוכיחים אותו? - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/new_blog/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/new_blog/">דף הבית</a>
                <a href="/new_blog/random.html">פוסט אקראי</a>
                <a href="/new_blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_blog/2009/05/03/godel_incompleteness_yes/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">משפטי אי השלמות של גדל - מה הם כן אומרים?</span>
            </a>
            

            
            <a href="/new_blog/2009/05/17/euler_proof_infinity_of_primes/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">הוכחת אוילר לקיום אינסוף ראשוניים</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט אי השלמות הראשון של גדל - איך (בערך) מוכיחים אותו?</h1>
            <div class="post-meta">
                <span class="date">2009-05-10</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/חישוביות.html">חישוביות</a>
                    
                    <a href="/categories/לוגיקה.html">לוגיקה</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/הוכחות יפות.html">הוכחות יפות</a>
                    
                    <a href="/tags/משפטי אי השלמות של גדל.html">משפטי אי השלמות של גדל</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <h2>הקדמה</h2>
<p>הרעיון המפורסם ביותר בהוכחת <a href="http://www.gadial.net/2009/05/03/godel_incompleteness_yes/">משפט אי השלמות הראשון של גדל</a> (איני חושב שאוכיח כאן את השני, לפחות לא כעת) הוא הרעיון של לכסון - שיטה ששימשה כבר את גאורג קנטור <a href="http://www.gadial.net/2007/08/29/cantor_diagonal/">בהוכחה שלו</a> לכך שעוצמת הממשיים אינה שווה לעוצמת הטבעיים. כמעט בכל תיאור של משפט גדל מזכירים את הדמיון שלו לפרדוקס השקרן (הפרדוקס שבו איש כרתים אומר "כל אנשי כרתים משקרים תמיד", ולכן לא ברור אם הוא אומר את האמת או משקר), ולעתים אף מגדילים לעשות ומסבירים עד כמה גאוני היה מצד גדל לחשוב על להשתמש בו - אך כאמור, קנטור כבר עשה זאת זמן מה קודם לכן. לדעתי, הגאונות האמיתית של גדל היא ברעיון, שכיום נראה אולי פשוט וברור לחלוטין - בפרט לבקיאים במדעי המחשב - להשתמש בנוסחאות שלכאורה מדברות רק על מספרים טבעיים כדי לתאר מערכות הוכחה, ולא סתם מערכות הוכחה אלא את אלו שבתוכן הנוסחאות הללו "חיות". ברעיון הזה אפשר להתחיל את תיאור ההוכחה של גדל.</p>
<h2>מספור גדל</h2>
<p>הבה ונזכור מהי הוכחה - סדרה של טענות, כשכל טענה היא סדרה של תווים מעל אלף-בית כלשהו של סימנים. לא כל סדרת תווים היא חוקית - יש כללים שקובעים אילו סדרות הן חוקיות (לסדרות כאלו, שמהוות טענה חוקית, לפעמים קוראים "Well formed formula" ומייד מקצרים ל-wff והופכים את יתר הטקסט לבלתי קריא) ואילו לא. מה שגדל מציע הוא לקודד כל טענה באמצעות מספר באופן הבא: ראשית, לכל תו באלף-בית נצמיד מספר טבעי - כך למשל "<span class="math">\(\wedge\)</span>" שמסמל "וגם" יכול לקבל את המספר 3, בעוד "<span class="math">\(x\)</span>" שהוא משתנה יכול לקבל 5 (יש אינסוף משתנים, אבל זו לא בעיה - כל משתנה יקבל מספר אחר. באופן כללי, אם <span class="math">\(t\)</span> הוא סימן כלשהו, אז <span class="math">\(g\left(t\right)\)</span> יהיה הערך שגדל מתאים לו.</p>
<p>עכשיו, בהינתן פסוק, למשל <span class="math">\(x\wedge\neg z\)</span>, אפשר להתאים לו מספר באופן הבא: <span class="math">\(2^{g\left(x\right)}\cdot3^{g\left(\wedge\right)}\cdot5^{g\left(\neg\right)}\cdot7^{g\left(z\right)}\)</span>. כלומר, המספר שמותאם לפסוק הוא מכפלה של ראשוניים, כאשר החזקה של הראשוני ה-<span class="math">\(k\)</span>-י במכפלה היא הערך המספרי שהותאם לתו ה-<span class="math">\(k\)</span>-י באותו פסוק. השימוש בראשוניים נובע מכך שלכל מספר יש פירוק יחיד לראשוניים, כך שלא ייתכן ששתי מכפלות שונות של ראשוניים יתנו את אותו מספר, ולכן כל פסוק מקודד באופן ייחודי.</p>
<p>בימינו, הרעיון הזה נמצא בשימוש בכל מחשב, כל הזמן; הדוגמה הקלאסית שלו היא <a href="http://he.wikipedia.org/wiki/ASCII">קוד ASCII</a>, שבו מקודדים 256 תווים שונים באמצעות מספרים מ-0 ועד 255. כל מחרוזת של תווים מקודדת כעת באמצעות רצף של מספרים שכאלו, וכשמחשב פותח קובץ טקסט הוא קורא את המספר הגדול מאוד שמהווה את הקידוד, ומתרגם אותו חזרה לסדרת תווים. גדל לא הכיר מחשבים ואת שיטת הקידוד ASCII, כמובן; בזמנו הם כלל לא היו קיימים. איני יודע אם הוא המציא את רעיון הקידוד באופן כללי - אני מניח שלא, ובכל זאת, הקרדיט על הרעיון של קידוד טענות פורמליות שמדברות על מספרים באמצעות מספרים, מה שמאפשר לטענות לדבר "על עצמן" - הקרדיט הזה ניתן לגדל במלואו.</p>
<p>באופן דומה לזה שבו מקודדים פסוקים, אפשר לקודד הוכחות שלמות - פשוט קחו את 2 בחזקת הקידוד של הפסוק הראשון בהוכחה, כפול 3 בחזקת הקידוד של הפסוק השני בהוכחה, וכן הלאה. מכיוון שכל הוכחה היא סופית, זה עובד - ושוב, למי שמכיר קידודים במחשב בימינו כל הדיון הזה נשמע קצת מיותר, ושיטת הקידוד של גדל - קצת מסורבלת.</p>
<h2>פונקציות רקורסיביות</h2>
<p>המושג הבא שגדל מדבר עליו הוא <a href="http://he.wikipedia.org/wiki/%D7%A4%D7%95%D7%A0%D7%A7%D7%A6%D7%99%D7%94_%D7%A4%D7%A8%D7%99%D7%9E%D7%99%D7%98%D7%99%D7%91%D7%99%D7%AA_%D7%A8%D7%A7%D7%95%D7%A8%D7%A1%D7%99%D7%91%D7%99%D7%AA">פונקציות רקורסיביות</a>. בימינו, המשמעות המוכרת של "פונקציה רקורסיבית" היא של פונקציה בתוכנית מחשב שמבצעת קריאה לעצמה (איך זה אפשרי? בשביל מה זה טוב? זה עניין לפוסט אחר). גדל, כמובן, מתכוון למשהו קצת שונה - כפי שנראה, שם יותר מתאים לפונקציות הללו הוא למעשה "פונקציות ניתנות לחישוב" - למשל, לחישוב על ידי מחשב, או אלגוריתם, או <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%9B%D7%95%D7%A0%D7%AA_%D7%98%D7%99%D7%95%D7%A8%D7%99%D7%A0%D7%92">מכונת טיורינג</a>, או אדם עם נייר ועט וסבלנות, אך זהו מושג שלא היה קיים בתקופת גדל; למרות שהרעיון של בניית פונקציות באופן רקורסיבי לא היה חדש, הפורמליזם המדוייק שגדל השתמש בו, והצליח לתפוס בצורה (כמעט) מדוייקת את הרעיון של "ניתן לחישוב", הוא (ככל שהצלחתי לברר) המצאה שלו, ואחד מהרעיונות המבריקים שבמאמר. אתאר כעת את הפורמליזם הזה.</p>
<p>באופן כללי, הדיון עוסק בפונקציות מהמספרים הטבעיים לטבעיים. כדי להקל על החיים, מרשים לפונקציה לקבל ולהחזיר <strong>סדרות סופיות</strong> של טבעיים, כלומר באופן כללי אנחנו מדברים על פונקציה <span class="math">\(f:\mathbb{N}^{n}\to\mathbb{N}^{m}\)</span>. ההגיון הוא שכל דבר שניתן לחישוב ניתן לתאר (באמצעות קידוד מתאים) כחישוב על טבעיים - ואכן, זה גם מה שגדל עושה - מתרגם פונקציות על טענות והוכחות (למשל, פונקציה שמחזירה 1 רק אם הוכחה מסויימת היא תקפה) לפונקציות על מספרים טבעיים.</p>
<p>מגדירים את הפונקציות הרקורסיביות באינדוקציה - מתחילים מפונקציות בסיס פשוטות מאוד, ובונים באמצעותן פונקציות מורכבות יותר. פונקציות הבסיס הן:</p>
<ol>
    <li> הפונקציה הקבועה אפס: <span class="math">\(f\left(x_{1},\dots,x_{n}\right)=0\)</span> (לכל<span class="math">\(n\)</span> טבעי, כלומר <span class="math">\(f\left(x\right)=0\)</span>, וגם <span class="math">\(f\left(x_{1},x_{2}\right)=0\)</span> וכו').</li>
    <li> פונקצית העוקב: <span class="math">\(g\left(x\right)=x+1\)</span>.</li>
    <li> פונקצית ההטלה על הרכיב ה-<span class="math">\(i\)</span>: <span class="math">\(h_{i}\left(x_{1},\dots,x_{n}\right)=x_{i}\)</span></li>
</ol>
<p>כל אלו הן פונקציות פשוטות למדי. אם אתם יודעים לתכנת, תוכלו לתכנת אותן ללא קושי רב. אם כן, בינתיים הפונקציות מתאימות היטב להגדרה של "ניתן לחישוב". ומה הלאה?</p>
<p>דרך אחת לבנות פונקציות חדשות מהישנות היא הרכבה. הניסוח הפורמלי מעט מסורבל, ולכן קודם כל דוגמה למקרה פשוט: אם יש לנו שתי פונקציות רקורסיביות,<span class="math">\(f\left(x\right),g\left(x\right)\)</span>, אז אפשר לבנות פונקציה חדשה שמסמלת קודם כל הפעלה של <span class="math">\(g\)</span> ואחרי הפעלה של <span class="math">\(f\)</span>. בכתיבה פורמלית,<span class="math">\(h\left(x\right)=f\left(g\left(x\right)\right)\)</span>. די בבירור אם<span class="math">\(f,g\)</span> ניתנות לחישוב, גם <span class="math">\(h\)</span> ניתנת לחישוב (קודם כל מחשבים את <span class="math">\(g\left(x\right)\)</span>, ואז מחשבים מה <span class="math">\(f\)</span> מחזיר על התוצאה).</p>
<p>באופן כללי הניסוח מסורבל מעט יותר, כאמור: אם <span class="math">\(g_{1}\dots g_{n}\)</span> כולן פונקציות רקורסיביות ב-<span class="math">\(m\)</span> משתנים, ו-<span class="math">\(f\)</span> היא פונקציה ב-<span class="math">\(n\)</span> משתנים, אז אפשר להגדיר כך פונקציה <span class="math">\(h\)</span> מ-<span class="math">\(m\)</span>:<span class="math">\(h\left(x_{1},\dots,x_{m}\right)=f\left(g_{1}\left(x_{1},\dots,x_{m}\right),\dots,g_{n}\left(x_{1},\dots,x_{m}\right)\right)\)</span>.</p>
<p>הבניה המרכזית והמעניינת ביותר, שנתנה לפונקציות את שמן, היא הרקורסיה. במשמעות ה"רגילה" של המילה, פונקציה רקורסיבית היא כזו שמוגדרת באמצעות עצמה, אך על קלט פשוט יותר. למשל, <span class="math">\(f\left(n\right)=f\left(n-1\right)+f\left(n-2\right)\)</span> היא פונקציה רקורסיבית (שמגדירה את מספר פיבונאצ'י ה-<span class="math">\(n\)</span>-י) כדי שיהיה טעם ברקורסיה, חייבים להיות מוגדרים לה "תנאי עצירה" - הגדרה מפורשת של ערכיה כאשר הקלט קטן דיו. עבור פיבונאצ'י, למשל, הגדרה אפשרית אחת היא <span class="math">\(f\left(0\right)=0,f\left(1\right)=1\)</span>.</p>
<p>פורמלית, פעולת הרקורסיה מוגדרת כך. נניח שיש לנו פונקציה רקורסיבית (במובן של "ניתנת לחישוב") <span class="math">\(f\left(y,z,x_{1},\dots,x_{n}\right)\)</span> ופונקציה רקורסיבית <span class="math">\(g\left(x_{1},\dots,x_{n}\right)\)</span> (זוהי הפונקציה של "תנאי ההתחלה"), אז אפשר להגדיר פונקציה רקורסיבית חדשה <span class="math">\(h\left(y,x_{1},\dots,x_{n}\right)\)</span> באופן הבא:</p>
<p><span class="math">\(h\left(0,x_{1},\dots,x_{n}\right) = g\left(x_{1},\dots,x_{n}\right) = h\left(n+1,x_{1},\dots,x_{n}\right) = f\left(n,h\left(n,x_{1},\dots,x_{n}\right),x_{1},\dots,x_{n}\right)\)</span></p>
<p>אם כן, <span class="math">\(h\left(n,x_{1},\dots,x_{n}\right)\)</span> פירושו "<span class="math">\(h\)</span> עבור הערך <span class="math">\(n\)</span> והפרמטרים הקבועים <span class="math">\(x_{1},\dots,x_{n}\)</span>". כאשר הערך <span class="math">\(n=0\)</span>, אז <span class="math">\(h\)</span> פשוט מחזירה את תנאי ההתחלה, וכאשר הוא גדול יותר מחזירים את מה ש-<span class="math">\(f\)</span> נותנת, שמתבסס על <span class="math">\(n\)</span>, על <span class="math">\(x_{1},\dots,x_{n}\)</span>, ועל הערך הקטן יותר של <span class="math">\(h\)</span>.</p>
<p>זהו פורמליזם קצת מתוסבך, אבל עם קצת מחשבה אפשר להבין מה קורה בו, ולראות שזה די קל לתכנת גם דבר שכזה, ולכן גם פונקציות שנבנות כך הן ניתנות לחישוב.</p>
<p>רק אחרי גדל, כאשר מודלים פורמליים של אלגוריתמים (למשל, מכונת טיורינג) פותחו ניתן היה להוכיח פורמלית גם את הכיוון ההפוך - שהפונקציות הרקורסיביות הן <strong>כל</strong> מה שניתן לחישוב. איני מדייק כאן עד הסוף - מה שתיארתי עד כה נקרא בימינו "פונקציות רקורסיביות <strong>פרימיטיביות</strong>", שכן ניתן להוסיף עוד כלל בנייה אחד - כלל המינימיזציה - ולקבל מחלקה רחבה יותר של פונקציות, אך כאלו שאינן בהכרח מוגדרות לכל קלט. ארחיב על כך בפוסט נפרד, אך לעת עתה אין בכך צורך; די בכך שאומר שאפשר להוכיח שכל תוכנית מחשב שמקבלת כקלט סדרת מספרים טבעיים, עוצרת לכל קלט אפשרי ומוציאה כפלט סדרת מספרים טבעיים - כל תוכנית מחשב שכזו ניתן לתאר באמצעות פונקציה רקורסיבית. זו תוצאה די מפתיעה - הרבה יותר מפתיעה מאשר "מכונת טיורינג יכולה לחשב את כל מה שתוכנית מחשב יכולה" (מה שמעיד על כך שמכונת טיורינג היא פורמליזם <strong>טוב</strong>) - וההוכחה שלה אינה טריוויאלית.</p>
<p>בזמנו של גדל, כמובן, כל זה לא היה ידוע. זו הסיבה שבגללה השלב הבא בהוכחה שלו הוא כל כך טכני ומורכב. מה שגדל רוצה לעשות כעת הוא לבנות פונקציה רקורסיבית <span class="math">\(B\left(x,y\right)\)</span> שמחזירה 1 אם המספר הטבעי <span class="math">\(x\)</span> הוא קידוד של הוכחה עבור הטענה שמקודדת על ידי המספר<span class="math">\(y\)</span> (למעשה, גדל מגדיר <strong>יחס</strong> ולא פונקציה, אך שני המושגים שקולים זה לזה ולא אתעמק בהבחנה הזו). אם אנחנו יודעים שקיימת פונקציה רקורסיבית עבור כל תוכנית מחשב, הקיום של <span class="math">\(B\)</span> אינו מפתיע במיוחד - בהינתן <span class="math">\(x,y\)</span>, זה עניין טכני ומכני בלבד לפענח את הקידוד של <span class="math">\(x\)</span> ולקבל סדרה של טענות, ואז זה עניין טכני ומכני בלבד לבדוק שכל טענה בסדרה היא או אקסיומה או נובעת מקודמותיה, ושהפסוק האחרון בסדרה הוא מה ש-<span class="math">\(y\)</span> מקודד; זה בדיוק המקום שבו נדרש ממערכת ההוכחה להיות אפקטיבית, כך שבדיקה שכזו תהיה אפשרית בכלל - אם המערכת לא הייתה אפקטיבית, ככל הנראה הפונקציה<span class="math">\(B\)</span> המדוברת לא הייתה רקורסיבית (כמובן, עדיין ניתן היה <strong>להגדיר</strong> את <span class="math">\(B\)</span> באופן מילולי; פשוט לא היינו יכולים לעשות בה את השימוש שגדל עושה אחר כך, ומצריך ממנה להיות רקורסיבית).</p>
<p>לרוע מזלו של גדל, נפנוף הידיים שלעיל מן הסתם לא היה קביל עבורו. התוצאה היא שהוא בונה את <span class="math">\(B\)</span> באופן מפורש ומדוייק, תוך עבודה צמודה עם ההגדרות שלעיל של כללי הבניה של פונקציות רקורסיביות. הבנייה היא הדרגתית - בכל פעם הוא בונה פונקציות רקורסיביות יותר ויותר מורכבות, שעליהן ניתן לבנות פונקציות עוד יותר מורכבות, וכן הלאה, עד שבסופו של דבר, לאחר לא פחות מ-45 צעדים (שכל אחד מהם דורש רק שורה או שניים, אמנם) הוא מגיע אל <span class="math">\(B\)</span> הנכספת. כאשר מוכיחים את משפט גדל לסטודנטים ללוגיקה, זה לרוב החלק בהוכחה שכולל הרבה נפנופי ידיים או הנחות לא מוכחות - ולדעתי בצדק, כי אין בבנייה הזו שום דבר מחכים לכשעצמה. גדל פשוט תכנת ב<a href="http://he.wikipedia.org/wiki/%D7%90%D7%A1%D7%9E%D7%91%D7%9C%D7%99">אסמבלי</a> של המתמטיקה (יותר מדוייק לומר "באסמבלי של תורת החישוביות"), לפני שהיו קיימות שפות עיליות. מבחינה טכנית זה מרשים מאוד, כמובן.</p>
<h2>ייצוג הפונקציות הרקורסיביות</h2>
<p>אוקיי, אז גדל הראה שאותה <span class="math">\(B\left(x,y\right)\)</span> היא רקורסיבית. מה עכשיו? כעת גדל מגיע לפאנץ' ליין של השימוש בפונקציות רקורסיביות - הוא מראה שבתורה שאותה הוא "תוקף", אפשר לייצג את הפונקציות הללו. המשמעות המדוייק של הייצוג הזה היא מעט טכנית ולא אכנס אליה, ולכן לצורך העניין ניתן לחשוב על כך (באופן לא מדוייק לגמרי) כאילו ניתן להשתמש בפונקציות רקורסיביות בצורה חופשית בפסוקים של התורה, כאילו הן היו חלק מהשפה עצמה. גדל אמנם מראה זאת רק עבור תורה ספציפית - <a href="http://en.wikipedia.org/wiki/Principia_Mathematica">זו של ראסל וויטהד </a>- אבל בהמשך הוא מראה כי די בפעולות החיבור והכפל ה"סטנדרטיות": כדי שאפשר יהיה להגדיר את הפונקציות הרקורסיביות. זו נקודה מעניינת, ולכן אני רוצה להתעכב גם עליה.</p>
<p>פונקציה רקורסיבית בסיסית, כמו <span class="math">\(f\left(x\right)=0\)</span> קל לייצג, כי יש לנו סימן עבור 0 בשפה; ובדומה, גם <span class="math">\(f\left(x\right)=x+1\)</span> קל לייצוג כי יש לנו בשפה סימן עבור עוקב. גם הטלות והרכבות לא קשה לייצג - האתגר האמיתי הוא פעולת הרקורסיה (שהיא, כאמור, הפעולה עם ה"בשר" כאן). בנפנוף ידיים, מה שצריך לעשות כדי לייצג פונקציה שנבנתה ברקורסיה, הוא לבנות פסוק שאומר "קיימת סדרת ערכים, כך שהערך הראשון מתקבל מבסיס הרקורסיה, וכל ערך גדול יותר מתקבל מקודמו על ידי הפעלת פונקצית הרקורסיה, והערך האחרון הוא הפלט של הפונקציה" (קצת מזכיר הוכחה פורמלית, לא?). האתגר שבבניית פסוק שכזה הוא בדיוק בטענת ה"קיימת סדרה" - הרי בלוגיקה מסדר ראשון אין דרך לכמת קבוצות של איברים, וסדרה היא קבוצה שכזו. כל מה שניתן לעשות הוא לטעון טענות "קיים מספר", לא "קיימת סדרת מספרים". אז איך עוקפים את זה?</p>
<p>התשובה היא שכל עוד הסדרה היא <strong>סופית</strong>, אפשר לקודד אותה באמצעות מספר בודד, ואז כל מה שצריך לעשות כדי לדבר על איברים ספציפיים בסדרה הוא "לפתוח את הקידוד" ולהתייחס למקום המתאים. הרעיון הזה נשמע מאוד דומה לרעיון של קידוד גדל - ושוב, לא במקרה - ולצורך הביצוע שלו גדל שולף מהשרוול טריק מתמטי אחד או שניים ומגדיר את מה שמכונה "פונקצית ה-<span class="math">\(\beta\)</span> של גדל". הפונקציה הזו מעניינת בכך שהיא ניתנת לייצוג באמצעות פעולות חיבור וכפל בלבד (אבל <strong>שתי</strong> הפעולות הללו הן הכרחיות, ולכן בלי פעולת כפל כל ההוכחה קורסת), והיא אכן מממשת בצורה מקסימה את רעיון ה"קידוד של כל הסדרות הסופיות". לא אתן כרגע תיאור מדוייק של הפונקציה, אך ייתכן שאקדיש לה פוסט בהמשך - רק אומר שהרעיון הבסיסי של הקידוד מתבסס על משפט עתיק יומין ויפה שכבר הזכרתי כאן - <a href="http://www.gadial.net/2007/11/10/modular_square_roots_hardness/">משפט השאריות הסיני</a>.</p>
<p>אם כן, סיכום ביניים: גדל משתמש בפונקצית ה-<span class="math">\(\beta\)</span> כדי להראות שכל הפונקציות הרקורסיביות ניתנות לייצוג בכל תורה אריתמטית. הוא כבר הראה שבכל תורה אפקטיבית, הפונקציה <span class="math">\(B\left(x,y\right)\)</span> של "<span class="math">\(x\)</span> היא הוכחה ל-<span class="math">\(y\)</span>" היא רקורסיבית. משני אלו עולה שהיא ניתנת לייצוג בתורה שהיא אריתמטית ואפקטיבית. כעת הגענו לישורת האחרונה.</p>
<h2>שובו של האלכסון</h2>
<p>החלקים הטכניים של ההוכחה כבר פחות או יותר מאחורינו - כל מה שנותר הוא רעיון חדש אחד או שניים, שניתנים להבנה גם עבור מי שלא בקיא בפרטים הקטנים של מה שהלך עד כה. ראשית כל ננסה לתת את המוטביציה להגדרה החדשה. יש לנו כבר יכולת לומר "<span class="math">\(x\)</span> הוא הוכחה ל-<span class="math">\(y\)</span>" והיינו רוצים לבנות פסוק <span class="math">\(G\)</span> שאומר "אין הוכחה עבורי". כעת, כל נוסחה <span class="math">\(\varphi\)</span> מיוצגת, כזכור, על ידי מספר - זהו מספור גדל המדובר. נסמן את המספר הזה בתור <span class="math">\(\left|\varphi\right|\)</span>. אם כן, מדוע לא לבנות את הפסוק הבא: <span class="math">\(G=\forall x\left(\neg B\left(x,\left|G\right|\right)\right)\)</span>? כלומר, <span class="math">\(G\)</span> הוא הפסוק שאומר "לא קיים <span class="math">\(x\)</span> שהוא הוכחה עבורי" - זה יסיים את העניין.</p>
<p>לרוע המזל, ההפניה העצמית שאנו כל כך אוהבים פונה כאן כנגדנו. שימו לב איך <strong>הגדרתי</strong> את הפסוק <span class="math">\(G\)</span>: חלק ממנו הוא <span class="math">\(\left|G\right|\)</span>, שהוא מספר טבעי שמיוצג בתורה שלנו באמצעות הפעלות חוזרות ונשנות של פונקצית העוקב על 0 - כלומר, זו מחרוזת ארוכה ומסובכת. מצד שני,<strong> הערך המספרי</strong> שאותה מחרוזת מייצגת הוא משהו שכדי לחשב אותו עלינו כבר לדעת את <strong>כל</strong> הנוסחה <span class="math">\(G\)</span>; במילים אחרות, ההגדרה שלנו היא מעגלית - כל עוד לא כתבנו במפורש את <span class="math">\(G\)</span> אין משמעות ל-<span class="math">\(\left|G\right|\)</span>, אבל מבלי שתהיה משמעות ל-<span class="math">\(\left|G\right|\)</span> אי אפשר לכתוב את <span class="math">\(G\)</span>! בקיצור, נתקענו, ואנו זקוקים לתעלול כדי לפתור את הבעיה. תעלול שכזה הוא בדיוק מה שגדל מספק; בסופו של דבר הוא יאפשר, בצורה עקיפה, להציב את <span class="math">\(\left|G\right|\)</span> בתוך <span class="math">\(G\)</span>.</p>
<p>ראשית, בואו נבהיר הגדרה חשובה אחת: "פסוק" פירושו של דבר שאין בו משתנים שאינם נופלים תחת כמת כלשהו. למשל, <span class="math">\(\varphi=\forall x,y\left(x+y=y+x\right)\)</span> הוא פסוק; לעומת זאת, <span class="math">\(\varphi^{\prime}=x+y&amp;gt;0\)</span> אינו פסוק. ההבדל מהותי: ל-<span class="math">\(\varphi\)</span> יש ערך אמת מוגדר, או שהוא נכון, או שלא. לעומת זאת, ערך האמת של <span class="math">\(\varphi^{\prime}\)</span> תלוי בערכים הספציפיים של<span class="math">\(x,y\)</span> ש"נציב" בו.</p>
<p>נניח לרגע שיש לנו נוסחה <span class="math">\(\varphi\)</span> שמכילה בדיוק משתנה חופשי אחד <span class="math">\(y\)</span>. אז <span class="math">\(\varphi\left(\left|\varphi\right|\right)\)</span> הוא <strong>פסוק</strong> שמתקבל מלקיחת <span class="math">\(\varphi\)</span> והצבת המספר <span class="math">\(\left|y\right|\)</span> בכל מקום שבו כתוב <span class="math">\(y\)</span> ב-<span class="math">\(\varphi\)</span>. זכרו שבשפה שלנו ניתן לתאר כל מספר טבעי, על ידי הפעלה של פונקצית העוקב מספר סופי של פעמים, ולכן <span class="math">\(\varphi\left(\left|\varphi\right|\right)\)</span> הוא פסוק חוקי בשפה. הפסוק הזה מכונה "<strong>הלכסון</strong> של <span class="math">\(\varphi\)</span>", וכאמור - ערכו הוא אמת אם ורק אם כאשר מציבים את <span class="math">\(\left|\varphi\right|\)</span> בתוך <span class="math">\(\varphi\)</span> מקבלים אמת. אם כן, עקפנו במובן מה את הקושי של הצבת מספר גדל של נוסחה "בתוך עצמה" - אבל המחיר ששילמנו הוא בזה שמספר גדל של הפסוק <span class="math">\(\varphi\left(\left|\varphi\right|\right)\)</span> שונה מזה של <span class="math">\(\varphi\)</span>.</p>
<p>דוגמה טיפשית: נניח ש-<span class="math">\(\varphi=\exists x\left(y&gt;x\wedge2\cdot y&lt;x\right)\)</span>. נניח שאחרי חישובים קשים מצאנו כי <span class="math">\(\left|\varphi\right|=1231\)</span> (מספר מפוברק, כמובן). אז <span class="math">\(\varphi\left(\left|\varphi\right|\right)=\exists x\left(1231&gt;x\wedge2\cdot1231&lt;x\right)\)</span>, וזהו פסוק שיש לו או ערך אמת, או ערך שקר. כאן אנחנו מתחילים לראות את ההתייחסות העצמית המדוברת של משפט גדל - אפשר לשאול את <span class="math">\(\varphi\)</span>"מה אתה אומר על עצמך?". אלן טיורינג ישתמש בדיוק ברעיון הזה מספר שנים לאחר מכן, ולא במקרה, אלא בהשראת הרעיון הזה של גדל.</p>
<p>מה בעצם משמעות המילה "לכסון" כאן? הנה אינטואיציה. חשבו על טבלה שבה לכל נוסחה במשתנה אחד <span class="math">\(\varphi\left(y\right)\)</span> יש שורה, ולכל מספר טבעי שמתאים לנוסחה שכזו יש עמודה. בעמודה <span class="math">\(n\)</span> בשורה של <span class="math">\(\varphi\)</span> יהיה 1 אם <span class="math">\(\varphi\left(n\right)\)</span> מקבל ערך אמת, ו-0 אחרת. כעת, אם נסדר את הנוסחאות <span class="math">\(\varphi\)</span> על פי סדר הגודל של מספרי גדל שלהם, הרי שהערכים של <span class="math">\(\varphi\left(\left|\varphi\right|\right)\)</span> יהיו בדיוק האלכסון של הטבלה.</p>
<p>כאמור, גם הלכסון של <span class="math">\(\varphi\)</span> הוא נוסחה, ולכן יש לו מספר גדל משל עצמו. זה פותח פתח להגדרת הפונקציה הבאה: <span class="math">\(diag\left(n\right)=k\)</span> אם <span class="math">\(k\)</span> הוא מספר גדל של הלכסון של הנוסחה <span class="math">\(\varphi\)</span> שעבורה <span class="math">\(\left|\varphi\right|=n\)</span>. כלומר, אם נתנו לנו <span class="math">\(n\)</span> אנחנו "מפענחים" את הנוסחה <span class="math">\(\varphi\)</span> שהוא מקודד, כותבים פורמלית את הנוסחה <span class="math">\(\varphi\left(\left|\varphi\right|\right)\)</span> (שכאמור, שונה פיזית מהנוסחה <span class="math">\(\varphi\left(y\right)\)</span> - סדרת הסמלים שמרכיבים אותה שונה, ולכן מספר גדל שלה יהיה שונה), מקודדים אותה בחזרה ומוציאים כפלט את המספר. ההסבר הזה הוא גם "אלגוריתם" לחישוב הפונקציה, ומכאן שהיא פונקציה רקורסיבית, ומכאן שהיא ניתנת לייצוג בתורה. בזאת סיימנו לדבר על הכלי החזק ביותר שבו נשתמש.</p>
<p>כעת נקשור את שני הרעיונות המרכזיים של גדל - הלכסון, והפונקציה <span class="math">\(B\left(x,y\right)\)</span>. נגדיר את הנוסחה הבאה: <span class="math">\(U\left(y\right)=\forall x\neg B\left(x,diag\left(y\right)\right)\)</span>. הנוסחה הזו אומרת "לא קיימת הוכחה לפסוק שמיוצג על ידי המספר<span class="math">\(diag\left(y\right)\)</span>". אנחנו כבר ממש ממש שם, נשארה רק עוד הגדרה אחת, אחרונה, שהיא הטוויסט הסופי - מה שמקבלים כאשר מלכסנים את <span class="math">\(U\)</span> עצמה.</p>
<p>אם כן, נגדיר <span class="math">\(G=U\left(\left|U\right|\right)\)</span>. הנוסחה <span class="math">\(G\)</span> הזו היא היעד הסופי שלנו - זה הפסוק שאינו ניתן להוכחה ועם זאת הוא נכון. ראשית, ברור שמדובר בפסוק, כי אין בו משתנים חופשיים. שנית, מה בעצם הוא אומר? הפסוק מקבל ערך אמת אם ורק אם הערך של <span class="math">\(U\)</span> על <span class="math">\(\left|U\right|\)</span> הוא אמת; אבל <span class="math">\(U\)</span> מקבל ערך אמת על <span class="math">\(\left|U\right|\)</span> אם ורק אם לא קיימת הוכחה לפסוק שמיוצג על ידי המספר <span class="math">\(diag\left(\left|U\right|\right)\)</span>. אבל מה זה הפסוק הזה? נזכר בהגדרה: <span class="math">\(diag\left(\left|U\right|\right)\)</span> הוא מספר גדל של הלכסון של <span class="math">\(U\)</span>, כלומר של הפסוק <span class="math">\(G=U\left(\left|U\right|\right)\)</span>. כלומר, בסיכומו של דבר קיבלנו ש-<span class="math">\(G\)</span> מקבל ערך אמת אם ורק אם לא קיימת הוכחה לפסוק שמיוצג על ידי <span class="math">\(G\)</span> - זהו הניסוח הפחות או יותר מדוייק לתיאור האינטואיטיבי של "<span class="math">\(G\)</span> אומרת שאין לה הוכחה".</p>
<p>וואו. בכל פעם שבה אני מגיע לשלב הזה בהוכחה, אני צריך לעצור ולשאוף קצת אוויר. אף שהרעיון של לכסון אינו חדש, גדל בהחלט הביא אותו כאן לכדי שלמות.</p>
<h2>מה עוד נשאר?</h2>
<p>למרות שבנינו את <span class="math">\(G\)</span>, עדיין לא סיימנו. הטיעון שנתתי לעיל, של "<span class="math">\(G\)</span> אומרת שאין לה הוכחה" הוא טיעון בנפנופי ידיים - טיעון "סמנטי" שמתבסס על המשמעות שאני מייחס ל-<span class="math">\(G\)</span>. עבור הוכחה פורמלית צריך להראות ממש שלא ניתן להוכיח את <span class="math">\(G\)</span>. בסימון פורמלי, <span class="math">\(\vdash\varphi\)</span> אומר "ניתן להוכיח את <span class="math">\(\varphi\)</span>". אם כן, אנו רוצים להראות כי <span class="math">\(\not\vdash G\)</span>. נניח אם כן כי <span class="math">\(\vdash G\)</span>; כלומר, קיימת הוכחה של <span class="math">\(G\)</span> במערכת שלנו, ולכן לאותה הוכחה קיים מספר גדל כלשהו, נניח <span class="math">\(m\)</span>; מכאן שמתקיים <span class="math">\(B\left(m,\left|G\right|\right)\)</span>, כלומר מתקיים <span class="math">\(B\left(m,diag\left(\left|U\right|\right)\right)\)</span> (כל זה - על פי ההגדרות). כעת, לא ממש הסברתי עד הסוף מה זה אומר ש-<span class="math">\(B\)</span>"מיוצגת" בתורה שלנו, אבל אחת מההשלכות של ה"ייצוג" הזה הוא שמתקיים <span class="math">\(\vdash B\left(m,diag\left(\left|U\right|\right)\right)\)</span>.</p>
<p>מצד שני, <span class="math">\(G=\forall x\neg B\left(x,diag\left(\left|U\right|\right)\right)\)</span> על פי הבניה שלנו, ולכן <span class="math">\(\vdash\forall x\neg B\left(x,diag\left(\left|U\right|\right)\right)\)</span>; מכללי ההיסק הסטנדרטיים נובע ש-<span class="math">\(\vdash\neg B\left(m,diag\left(\left|U\right|\right)\right)\)</span> (אם ניתן להוכיח שזה קורה לכל <span class="math">\(x\)</span>, ניתן להוכיח שזה קורה ספציפתי עבור <span class="math">\(x=m\)</span>). לכן קיבלנו שהמערכת שלנו מוכיחה משפט ושלילתו - סתירה לכך שהיא עקבית.</p>
<p>שימו לב למה שקרה כאן כרגע - היינו חייבים להתבסס על עקביות התורה. אם היא לא הייתה עקבית, הרי שכן היה ניתן להוכיח את פסוק גדל שלנו, ולכן הטענה שהוא טוען הייתה <strong>שגויה</strong>. מכאן שלא מדויק לומר שהפסוק <span class="math">\(G\)</span> הוא "נכון" - יותר מדויק לומר ש<strong>אם</strong> המערכת שלנו עקבית, <strong>אז</strong> הפסוק נכון. ההבחנה הזו קריטית, מכיוון שלפעמים מנסים לטעון ש"אנחנו יותר חכמים מהמערכת הלוגית" כי אנחנו יודעים ש-<span class="math">\(G\)</span> נכון בזמן שהיא לא יודעת זאת כי היא לא מסוגלת להוכיח זאת. דא עקא, אנחנו לא באמת יודעים ש-<span class="math">\(G\)</span> נכון; "לדעת" ש-<span class="math">\(G\)</span> נכון היה אומר שאנחנו יודעים שהמערכת שלנו היא עקבית, אבל אנחנו לא יודעים זאת!</p>
<p>אני לא רוצה לתת את הרושם הלא נכון - ה"הוכחה" שכתבתי פה היא לא יותר מאשר ערב רב של נפנופי ידיים לא מדויקים. הפרטים הטכניים של ההוכחה רבים ומורכבים יותר, וישנן נקודות עדינות רבות שלא הזכרתי או שאולי אף איני מכיר (או שם אליהן לב) בעצמי. בפרט, שימו לב שלא הוכחתי בכלל כי בתורה שלנו לא ניתן להוכיח את השלילה של <span class="math">\(G\)</span>! (הסיבוך הטכני שמתקשר להוכחה הזו לא שווה את זה, במסגרת הפוסט הזה). עם זאת, אני מקווה שאת רוח ההוכחה ורעיונותיה המרכזיים עלה בידי להעביר.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>