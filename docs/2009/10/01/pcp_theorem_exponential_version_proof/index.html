<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אז מה בין קודים לתיקון שגיאות והוכחת משפט ה-PCP? - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/new_blog/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/new_blog/">דף הבית</a>
                <a href="/new_blog/random.html">פוסט אקראי</a>
                <a href="/new_blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_blog/2009/09/23/locally_checkable_codes/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">קודים לתיקון שגיאות (שניתנים לבדיקה מקומית)</span>
            </a>
            

            
            <a href="/new_blog/2009/10/04/sub_loglog_space_is_constant/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">למה זכרון שהוא פחות מלגלג הוא קבוע?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>אז מה בין קודים לתיקון שגיאות והוכחת משפט ה-PCP?</h1>
            <div class="post-meta">
                <span class="date">2009-10-01</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/משפט ה-PCP.html">משפט ה-PCP</a>
                    
                    <a href="/tags/קוד הדמר.html">קוד הדמר</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בשני הפוסטים האחרונים הצגתי שני מושגים שנראים על פניו חסרי קשר. <a href="http://www.gadial.net/2009/09/19/pcp_theorem_intro/">המושג הראשון</a> היה הוכחות PCP, שהן מעין תחליף להוכחות "רגילות" שבהן יש ודאות מוחלטות שההוכחה נכונה, כשהתמורה הבולטת לויתור הזה על הביטחון המוחלט (והחלפתו בביטחון "מוחלט לכל רמת דיוק שנרצה פרט למאה אחוז") היא שכבר אין צורך לקרוא את כל ההוכחה, אלא רק מספר קבוע של ביטים ממנה, בלי תלות בטענה הספציפית שרוצים להוכיח (מבחינה פורמלית זה טיפה יותר מסובך - תמיד יש "שפה" ברקע, והטענות שהמערכת מטפלת בהן הן מהצורה "המילה הזו שייכת לשפה").</p>
<p><a href="http://www.gadial.net/2009/09/23/locally_checkable_codes/">המושג השני</a> היה קודים לתיקון וזיהוי שגיאות, ועיקר הפוסט הוקדש להצגת קוד מסויים - קוד הדמר - בעל התכונה שהוא ניתן לבדיקה מקומית - מספיק לדגום (באקראי) מספר קבוע של ביטים מתוך מילה נתונה כדי לבדוק בהסתברות טובה למדי האם זוהי מילת קוד חוקית או לא. זה התחיל להזכיר את משפט ה-PCP, שגם בו מבוצעת בדיקה אקראית "מקומית", אבל עדיין רב הנסתר על הנגלה - איך קודים מתקשרים להוכחות? בכך אטפל בפוסט הזה.</p>
<p>השלב הראשון הוא מעבר ממודל החישוב הרגיל שלנו - שנע בין דיבורים מעורפלים על "אלגוריתם" ו"מוודא" ועד למודל הפורמלי של <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%9B%D7%95%D7%A0%D7%AA_%D7%98%D7%99%D7%95%D7%A8%D7%99%D7%A0%D7%92">מכונת טיורינג</a> - למודל חישוב אחר, שבמובנים רבים הוא פשוט אף יותר, ויהיה מושלם למה שאנחנו מנסים לעשות - <a href="http://he.wikipedia.org/wiki/%D7%A1%D7%99%D7%91%D7%95%D7%9B%D7%99%D7%95%D7%AA_%D7%9E%D7%A2%D7%92%D7%9C%D7%99%D7%9D">מעגלים בוליאניים</a>.</p>
<p>על מעגלים בוליאניים אפשר לכתוב פוסטים מכאן ועד להודעה חדשה, אבל כמו במקרה של קודים לתיקון שגיאות גם כאן אתמקד כעת במה שרלוונטי עבורנו. בבסיסם, מעגלים הם מודל חישובי פשוט מאוד, שמורכב מ"שערים לוגיים" וחיבורים ביניהם. שער לוגי מקבל מספר ערכים, שכל אחד מהם הוא או 0 או 1, ומבצע עליהם חישוב פשוט. למשל, שער NOT מחזיר 1 אם קיבל 0, ו-0 אם קיבל 1; ושער AND מקבל שני ערכים, מחזיר 1 אם שניהם 1 ואחרת (אם לפחות אחד מהם הוא אפס) מחזיר 0. יש עוד שערים אבל די לנו בשני אלו כדי לייצג <strong>כל</strong> פונקציה בוליאנית (פונקציה שמקבלת מספר ערכים של 0 ו-1 ומחזירה כפלט 0 או 1) בעזרת מעגל שמכיל רק את השערים הללו.</p>
<p>המילה "מעגל" קצת מטעה; אין במעגל הזה מעגלים אמיתיים, כלומר לא ניתן למצוא שער שהפלט שלו יכול להתחבר איכשהו לקלט שלו. המעגל מתחיל בקלטים, שעליהם אפשר לחשוב כעל שערים פשוטים שפולטים ביט בודד, והקלטים נכנסים לשערים אחרים, והפלט שלהם נכנס לשערים נוספים, וכן הלאה וכן הלאה עד שלבסוף הכל מתנקז לשער אחד אחרון, שהיציאה שלו היא הפלט של המעגל כולו. כרגיל בעניינים כאלו, תמונה אחת שווה אלף מילים:</p>
<p><img src="http://users.ece.gatech.edu/~sudha/academic/class/ece2030/Lectures/gate-design/examples-14.gif" height="255" width="469" /></p>
<p>מעגלים בוליאניים צצים דווקא בהקשרים מעשיים - זה (בפשטנות רבה להחריד, כמובן) מה שקורה בפועל במעגלים חשמליים. עם זאת, המקור ה"מעשי" של המעגלים לא מונע מהם להיות נושא מרתק וחשוב בעיסוקים תיאורטיים טהורים, כמו זה שכאן. האבחנה החשובה הראשונה היא שמעגלים בוליאניים יכולים לחשב כל פונקציה בוליאנית, ובפרט שלכל מכונת טיורינג (שהיא, כזכור, מודל מתמטי קונקרטי של "אלגוריתם") אפשר לתת משפחה של מעגלים בוליאניים שמתנהגים "כמוה". למה "משפחה"? כי בניגוד למכונת טיורינג, שמסוגלת לקבל קלטים מכל אורך שהוא, מעגל בוליאני מוגבל מראש - כל מעגל בנוי כך שהוא מקבל מספר קלטים ספציפי, ולכן אם רוצים לטפל בכל אורכי הקלטים האפשריים צריך לתת משפחה של מעגלים - מעגל לכל אורך קלט אפשרי. לעתים קרובות כל המעגלים הללו יהיו דומים זה לזה כך שאין כאן בעיה של ממש, אבל כשמנסים להגדיר פורמלית את מודל החישוב הזה, ה"משפחתיות" הזו יוצרת בעיות שלא ניכנס אליהן כעת (רק אעיר שאם לא מגבילים אותה, מקבלים מודל חישובי ש<strong>חזק</strong> יותר ממכונת טיורינג, אך אינו סביר בעליל).</p>
<p>נתמקד כעת במקרה שלנו - אנחנו מדברים על בעיות שנמצאות ב-NP, כלומר בעיות שאפשר לנסח במונחים של "וידוא שמילה <span class="math">\(w\)</span> שייכת לשפה <span class="math">\(L\)</span>", כך שקיים "מוודא" עבור השפה <span class="math">\(L\)</span> שמסוגל לקרוא "הוכחות" <span class="math">\(\pi\)</span> לכך ש-<span class="math">\(w\in L\)</span> ולומר "כן", ואם <span class="math">\(w\notin L\)</span> אז שום הוכחה לא תגרום למוודא לומר כן; והמוודא מבצע את הבדיקה שלו ביעילות - זמן שהוא פולינומי בגודל של <span class="math">\(w\)</span>. את המודל הזה אפשר להחליף במודל של מעגלים - לכל מספר טבעי <span class="math">\(n\)</span> אפשר לבנות מעגל כך שהוא מקבל קלט <span class="math">\(w\)</span> מאורך <span class="math">\(n\)</span>, ועוד קלט <span class="math">\(\pi\)</span> מאורך כלשהו שפולינומי ב-<span class="math">\(n\)</span> (וגם הוא קבוע), כך שאם <span class="math">\(w\in L\)</span> אז קיים <span class="math">\(\pi\)</span> שעבורו המעגל פולט 1, אם <span class="math">\(w\notin L\)</span> אז לכל <span class="math">\(\pi\)</span> המעגל פולט 0, וגודל המעגל כולו פולינומי ב-<span class="math">\(n\)</span> (כלומר, אין מספר גדול במיוחד של שערים). איך אפשר לבנות מעגל כזה? שאלה מצויינת. למי שמכיר את <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%A4%D7%98_%D7%A7%D7%95%D7%A7-%D7%9C%D7%95%D7%99%D7%9F">משפט קוק-לוין</a>, הרעיון זהה (משפט קוק-לוין מתוחכם עוד יותר - מסמלצים מכונת טיורינג באמצעות נוסחה בתחשיב הפסוקים - ועל נוסחה כזו אפשר לחשוב כגרסה פשוטה של מעגל בוליאני, שבו כל יציאה של שער נכנסת לכניסה של שער אחד בלבד, כלומר לא ניתן "למחזר" אותה). למי שלא מכיר - תאמינו לי לבינתיים, זו לא מטרת הפוסט.</p>
<p>עכשיו בואו נסתכל על התמונה הגדולה. נניח שאני מוודא PCP עבור השפה <span class="math">\(L\)</span>. בהינתן מילה <span class="math">\(w\)</span>, אני מצפה לקבל הוכחה כלשהי לכך ש-<span class="math">\(w\)</span> שייכת ל-<span class="math">\(L\)</span> - הוכחה שאצטרך לדגום ממנה רק מספר קבוע של ביטים. איך תיראה ההוכחה הזו? בתור התחלה, נוכל לחשוב על המעגל שתיארתי קודם, שמסמלץ את מוודא ה-NP עבור <span class="math">\(L\)</span>; אפשר "להקפיא" את הכניסות שמייצגות את <span class="math">\(w\)</span>, ולכן נישאר עם מעגל שאסמן ב-<span class="math">\(C\)</span>, שמקבל קלט בודד - <span class="math">\(\pi\)</span> - וקיים פלט כלשהו שעבורו הוא פולט 1 רק אם <span class="math">\(w\)</span> שייך לשפה. כלומר, כדי להשתכנע ש-<span class="math">\(w\in L\)</span> אני רוצה שיביאו לי הוכחה שניתן לספק את <span class="math">\(C\)</span>.</p>
<p>הוכחה פשוטה יחסית היא שפשוט יביאו לי את <span class="math">\(\pi\)</span> ויגידו לי "אתה יודע מהו <span class="math">\(C\)</span>, פשוט תריץ אותו על <span class="math">\(\pi\)</span> וגמרנו". זה לא טוב, כי כי להריץ את <span class="math">\(C\)</span> על <span class="math">\(\pi\)</span> אצטרך לקרוא כל הנראה את כל הביטים של <span class="math">\(\pi\)</span> (כי כל אחד מהם בא לידי ביטוי ב-<span class="math">\(C\)</span> בשלב זה או אחר).</p>
<p>הוכחה יותר מחוכמת, אם כן, תכלול לא רק את <span class="math">\(\pi\)</span>, אלא גם את הערך שכל שער של <span class="math">\(C\)</span> מקבל כאשר מזינים ל-<span class="math">\(C\)</span> את <span class="math">\(\pi\)</span>. בצורה זו לא אהיה חייב לקרוא את <span class="math">\(\pi\)</span> כדי לראות ש-<span class="math">\(C\)</span> מוציא עליו את הפלט 1; אוכל להסתפק בקריאת ערכי השערים של <span class="math">\(C\)</span>. לרוע המזל, <span class="math">\(C\)</span> ככל הנראה יהיה גודל <strong>יותר</strong> מ-<span class="math">\(\pi\)</span> ולכן אצטרך לקרוא עוד <strong>יותר</strong> ביטים, אז לא הרווחתי (בינתיים) כלום.</p>
<p>הצעד הבא הוא להסכים לקבל הוכחה מהסוג שתיארתי כרגע, של "רשימת כל הערכים שהשערים של <span class="math">\(C\)</span> מקבלים שמזינים ל-<span class="math">\(C\)</span> <span class="math">\(\pi\)</span> שמספק אותו", אבל לא לקרוא את כולה, אלא רק "לדגום" חלקים ממנה. מה בעצם אנחנו רוצים לבדוק? ששער היציאה של <span class="math">\(C\)</span> הוא 1 (אחרת <span class="math">\(\pi\)</span> בוודאי שאינו מספק את <span class="math">\(C\)</span>) ושכל שער מתנהג בצורה חוקית. אם נמספר את כל השערים ב-<span class="math">\(C\)</span> ונסמן ב-<span class="math">\(\alpha_{i}\)</span> את הערך של השער ה-<span class="math">\(i\)</span> (נניח לצורך העניין שגם הביטים של <span class="math">\(\pi\)</span> מיוצגים על ידי שערים), אפשר לסכם את הדרישות באופן הבא:</p>
<ol>
    <li> <span class="math">\(\alpha_{t}=1\)</span>, כאשר <span class="math">\(t\)</span> הוא מספר שער היציאה של <span class="math">\(C\)</span>.</li>
    <li> אם <span class="math">\(i\)</span> הוא שער AND שהכניסות שלו הן מהשערים <span class="math">\(j,k\)</span>, אז <span class="math">\(\alpha_{i}=\alpha_{j}\alpha_{k}\)</span>.</li>
    <li> אם <span class="math">\(i\)</span> הוא שער NOT שהכניסה שלו היא מהשער <span class="math">\(j\)</span>, אז <span class="math">\(\alpha_{i}=\alpha_{j}+1\)</span> (כאן חיבור הוא מודולו 2, כלומר <span class="math">\(1+1=0\)</span>).</li>
</ol>
<p>אם כן, צמצמנו את ה"הוכחה" שאנחנו רוצים לקבל לאוסף של ביטים <span class="math">\(\alpha_{i}\)</span> שמקיימים אוסף של "אילוצים". כשבודקים את <span class="math">\(C\)</span> אפשר לבחור באופן אקראי אחד מהאילוצים, נניח אילוץ AND שמערב את שערים <span class="math">\(5,3,1\)</span> ולבדוק אם <span class="math">\(\alpha_{5}=\alpha_{3}\alpha_{1}\)</span> - דבר שדורש קריאה של שלושה ביטים בלבד. אם כן - נניח שהכל בסדר ונגיד "כן", ואם לא, נדחה. הכוח שלנו נובע מכך שכל אחד מהאילוצים עלול להיות מוגרל, ולכן מי שמספק לנו את ההוכחה לא יכול לרמות באף אחד מהם.האמנם?</p>
<p>ובכן, לא. מי שמספק לנו את ההוכחה יכול לרמות בשער בודד - שער AND אחד שמקבל 0 ו-1 אבל מחזיר 1 יכול לגרום למעגל להסתפק, למרות שאם לא מרמים אין שום השמה שתספק אותו. כמובן, ייתכן שנגריל את השער הזה; אבל אם יש הרבה שערים, ההסתברות לכך היא נמוכה יחסית, ואילו אנחנו רוצים הסתברות לגילוי שקר שאינה תלויה בכלל בגודל המעגל הנבדק. לכן אנחנו שוב בבעיה. פתרון אחד הוא לדגום הרבה שערים - אבל זה יכריח אותנו שוב לקרוא הרבה ביטים מההוכחה ולא הרווחנו כלום. צריך לעשות כאן משהו חכם יותר.</p>
<p>היינו רוצים, אם זה אפשרי, לבדוק את כל השערים במעגל "בו זמנית", על ידי דגימה של מספר זעום של ביטים - יודעים מה? ביט בודד. זה לא אפשרי באופן ישיר, אבל כן אפשר לעשות זאת "בערך".</p>
<p>בואו נלך עוד צעד אחד קדימה בדרך לפישוט הבעיה שלנו. לכל אילוץ אפשרי נגדיר משתנה <span class="math">\(\phi_{i}\)</span>, שמקבל את הערך 0 אם האילוץ מסופק ואת הערך 1 אם הוא מופר. למשל, <span class="math">\(\phi_{t}=1+\alpha_{t}\)</span>; ואם <span class="math">\(i\)</span> הוא שער AND אז <span class="math">\(\phi_{i}=\alpha_{i}+\alpha_{j}\alpha_{k}\)</span>; ואם <span class="math">\(i\)</span> הוא שאר NOT אז <span class="math">\(\phi_{i}=\alpha_{i}+\alpha_{j}+1\)</span>. כעת, מהו הסכום <span class="math">\(\sum\phi_{i}\)</span> (מודולו 2)? אם כל האילוצים מסופקים, יש לנו סכום של אפסים, ולכן הסכום יהיה אפס; ואילו אם אילוץ אחד לפחות מופר, הסכום יהיה שונה מאפס... רגע, אופס, לא. בגלל שהסכום הוא מודולו 2, אז הסכום יהיה שונה מאפס אם מספר <strong>אי זוגי</strong> של אילוצים מופר, אבל יהיה עדיין אפס אם מספר <strong>זוגי</strong> של אילוצים מופר.</p>
<p>אז בואו נשכלל עוד יותר את הבדיקה. במקום לסכום את <strong>כל</strong> האילוצים, מה שנעשה יהיה להגריל תת קבוצה של אילוצים; עבור כל אילוץ נטיל מטבע, ובהסתברות של <span class="math">\(\frac{1}{2}\)</span> נוסיף אותו לסכום. כלומר, בסופו של דבר נחשב צירוף לינארי <span class="math">\(\sum a_{i}\phi_{i}\)</span>, כאשר <span class="math">\(a_{i}\)</span> שווה או לאפס (בהסתברות חצי) או לאחד (בהסתברות חצי). אם אף אילוץ לא מופר, הסכום של כל צירוף לינארי שכזה יהיה 0; אם לפחות אילוץ אחד מופר, כמה מהצירופים הללו יהיו שווים ל-1?</p>
<p>כאן נכנס לתמונה תעלול נפוץ בניתוח של סיטואציות מעין אלו. הבה ניקח אילוץ ספציפי אחד שמופר, <span class="math">\(\phi_{j}=1\)</span>, ו"נקפיא" אותו. כעת, אפשר לחלק את כל הצירופים הלינאריים האפשריים לשני סוגים - כאלו שבהן <span class="math">\(a_{j}=0\)</span>, וכאלו שבהם <span class="math">\(a_{j}=1\)</span>. הבה וניקח צירוף לינארי שכזה שבו <span class="math">\(a_{j}=0\)</span>, כלומר <span class="math">\(\phi_{j}\)</span> לא משתתף בו. אם סכומו של הצירוף הזה הוא 0, אז ערכו של הצירוף שזהה לו בכל פרט לכך ש-<span class="math">\(a_{j}=1\)</span> יהיה 1 (שכן הוספנו לצירוף הזה, שקודם ערכו היה 0, את הערך <span class="math">\(\phi_{j}\)</span> שהוא 1). בדומה, אם סכומו של הצירוף היה 1, אחרי שנשנה את <span class="math">\(a_{j}\)</span> ל-1 נקבל 0.</p>
<p>מה זה בעצם אומר? שאפשר לפרק את קבוצת כל הצירופים הלינאריים לאוסף של זוגות, כך שבכל זוג בדיוק אחד משני הצירופים נותן 1, והצירוף השני נותן 0. מסקנה: אם ולו אילוץ אחד מופר, הרי ש<strong>בדיוק חצי</strong> מהצירופים האפשריים נותן 1. לכן אם באמת נגריל את הצירופים באופן שתיארתי לעיל (כל אילוץ נבחר בהסתברות חצי) תהיה לנו הסתברות חצי לגלות שעבדו עלינו, בלי תלות בגודל המעגל. אאורקה!</p>
<p>כל זה טוב ויפה, אבל עדיין לא הסברתי <strong>איך</strong> אפשר, אחרי שכבר הגרלתי צירוף לינארי מסויים <span class="math">\(\sum a_{i}\phi_{i}\)</span>, לחשב את ערכו על ידי קריאה של ביט אחד בלבד. לשם כך צריך להיזכר מהם <span class="math">\(\phi_{i}\)</span> השונים. בואו נשכח לרגע מכך ש-<span class="math">\(\phi_{i}\)</span> יכול להכיל דברים שנראים כמו <span class="math">\(\alpha_{j}\alpha_{k}\)</span> (כלומר, מכפלה של שתי <span class="math">\(\alpha\)</span>-ות) ונדמיין, אם כן, שכל צירוף <span class="math">\(\sum a_{i}\phi_{i}\)</span> ניתן לתיאור באמצעות צירוף מהצורה <span class="math">\(\sum b_{i}\alpha_{i}+b\)</span> כש-<span class="math">\(b\)</span> הוא קבוע. כלומר, כדי לחשב את <span class="math">\(\sum a_{i}\phi_{i}\)</span> מספיק להיות מסוגלים לחשב את <span class="math">\(\sum b_{i}\alpha_{i}\)</span> - לחשב צירוף לינארי של ה-<span class="math">\(\alpha\)</span>-ות ששייכות להוכחה שקיבלנו. לרוע המזל, נראה שלא הרווחנו כלום - כדי לחשב צירוף כזה צריך לקרוא במפורש את כל ה-<span class="math">\(\alpha_{i}\)</span>-ות שעבורן <span class="math">\(b_{i}\ne0\)</span>, אז מה יצא לנו מזה?</p>
<p>כאן נכנס לתמונה קוד הדמר שתיארתי בפוסט הקודם. כזכור, קוד הדמר של מילה היה מורכב מכל הצירופים הלינאריים האפשריים של הביטים במילה. אם כן, אם מישהו נותן לנו בתור הוכחה לא את ה-<span class="math">\(\alpha_{i}\)</span> אלא את קידוד הדמר שלהן - ניצחנו, כי אז כדי לחשב את <span class="math">\(\sum b_{i}\alpha_{i}\)</span> די בדגימת הביט הבודד מתוך קוד הדמר שמכיל את הצירוף הלינארי הזה. אם כן, האם סיימנו?</p>
<p>התשובה היא שכמובן שלא. אם בא מישהו ואומר "שמעו, <span class="math">\(C\)</span> ספיק, והנה הוכחה: הערכים של השערים של <span class="math">\(C\)</span> כשמזינים לו השמה מספקת, כשהם מקודדים בקוד הדמר" אין לי שום סיבה להאמין לו. אולי הוא סתם נתן לי ג'יבריש. אולי הוא נתן לי משהו שהונדס כדי לעבוד עלי. לכן אני צריך לוודא בראש ובראשונה שמה שקיבלתי הוא <strong>מילה חוקית בקוד הדמר</strong>. אם הצלחתי לוודא זאת, אפשר להשתמש בכך שזה קוד הדמר (ולכן כל ביט הוא צירוף לינארי) כדי לוודא שזו לא סתם מילה חוקית, אלא מילה שמתארת את ערכי השערים של <span class="math">\(C\)</span> בהשמה מספקת (על ידי הבדיקה שתיארתי קודם).</p>
<p>ובכן, איך מוודאים שמה שקיבלתי הוא מילה חוקית בקוד הדמר? אפשר לקרוא את כל הביטים בקוד, אבל זה שוב יגרום לנו לקרוא יותר מדי ביטים. לחילופין, אפשר להשתמש במה שראינו את קיומו בפוסט הקודם - בודק מקומי עבור קוד הדמר. הבודק הזה צריך לקרוא מספר קבוע וקטן של ביטים כדי להכריע אם המילה שהוא קיבל לכל הפחות קרובה מאוד להיות מילה בקוד הדמר. אין לנו בטחון גמור שהמילה היא אכן מילה חוקית בקוד הדמר, כי אולי חלק קטן מהביטים במילה שגויים; אבל אם יש רק מספר מועט של ביטים שגויים, גם הסיכוי שנדגום אותם בזמן שנערוך את המבחן שתיארתי לעיל (חישוב <span class="math">\(\sum b_{i}\alpha_{i}\)</span>) הוא נמוך, ולכן רוב הסיכויים הם שהמבחן שלי יצליח.</p>
<p>נסכם: לקחנו את הבעיה של הוכחה ש-<span class="math">\(w\in L\)</span> וצמצמנו אותה לבעיה של הוכחה שמעגל <span class="math">\(C\)</span> כלשהו ספיק. ה"הוכחה" לכך היא תיאור של השמה מספקת ל-<span class="math">\(C\)</span> והערכים ששערי <span class="math">\(C\)</span> מקבלים כשמזינים אותה אליו, כשכל זה מקודד בקוד הדמר. בהינתן ההוכחה הזו, אנחנו:</p>
<ol>
    <li> בודקים שההוכחה היא אכן מילה שמקודדת בקוד הדמר (או לכל הפחות, הרוב המוחץ של הביטים בה מתנהגים על פי החוקיות הזו). הבדיקה הזו דורשת קריאת מספר קטן וקבוע של ביטים, וההסתברות לטעות במקרה שעובדים עלינו היא קבועה.</li>
    <li> בודקים שההוכחה אכן מתארת התנהגות חוקית של <span class="math">\(C\)</span>, כלומר שכל האילוצים שלו מסתפקים. לבדיקה הזו נדרשת קריאת ביט בודד, וההסתברות לטעות במקרה שעובדים עלינו היא קבועה (חצי).</li>
    <li> אפשר לחזור על התהליך עוד כמה פעמים ולהקטין כרצוננו את ההסתברות לטעות - המחיר יהיה הגדלה של מספר הביטים הנקראים, אך הוא עדיין יהיה קבוע.</li>
</ol>
<p>סוף דבר.או שלא. הסתרתי כאן עוד קושי טכני מרגיז - ה-<span class="math">\(\phi_{i}\)</span> יכול להכיל גם איברים מהצורה <span class="math">\(\alpha_{i}\alpha_{j}\)</span>, כלומר ב"צירוף הלינארי" שעלינו לחשב עשויים להופיע גם איברים מהצורה <span class="math">\(b\alpha_{i}\alpha_{j}\)</span>, מה שאומר שזה בכלל לא צירוף לינארי אלא צירוף "ריבועי". איך פותרים את זה? ובכן, זה טכני, ולא משנה שום דבר מהותי ברעיונות של ההוכחה, ולכן לא אתעמק בכך; הרעיון הוא להגדיר משתנים חדשים, <span class="math">\(\beta_{ij}=\alpha_{i}\alpha_{j}\)</span>, ואז לדבר על צירופים לינאריים של ה-<span class="math">\(\beta\)</span>-ות הללו. זה מגדיל עוד קצת את מספר הבדיקות שעלינו לעשות, אך הוא עדיין יהיה קבוע.</p>
<p>אם כן, זה סוף הסיפור, וזו ה"הוכחה" הבסיסית ביותר שאני מכיר למשפט ה-PCP. אני מקווה שכעת הוודו נראה קצת פחות מטורף. עם זאת, זו רחוקה מלהיות ההוכחה ה<strong>טובה</strong> ביותר של המשפט - יש הוכחות לגרסאות חזקות יותר מזו שהצגתי כאן (בפרט, עם הוכחה שאינה בגודל אסטרונומי כמו הוכחה שמקודדת בקידוד הדמר). אולי אציג אותן בעתיד.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>