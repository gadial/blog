<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>למה זכרון שהוא פחות מלגלג הוא קבוע? - לא מדויק</title>
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <header>
            <h1>למה זכרון שהוא פחות מלגלג הוא קבוע?</h1>
            <div class="post-meta">
                <span class="date">2009-10-04</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/סיבוכיות זכרון.html">סיבוכיות זכרון</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>ב<a href="http://www.gadial.net/2009/08/30/finite_automata_and_regular_languages/">פוסט קודם</a> הזכרתי בחטף טענה ב<a href="http://he.wikipedia.org/wiki/%D7%A1%D7%99%D7%91%D7%95%D7%9B%D7%99%D7%95%D7%AA">תורת הסיבוכיות</a> שנשמעת מוזרה מעט במבט ראשון - שאם בעיה דורשת כמות נמוכה יחסית של זכרון לפתרונה, אך כזו שעדיין תלויה בגודל הקלט (ועל כן, כאשר הקלט גדל עוד ועוד גם הזכרון גדל עוד ועוד, "לאינסוף"), הרי שלמעשה ניתן לפתור אותה תוך שימוש בכמות קבועה של זכרון (בלי תלות בגודל הקלט), וחסל. ה"נמוכה יחסית" הייתה, מבחינה פורמלית, כל פונקציה שקטנה ממש אסימפטוטית מ-<span class="math">\(\lg\lg n\)</span> (הכוונה בכך היא שניתן להקטין את היחס <span class="math">\(\frac{f\left(n\right)}{\lg\lg n}\)</span> כרצוננו ככל שנגדיל את <span class="math">\(n\)</span>).</p>
<p>בפוסט הזה אני רוצה להראות בדיוק מדוע זה כך. ההוכחה אינה קלה במיוחד, אך היא משתמשת ברעיונות שכולם סטנדרטיים יחסית בתורת הסיבוכיות ולכן היא מספקת תירוץ טוב להציג אותם. הרעיון הבסיסי הוא שמכונה שמשתמשת רק בכמות עלובה כל כך של זכרון אינה מסוגלת לעשות כמעט שום דבר מעניין - בפרט, היא לא יכולה להשתמש ברוב הזכרון שעומד לרשותה כי אז היא "תתבלבל" ותנצל כמות גדולה הרבה יותר שלו. באופן טיפה יותר פורמלי מה שעושים הוא לקחת מכונה <span class="math">\(M\)</span> שפועלת בסיבוכיות זכרון <span class="math">\(f\left(n\right)\)</span> קטנה כמתואר לעיל, ולתת באופן כמעט מפורש חסם קבוע (שאינו תלוי ב-<span class="math">\(n\)</span>) על כמות הזכרון שהמכונה תצרוך באמת בכל ריצה שלה. כדי להשתכנע שהחסם עובד, פועלים בדרך השלילה - מניחים שיש קלטים שעליהם המכונה חורגת מהחסם, לוקחים את המינימלי שבהם, ומראים שאפשר לקצר גם אותו ועדיין לקבל קלט שעליו המכונה חורגת מהחסם - סתירה למינימליות. עיקר החוכמה כאן היא איך מראים שאפשר לקצר את הקלט - זה דורש ניתוח מדוקדק יחסית של התנהגות המכונה על כל ביט בקלט והדגמה שקיימים שני ביטים שהם "זהים" מבחינת התנהגות המכונה עליהם, ניתוח שהוא טכני באופן בלתי נמנע.</p>
<p>התוצאה הזו היא אחד מהמקומות שבהם יש חשיבות גדולה למודל הספציפי של החישוב שאנחנו בוחרים - עבור מודל אחר ככל הנראה הפונקציה היתה שונה (במודלים "מתוחכמים" יותר אפשר להסתיר פעולות בעלות סיבוכיות לא קבועה תחת מעטה של "פעולה אטומית"). לכן אתאר בקצרה את המודל שלנו - <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%9B%D7%95%D7%A0%D7%AA_%D7%98%D7%99%D7%95%D7%A8%D7%99%D7%A0%D7%92">מכונת טיורינג</a> היא יצור שמורכב מסרט קלט (הניתן לקריאה בלבד), סרט עבודה לקריאה ולכתיבה, ראש קורא שנע על סרט הקלט, ראש קורא/כותב שנע על סרט העבודה, ואוסף <span class="math">\(Q\)</span> של "מצבים פנימיים", שהמכונה נמצאת כל רגע באחד מהם. המכונה פועלת ב"צעדים", כאשר ההתנהגות בכל צעד נקבעת על פי המצב הפנימי של המכונה ותוכן התאים ששני הראשים קוראים; ובכל צעד המכונה יכולה לשנות את המצב הפנימי שלה, לכתוב תו על סרט העבודה במקום התו שהיה קודם במקום שעליו הראש הצביע, ולהזיז כל אחד מהראשים צעד אחד ימינה או שמאלה (הם בלתי תלויים זה בזה). זה הכל. בניסוחים נאיביים בדרך כלל לא טורחים לתת למכונה שני סרטים, וסרט הקלט משמש גם לקריאה וגם לכתיבה; אבל מכיוון שאנחנו עוסקים כאן בסיבוכיות זכרון שקטנה בהרבה מגודל הקלט, ההפרדה בין הזכרון של הקלט והזכרון שעליו כותבים היא הכרחית.</p>
<p>כעת הגיע הזמן להציג את המושג המרכזי בהוכחה (ומושג חשוב באופן כללי בתורת הסיבוכיות) - ה"קונפיגורציה" של המכונה (תרגום לעברית יכול להיות "תיאור רגעי", אבל אני מעדיף את הלועזית כאן). גם כאן אתן הגדרה שתפורה עבור ההוכחה הזו, ואינה זהה לחלוטין להגדרה הסטנדרטית. קונפיגורציה של מכונה באה לתאר את מצבה הרגעי במהלך חישוב, ומורכבת מתוכן סרט העבודה ("הסרט כרגע מכיל את המחרוזת 01001"), מיקום הראש הקורא/כותב עליו ("הראש כרגע מעל תא מספר 3"), התוכן של התא שהראש הקורא נמצא מעליו כרגע ("אני קורא את הביט 1") והמצב הפנימי הנוכחי של המכונה ("המכונה במצב פנימי מספר 17"). האבחנה המרכזית הנוגעת לקונפיגורציות היא שאם המכונה נמצאת באותה קונפיגורציה פעמיים במהלך החישוב שלה, כשבנוסף לכך בשתי הפעמים הללו הראש הקורא נמצא מעל אותו תא - פירוש הדבר הוא שהיא בלולאה אינסופית. מדוע? כי הקונפיגורציה הנוכחית, בתוספת מיקום הראש הקורא, קובעות בצורה יחידה ודטרמיניסטית את התנהגות המכונה בצעד הבא, ובפרט את הקונפיגורציה הבאה (והמיקום הבא של הראש הקורא). חשבו על תוכנית מחשב שמגיעה פעמיים לאותה שורת קוד, כשמצב כל המשתנים בתוכנית זהה בין שתי הפעמים - אם היא הגיעה משורה 17 שוב אל שורה 17 מבלי שכלום השתנה, אז בגלל הדטרמיניזם של אופן פעולתה, היא שוב תגיע לשורה 17 מבלי לשנות שום דבר, ושוב ושוב עד אין קץ.</p>
<p>נניח שהמכונה שלנו רצה על קלט מאורך <span class="math">\(n\)</span>, ולכן היא יכולה להשתמש לכל היותר ב-<span class="math">\(f\left(n\right)\)</span> תאים של זכרון העבודה. כמה קונפיגורציות שונות אפשריות קיימות עבורה? לצורך העניין נניח שסרט העבודה מכיל רק ביטים, אז יש <span class="math">\(2^{f\left(n\right)}\)</span> אפשרויות שונות לתוכן סרט העבודה (קומבינטוריקה פשוטה: לכל אחד מ-<span class="math">\(f\left(n\right)\)</span> התאים יש לנו שתי אפשרויות, 0 או 1, וכל תא נקבע באופן בלתי תלוי באחרים). כמו כן יש <span class="math">\(f\left(n\right)\)</span> אפשרויות למיקום הראש הקורא/כותב, 2 אפשרויות לתוכן התא שהראש הקורא קורא ו-<span class="math">\(\left|Q\right|\)</span>מצבים פנימיים אפשריים (זה מספר קבוע שאינו תלוי ב-<span class="math">\(n\)</span> ולכן אינו כה מעניין). סה"כ יש <span class="math">\(t\left(n\right)=2\cdot\left|Q\right|\cdot f\left(n\right)\cdot2^{f\left(n\right)}=O\left(2^{f\left(n\right)}\right)\)</span> קונפיגורציות אפשריות. אם כן, אם הראש הקורא של המכונה מבקר בתא כלשהו בסרט הקלט יותר מ-<span class="math">\(t\left(n\right)\)</span> פעמיים, המכונה נכנסה ללולאה אינסופית, כי היינו באותה קונפיגורציה פעמיים בעת שהראש הקורא היה באותו תא (למה היינו באותה קונפיגורציה פעמיים? <a href="http://he.wikipedia.org/wiki/%D7%A2%D7%A7%D7%A8%D7%95%D7%9F_%D7%A9%D7%95%D7%91%D7%9A_%D7%94%D7%99%D7%95%D7%A0%D7%99%D7%9D">עקרון שובך היונים</a>).</p>
<p>כעת מגיע אחד מהרעיונות המורכבים ביותר בהוכחה. לכל תא בסרט <strong>הקלט</strong>, נבנה רשימה של כל הקונפיגורציות שבהן המכונה הייתה בשעה שהיא ביקרה בתא הזה. למשל, הרשימה "11,53,23" עבור תא מס' 3 אומרת שבפעם הראשונה שבה המכונה הגיעה לתא מס' 3, היא הייתה בקונפיגורציה 11, ובפעם השניה שבה היא הגיעה לתא מס' 3 (אולי אלפי צעדים לאחר מכן) היא הייתה בקונפיגורציה 53; ובפעם השלישית - בואו נניח שהיא הייתה מייד לאחר הפעם השניה, כי הראש הקורא לא זז - היא שינתה משהו בסרט העבודה שלה ועברה לקונפיגורציה 23. המספרים מומצאים, כמובן, אבל זה הרעיון. השאלה המהותית כאן היא מה האורך האפשרי של הרשימה הזו? התשובה פשוטה, ונעוצה במה שאמרתי לפני שנייה: אם הרשימה (עבור תא <strong>כלשהו</strong>) תכיל יותר מ-<span class="math">\(t\left(n\right)\)</span> איברים, פירוש הדבר שהמכונה בלולאה אינסופית ולכן הרשימה תתחיל לחזור על עצמה לאחר מכן. מכאן שיש בסך הכל <span class="math">\(t\left(n\right)^{t\left(n\right)}\)</span> סדרות אפשריות שכאלו של קונפיגורציות (כי אמרנו שיש לכל היותר <span class="math">\(t\left(n\right)\)</span> איברים בסדרה, ו"איבר" יכול להיות כל אחת מ-<span class="math">\(t\left(n\right)\)</span> הקונפיגורציות החוקיות). מסובך? כן, בהחלט; רצוי לקרוא את זה כמה פעמים (וגם אם לא מבינים, זה לא סוף העולם).</p>
<p>אנחנו חותרים להראות שעבור ריצות "בעייתיות" לכאורה עבורנו, נצליח למצוא כמה וכמה תאים בסרט הקלט שסדרת הקונפיגורציות שלהן תהיה זהה (ולכן התנהגות המכונה עליהן תהיה זהה). לשם כך אנחנו רוצים למצוא <span class="math">\(n\)</span>-ים שעבורם יש יחסית מעט סדרות של קונפיגורציות, ויחסית הרבה תאי קלט - למעשה, פי שלוש מאשר סדרות של קונפיגורציות. זה נשמע מופרך - הרי יש <span class="math">\(n\)</span> תאי קלט, אבל <span class="math">\(t\left(n\right)^{t\left(n\right)}\)</span> סדרות; והרי פונקציות אקספוננציאליות גדלות מהר מאוד - אם כן, איך ייתכן שיהיה <span class="math">\(n\)</span> שעבורו <span class="math">\(t\left(n\right)^{t\left(n\right)}&lt;n\)</span>? התשובה פשוטה - אל תשכחו ש-<span class="math">\(f\left(n\right)\)</span>, סיבוכיות הזכרון שלנו, היא קטנה מאוד, הרבה הרבה הרבה יותר קטנה מ-<span class="math">\(n\)</span>; זה בדיוק הרעיון כאן, וזה גם המקום שממנו החסם על <span class="math">\(f\left(n\right)\)</span> מגיע. אם <span class="math">\(f\left(n\right)=o\left(\lg\lg n\right)\)</span>, אז מתקיים ש-<span class="math">\(t\left(n\right)^{t\left(n\right)}=o\left(n\right)\)</span>, כלומר קיים <span class="math">\(n_{0}\)</span> גדול דיו כך שלכל <span class="math">\(n&gt;n_{0}\)</span> מתקיים <span class="math">\(t\left(n\right)^{t\left(n\right)}&lt;\frac{n}{3}\)</span>. אני לא אכנס כאן לפרטי ההוכחה שהם טכניים ולא מעניינים - ה"אינטואיציה" היא שהחלק הדומיננטי ביותר ב-<span class="math">\(t\left(n\right)^{t\left(n\right)}\)</span> הוא מהצורה <span class="math">\(2^{2^{f\left(n\right)}}\)</span>, ושתי החזקות הללו "נאכלות" בידי הלוגריתם הכפול (כלומר: <span class="math">\(2^{2^{f\left(n\right)}}=o\left(2^{2^{\lg\lg n}}\right)=o\left(2^{\lg n}\right)=o\left(n\right)\)</span>).</p>
<p>כעת הגענו לטענה המרכזית שלנו - המכונה לא משתמשת ביותר מאשר <span class="math">\(f\left(n_{0}\right)\)</span> זכרון בכלל, על כל קלט. מכיוון ש-<span class="math">\(n_{0}\)</span> הוא קבוע (ואפילו הראינו דרך יחסית קונסטרוקטיבית למצוא אותו), גם <span class="math">\(f\left(n_{0}\right)\)</span> הוא קבוע, ולכן הטענה הזו מסיימת את ההוכחה. כדי להראות אותה, נניח בשלילה שהיא איננה נכונה וניקח את הקלט <span class="math">\(x\)</span> בעל האורך המינימלי שעדיין גדול מ-<span class="math">\(n_{0}\)</span> (כלומר, <span class="math">\(\left|x\right|=n&gt;n_{0}\)</span>) שבריצתה עליו המכונה משתמשת ביותר מ-<span class="math">\(f\left(n_{0}\right)\)</span> זכרון. מה שנראה הוא שניתן להקטין את <span class="math">\(x\)</span> ולקבל קלט אחר, <span class="math">\(x^{\prime}\)</span>, שעליו המכונה מתנהגת באופן זהה, ולכן גם מנצלת את אותה כמות זכרון, וזוהי סתירה למינימליות <span class="math">\(x\)</span>. במילים אחרות - אנחנו מראים שעל קלטים ארוכים מספיק, המכונה מתנהגת באופן זהה לזה שבו היא מתנהגת על קלטים קצרים יותר - ולכן צריכת הזיכרון שלה היא לא יותר מאשר צריכת הזיכרון המקסימלית של המכונה על אחד מאותם קלטים קצרים. מכיוון שיש מספר סופי של קלטים קצרים שכזה, צריכת הזכרון המקסימלית הזו היא מספר קבוע.</p>
<p>כעת נעבור לפאנץ' שמסביר את קיום מספר הקסם המסתורי <span class="math">\(\frac{n}{3}\)</span>. מכיוון ש-<span class="math">\(\left|x\right|=n&gt;n_{0}\)</span> אז <span class="math">\(t\left(n\right)^{t\left(n\right)}&lt;\frac{n}{3}\)</span>. ובמילים - מספר סדרות הקונפיגורציות האפשריות הוא פחות משליש ממספר תאי הזכרון. מכאן נובע שיש לפחות שלושה תאי זכרון <strong>עם אותה סדרת קונפיגורציות בדיוק</strong>. נניח שהתוכן שלהם הוא 0 (עבור תוכן של 1 ההוכחה היא אותו דבר), אז ניתן לתאר את הקלט כולו כך: <span class="math">\(x=\alpha0\beta0\gamma0\delta\)</span>, כש-<span class="math">\(\alpha,\beta,\gamma,\delta\)</span> הם פשוט סימונים לתת-מחרוזות. כן, אני יודע שזה נראה קצת מפחיד.</p>
<p>מה שאני רוצה להראות הוא שגם אם אקצץ את <span class="math">\(\beta0\)</span> מהמחרוזת הזו ואקבל <span class="math">\(x^{\prime}=\alpha0\gamma0\delta\)</span>, ההתנהגות של המכונה על הקלט תהיה זהה (חוץ מההתנהגות שלה על הקטע <span class="math">\(\beta\)</span> שכבר אינו קיים). כמקודם, זה טכני ואעדיף שלא לחפור יותר מדי בפרטים, אבל הנה הרעיון הכללי: כל עוד המכונה (שמתחילה לעבור על הקלט מצד שמאל) מתרוצצת על החלק של <span class="math">\(\alpha\)</span> ברור שההתנהגות שלה זהה הן עבור <span class="math">\(x\)</span> והן עבור <span class="math">\(x^{\prime}\)</span>. בכל פעם שהיא מגיעה ל-0 הראשון היא עשויה או לפנות שמאלה, או ימינה. אם היא פונה שמאלה היא ממשיכה להתעסק באיזור ה-<span class="math">\(\alpha\)</span>; כשהיא פונה ימינה לראשונה, נניח בביקור ה-<span class="math">\(i\)</span>, זה יהיה כך הן עבור <span class="math">\(x\)</span> והן עבור <span class="math">\(x^{\prime}\)</span> - המכונה תהיה באותה קונפיגורציה. כעת ריצת המכונה על <span class="math">\(x\)</span> מגיעה לאיזור של <span class="math">\(\beta\)</span> ומי יודע מה קורה שם, אבל דבר אחד ברור - בכל פעם שהיא מגיעה אל ה-<span class="math">\(0\)</span> שמימין לאותו <span class="math">\(\beta\)</span>, היא תפנה שמאלה, עד הפעם ה-<span class="math">\(i\)</span> בדיוק - וזאת בגלל שסדרת הקונפיגורציות של ה-<span class="math">\(0\)</span> שליד <span class="math">\(\alpha\)</span> וה-<span class="math">\(0\)</span> שליד <span class="math">\(\beta\)</span> זהה, ולכן ההתנהגות של המכונה שם היא זהה.</p>
<p>כלומר, בפעם הראשונה שבה המכונה תפנה <strong>ימינה</strong> ב-<span class="math">\(0\)</span> שאחרי ה-<span class="math">\(\beta\)</span> זה יהיה בביקור ה-<span class="math">\(i\)</span> של המכונה שם - כלומר, כשהיא נמצאת באותה קונפיגורציה בדיוק כמו המכונה בריצתה על <span class="math">\(x^{\prime}\)</span> כשהיא פנתה ימינה בביקור ה-<span class="math">\(i\)</span> שלה על ה-<span class="math">\(0\)</span> שליד <span class="math">\(\alpha\)</span>... אני מקווה שהבנתם את הרעיון. אם לא, נסו לשחק את המשחק בעצמכם קצת - זו כנראה הדרך היחידה להבין עד הסוף, שאינה טרוחה בהוכחה ארוכה וטרחנית. אם טרם הבנתם, קחו את המילה שלי לגבי העניין הזה.</p>
<p>באופן דומה אפשר להראות שגם על <span class="math">\(x^{\prime\prime}=\alpha0\beta0\delta\)</span> המכונה מתנהגת כמו שהיא מתנהגת על <span class="math">\(x\)</span>. כעת אפשר להגיע לפאנץ' הסופי. אנחנו יודעים שלצריכת הזיכרון המקסימלית שלה המכונה מגיעה כשהיא על תו כלשהו מהקלט, אבל איזה תו? אם הוא ב-<span class="math">\(\alpha\)</span>, או ב-<span class="math">\(\gamma\)</span>, או ב-<span class="math">\(\delta\)</span>, או ב-<span class="math">\(0\)</span> שליד <span class="math">\(\alpha\)</span>, או ב-<span class="math">\(0\)</span> שליד <span class="math">\(\gamma\)</span> - בכל אחד מהמקרים הללו, התו הזה קיים גם ב-<span class="math">\(x^{\prime}\)</span> והמכונה מתנהגת עליו באותו אופן - כלומר, המכונה מגיעה לצריכת הזכרון המקסימלית שלה גם על <span class="math">\(x^{\prime}\)</span> הקטן מ-<span class="math">\(x\)</span>. ואם צריכת הזכרון המקסימלית היא ב-<span class="math">\(\beta\)</span> או ב-<span class="math">\(0\)</span> שלידו, אז היא מגיעה אליו ב-<span class="math">\(x^{\prime\prime}\)</span> הקטן יותר מ-<span class="math">\(x\)</span>. זו הסיבה שנזקקנו הן ל-<span class="math">\(x^{\prime}\)</span> והן ל-<span class="math">\(x^{\prime\prime}\)</span> - כדי למנוע את המצב המעצבן שבו צריכת הזכרון המקסימלית היא דווקא בתוך החלק מהמילה שאנחנו מקצצים.</p>
<p>זה סוף ההוכחה. היא הייתה מאוד טכנית, כמו שהבטחתי, אך אני מקווה שלפחות חלק מהרעיונות שבה ברורים כעת יותר, ושעוד נפגוש בהם בעתיד.</p>
        </article>
        
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2009/10/09/insolubility_of_the_quintic/" class="nav-link nav-next">
                <span class="nav-label">→ פוסט חדש יותר</span>
                <span class="nav-title">למה (בגדול, מאוד בגדול) לא ניתן לפתור משוואות ממעלה חמישית ומעלה, ומה זה בכלל אומר?</span>
            </a>
            
            
            
            <a href="/2009/10/01/pcp_theorem_exponential_version_proof/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר ←</span>
                <span class="nav-title">אז מה בין קודים לתיקון שגיאות והוכחת משפט ה-PCP?</span>
            </a>
            
        </nav>
        
        
        <footer>
            <p>בלוג מתמטיקה בעברית</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>