<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>קודים לתיקון שגיאות (שניתנים לבדיקה מקומית) - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2009/09/23/locally_checkable_codes/">
    <meta property="og:title" content="קודים לתיקון שגיאות (שניתנים לבדיקה מקומית)">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2009/09/23/locally_checkable_codes/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="קודים לתיקון שגיאות (שניתנים לבדיקה מקומית)">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- Post-specific social media image -->
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2009/09/19/pcp_theorem_intro/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">משפט ה-PCP או: איך למדתי להפסיק לדאוג ולאהוב הוכחות הניתנות לבדיקה הסתברותית</span>
            </a>
            

            
            <a href="/2009/10/01/pcp_theorem_exponential_version_proof/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">אז מה בין קודים לתיקון שגיאות והוכחת משפט ה-PCP?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>קודים לתיקון שגיאות (שניתנים לבדיקה מקומית)</h1>
            <div class="post-meta">
                <span class="date">2009-09-23</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/מבני נתונים ואלגוריתמים.html">מבני נתונים ואלגוריתמים</a>
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/קוד הדמר.html">קוד הדמר</a>
                    
                    <a href="/tags/קודים הניתנים לבדיקה מקומית.html">קודים הניתנים לבדיקה מקומית</a>
                    
                    <a href="/tags/קודים לתיקון שגיאות.html">קודים לתיקון שגיאות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אוהבים ללעוג למתמטיקאים על כך שהמתמטיקה הנקייה והאידאלית שלהם לא מסתדרת טוב עם העולם האמיתי המלוכלך. גם מדעי המחשב סובלים מבעיה דומה, והראיתי את זה לא מזמן, ב<a href="http://www.gadial.net/2009/07/22/bad_math_rsa/">פוסט</a> שעסק במאמר שלעג ל"חשיבה המתמטית" שמונעת את ראיית הדרך ה"פשוטה" לפצח את RSA; טענתי אז שגם התאורטיקנים הגדולים ביותר יודעים לטפל - בואפן מתמטי ומדוייק - בבעיות שקשורות לעולם האמיתי. דוגמה מעניינת נוספת לכך היא <a href="http://gadial.blogli.co.il/wp-admin/%D7%A7%D7%95%D7%93%D7%99%D7%9D%20%D7%9C%D7%AA%D7%99%D7%A7%D7%95%D7%9F%20%D7%A9%D7%92%D7%99%D7%90%D7%95%D7%AAhttp://he.wikipedia.org/wiki/%D7%A7%D7%95%D7%93_%D7%AA%D7%99%D7%A7%D7%95%D7%9F_%D7%A9%D7%92%D7%99%D7%90%D7%95%D7%AA">קודים לתיקון שגיאות</a> - הם באים לטפל בבעיה אמיתית מאוד, ומשתמשים בהם כל הזמן בעולם האמיתי, ומצד שני התורה שלהם יכולה להיות תאורטית מאוד, מתבססת בחלקה הגדול על אלגברה לינארית ומופשטת, והחשוב מכל - יש לה שימושים מפתיעים גם בהוכחת תוצאות תיאורטיות לחלוטין בתחומים אחרים של מדעי המחשב, ובפרט את משפט ה-PCP ש<a href="http://www.gadial.net/2009/09/19/pcp_theorem_intro/">הזכרתי בפוסט הקודם</a>.</p>
<p>נחזור לבסיס. במדעי המחשב, אפשר לחשוב על כל אינפורמציה כאילו היא מיוצגת כרצף של סיביות - אפסים ואחדים. גם כשמאחסנים מידע במחשב ועל מדיות שונות ומשונות (כגון דיסקים) וגם כששולחים אותו בקו תקשורת, זה מה שנשלח - אפסים ואחדים. כמובן שבפועל מה שקורה הוא מסובך יותר, אבל זוהי הפשטה שאפשר לבצע ועדיין לקבל תיאור די מדוייק של המציאות; לא ארחיב בנושא מעבר לכך כעת.</p>
<p>אלא שהעולם האמיתי הוא מקום מלוכלך - לקווי תקשורת יש "רעש", דיסקים יכולים להישרט, וכן הלאה. בפועל המשמעות של זה מבחינתנו היא שחלק מהמידע שאנחנו שולחים (מכאן ואילך "לשלוח" פירושו גם "לשים מידע על דיסק"; תחשבו על זה כאילו אנחנו שולחים כך מידע אל גרסה עתידית שלנו שתנסה לקרוא את הדיסק) ייהרס. מה זה "ייהרס" מבחינתנו אם כל מה שיש הוא אפסים ואחדים? שבמקום לקרוא 0 נקרא 1, ולהפך. למשל, נשלח את המילה 0010 ובצעד השני תתקבל המילה 0110. כאן הביט השני "התקלקל". זה יכול לגרום לשינוי עצום במשמעות של המידע שנשלח ולהיות בעל תוצאות הרסניות - בקיצור, אסור להתיר לדברים כאלו לקרות. הבעיה היא שבעולם האמיתי הם קורים כל הזמן. לא סביר לבנות ערוץ ממשי שבו תקלות כאלו לא יתרחשו כל הזמן. בקצרה - אנו נזקקים לפתרון לבעיה שאינו תלוי ערוץ; אנחנו צריכים לקבל את הקלקולים בתור חלק מהחיים ולמצוא דרך לטפל בהם בכל זאת.</p>
<p>גישה נאיבית לבעיה היא זו - במקום לשדר את המידע סיבית-סיבית, נשכפל כל סיבית מספר פעמים כלשהו - נאמר, שלוש - ונשלח את השכפולים ברצף. כך למשל במקום לשלוח את המידע 0010, נשלח 000000111000. מי שמקבל את המידע בצד השני יפרק את הקלט שקיבל לשלשות, ויחליט מה הסיבית שכל שלשה מייצגת על פי "הכרעת רוב". למשל, אם קיבלנו 111, אפשר להניח שהשלשה הזו מייצגת את הסיבית 1; ואם קיבלנו 100, אפשר להניח שהשלשה מייצגת את הסיבית 0. כמובן, ייתכן שנשלח את 000 ובדרך כל שלוש הסיביות יתפקששו, בצד השני יתקבל 111 והמפענח יחשוב שניסיתי לשדר לו 1; אבל הסיכוי לכך שזה יקרה הוא נמוך יחסית. כמובן שכדי לבצע חישוב מדוייק צריך לדעת מהי ההסתברות לכך שסיבית תתפקשש, ובהתאם אפשר לשלוח 5 עותקים של הספרה שרוצים להעביר, או 7, וכו' - איני רוצה להיכנס לניתוחים הללו כעת.</p>
<p>הנה עוד דוגמה לדבר מה שניתן לעשות - אם אני רוצה לשלוח רצף של סיביות, נניח 01010, אני אוסיף לסוף הרצף עוד סיבית אחת, שתתקבל מ"חיבור" כל הסיביות (עם הכלל לפיו <span class="math">\(1+1=0\)</span>). הסיבית הזו נקראת "סיבית הזוגיות", שכן היא 0 אם יש מספר זוגי של 1 ברצף שאני שולח (למשל, ברצף שנתתי בדוגמה) והיא 1 אם יש מספר אי זוגי שלהן (למשל, ברצף 11100). בשביל מה זה טוב? אם בצד השני יקבלו 110001, יבינו שמשהו השתבש, כי סיבית הסימן היא 1 ועם זאת בין שאר חמש הסיביות (שאמורות לייצג את המידע האמיתי) יש רק שתיים שהן מגודל 1. זה טוב לזיהוי השגיאה, אבל לא ממש עוזר לתקן אותה במקרה הזה (כמובן שזיהוי שגיאה הוא חשוב מספיק לכשעצמו - אם שגיאות הן נדירות, אז כשמזוהה שגיאה אפשר לבקש מהשולח שישלח את פיסת המידע שוב).</p>
<p>באופן כללי אפשר לתאר קוד באמצעות שלושה פרמטרים - ראשית, מספר הסיביות שיש בכל מילת קוד; שנית, קבוצת המילים בקוד; שלישית, המרחק המינימלי שבין המילים בקוד. בואו נחזור לרגע לקוד השלשות שתיארתי קודם - זה קוד שהכיל בדיוק שתי מילות קוד, 111 ו-000; כל מילה אחרת הייתה "לא חוקית". אם כן, זה קוד שבו המילים הן מאורך 3 ויש בדיוק שתי מילים. הקוד הזה מאפשר לנו, אם כן, לשלוח שני "סוגי מידע שונים"; אני הגדרתי שרירותית ש-000 ייצג את 0 וש-111 ייצג את 1 אבל זה לא הכרחי; הייתי יכול גם לקבוע ש-000 מייצג את 1 ו-111 מייצג את 0, או שהם מייצגים בכלל את 012 ואת 4325, או כל זוג מוזר אחר. נותר להסביר מהו עניין ה"מרחק".</p>
<p>המילה 000 נראית לנו שונה מהמילה 111 הרבה יותר מאשר 110 שונה מ-111. ההבדל ברור -<strong> מספר המקומות השונים</strong> בין 000 ו-111 הוא 3, בעוד שמספר המקומות השונים בין 110 ו-111 הוא 1 בלבד. זה מוביל להגדרה של מרחק המינג בין שתי מחרוזות מאורך זהה - מספר המקומות השונים זה מזה במחרוזת, או אם תרצו: מספר <strong>השגיאות</strong> שצריכות להתרחש כדי שבמקום המחרוזת א' תתקבל המחרוזת ב'.</p>
<p>הסיבה שקוראים להגדרה הזו "<a href="http://he.wikipedia.org/wiki/%D7%9E%D7%98%D7%A8%D7%99%D7%A7%D7%94">מרחק</a>" היא שהתכונות הקלאסיות של מרחק מתקיימות עבורה. המרחק של כל מילה מעצמה הוא 0, ואם יש מרחק 0 בין שתי מילים, זוהי אותה המילה; המרחק של א' מב' זהה למרחק של ב' מא'; והמרחק של א' מג' קטן מסכום המרחקים של א' מב' ומב' לג', לכל מילה ב'. לתכונה האחרונה קוראים "אי שוויון המשולש" בגלל שהיא ניסוח פורמלי של התכונה המוכרת לפיה במשולש סכום אורכי שתי צלעות תמיד גדול או שווה לאורך הצלע השלישית. אם חושבים על צלעות המשולש בתור מסלולים שיש ללכת בהם, אי שוויון המשולש הוא פורמליזציה של האבחנה הפשוטה לפיה עדיף ללכת בקו ישר ולא להתעכב בנקודות ביניים בדרך.</p>
<p>אם כן, המרחק המינימלי בין שתי מילים בקוד הוא מספר השגיאות שצריכות ליפול במהלך השידור כדי שנטעה לחשוב ששום דבר לא השתבש, ונקבל מילת קוד לא נכונה. יותר מזה - <strong>חצי</strong> מהמרחק המינימלי הוא מספר השגיאות המקסימלי שיכולות ליפול בקוד כך שעדיין נוכל לשחזר את מילת הקוד הנכונה המקורית (למעשה, מספר השגיאות חייב להיות קטן <strong>ממש</strong> מחצי) - נסו לחשוב מדוע.</p>
<p>כעת אני רוצה לעזוב את הנושא הכללי הזה, שלא התחלתי אפילו לדגדג את קצה-קצהו, ולדבר על קוד מאוד ספציפי, עם תכונה מאוד ספציפית - <a href="http://en.wikipedia.org/wiki/Hadamard_code">קוד הדמר</a> (Hadamard), עם תכונה מאוד ספציפית - הוא <a href="http://en.wikipedia.org/wiki/Locally_testable_code">ניתן לבדיקה מקומית </a>(Locally Testable). הכוונה ב"בדיקה מקומית" היא שבאמצעות דגימה של מספר קטן מאוד - סופי - של ביטים ממילת הקוד ניתן יהיה לזהות בהסתברות טובה האם היא חוקית או לא. ליתר דיוק - אם היא חוקית, תמיד נזהה זאת; אם היא לא חוקית, אז ככל שהיא רחוקה מלהיות מילת קוד חוקית ההסתברות שלנו לזהות זאת תגדל משמעותית (מובן מאליו שאם נפלה שגיאה בביט בודד במילת הקוד אין סיכוי לזהות זאת בהסתברות גדולה על ידי בדיקה של מספר סופי של ביטים - הרי חייבים לקלוע "בול" לביט שהתקלקל כדי שיהיה בכלל סיכוי להבין שמשהו השתבש).</p>
<p>קוד הדמר, כמו רוב הקודים לתיקון שגיאות, הוא קוד לינארי - מילות הקוד מהוות <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A8%D7%97%D7%91_%D7%95%D7%A7%D7%98%D7%95%D7%A8%D7%99">מרחב לינארי</a> מעל <a href="http://he.wikipedia.org/wiki/%D7%A9%D7%93%D7%94_%D7%A1%D7%95%D7%A4%D7%99">שדה סופי</a> כלשהו. אני לא סתם נכנס לעובדה הטכנית הזו - כדי להבין את הרעיון בקוד אין כמעט מנוס מלהכניס לתמונה <a href="http://he.wikipedia.org/wiki/%D7%90%D7%9C%D7%92%D7%91%D7%A8%D7%94_%D7%9C%D7%99%D7%A0%D7%90%D7%A8%D7%99%D7%AA">אלגברה לינארית</a>.</p>
<p>שדה המשחק שלנו הוא מרחבים וקטוריים מעל <span class="math">\(\mathbb{F}_{2}\)</span> - השדה הסופי בן שני איברים (0 ו-1, עם כללי החיבור והכפל הרגילים, כשב"רגילים" הכוונה לכך ש-<span class="math">\(1+1=0\)</span>). "מרחב וקטורי מעל השדה הזה" הוא בסך הכל אוסף של סדרות מאורך נתון כלשהו של איברים מ-<span class="math">\(\mathbb{F}_{2}\)</span>; למשל, אם המרחב הוקטורי הוא ממימד 3, אז אברי המרחב הם <span class="math">\(\left(0,0,0\right),\left(0,1,0\right)\)</span> וכן הלאה. בקיצור, טרם חידשנו משהו. כעת יש להכניס לתמונה את שאר התכונות של מרחב וקטורי: אם <span class="math">\(v_{1},v_{2}\)</span> הם איברים של המרחב הוקטורי, כך גם <span class="math">\(v_{1}+v_{2}\)</span> (כשחיבור הוא "רכיב-רכיב", כלומר <span class="math">\(\left(1,0,1\right)+\left(1,1,0\right)=\left(0,1,1\right)\)</span> ). מי שמכיר אלגברה לינארית יודע שיש גם דרישה של כפל בסקלר, אבל במקרה הזה היא לא מעניינת במיוחד (למה?)</p>
<p>בואו נחשוב לרגע שוב על קודים באופן כללי. קוד פשוט יכול להיות קוד שלוקח מילה <span class="math">\(w\)</span> וממיר אותה במילת הקוד <span class="math">\(\left(w,f\left(w\right)\right)\)</span> כש-<span class="math">\(f\)</span> היא פונקציה שמקבלת את <span class="math">\(w\)</span> ופולטת ביט בודד. אם נרצה שהקוד יהיה לינארי (ואנחנו רוצים, שכן קודים לינאריים הם קלים מאוד לניתוח), אז חיבור של שתי מילות קוד צריך לתת בעצמו מילת קוד, כלומר צריך שיתקיים ש-<span class="math">\(\left(w,f\left(w\right)\right)+\left(v,f\left(v\right)\right)=\left(w+v,f\left(w\right)+f\left(v\right)\right)\)</span> יהיה בעצמו מילת קוד חוקית, כלומר שיתקיים <span class="math">\(f\left(w+v\right)=f\left(w\right)+f\left(v\right)\)</span>. התכונה הזו נקראת "לינאריות של <span class="math">\(f\)</span>". נסכם - אם אנחנו רוצים לבנות את הקוד שלנו על ידי כך שנוסיף ל-<span class="math">\(w\)</span> עוד ביטים לאחריו, שמחושבים באופן מסויים מ-<span class="math">\(w\)</span>, אז כל ביט שכזה חייב להיות מחושב באמצעות פונקציה לינארית.</p>
<p>קוד הדמר לוקח את הגישה הזו עד הסוף - הוא אומר "בואו נוסיף אחרי <span class="math">\(w\)</span> את <strong>כל</strong> הביטים האפשריים שיכולים להתקבל מחישוב של פונקציה לינארית כלשהי". זה מייד מעלה את השאלה איך בכלל אפשר למצוא ולייצג את כל הפונקציות הלינאריות הללו. זה שוב עניין לסטודנטים לאלגברה לינארית; אבל אפשר להראות שאם <span class="math">\(v=\left(v_{1},v_{2},\dots,v_{n}\right)\)</span> הוא וקטור, אז כל פונקציה לינארית היא מהצורה <span class="math">\(f\left(v\right)=\sum_{i=1}^{n}a_{i}v_{i}\)</span>, כשכל <span class="math">\(a_{i}\)</span> הוא או 0 או 1. זו הפשטה נוראית של מה שקורה במקרה הכללי יותר, של מרחב מעל שדה גדול יותר - אבל אני רוצה לא לגלוש לדיון הכללי כרגע.</p>
<p>כעת, הנה אבחנה מעניינת נוספת - <span class="math">\(a=\left(a_{1},a_{2},\dots,a_{n}\right)\)</span> הוא בעצמו איבר המרחב הוקטורי ממימד <span class="math">\(n\)</span> מעל <span class="math">\(\mathbb{F}_{2}\)</span>, כלומר אפשר לייצג כל פונקציה לינארית מהמרחב הוקטורי הזה באמצעות <strong>איבר</strong> מהמרחב הוקטורי הזה! (גם זו תוצאה כללית בהרבה מכפי שאני מציג אותה כאן). כדי לפשט את הסימונים, מגדירים <span class="math">\(a\cdot v=\sum_{i=1}^{n}a_{i}v_{i}\)</span> - לדבר הזה קוראים "מכפלה סקלרית". מכפלה סקלרית דומה למדי לכפל "רגיל", למשל <span class="math">\(a\left(v_{1}+v_{2}\right)=av_{1}+av_{2}\)</span> (התכונה הזו תהיה חשובה בקרוב). נסו להוכיח את התכונה הזו - זה קל למדי, ומסתמך באופן חזק על התכונה הדומה עבור כפל "רגיל".</p>
<p>כעת, אם יש לנו מילה <span class="math">\(w\in\mathbb{F}_{2}^{n}\)</span> (כלומר, רצף של <span class="math">\(n\)</span> ספרות שהן אפס או אחד), אפשר להתעלל קצת בסימונים ולהגיד שנשתמש ב-<span class="math">\(w\)</span> גם כדי לתאר את המילה המקודדת, ולסמן בתור <span class="math">\(w_{a}\)</span> את הביט המתאים במילה המקודדת שמתקבל על ידי חישוב <span class="math">\(a\cdot w\)</span> (ובפירוט יתר: הביט שמתאים להפעלה של הפונקציה הלינארית שמיוצגת על ידי <span class="math">\(a\)</span> על המילה <span class="math">\(w\)</span>). עכשיו אפשר לשים לב לכך שההפרדה המקורית שלנו את מילת הקוד ל"קודם כל המילה המקורית, ואז התוצאה של הפעלת כמה פונקציות לינאריות עליה" היא מלאכותית למדי; גם הביטים של מילת הקוד עצמה יכולים להתקבל מהפעלה של פונקציות לינאריות. למשל, הביט הראשון של <span class="math">\(w\)</span> מתקבל על ידי כפל עם המילה <span class="math">\(e_{1}=\left(1,0,0,\dots,0\right)\)</span>, הביט השני על ידי כפל עם <span class="math">\(e_{2}=\left(0,1,0,0,\dots,0\right)\)</span> וכן הלאה. מעתה אמרו - הקידוד של <span class="math">\(w\)</span> הוא פשוט אוסף ההפעלות של כל הפונקציות הלינאריות האפשריות על <span class="math">\(w\)</span>. לקידוד הזה יש מחיר - אנחנו מקודדים <span class="math">\(n\)</span> ביטים באמצעות <span class="math">\(2^{n}\)</span> ביטים (כי יש <span class="math">\(2^{n}\)</span> פונקציות לינאריות אפשריות - למה?) - ניפוח אקספוננציאלי של המידע המקורי.</p>
<p>למה זה מועיל? כי במובן מסויים, זה לוקח את המילה <span class="math">\(w\)</span> ו"מורח" את הביטים שלה טוב-טוב. כל קומבינציה אפשרית של ביטים של <span class="math">\(w\)</span> באה לידי ביטוי איפה שהוא במילת הקוד. לכן לדגום באקראי ביט מתוך מילת הקוד בעצם שקול לדגימה אקראית של<strong> מספר כלשהו</strong> של ביטים מתוך <span class="math">\(w\)</span>; יותר במדוייק, אם אני בוחר ביט במילת קוד באקראי, אני בעצם מגריל אינדקס <span class="math">\(a\)</span> באקראי וקורא את <span class="math">\(w_{a}\)</span>; והגרלה של <span class="math">\(a\)</span> באופן אקראי (בהתפלגות אחידה) פירושו שכל קוארדינטה של <span class="math">\(a\)</span> מוגרלת בהסתברות <span class="math">\(\frac{1}{2}\)</span> ל-0 ו-<span class="math">\(\frac{1}{2}\)</span> ל-1. כלומר, בדגימה אקראית של ביט ממילת הקוד אנחנו מגרילים כל ביט מ-<span class="math">\(w\)</span> בהסתברות חצי. האבחנה הזו היא המפתח לכך שקוד הדמר ניתן לבדיקה מקומית.</p>
<p>בואו ננסח במדוייק כעת מה מטרתו של בודק מקומי עבור הקוד. הדרישה היא שבהינתן מילת קוד חוקית, הבודק יגיד "כן", ובהינתן מילה שאינה מילת קוד, הבודק יגיד "לא" בהסתברות סבירה, שתלויה במרחק המילה ממילת קוד חוקית. נאמר שהמילה <span class="math">\(w\)</span> רחוקה עד כדי <span class="math">\(\delta\)</span> ממילת קוד חוקית, כש-<span class="math">\(0<\delta\le1\)</span>, אם צריך לשנות <span class="math">\(\delta\)</span> מהכניסות של <span class="math">\(w\)</span> כדי לקבל מילת קוד חוקית (למשל, אם <span class="math">\(\delta=\frac{1}{4}\)</span> זה אומר שצריך לשנות רבע מהכניסות של <span class="math">\(w\)</span>). לאלו מכם שרוצים פורמליזם, ההגדרה המדוייקת היא <span class="math">\(\delta=\min_{w^{\prime}\in C}\frac{d\left(w,w^{\prime}\right)}{\left|w\right|}\)</span>. זהו בעצם המרחק במשמעותו המקורית כשהוא מנורמל באופן שמתחשב באורך המילים - "המרחק היחסי" שבין המילים. מכניסים אותו לתמונה כי הוא מפשט את הניסוחים הטכניים.</p>
<p>אם כן, מה שאראה הוא בודק מקומי שעל מילה שאיננה מילת קוד חוקית, מזהה זאת בהסתברות של <span class="math">\(\frac{\delta}{2}\)</span> לפחות, אך לא יותר מ-<span class="math">\(\frac{2}{9}\)</span>. זאת אומרת שאם <span class="math">\(\delta<\frac{4}{9}\)</span>, אז ההסתברות שתתגלה שגיאה היא <span class="math">\(\frac{\delta}{2}\)</span> (ולכן עבור <span class="math">\(\delta\)</span> קטן היא לא גדולה; אבל היא לינארית ב-<span class="math">\(\delta\)</span>, וזה טוב), ועבור ערכים גדולים יותר יש הסתברות קבועה של <span class="math">\(\frac{2}{9}\)</span> לגלות שגיאה ולכן על ידי הפעלות נשנות של הבודק אפשר "לנפח" את ההסתברות לגילוי שגיאה עד שתתקרב כרצוננו ל-1. ה"מחיר" יהיה קריאה של בדיוק שלושה ביטים מהקלט; כמובן שה"ניפוח" מצריך קריאה של עוד ביטים, אבל עדיין מספר קבוע שאינו תלוי ב-<span class="math">\(n\)</span>. כאן אנחנו מתחילים להרגיש את ה-PCP שהזכרתי בפוסט הקודם; גם שם הרעיון הוא קריאה של מספר קבוע של ביטים.</p>
<p>ואיך הבודק עובד? באופן כמעט מגוחך. הוא בוחר באקראי וקטורים <span class="math">\(a,b\)</span> וקורא את <span class="math">\(w_{a},w_{b}\)</span>. כזכור, הערכים הללו הם <span class="math">\(a\cdot w,b\cdot w\)</span>, ועל פי כללי הכפל נובע ש-<span class="math">\(aw+bw=\left(a+b\right)w\)</span>, מה שמוביל אותנו בקלות לביט הנוסף שיש לדגום - הוא קורא את <span class="math">\(w_{a+b}\)</span> ובודק האם <span class="math">\(w_{a+b}=w_{a}+w_{b}\)</span>. אם כן - הוא מקבל (או מתחיל סיבוב בדיקה חדש); אם לא, הוא דוחה. כל כך פשוט.</p>
<p>טוב, אבל למה זה עובד? התשובה הקצרה היא "זה טכני". התשובה הארוכה היא "זה טכני, אבל אראה את זה בכל זאת ובתקווה לא אאבד יותר מדי אנשים, כי זו אחת מההוכחות האהובות עלי". אני מקווה שברור מדוע אם <span class="math">\(w\)</span> היא מילת קוד חוקית הבדיקה עובדת - נימקתי זאת לעיל. השאלה היא מה קורה אם <span class="math">\(w\)</span> אינה מילת קוד חוקית.</p>
<p>הבה ונסמן את ההסתברות שהבודק ידחה את המילה <span class="math">\(w\)</span> ב-<span class="math">\(\varepsilon\)</span>. אם <span class="math">\(\varepsilon\ge\frac{2}{9}\)</span>, "ניצחנו" - הראנו שהבודק עובד טוב על <span class="math">\(w\)</span>. לכן ההנחה היא ש-<span class="math">\(\varepsilon<\frac{2}{9}\)</span>. מה שרוצים להראות הוא שמכך נובע שהמרחק היחסי של <span class="math">\(w\)</span> ממילת הקוד החוקית הקרובה ביותר (שהוא, כזכור, <span class="math">\(\delta\)</span>) לא עולה על <span class="math">\(2\varepsilon\)</span> (כלומר - <span class="math">\(\delta\le2\varepsilon\)</span>, או <span class="math">\(\varepsilon\ge\frac{\delta}{2}\)</span>). בקיצור - רוצים למצוא איכשהו מילת קוד חוקית שקרובה יחסית ל-<span class="math">\(w\)</span>. אה, אבל זה בדיוק מה שקודים לתיקון שגיאות עושים - בהינתן מילה "מקולקלת", מראים כיצד לתקן אותה.</p>
<p>כאן מגיע הרעיון המרכזי בהוכחה, שהוא מקסים. כיצד תיבנה אותה מילת קוד, שאסמן בתור <span class="math">\(v\)</span>? באופן הבא. הכניסה <span class="math">\(v_{a}\)</span> במילה תוגדר בתור "הצבעת הרוב" של <span class="math">\(w\)</span>. למה הכוונה? אנחנו יודעים ש<strong>אם</strong> <span class="math">\(w\)</span> הייתה מילה חוקית, אז היה מתקיים <span class="math">\(w_{a}+w_{b}=w_{a+b}\)</span> לכל <span class="math">\(b\)</span> אפשרי, או בניסוח אחר - <span class="math">\(w_{a}=w_{a+b}-w_{b}\)</span>. לרוע המזל <span class="math">\(w\)</span> איננה מילת קוד חוקית ולכן זה לא מתקיים עבורה תמיד - כלומר, ייתכן ש-<span class="math">\(w_{a+b}-w_{b}\)</span> לא תמיד מחזיר את אותו ערך, כאשר משנים את הערכים ש-<span class="math">\(b\)</span> מקבל. עם זאת, הערך שמופיע מספר רב יותר של פעמים הוא כנראה הערך ה"נכון" עבור <span class="math">\(w\)</span>. אם כן, התיקון של <span class="math">\(w\)</span> יהיה <span class="math">\(v\)</span> כך ש-<span class="math">\(v_{a}=\text{majority}_{b}\left\{ w_{a+b}-w_{b}\right\} \)</span>, כאשר <span class="math">\(\text{majority}\)</span> היא פונקציה שמחזירה את האיבר השכיח יותר ב"קבוצה" שהיא מקבלת ("קבוצה" במרכאות כי בדרך כלל בקבוצות כל איבר נספר פעם אחת, וכאן למספר המופעים יש חשיבות מכרעת).</p>
<p>צריך כעת להראות שני דברים: ראשית ש-<span class="math">\(v\)</span> היא בכלל מילת קוד חוקית; שנית, שהיא קרובה ל-<span class="math">\(w\)</span> עד כדי <span class="math">\(2\varepsilon\)</span> - פורמלית נסמן זאת <span class="math">\(d\left(w,v\right)<\varepsilon\)</span>. נתחיל דווקא מהתוצאה השניה. האינטואיציה כאן אינה קשה - אם <span class="math">\(w_{a}\ne v_{a}\)</span>, אז אם הבודק המקומי יבחר את <span class="math">\(a\)</span> כאחת משתי הקוארדינטות שהוא בודק, יהיה לו סיכוי של לפחות חצי לעלות על שגיאה, שהרי <span class="math">\(w_{a}\)</span> <strong>אינו</strong> מתאים לכלל הצבעת הרוב, ולכן עבור רוב הערכים של <span class="math">\(b\)</span> שהבודק יגריל, יתקיים ש-<span class="math">\(w_{a}\ne w_{a+b}-w_{b}\)</span> (כלומר, <span class="math">\(w_{a}+w_{b}\ne w_{a+b}\)</span>). כעת, שימו לב שהסיכוי של הבודק ליפול על <span class="math">\(a\)</span> שמקיים <span class="math">\(w_{a}\ne v_{a}\)</span> הוא בדיוק המרחק היחסי שלהם; ואם הבודק כבר נפל על <span class="math">\(a\)</span> שכזה, ההסתברות שלו ליפול על <span class="math">\(b\)</span> שיכשיל את <span class="math">\(w\)</span> היא לפחות חצי; ולכן ההסתברות של הבודק לדחות את <span class="math">\(w\)</span> היא לפחות <span class="math">\(\frac{1}{2}d\left(w,v\right)\)</span>; אבל סימנו ב-<span class="math">\(\varepsilon\)</span> את ההסתברות של הבודק לדחות את <span class="math">\(w\)</span>, כלומר <span class="math">\(\frac{1}{2}d\left(w,v\right)\le\varepsilon\)</span>, כלומר <span class="math">\(\delta\le d\left(w,v\right)\le2\varepsilon\)</span>.</p>
<p>אם כן, נותר אתגר בודד - להראות ש-<span class="math">\(v\)</span> היא מילת קוד חוקית. כפי שניתן לנחש, זה המקום שבו <span class="math">\(\frac{2}{9}\)</span> המסתורי יבוא לידי ביטוי. ברשותכם, ארשה לעצמי להמשיך להיות טכני ולהציג את ההוכחה במלואה. ראשית כל צריך להבהיר לעצמנו כיצד ניתן להוכיח שמילה כלשהי <span class="math">\(v\)</span> היא מילת קוד חוקית. דרך אחת היא להראות איך מילה בת <span class="math">\(n\)</span> ביטים ממופה ל-<span class="math">\(v\)</span> על ידי הקוד; אבל זה די מסורבל. הרבה יותר נחמד להשתמש בקריטריון הבדיקה שכבר הצגנו, ומסתבר שזה אכן מספיק: אם <span class="math">\(v_{a}+v_{b}=v_{a+b}\)</span> לכל <span class="math">\(a,b\)</span>, אז <span class="math">\(v\)</span> היא מילת קוד חוקית. האבחנה הזו טבעית למדי - הרי כפי שראינו, גם הביטים של "המילה המקורית" שממנה התקבל הקוד מקודדים בתוך <span class="math">\(v\)</span> (הביט ה-<span class="math">\(i\)</span> מקודד כ-<span class="math">\(v_{e_{i}}\)</span>) ומתכונת החיבוריות הזו נובע שלכל <span class="math">\(a=\sum\alpha_{i}e_{i}\)</span> מתקיים <span class="math">\(v_{a}=v_{\sum\alpha_{i}e_{i}}=\sum\alpha_{i}v_{e_{i}}\)</span>, כנדרש.</p>
<p>אם כן, מספיק לקחת <span class="math">\(a,b\)</span> שרירותיים ולהראות שעבורם מתקיים <span class="math">\(v_{a}+v_{b}=v_{a+b}\)</span>. באופן די מפתיע, ההוכחה היא כמעט מיידית אם רק נראה עוד משהו אחד - ש"הכרעת הרוב" שמגדירה את <span class="math">\(v_{a}\)</span> היא לא סתם הכרעת רוב, אלא הכרעת רוב מוחץ: שלפחות <span class="math">\(\frac{2}{3}\)</span> מה"הצבעות" <span class="math">\(w_{a+b}-w_{a}\)</span> נתנו את הערך של <span class="math">\(v_{a}\)</span> ולא את הערך השני האפשרי. קודם כל אסביר מדוע זה מסיים את העניין ואז אוכיח זאת.</p>
<p>הטריק הוא להשתמש בשיטה ההסתברותית - להוכיח שמשהו קיים על ידי כך שמראים שההסתברות למציאתו במרחב החיפוש שלנו גדולה מאפס. מה שאנו מחפשים הוא מילה <span class="math">\(c\)</span> שתקיים את שלוש התכונות הבאות <strong>בו זמנית</strong>:</p>
<ol>
    <li> <span class="math">\(v_{a}=w_{c}-w_{a+c}\)</span></li>
    <li> <span class="math">\(v_{b}=w_{b+c}-w_{c}\)</span></li>
    <li> <span class="math">\(v_{a+b}=w_{b+c}-w_{a+c}\)</span></li>
</ol>
<p>אם מצאנו <span class="math">\(c\)</span> כזה, סיימנו. למה? שכן אז <span class="math">\(v_{a}+v_{b} = \left(w_{c}-w_{a+c}\right)+\left(w_{b+c}-w_{c}\right)=w_{b+c}-w_{a+c}=v_{a+b}\)</span> כנדרש. אז למה קיים <span class="math">\(c\)</span> כזה? ובכן, בואו נביט לרגע על המשוואה הראשונה, <span class="math">\(v_{a}=w_{c}-w_{a+c}\)</span>. מכיוון שפעולת החיבור מתבצעת מעל <span class="math">\(\mathbb{F}_{2}\)</span> (כלומר, <span class="math">\(1+1=0\)</span>, או במילים אחרות <span class="math">\(1=-1\)</span>), זו בדיוק אותה משוואה כמו <span class="math">\(v_{a}=w_{a+c}-w_{c}\)</span></p>
<p>מה ההסתברות, אם מגרילים <span class="math">\(c\)</span>, שהיא לא מתקיימת? בדיוק ההסתברות ש-<span class="math">\(c\)</span> יהיה אחד מקולות המיעוט בהצבעה שקבעה את <span class="math">\(v_{a}\)</span>. מכיוון שאמרנו שהרוב בהצבעה היה לפחות <span class="math">\(\frac{2}{3}\)</span>, נובע מכך שההסתברות ש-<span class="math">\(c\)</span> יהיה "מקלקל" שכזה היא לכל היותר <span class="math">\(\frac{1}{3}\)</span>. באופן דומה גם עבור שני התנאים האחרים אפשר להראות שההסתברות לכך ש-<span class="math">\(c\)</span> לא יקיים אותם היא לכל היותר <span class="math">\(\frac{1}{3}\)</span>. כעת, <a href="http://en.wikipedia.org/wiki/Boole%27s_inequality">חסם טריוויאלי</a> בהסתברות (שמכונה Union bound) אומר כי אם יש לנו קבוצת מאורעות, אז ההסתברות שלפחות אחד מהם יתרחש היא לכל היותר סכום ההסתברויות של כולם. כאן יש לנו שלושה מאורעות שההסתברות של כל אחד מהם קטנה מ-<span class="math">\(\frac{1}{3}\)</span>, ולכן ההסתברות שלפחות אחד מהם יקרה קטנה מ-<span class="math">\(1\)</span> - כלומר, קיים <span class="math">\(c\)</span> שלא מקיים אף אחד מהמאורעות. מכיוון שהמאורעות היו "1 מתקלקל", "2 מתקלקל" ו-"3 מתקלקל", קיבלנו שיש <span class="math">\(c\)</span> שעבורו אף אחד משלושת התנאים אינו מתקלקל - כלומר, סיימנו.</p>
<p>נותר רק להראות שאכן מתקיימת "הכרעת רוב מוחץ", כלומר שעבור לפחות <span class="math">\(\frac{2}{3}\)</span> מה-<span class="math">\(b\)</span>-ים האפשריים מתקיים <span class="math">\(v_{a}=w_{a+b}-w_{b}\)</span>.</p>
<p>הבה ונסמן את גודל הרוב ב-<span class="math">\(p\)</span>, כלומר <span class="math">\(\text{Pr}\left[v_{a}=w_{a+b}-w_{b}\right]=p\)</span> (<span class="math">\(\text{Pr}\)</span> הוא סימון סטנדרטי להסתברות של המאורע שבסוגריים; ההסתברות נלקחת על פני הבחירות האקראיות של <span class="math">\(b\)</span>). כעת נשדרג את המשחק - נניח שאנחנו בוחרים באקראי <strong>שני</strong> "מצביעים", <span class="math">\(b,c\)</span> ושואלים אותם לדעתם; מה ההסתברות שהם יגידו את אותו הדבר? כלומר, מהו <span class="math">\(\text{Pr}\left[w_{a+b}-w_{b}=w_{a+c}-w_{c}\right]\)</span>? ובכן, אחד משניים: או ששניהם הצביעו לערך שהרוב בחרו, בהסתברות <span class="math">\(p\)</span> כל אחד ולכן <span class="math">\(p^{2}\)</span> לשניהם יחד; או ששניהם הצביעו עבור הערך השני, בהסתברות <span class="math">\(\left(1-p\right)\)</span> כל אחד ולכן <span class="math">\(\left(1-p\right)^{2}\)</span> לשניהם יחד. סה"כ ההסתברות שהם מסכימים היא <span class="math">\(p^{2}+\left(1-p\right)^{2}\)</span>. אם נצליח למצוא חסם תחתון כלשהו על ההסתברות הזו, נוכל לחלץ מהמשוואה (ומכך ש-<span class="math">\(p\ge\frac{1}{2}\)</span>) חסם תחתון על <span class="math">\(p\)</span>. כאן גם מתחילה ה"הנדסה לאחור" שלבסוף תניב את ה-<span class="math">\(\frac{2}{9}\)</span> הידוע לשמצה - אנחנו מחפשים חסם תחתון על <span class="math">\(p^{2}+\left(1-p\right)^{2}\)</span> שיגרור <span class="math">\(p>\frac{2}{3}\)</span>; קצת משחק בפרמטרים ופתרון משוואה ריבועית יראה כי החסם התחתון הזה הוא <span class="math">\(\frac{5}{9}\)</span> (נסו זאת בבית!).</p>
<p>נסכם: עלינו להראות כי <span class="math">\(\text{Pr}\left[w_{a+b}-w_{b}=w_{a+c}-w_{c}\right]&gt;\frac{5}{9}\)</span>. הטכניקה דומה לטכניקה שכבר השתמשתי בה. ראשית נשים לב לכך ש-<span class="math">\(\text{Pr}\left[w_{a+b}-w_{b}=w_{a+c}-w_{c}\right] = \text{Pr}\left[w_{a+b}+w_{c}=w_{a+c}+w_{b}\right]\)</span></p>
<p>כעת שני האגפים הם "מאוזנים" במידת מה - בכולם מופיעים גם <span class="math">\(a\)</span>, גם <span class="math">\(b\)</span> וגם <span class="math">\(c\)</span>. יותר מכך - אם <span class="math">\(w\)</span> הייתה מילת קוד חוקית, שני האגפים היו שווים ל-<span class="math">\(w_{a+b+c}\)</span>. לכן ההסתברות של המאורע שלמטה היא בעצם ההסתברות שלא חל "קלקול" בחישוב של <span class="math">\(w_{a+b+c}\)</span> לא באמצעות <span class="math">\(w_{a+b}+w_{c}\)</span>, וגם לא באמצעות <span class="math">\(w_{a+c}+w_{b}\)</span>. לכן שוב נשאל את עצמנו - מה ההסתברות שכן חל קלקול באחד משני המקרים הללו?</p>
<p>אם כן, מה ההסתברות ש-<span class="math">\(w_{a+b}+w_{c}\ne w_{a+b+c}\)</span>? זה טיפה מבלבל מכיוון שהן <span class="math">\(b\)</span> והן <span class="math">\(c\)</span> נבחרו באקראי ואילו <span class="math">\(a\)</span> נקבע מראש, אבל אפשר לפשט קצת את העניינים: אם <span class="math">\(b\)</span> נבחר באקראי ובהתפלגות אחידה מבין כל הערכים האפשריים, ו-<span class="math">\(a\)</span> קבוע, אז גם <span class="math">\(a+b\)</span> מוגרל בהתפלגות אחידה מבין כל הערכים האפשריים (למה?). לכן אפשר לסמן לצורך פשטות <span class="math">\(a^{\prime}=a+b\)</span> ולשאול את עצמנו את השאלה הפשוטה יותר: מהי ההסתברות ש-<span class="math">\(w_{a^{\prime}}+w_{c}\ne w_{a^{\prime}+c}\)</span> כאשר הן <span class="math">\(a^{\prime}\)</span> והן <span class="math">\(c\)</span> נבחרים באקראי? ואת התשובה לשאלה הזו אנחנו יודעים: ההסתברות הזו חסומה על ידי ההסתברות שהבודק ידחה את <span class="math">\(w\)</span> - שהרי זה בדיוק מה שהבודק עושה - מגריל שני אינדקסים ומבצע את בדיקת השוויון שלעיל.</p>
<p>כזכור, בתחילת הדיון הזה הנחנו שהסתברות הדחייה של הבודק היא נמוכה יחסית - נמוכה מ-<span class="math">\(\frac{2}{9}\)</span> (כי במקרה שהיא גבוהה יותר אין מה להראות). מכאן שההסתברות ש-<span class="math">\(w_{a+b}+w_{c}\ne w_{a+b+c}\)</span> קטנה מ-<span class="math">\(\frac{2}{9}\)</span>, וגם ההסתברות ש-<span class="math">\(w_{a+c}+w_{b}\ne w_{a+b+c}\)</span> קטנה מ-<span class="math">\(\frac{2}{9}\)</span>, ולכן על פי ה-Union bound נקבל שההסתברות שאף אחד משני מאורעות אלו אינו מתרחש, ולכן <span class="math">\(w_{a+b}+w_{c}=w_{a+c}+w_{b}\)</span>, היא לפחות <span class="math">\(\frac{5}{9}\)</span>, כמו שרצינו. זה מסיים, סוף כל סוף, את ההוכחה כולה.</p>
<p>תרגיל בית למי שרוצה לוודא שהוא אכן הבין את כל החישובים הקטנים והקטנוניים האחרונים, ושה-<span class="math">\(\frac{2}{9}\)</span> שהופיע בהתחלה לא נפל משמיים אלא אפשר להגיע אליו בדרך טבעית: נניח שהיינו רוצים להראות ש-<span class="math">\(p>\frac{3}{4}\)</span> ולא סתם <span class="math">\(p>\frac{2}{3}\)</span>; מהו החסם החדש על <span class="math">\(\varepsilon\)</span> שהיה עלינו לדרוש?</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>