<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט ה-PCP או: איך למדתי להפסיק לדאוג ולאהוב הוכחות הניתנות לבדיקה הסתברותית - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.5em 10px;
            quotes: "\201C""\201D""\2018""\2019";
        }
        
        blockquote:before {
            color: #ccc;
            content: open-quote;
            font-size: 4em;
            line-height: 0.1em;
            margin-left: 0.25em;
            vertical-align: -0.4em;
        }
        
        blockquote p {
            display: inline;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2009/09/10/automata_and_generating_functions/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">אז מה הקשר בין אוטומטים ופונקציות יוצרות?</span>
            </a>
            

            
            <a href="/2009/09/23/locally_checkable_codes/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">קודים לתיקון שגיאות (שניתנים לבדיקה מקומית)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט ה-PCP או: איך למדתי להפסיק לדאוג ולאהוב הוכחות הניתנות לבדיקה הסתברותית</h1>
            <div class="post-meta">
                <span class="date">2009-09-19</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/מערכות הוכחה.html">מערכות הוכחה</a>
                    
                    <a href="/tags/משפט ה-PCP.html">משפט ה-PCP</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אחד מהנושאים הלוהטים ביותר במדעי המחשב המודרניים הוא משפט ה-PCP, הרחבותיו והשלכותיו. אלא שכל הקשור ל-PCP עשוי להישמע מוזר מאוד כששומעים לראשונה מה ראשי התיבות הללו מסמלים: Probabilistically Checkable Proofs, הוכחות הניתנות לבדיקה הסתברותית. מה זה בכלל, ואיך אפשר לזהם מושג טהור כמו "הוכחה" שהיא תמיד ודאית ב-100 אחוז (לפחות כשמדובר על הוכחה "מתמטית") עם המושג הבזוי של "הסתברות"?</p>
<p>לשם כך ראשית יש להציג את הגישה של מדעי המחשב למושג ההוכחה, שהוא שונה מעט מהגישה המתמטית. בגישה המתמטית אנו קובעים מערכת של אקסיומות וכללי היסק, ואז הוכחה היא פשוט סדרה של טענות כך שכל טענה היא אקסיומה או נובעת מטענות קודמות באמצעות כללי ההיסק. <a href="http://www.gadial.net/2009/04/26/continuum_hypothesis_light/">דיברתי בפירוט רב יותר</a> על מערכות שכאלו כאשר הזכרתי את משפטי גדל. כמובן, אפילו במתמטיקה זו איננה המשמעות היחידה של "הוכחה" (למשל, אפשר לחשוב על מערכות שבהן מוכיחים דברים בדרך השלילה - מתחילים מטענה כלשהי ומסיקים לבסוף סתירה. אלו מערכות הוכחה מעניינות בפני עצמן), אבל זו המשמעות המקובלת ביותר.</p>
<p>במדעי המחשב נוקטים גישה אחרת, שבמובן מסויים היא "טבעית" יותר. הבה ונחשוב לרגע על ספר מתמטיקה. ההוכחות שנמצאות בו למשפטים אינן, על פי רוב, הוכחות במובן המתמטי הפורמלי; כמעט כל הוכחה בספרים נכתבת בשפה טבעית, מסבירה דברים ב"נפנוף ידיים", משאירה חלק מההוכחה כתרגיל לקורא, מבצעת מעברים מורכבים בלי שום נימוק של סדרת הצעדים שבאמצע (שלעתים נדרש קורס שלם כדי להכיר אותם) וכן הלאה. עם זאת, על פי רוב ההוכחות הלו נחשבות ללגיטימיות ואפילו להכרחיות, שכן כל נסיון לכתוב הוכחה פורמלית יגרום להוכחה להיות ארוכה בהרבה וקריאה הרבה פחות על ידי בני אדם.</p>
<p>אם כן, הדגש המרכזי כאן הוא על ה<strong>יעילות</strong> שבה ההוכחה מסוגלת להיקרא בידי מי שקורא אותה. בפרט, אנחנו מתייחסים אל ה<strong>קורא</strong> כאל חלק אינטגרלי ממערכת ההוכחה - לקוראים שונים אולי יתאימו הוכחות שונות. לכן הגדרת ההוכחה מפסיקה לדבר על איזה שהוא ערך פנימי שטמון בה, והיא הופכת להיות תלויה לחלוטין בהשפעה שלה על הקורא. מה שעוד נותר לדבר עליו הוא מהם הדברים שההוכחה מנסה להוכיח, וגם כאן נכנסת לתמונה הגישה של מדעי המחשב.</p>
<p>במקום לדבר על הוכחה של טענה בשפה מסדר ראשון או כל דבר דומה, מפשיטים; טענה, בשורה התחתונה, היא רצף של אותיות מעל אלפבית כלשהו, שהוא או נכון או לא נכון תחת פירוש מסויים שאנחנו נותנים לעולם. יותר במובהק, אם אנחנו קובעים את האלפבית שלנו מראש ואת הפרשנות שלנו לעולם מראש, אנחנו נשארים עם שלושה סוגים שונים של רצפי אותיות - כאלו שאין להם שום משמעות (למשל "עגכדהא"), כאלו שיש להם משמעות והם נכונים ("יש אינסוף מספרים ראשונים") וכאלו שיש להם משמעות והם אינם נכונים ("יש מספר סופי של ראשוניים"). על כל טענה כזו אפשר לחשוב בתור "מילה" - רצף אותיות (במקרה שלנו, כולל האות "רווח"), ועל אוסף הטענות הנכונות אפשר לחשוב בתור שפה (שפה היא פשוט אוסף של מילים). כלומר, צמצמנו את הבעיה שלנו לבעיה של זיהוי מתי מילה שייכת לשפה כלשהי. זה גם בדיוק המושג שהופיע <a href="http://www.gadial.net/2009/08/30/finite_automata_and_regular_languages/">בפוסטים הקודמים שלי</a>, שעסקו באוטומטים; מה שחשוב להבין הוא שדרך ההתבוננות הזו לא גורעת מהכלליות של הדיון על הוכחה אלא רק מרחיבה אותו.</p>
<p>בואו נחשוב על כמה דוגמה פשוטה, להבדיל מכל מערכות ההוכחה מסדר ראשון ודומיהן. אפשר לחשוב על שפה של <a href="http://www.gadial.net/2008/05/06/eulerian_graphs/">גרפים שיש בהם מסלול המילטוני</a> (מסלול שמבקר בכל הצמתים בדיוק פעם אחת). בהקשר הזה אנחנו מפרשים כל מילה בתור גרף (או אומרים "המילה הזו מקושקשת ואי אפשר לחשוב עליה כאילו היא מתארת גרף"), והשפה שלנו תכלול בדיוק את אותן מילים שמייצגות גרפים המילטוניים. במקרה הזה טענה מסוג "המילה הזו שייכת לשפה" היא בעצם טענת "הגרף הזה הוא המילטוני".</p>
<p>עכשיו, בהינתן גרף המילטוני, איך אפשר להשתכנע בכך שהוא אכן המילטוני? הבה ונקרא למי שמנסה להשתכנע "המוודא" (כי הוא מוודא שהטענה נכונה). המוודא יכול לנסות באופן שרירותי את כל המסלולים בגרף עד שימצא אחד המילטוני (או שלא ימצא, ואז ידע בודאות שהגרף <strong>אינו</strong> המילטוני). עם זאת, אפשר לעשות לו את החיים קלים יותר ולספק לו מראש תיאור של מסלול המילטוני בגרף - ואז כל מה שיישאר לו לעשות הוא לוודא שאכן התיאור הזה חוקי ומתאים לגרף. אם מישהו רמאי ייתן לו תיאור שקרי, המוודא יעלה על זה בקלות. זה מביא אותנו סוף סוף אל ההגדרה הפורמלית של "מערכת הוכחה עבור השפה <span class="math">\(L\)</span>": היא מורכבת ממוודא <span class="math">\(V\)</span>, שאפשר לחשוב עליו בתור אלגוריתם מתוחכם (אבל עדיין אלגוריתם - כזה שכל צעד שלו מוגדר בצורה מדוייקת) שמקבל שני "קלטים" - טענה <span class="math">\(w\)</span>, והוכחה <span class="math">\(\pi\)</span>. הן הטענה והן ההוכחה הן פשוט מילים; המוודא רץ על שני הקלטים הללו ופולט לבסוף "מקבל" או "דוחה". פורמלית ניתן לכתוב זאת <span class="math">\(V\left(w,\pi\right)=\text{acc}\)</span> ו-<span class="math">\(V\left(w,\pi\right)=\text{rej}\)</span>. הציפיות שלנו ממערכת הוכחה "טובה" (כלומר, ממוודא "טוב") הן שיתקיימו שלוש הדרישות הבאות:</p>
<ol>
    <li> שלמות: לכל <span class="math">\(w\in L\)</span> קיימת הוכחה <span class="math">\(\pi\)</span> כך ש-<span class="math">\(V\left(w,\pi\right)=\text{acc}\)</span>.</li>
    <li> נאותות: לכל <span class="math">\(w\notin L\)</span> ולכל הוכחה <span class="math">\(\pi\)</span> מתקיים <span class="math">\(V\left(w,\pi\right)=\text{rej}\)</span>.</li>
    <li> יעילות: צריכת המשאבים של <span class="math">\(V\)</span> על הקלטים <span class="math">\(w,\pi\)</span> היא יעילה ביחס לגודל הייצוג של <span class="math">\(w\)</span>.</li>
</ol>
<p>שתי הדרישות הראשונות הן מתמטיות "קלאסיות", בזמן שהשלישית היא מדעי-המחשבניקית "מודרנית". זו גם הדרישה הכי מעורפלת, ולכן אתמקד מעכשיו בפורמליזציה הסטנדרטית שלה- אנו דורשים כי זמן הריצה של <span class="math">\(V\)</span> יהיה פולינומי בגודל <span class="math">\(w\)</span>. פולינומי, שכן זה מה שנחשב לזמן ריצה סביר בדרך כלל. כעת נשאלת השאלה מהן השפות שמקיימות את שלוש התכונות הללו. התשובה היא שאלו הן בדיוק השפות שבמחלקה המפורסמת <span class="math">\(\text{NP}\)</span> ש<a href="http://www.gadial.net/2007/12/16/np_haystack/">הזכרתי כאן לא אחת</a>. אין כאן שום תובנה מחוכמת - ה"הוכחה" שמקבל <span class="math">\(V\)</span> היא אותו דבר במהותו כמו ה"רמז" שבדרך כלל נהוג לומר שהמכונה לשפת ה-<span class="math">\(\text{NP}\)</span> מקבלת (אם חושבים על <span class="math">\(\text{NP}\)</span> כעל אוסף השפות שיש מכונה אי דטרמיניסטית שמכריעה אותן השקילות מעט פחות ברורה - ה"הוכחה" במקרה זה תהיה תיאור של הבחירות האי דטרמיניסטיות שהמכונה מבצעת עד לקבלת המילה השייכת לשפה).אם כן, במובן מסויים <span class="math">\(\text{NP}\)</span> מסמלת עבורנו את מחלקת כל ה"תורות" שקיימת עבורן מערכת הוכחה יעילה. לאן ממשיכים מכאן?</p>
<p>כיוון אחד שניתן להמשיך אליו הוא הרחבה של מושג ה"הוכחה". במקום סתם הוכחה כתובה <span class="math">\(\pi\)</span>, אפשר לדבר על "מוכיח" <span class="math">\(P\)</span> שמנהל שיחה מנומסת עם <span class="math">\(V\)</span> ומנסה לשכנע אותו שהוא צודק. למערכת הוכחה כזו קוראים "<a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A2%D7%A8%D7%9B%D7%AA_%D7%94%D7%95%D7%9B%D7%97%D7%94_%D7%90%D7%99%D7%A0%D7%98%D7%A8%D7%90%D7%A7%D7%98%D7%99%D7%91%D7%99%D7%AA">מערכת הוכחה אינטראקטיבית</a>". לרוע המזל, ניתן להוכיח כי השינוי הזה לא מוסיף כוח למערכת - גם מערכת הוכחה אינטראקטיבית מסוגלת להוכיח רק שפות ב-<span class="math">\(\text{NP}\)</span>. אם כן, צריך להקל איכשהו על אחת משלוש הדרישות שלנו. על יעילות לא רוצים לוותר בשום פנים ואופן, ולכן נותרו השלמות והנאותות. אם נלך לפי הגישה לפיה עדיפים עשרה פושעים מחוץ לכלא מאשר איש חף מפשע אחד בתוכו, הרי שעלינו לפגוע בנאותות, לא בשלמות; פגיעה בשלמות פירושה שייתכן שטענות <strong>נכונות</strong> לא יהיו ניתנות להוכחה; פגיעה בנאותות פירושה שיהיה אפשרי להשתכנע בטעות שטענה שגויה היא נכונה. החוכמה היא להגביל את ה"אפשרי" הזה ככל הניתן.</p>
<p><a href="http://www.gadial.net/2009/08/18/probablistic_algorithms/">לא מזמן דיברתי</a> על אלגוריתמים הסתברותיים. הדגשתי שם שהדבר החשוב באלגוריתם הסתברותי הוא שההסתברות תילקח על פני כל הריצות האפשריות של האלגוריתם על קלט מסויים, ולא על פני כל הקלטים. ההבדל מהותי: במקום שיהיו קלטים שעבורם האלגוריתם <strong>תמיד נכשל</strong> אבל "ההסתברות שהם יתקבלו" היא נמוכה (במרכאות, כי זה מושג מאוד בעייתי), האלגוריתם מבטיח הסתברות הצלחה כלשהי <strong>לכל הקלטים</strong>. כך גם במערכת הוכחה - אנחנו דורשים שלכל מילה <span class="math">\(w\notin L\)</span> ולכל "הוכחה" <span class="math">\(\pi\)</span> עבור <span class="math">\(w\)</span> ("הוכחה" כזו היא בעצם נסיון להטעות את המוודא), ההסתברות שיתקיים <span class="math">\(V\left(w,\pi\right)=\text{rej}\)</span> היא לפחות <span class="math">\(\frac{2}{3}\)</span> או קבוע דומה (בפוסט על אלגוריתמים הסתברותיים הסברתי מדוע בחירת הקבוע אינה כה מהותית). כמובן שזה אומר, בפרט, שהמוודא פועל באופן הסתברותי.</p>
<p>אם מקבלים את ההקלה הזו של תנאי 2, פתאום מערכות ההוכחה שלנו מקבלות כוח רב הרבה יותר. אם הולכים בכיוון של מערכות הוכחה אינטראקטיביות, הרי שמתברר כי מערכת הוכחה אינטראקטיבית עם ההקלה ההסתברותית שהצגנו הופכת להיות חזקה כמו <span class="math">\(\text{PSPACE}\)</span>: כל בעיה שניתנת לפתרון ב<strong>זכרון</strong> פולינומי, ניתנת להוכחה במערכת כזו. השלב הבא, והמשעשע עוד יותר, הוא הרחבת המערכת האינטראקטיבית כך שיהיו <strong>שני</strong> מוכיחים במקום אחד, כך שהמוודא מדבר עם כל אחד מהמוכיחים בנפרד, מבלי שהם יוכלו לתקשר זה עם זה. הדבר מזכיר קצת שני פושעים שנחקרים בנפרד והשקרים שהם מספרים אינם מתואמים, כך שקל לעלות עליהם. במדעי המחשב התחושה האינטואיטיבית הזו תורגמה לתוצאה מדוייקת - מערכות הוכחה שכאלו תופסות את כל <span class="math">\(\text{NEXP}\)</span> - אוסף הבעיות שניתנות לפתרון אי דטרמיניסטי בזמן אקספוננציאלי. מחלקה זו גדולה לפחות כמו <span class="math">\(\text{PSPACE}\)</span> (ככל שידוע לי, השאלה האם הן שוות או לא עודנה פתוחה).</p>
<p>עם זאת, הכיוון שאני רוצה לדבר עליו כעת אינו הכיוון האינטראקטיבי - נמשיך לדבר על הסיטואציה שבה המוודא מקבל הוכחה כתובה ותו לא. מכיוון שההסתברות מוסיפה לו כוח רב, מעניין לשאול איך אפשר "להצטמצם" כעת באופן אחר ועדיין לתפוס את מה שתפסה ההגדרה ה"קלאסית" להוכחה, כלומר את <span class="math">\(\text{NP}\)</span>. זה בדיוק המקום שבו נכנס משפט ה-<span class="math">\(\text{PCP}\)</span> לתמונה.</p>
<p>כל בודק תרגילים (לפחות בתחום הריאלי) ודאי מכיר את התופעה הזו - אחרי שבודקים ארבע-חמש עבודות, כבר נהיה ברור לחלוטין מה דרך הפתרון שבה רוב הפותרים נוקטים ואיפה נמצאים ה"מוקשים" שבהם הם נכשלים. מאותו רגע, בדיקת העבודות מתקצרת - במקום לנבור בכל הטקסט, די לאתר ולבדוק את ה"מוקשים" וחסל. זו לא דרך מדוייקת לחלוטין, ולכן לפעמים נוצר אילוץ לקרוא את העבודה כולה, אבל בדרך כלל די בבדיקת המוקשים ורפרוף מהיר על יתר הפתרון. כלומר, ההוכחה ניתנת לבדיקה <strong>מבלי שנקרא את כולה</strong>.</p>
<p>זה גם בדיוק הרעיון שמנחה את ה-PCP: להגביל את כמות המידע שניתן לקרוא מתוך ההוכחה עצמה. זה גם מעלה את השאלה, שעד כה די הסתרתי, מה צריך להיות <strong>אורכה</strong> של ההוכחה. עד כה לא דרשתי שום דרישה על אורך ההוכחה, אבל כן דרשתי שהמוודא ירוץ בזמן פולינומי באורך <span class="math">\(w\)</span>; מכיוון שעד כה המוודא היה דטרמיניסטי, נבע מכך שגם מההוכחה עצמה הוא יוכל לקרוא מספר תווים שהוא לכל היותר פולינומי ב-<span class="math">\(w\)</span>, ולכן לא היה טעם לדבר על הוכחות ארוכות יותר; דה-פקטו, ההוכחת היו מאורך פולינומי ב-<span class="math">\(w\)</span>. לרוב בדיונים על <span class="math">\(\text{NP}\)</span> הדרישה הזו מבוצעת במפורש.</p>
<p>אלא שכעת איננו חייבים לקרוא את כל ההוכחה - אנחנו יכולים לדגום תווים ממנה באקראי. למשל, להגריל את תו 13, תו 57 ותו 42,423 ולהחליט שרק אותם נקרא. גם כאן יש עניינים טכניים כלשהם של "איך קוראים את התו במקום ה-1,000,000,000 במהירות?" שלא אכנס אליהם (מה שעושים בפועל הוא להניח שההוכחה נתונה כ"קופסה שחורה" - בהינתן קלט של מקום בהוכחה, הקופסה מחזירה את התו שנמצא באותו מקום). מכאן שאנו מאפשרים להוכחות להיות ארוכות מאוד, אבל מרשים קריאה רק של חלק מצומצם מהן.</p>
<p>הדבר הנוסף שאותו ניתן להגביל הוא כמות האקראיות שבה מותר למוודא להשתמש (מספר ה"מטבעות" שיהיה מותר לו להטיל). שימו לב לקשר עדין ולא ברור מיידית בין נתון זה ובין גודל ההוכחה - אם לא ניתן להגריל יותר מדי ביטים, גם לא ניתן להגריל אינדקסים יותר מדי גדולים של מקומות בהוכחה; לכן מגבלה על מספר הביטים האקראיים שזמינים לנו כופה מגבלה דה-פקטו על הגודל האפקטיבי של ההוכחה.</p>
<p>וכעת מגיע הפאנץ'. נסמן ב-<span class="math">\(\text{PCP}\left(r\left(n\right),q\left(n\right)\right)\)</span> את אוסף הבעיות שקיימת עבורן מערכת הוכחה מהסוג שתיארתי, שבה על קלט מאורך <span class="math">\(n\)</span> ניתן להשתמש לכל היותר ב-<span class="math">\(O\left(r\left(n\right)\right)\)</span> ביטים של אקראיות ולקרוא לכל היותר <span class="math">\(O\left(q\left(n\right)\right)\)</span> ביטים מההוכחה. כך למשל <span class="math">\(\text{NP}=\text{PCP}\left(0,\text{poly}\left(n\right)\right)\)</span> מתקיים בבירור (<span class="math">\(\text{poly}\)</span> פירושו שאנו מרשים ל-<span class="math">\(q\left(n\right)\)</span> להיות פולינום מכל חזקה שהיא; בפועל פירוש הדבר הוא גישה חופשית להוכחה כולה כל עוד עומדים במגבלות הזמן). התוצאה המפתיעה של משפט ה-<span class="math">\(\text{PCP}\)</span> היא שמתקיים גם <span class="math">\(\text{NP}=\text{PCP}(\log(n),1)\)</span>.</p>
<p>במילים - אם מרשים שימוש ב-<span class="math">\(O\left(\log n\right)\)</span> ביטים של אקראיות (וזה לא הרבה בכלל), אפשר להסתפק בקריאה של מספר <strong>קבוע</strong> של ביטים מההוכחה. קבוע, כלומר לא תלוי בכלל באורך <span class="math">\(w\)</span>. פירוש הדבר הוא, לדוגמה, שבבעיית המעגל ההמילטוני מספיק תמיד לקרוא 13 ביטים (שנבחרים באקראי) מההוכחה ואז לבצע כמה חישובים, ואין זה משנה כלל אם הגרף הנבדק הוא בעל 10 צמתים או בעל <span class="math">\(10^{100}\)</span> צמתים. לטעמי האישי זוהי תוצאה מדהימה.</p>
<p>כמובן, יש דברים שמסתתרים כאן מאחורי הקלעים; בפרט, יש מספר גרסאות שונות למשפט (כולן אומרות כי <span class="math">\(\text{NP}=\text{PCP}\left(\log\left(n\right),1\right)\)</span> אך נבדלות בקבועים ובפרמטרים נוספים שמאחורי הקלעים - למשל, דרישות השלמות והנאותות נפגעות בצורות שונות ומשונות). בגרסה שאני מתמקד בה, גודלה של ההוכחה יהיה עצום (אך כאמור, לא נצטרך לקרוא את כולה). בפוסטים הבאים אתאר (בעיקר בנפנופי ידיים, כי מדובר בנושא טכני למדי) את ההוכחה של גרסה מוחלשת של המשפט בכדי לתת תחושה של "מה הולך כאן בכלל", ולהציג את הנושא היפהפה בזכות עצמו שעליו ההוכחה מסתמכת - קודים לתיקון שגיאות. לעת עתה, אני מקווה שהתוצאה מצליחה להיות מעניינת בזכות עצמה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>