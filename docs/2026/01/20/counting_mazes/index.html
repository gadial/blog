<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מונה מבוכים - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2026/01/20/counting_mazes/">
    <meta property="og:title" content="מונה מבוכים">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2026/01/20/counting_mazes/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="מונה מבוכים">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- Post-specific social media image -->
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2025/11/28/cayleys_formula/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">נוסחת קיילי לספירת עצים</span>
            </a>
            

            
            <a href="/2026/01/24/are_most_primes_small/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">האם רוב הראשוניים הם קטנים?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מונה מבוכים</h1>
            <div class="post-meta">
                <span class="date">2026-01-20</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/משחקים וחידות מתמטיות.html">משחקים וחידות מתמטיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/חידה מתמטית.html">חידה מתמטית</a>
                    
                    <a href="/tags/גרף.html">גרף</a>
                    
                    <a href="/tags/משפט המטריצה-עץ של קירקהוף.html">משפט המטריצה-עץ של קירקהוף</a>
                    
                    <a href="/tags/לפלסיאן של גרפים.html">לפלסיאן של גרפים</a>
                    
                    <a href="/tags/ערכים עצמיים.html">ערכים עצמיים</a>
                    
                    <a href="/tags/פולינומי צ&#39;בישב.html">פולינומי צ&#39;בישב</a>
                    
                    <a href="/tags/סכום קרונקר.html">סכום קרונקר</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <h2>מה אנחנו מנסים לעשות פה בכלל</h2>
<p>בפוסט הזה אני רוצה לדבר על משהו שהוא בין חידה לבין תוצאה מתמטית ישירה יחסית, אבל כזו שהיא ממש נחמדה בזכות שילוב של שני דברים: ראשית, זו בעיה מספרית קונקרטית עם פתרון קונקרטי, וכזה שזועק בכל הכוח "אין לכם שום סיכוי למצוא אותי בלי להיות חכמים!" ושנית, זו חידה שנותנת הזדמנות לראות כמה וכמה פיסות יפות של מתמטיקה שמשתלבות נהדר ביחד כדי לפתור אותה. והחידה היא זו: כמה מבוכים מגודל <span class="math">\(423\times855\)</span> יש?</p>
<p>כמובן, נצטרך להסביר את זה קצת.</p>
<p>ראשית, מבוכים יש משלל סוגים ומינים. אני מדבר על סוג מאוד קונקרטי - מבוכים שנראים ככה:</p>
<p><img src="/img/2026/maze.png" alt=""/></p>
<p>במבוכים כאלו, ה"עולם" שלנו הוא לוח דו ממדי של <span class="math">\(n\times m\)</span> תאים ריבועיים. לכל תא יש ארבעה שכנים (למעלה/למטה/ימינה/שמאלה) למעט אלו שבקצוות, ובין כל שני שכנים או שיש קיר, או שאין קיר. בשביל שמשהו יהיה "מבוך" צריך שיהיה בדיוק מסלול <strong>יחיד</strong> בין כל שני תאים - כך שמצד אחד אפשר להגיע מכל מקום לכל מקום, ומצד שני אין לנו שתי דרכים שונות להגיע לאותו מקום. אפשר לחשוב על זה ככה - מבוך כזה ממקסם את מספר הקירות שיש בו תוך שמירה על התכונה שאפשר להגיע בו לכל מקום.</p>
<p>הנה דוגמא לכל 15 המבוכים הקיימים מגודל <span class="math">\(3\times2\)</span> :</p>
<p><img src="/img/2026/small_mazes.png" alt=""/></p>
<p>אם כן, עבור גודל <span class="math">\(n\times m\)</span> עבור <span class="math">\(n,m\)</span> שרירותיים, איך סופרים כמה מבוכים יש? נתחיל מהשיטה הכי נאיבית; הרבה פעמים הגישה הנאיבית עובדת מספיק טוב בפועל ולא צריך לחשוב יותר מדי. לא הפעם. בגישה הנאיבית כאן, אפשר לבנות רשימה של כל הקירות הפוטנציאליים, ולכל תת-קבוצה של קירות לבדוק אם קיבלנו מבוך או לא, ואם כן להוסיף אותו לספירה. כמה קירות פוטנציאליים יש? אם נסתכל על השורה העליונה של המבוך, היא כוללת <span class="math">\(m\)</span> תאים שמופרדים ב-<span class="math">\(m-1\)</span> קירות אנכיים, אז יש <span class="math">\(n\left(m-1\right)\)</span> קירות אנכיים בכל המבוך ובאופן דומה יש גם <span class="math">\(m\left(n-1\right)\)</span> קירות אופקיים, כלומר בסך הכל יש <span class="math">\(2mn-\left(n+m\right)\)</span> קירות. אם אנחנו רק רוצים לקבל אינטואיציה אפשר להניח ש-<span class="math">\(n,m\)</span> הם בערך מאותו סדר גודל ולהשתמש בסימן <span class="math">\(O\)</span> שבמדעי המחשב אוהבים להשתמש בו כדי להגיד "בערך"(בערך... למעשה <span class="math">\(\Theta\)</span> הוא סימון יותר מדויק כאן אבל למי אכפת) ולהגיד שיש לנו סדר גודל של <span class="math">\(O\left(n^{2}\right)\)</span> קירות. עכשיו, אם <span class="math">\(A\)</span> היא קבוצה אז יש לה <span class="math">\(2^{\left|A\right|}\)</span> תת-קבוצות אז יש לנו <span class="math">\(O\left(2^{n^{2}}\right)\)</span> מבוכים פוטנציאליים, ועבור כל אחד כזה צריך <strong>לבדוק</strong> אלגוריתמית שבאמת קיבלנו מבוך... זה לא יילך, יש מספר אקספוננציאלי של מבוכים פוטנציאליים ובדיקה שמשהו היא מבוך תשתמש באלגוריתם חיפוש כמו DFS שלוקח <span class="math">\(O\left(n^{2}\right)\)</span> זמן (לפחות כמספר התאים, הרי הוא צריך לבקר בכולם). בקיצור, לא לא לא. הפתרון הנאיבי לא קשור למציאות פה.</p>
<p>אבל יש מושג שהכנסה שלו לתמונה מייד מפשטת את כל הסיפור - <strong>עץ</strong>. <a href="https://gadial.net/2013/09/30/graphs_spanning_trees_and_code/">הצגתי את המושג הזה בעבר בבלוג</a> ספציפית מתוך הדוגמא של בניית מבוכים, אז אפשר להבין שאני אוהב את הנושא הזה - אבל שימוש בעצים לתאר מבוכים הוא רק קצה-קצהו של תחום עצום של כל הדברים שעצים משמשים להם. הנה התקציר: עץ הוא מקרה פרטי מעניין של מה שנקרא <strong>גרף</strong>, כשגרף הוא משהו שכולל אוסף של "צמתים" כך שכל שני צמתים יכולים להיות מחוברים בקשת, או לא מחוברים בקשת. אצלנו אפשר לחשוב על מבוך בתור גרף שבו התאים הם הצמתים, ויש קשת בין שני תאים סמוכים <strong>שלא</strong> מופרדים בקיר.</p>
<p>המושג של "אפשר להגיע מכל תא לכל תא" מתורגם לתורת הגרפים בתור האמירה ש"הגרף קשיר" , והקטע הזה שאין שתי דרכים שונות להגיע מנקודה א' לנקודה ב' מתואר בתור "הגרף חסר מעגלים" . ההגדרה הפורמלית של <strong>עץ</strong> היא בתור "גרף קשיר וחסר מעגלים" . אלו שתי תכונות שהן מנוגדות זו לזו במובן מסוים - ככל שמוסיפים קשתות כך אנחנו מגדילים את הסיכוי שהגרף יהיה קשיר אבל מקטינים את הסיכוי שהגרף יהיה חסר מעגלים, וההפך. לכן הנקודה שבה שתי התכונות הללו מתקיימות בו זמנית היא קסומה למדי (יש סיטואציה דומה מאוד באלגברה לינארית שבה קבוצת וקטורים יכולה להיות <strong>בלתי תלויה לינארית</strong> ויכולה להיות <strong>פורשת</strong> וכששתי התכונות הללו מתקיימות בו זמנית אנחנו מקבלים את המושג הקסום של <strong>בסיס</strong>; הדמיון הזה לא מקרי ושתי הסיטואציות הללו מוכללות על ידי מושג שנקרא מטרואיד, אבל נעזוב את זה).</p>
<p>אחד הדברים הנחמדים שאפשר להוכיח על עץ הוא שאם העץ כולל <span class="math">\(n\)</span> צמתים, אז הוא כולל בדיוק <span class="math">\(n-1\)</span> קשתות - כל קשת שנוסיף תיצור מעגל, וכל הסרת קשת תקלקל את הקשירות. מה שזה אומר לנו הוא שמלכתחילה אין טעם לבדוק את <strong>כל</strong> תתי-הקבוצות של הקירות האפשריים; במבוך שלנו יש <span class="math">\(nm\)</span> <br />
תאים אז אנחנו צריכים להסתכל רק על תת-קבוצות מגודל <span class="math">\(nm-1\)</span> של קבוצת כל הקירות האפשריים ולהסיר רק את הקירות הללו. העניין הוא שמספר תתי-הקבוצות הללו הוא... עדיין אקספוננציאלי. התיאוריה הבסיסית של עצים חוסכת לנו חלק מהעבודה, אבל לא חלק גדול במיוחד. צריך להוסיף משהו חזק יותר.</p>
<p>המשהו החזק יותר נקרא "משפט המטריצה-עץ של קירקהוף" והוא לטעמי תוצאה יפהפיה ממש. <a href="https://gadial.net/2011/09/13/kirkhoffs_matrix_tree_theorem/">יש לי כבר פוסט עליו</a> שבו אני גם מוכיח אותו, אז פה מן הסתם אוותר על ההוכחה (הלא פשוטה אבל היפה מאוד בזכות עצמה). הרעיון פה הוא שאיכשהו אפשר להמיר את הבעיה של ספירת עצים לבעיה מתחום האלגברה הלינארית, של חישוב <strong>דטרמיננטה</strong> של מטריצה מסוימת שנבנית מתוך הגרף שלנו. חישוב דטרמיננטה הוא דבר קל יחסית מבחינה חישובית; והפוסט הזה יעסוק בעיקר באיך עבור הסיטואציה הספציפית שלנו של דטרמיננטה של מטריצה שהגיעה מגרף שהוא עץ שנבנה בצורה שמתאימה למבוך החישוב הזה אפילו עוד יותר קל מאשר בדרך כלל.</p>
<p>אז איך המשפט הולך? ראשית, מה שהמשפט עושה הוא לספור <strong>עצים פורשים</strong> של גרף נתון. הרעיון בעץ פורש הוא לקחת גרף שהוא כבר קשיר, ולהסיר ממנו קשתות עד שהוא הופך גם לחסר מעגלים (כלומר הוא עץ, והוא "פורש את הגרף" במובן זה שהוא על אותה קבוצת צמתים כמו הגרף המקורי ומשתמש בקשתות מתוך הגרף המקורי). אפשר להראות שלא משנה איך מסירים קשתות, כל עוד השיטה היא "תמצאו קשת שהסרה שלה לא פוגעת בקשירות של הגרף ותעיפו אותה עד שאין יותר כאלו" היא תמיד תחזיר עץ, אבל לפעמים יש עצים פורשים שהם יותר מעניינים; למשל, אם יש על הקשתות <strong>משקלים</strong> ואנחנו רוצים למצוא עץ פורש שהמשקל הכולל של הקשתות שלו הוא מינימלי, זו הזדמנות לשלוף את האלגוריתמים של קרוסקל ופרים שאוהבים להראות בקורס מבוא לאלגוריתמים ומוצאים עץ מינימלי שכזה בצורה לא רעה בכלל.</p>
<p>במקרה שלנו אנחנו לא רוצים <strong>למצוא</strong> עץ פורש אלא <strong>לספור</strong> כאלו, והגרף שאנחנו רוצים למצוא עצים פורשים שלו הוא הגרף שמתאר את המבוך כשאין בו בכלל קירות - כלומר, כשיש בו את כל הקשתות האפשריות. זה <strong>לא</strong> אומר שכל שני צמתים בגרף יהיו מחוברים בקשת - תזכרו, מלכתחילה קשת יכולה להיות רק בין תא במבוך ובין ארבעת השכנים שלו (או פחות שכנים, אם הוא בקצה כלשהו של המבוך וחלק מהשכנים חסרים). זה אומר שמלכתחילה, הגרף הוא "דליל" יחסית - רוב זוגות הצמתים לא הולכים להיות מחוברים בקשת, ולמעשה הדרגה של כל צומת (מספר הקשתות שמחוברות אליו) מראש מוגבלת על ידי מספר נמוך יחסית (4) שבכלל לא תלוי בגודל הגרף. ועוד יותר מכך - לגרף יש <strong>מבנה נחמד</strong> שמגיע מכך שהוא מתקבל ממבוך שנראה נחמד, עם יחסי שכנות די מסודרים. בשלב הראשון לא נשתמש בזה, אבל בהמשך בהחלט כן.</p>
<p>אני אניח שאנחנו יודעים מה זו מטריצה. אם לא, <a href="https://gadial.net/2011/10/05/matrix_row_reducing/">יש לי פוסטים</a> בנושא ואפשר פשוט לחשוב עליה בתור טבלה של מספרים, אבל לא אכנס כאן להגדרות הפורמליות שלה.</p>
<p>בשביל משפט המטריצה-עץ אנחנו מגדירים מטריצה שנקראת <strong>לפלסיאן</strong> של גרף. אם <span class="math">\(G=\left(V,E\right)\)</span> הוא הגרף שלנו, עם קבוצת צמתים <span class="math">\(V=\left\{ v_{1},\ldots,v_{n}\right\}\)</span> וקבוצת קשתות <span class="math">\(E\)</span> , אז מטריצה די טבעית שנהוג להגדיר עבור <span class="math">\(G\)</span> היא <strong>מטריצת השכנויות</strong> של <span class="math">\(G\)</span> : מטריצה <span class="math">\(A_{G}\)</span> כך ש-<span class="math">\(\left[A_{G}\right]_{ij}=\begin{cases}
1 & \left(v_{i},v_{j}\right)\in E\\
0 & \left(v_{i},v_{j}\right)\notin E
\end{cases}\)</span> . כלומר, אם יש קשת בין <span class="math">\(v_{i},v_{j}\)</span> אז כתוב בה 1 ואחרת כתוב בה 0. את זה אפשר להכליל די בקלות - אם בגרף שלנו מרשים שיותר מקשת אחת תחבר כל זוג צמתים (מה שמגדיל את מספר העצים הפורשים, כי אפשר פעם לבחור אחת מהקשתות הללו ופעם קשת אחרת) אז במקום לכתוב 1 פשוט נכתוב את מספר הקשתות שיש בין <span class="math">\(v_{i},v_{j}\)</span> . עוד פישוט שאני אעשה יהיה להניח ש-<span class="math">\(A_{ii}=0\)</span> תמיד, כלומר שאין קשת שמחברת צומת לעצמו ("חוג עצמי") - בהחלט <strong>יכולות</strong> להיות קשתות כאלו בגרף כללי, אבל בהקשר של ספירת עצים פורשים הן לא רלוונטיות כי כל קשת כזו יוצרת מעגל ולכן הן לא יהיו באף עץ פורש, ולכן אם רוצים שנמצא את מספר העצים הפורשים בגרף נתון, הוא יהיה שווה למספר העצים הפורשים באותו הגרף אחרי שהוסרו ממנו החוגים העצמיים, ולכן אפשר לבצע את ההנחה הזו "בלי הגבלת הכלליות" , כפי שנהוג לומר.</p>
<p>מטריצת השכנויות הזו היא <strong>לא</strong> הלפליסאן, בשביל זה נצטרך להגדיר עוד מטריצה שגם היא <strong>לא</strong> הלפלסיאן: מטריצת הדרגות <span class="math">\(\Delta_{G}\)</span> שהיא מטריצה אלכסונית כך ש-<span class="math">\(\Delta_{ii}=d\left(v_{i}\right)\)</span> , כלומר היא מספר הקשתות שמחוברות אל <span class="math">\(v_{i}\)</span> . עכשיו אפשר לשלב את שתיהן כדי לקבל את מה שהוא <strong>כן</strong> הלפלסיאן:</p>
<p><span class="math">\(L_{G}=\Delta_{G}-A_{G}\)</span> , כלומר זו המטריצה שבאלכסון שלה כתובות דרגות הצמתים, ובכל כניסה אחרת כתוב <strong>מינוס</strong> מספר הקשתות שמחברות שני צמתים נתונים.</p>
<p>אם ננסה לחשב את הדטרמיננטה (<a href="https://gadial.net/2011/11/10/determinants/">הנה הפוסט שלי</a> על מה זו דטרמיננטה) של המטריצה הזו נגלה להפתעתנו הרבה שמקבלים 0... לא הבטחתי שנקבל את מספר העצים הפורשים? ובכן, לא, אבל הנה מה שעושים - בוחרים צומת שרירותי <span class="math">\(v_{i}\)</span> , מסלקים מהמטריצה את השורה והעמודה ה-<span class="math">\(i\)</span> (זה אומר שלוקחים <strong>מינור</strong> של המטריצה) ואז מחשבים את הדטרמיננטה - בסיטואציה הזו נקבל תמיד את אותה תוצאה בלי תלות באיזה צומת הסרנו, והתוצאה הזו תהיה מספר העצים הפורשים של הגרף (במקרה שבו הגרף <strong>מכוון</strong>, שלא עליו אני מדבר, יש יותר משמעות לשאלה איזה <span class="math">\(v_{i}\)</span> בוחרים - הספירה תהיה רק של העצים הפורשים ש-<span class="math">\(v_{i}\)</span> <br />
הוא <strong>השורש</strong> שלהם).</p>
<p>בואו נראה דוגמא לקסם הזה בפעולה, עבור המבוכים שלנו. כדי לשמור את העניינים עדיין סבירים בקושי, נסתכל על מבוך של <span class="math">\(2\times3\)</span> . כבר ראינו קודם שקיימים 15 מבוכים כאלו על ידי זה שציירנו אותם במפורש. הנה מטריצת הלפלסיאן במקרה הזה:</p>
<p><span class="math">\(L_{G}=\left(\begin{array}{cccccc}
2 & -1 & 0 & -1 & 0 & 0\\
-1 & 3 & -1 & 0 & -1 & 0\\
0 & -1 & 2 & 0 & 0 & -1\\
-1 & 0 & 0 & 2 & -1 & 0\\
0 & -1 & 0 & -1 & 3 & -1\\
0 & 0 & -1 & 0 & -1 & 2
\end{array}\right)\)</span> <br />
בגלל שלוח של <span class="math">\(2\times3\)</span> הוא ממש צפוף וכל תא נמצא בקצה כלשהו של המבוך, אנחנו לא רואים כל כך טוב פה את זה שעל האלכסון צפויים להיות בעיקר 4-ים ושבכל שורה ועמודה יהיו מעט יחסית <span class="math">\(-1\)</span> -ים ובעיקר יהיו אפסים, אבל לא נורא. לחשב את הדטרמיננטה של המטריצה הזו זה טיפה כאב ראש אבל אפשר לעשות את זה עם דירוג מטריצות יחסית מהר (מודולו עשר שגיאות החישוב שיהיו לי בדרך) ומקבלים, כמה מפתיע, 15! אז המשפט עובד. כאמור, לא אוכיח את המשפט כי יש לי פוסט ייעודי עבור ההוכחה, אבל זה ממש ממש מגניב שזה עובד.</p>
<p>האם סיימנו? לא. כי לא שאלתי על <span class="math">\(2\times3\)</span> . שאלתי על <span class="math">\(423\times855\)</span> . במקרה הזה אני אצטרך מטריצה מסדר <span class="math">\(t\times t\)</span> כאשר <span class="math">\(t=423\cdot855=361,665\)</span> . זו כבר מטריצה די גדולה, ולחשב את הדטרמיננטה <strong>שלה</strong> יהיה כאב ראש אמיתי, שלא לדבר על כך שהדטרמיננטה צפויה להיות מספר עצום ולכן נצטרך לעבוד עם מספרים שמיוצגים בנקודה צפה, ולוודא שאין לנו שגיאות נומריות שמצטברות בחישוב של הדטרמיננטה... את כל אלו <strong>אפשר לעשות</strong> - יש תחום שלם ומפואר שעוסק בחישובים עם מטריצות דלילות ומספרים גדולים - אבל מה שיפה פה הוא שבמקרה הקונקרטי שלנו אפשר לנצל את <strong>המבנה המיוחד</strong> של הגרף שלנו כדי לפשט בצורה משמעותית ביותר את החישוב.</p>
<h2>מה הולך ללכת כאן</h2>
<p>עד עכשיו הבנו את כל המרכיבים העקרוניים של הפתרון, עכשיו אפשר להציג את הפתרון עצמו בלי יותר מדי הוכחות, ואז נגיע להוכחות עצמן (שהן כבדות יחסית ולכן עדיף לחכות איתן). ראשית, אם נסתכל על מטריצת הלפלסיאן <span class="math">\(L_{G}\)</span> ונסמן את הערכים העצמיים שלה ב-<span class="math">\(\lambda_{0},\lambda_{1},\ldots,\lambda_{t-1}\)</span> (זו מטריצה מסדר <span class="math">\(t\times t\)</span> ולכן יש לה <span class="math">\(t\)</span> ערכים עצמיים) כך ש-<span class="math">\(\lambda_{0}=0\)</span> הוא הערך העצמי 0 (אנחנו נראה ש-0 הוא תמיד ערך עצמי של <span class="math">\(L_{G}\)</span> ) אז הדטרמיננטה <strong>של המינור</strong> שלה היא <span class="math">\(\frac{1}{t}\lambda_{1}\lambda_{2}\cdots\lambda_{t-1}\)</span> . כלומר - אין צורך לחשב דטרמיננטה בכלל, מספיק למצוא את הערכים העצמיים.</p>
<p>שנית, הגרף <span class="math">\(G\)</span> הוא לא סתם גרף אקראי, יש לו כאמור מבנה יפה - אפשר להציג אותו בתור <strong>מכפלה</strong> של שני גרפים פשוטים בהרבה. יש כמה סוגים של מכפלות של גרפים, והסוג שמתאים כאן נקרא <strong>מכפלת קופסה</strong>, <span class="math">\(G=G_{1}\square G_{2}\)</span> , ונראה עוד מעט את הההגדרה שלו. זה מפשט את העניינים עבורנו כי אפשר להראות שאם הערכים העצמיים של <span class="math">\(L_{G_{1}}\)</span> הם <span class="math">\(\tau_{0},\tau_{1},\ldots,\tau_{n-1}\)</span> <br />
והערכים העצמיים של <span class="math">\(L_{G_{2}}\)</span> הם <span class="math">\(\rho_{0},\rho_{1},\ldots\rho_{m-1}\)</span> <br />
אז הערכים העצמיים של <span class="math">\(L_{G_{1}\square G_{2}}\)</span> הם מהצורה <span class="math">\(\lambda_{kh}=\tau_{k}+\rho_{h}\)</span> <br />
עבור <span class="math">\(0\le k\lt n\)</span> ו-<span class="math">\(0\le h\lt m\)</span> . זה, והנוסחה של <span class="math">\(\frac{1}{t}\lambda_{1}\lambda_{2}\cdots\lambda_{t-1}\)</span> <br />
שראינו קודם, יאפשרו לנו להגיע למסקנה שמספיק לחשב את המכפלה</p>
<p><span class="math">\(\prod_{k=1}^{m-1}\prod_{h=1}^{n-1}\left(\tau_{k}+\rho_{h}\right)\)</span> (שימו לב שה-<span class="math">\(\frac{1}{t}\)</span> נעלם והאינדקסים מתחילים מ-1 ולא מ-0; זה כמובן לא מקרי אלא הם יבטלו זה את זה איכשהו)</p>
<p>הגרפים <span class="math">\(G_{1},G_{2}\)</span> שבהם נשתמש יהיו <strong>שרוכים</strong>, כלומר גרפים שהם בסך הכל מסלול ישר, אחד עם <span class="math">\(n\)</span> צמתים ואחד עם <span class="math">\(m\)</span> צמתים, שיסומנו <span class="math">\(P_{n},P_{m}\)</span> . אלו גרפים כל כך פשוטים שאפשר לחשב בקלות יחסית את הערכים העצמיים שלהם, ואנחנו נשתמש במשהו שנקרא <strong>פולינומי צ'בישב</strong> כדי לקבל שהערך העצמי ה-<span class="math">\(k\)</span> -י של <span class="math">\(P_{n}\)</span> הוא <span class="math">\(4\cos^{2}\left(\frac{k\pi}{2n}\right)\)</span> . מכאן נקבל את הנוסחה הסופית, שסופרת את מספר המבוכים מסדר <span class="math">\(n\times m\)</span> :</p>
<p><span class="math">\(T\left(n,m\right)=\prod_{k=1}^{n-1}\prod_{h=1}^{m-1}\left(4\cos^{2}\left(\frac{k\pi}{2n}\right)+4\cos^{2}\left(\frac{h\pi}{2m}\right)\right)\)</span> <br />
הנוסחה הזו אולי נראית קצת מפחידה, אבל היא פשוטה מאוד לחישוב בעזרת מחשב, גם עבור <span class="math">\(n=423,m=855\)</span> . החלק הטריקי היחיד הוא שאנחנו נגררים להכפלה של מספרי ענק, וזה קשה למחשבים, אבל יש תעלול סטנדרטי שפותר את זה - לוקחים לוגריתם של הכל, והוא הופך את המכפלה לסכום, ואז לסיום לוקחים את התוצאה שמקבלים ומוציאים את האקספוננט שלה. גם את זה אני הולך להראות במפורש.</p>
<p>יפה, אז עכשיו אנחנו מבינים מה הולך לקרות, אבל עדיין נשארו ההוכחות המסודרות שיעזרו לנו להבין למה בעצם כל הקסם הזה <strong>עובד</strong>.</p>
<h2>הדטרמיננטה של לפלסיאן</h2>
<p>נתחיל עם מה שקל להראות - למטריצת הלפלסיאן יש ערך עצמי 0. בשביל לראות את זה בקלות בואו נחזור ללפלסיאן הדוגמא שלנו:</p>
<p><span class="math">\(L_{G}=\left(\begin{array}{cccccc}
2 & -1 & 0 & -1 & 0 & 0\\
-1 & 3 & -1 & 0 & -1 & 0\\
0 & -1 & 2 & 0 & 0 & -1\\
-1 & 0 & 0 & 2 & -1 & 0\\
0 & -1 & 0 & -1 & 3 & -1\\
0 & 0 & -1 & 0 & -1 & 2
\end{array}\right)\)</span> <br />
אם נסתכל על כל שורה, נראה שהיא מסתכמת ל-0. זה לא מקרי; על האלכסון בכניסה <span class="math">\(ii\)</span> יש לנו את הדרגה של הצומת <span class="math">\(v_{i}\)</span> , כלומר מספר הקשתות שמחוברות אליו. יתר השורה ה-<span class="math">\(i\)</span> -ית כוללת, לכל צומת <span class="math">\(v_{j}\ne v_{i}\)</span> , את המינוס של מספר הקשתות בין <span class="math">\(v_{i}\)</span> <br />
ו-<span class="math">\(v_{j}\)</span> . עכשיו, כל קשת שמחוברת אל <span class="math">\(v_{i}\)</span> מחוברת לצומת <strong>כלשהו</strong> וזה לא יכול להיות <span class="math">\(v_{i}\)</span> עצמו כי הנחנו שבגרף שלנו אין חוגים עצמיים, ולכן סך כל השורה חוץ מהאיבר על האלכסון הוא מינוס מספר הקשתות שמחוברות של <span class="math">\(v_{i}\)</span> , כלומר מינוס הדרגה שלו, ולכן בתוספת האיבר על האלכסון נקבל 0.</p>
<p>עכשיו, טריק ידוע מאלגברה לינארית הוא שאם <strong>כל</strong> השורות של מטריצה מסתכמות לאותו מספר <span class="math">\(\lambda\)</span> בדיוק, אז <span class="math">\(\lambda\)</span> היא ערך עצמי של המטריצה עם הוקטור העצמי</p>
<p><span class="math">\(\left(\begin{array}{c}
1\\
1\\
\vdots\\
1
\end{array}\right)\)</span> <br />
את זה אפשר לבדוק בצורה ישירה: כופלים את המטריצה בוקטור הזה, ונקבל אותו עצמו כפול <span class="math">\(\lambda\)</span> . במקרה שלנו, זה אומר ש-<span class="math">\(\lambda=0\)</span> הוא ערך עצמי של המטריצה, כמו שהבטחתי.</p>
<p>עכשיו, אם יש לנו מטריצה ריבועית <span class="math">\(A\)</span> <strong>כלשהי</strong> מעל שדה סגור אלגברית כמו <span class="math">\(\mathbb{C}\)</span> (וזה המקרה שלנו) אז יש לה <strong>צורת ז'ורדן</strong>, כלומר קיימת מטריצה משולשית עליונה <span class="math">\(J\)</span> ומטריצה הפיכה <span class="math">\(P\)</span> כך ש-<span class="math">\(A=P^{-1}JP\)</span> . יש הרבה מה לומר על המבנה של <span class="math">\(J\)</span> <a href="https://gadial.net/2016/10/27/rational_and_jordan_form/">ואני מדבר על זה כאן</a>, אבל מה שאנחנו צריכים פה הוא רק את זה שהאלכסון של <span class="math">\(J\)</span> כולל את כל הערכים העצמיים של <span class="math">\(A\)</span> , ושהדטרמיננטה של מטריצה משולשית עליונה היא מכפלת אברי האלכסון. בנוסף, <strong>הכפליות של הדטרמיננטה</strong> נותנת לנו</p>
<p><span class="math">\(\left|A\right|=\left|P^{-1}\right|\left|J\right|\left|P\right|=\left|J\right|\left|P\right|^{-1}\left|P\right|=\left|J\right|\)</span> (כאן השתמשנו בקסם היפהפה שבו דטרמיננטה היא סך הכל מספר מרוכב, ומספרים מרוכבים מתחלפים בכפל, להבדיל ממטריצות).</p>
<p>כלומר, המסקנה היא שלכל מטריצה ריבועית <span class="math">\(A\)</span> מסדר <span class="math">\(n\times n\)</span> (לא רק מטריצת לפלסיאן) מעל שדה סגור אלגברית, הדטרמיננטה שלה היא מכפלת כל הערכים העצמיים שלה. בפרט עבור מטריצת הלפלסיאן ראינו ש-0 הוא ערך עצמי ולכן הדטרמיננטה שלה היא 0. אז האינפורמציה המעניינת צצה רק כשמוחקים שורה ועמודה ולוקחים את הדטרמיננטה של התוצאה, ואני טוען שאם זו השורה והעמודה ה-<span class="math">\(i\)</span> -יות, אז הדטרמיננטה תצא <span class="math">\(\frac{1}{n}\lambda_{1}\cdots\lambda_{n-1}\)</span> . אבל למה? זה לא נכון באופן כללי; אם למשל אני לוקח מטריצה אלכסונית עם <span class="math">\(\lambda_{0},\ldots,\lambda_{n-1}\)</span> על האלכסון ומוריד את השורה והעמודה הראשונים, אז אני אקבל מטריצה אלכסונית עם <span class="math">\(\lambda_{1},\ldots,\lambda_{n-1}\)</span> על האלכסון ולכן דטרמיננטה <span class="math">\(\lambda_{1}\cdots\lambda_{n-1}\)</span> . עבור מטריצות אחרות אני אקבל דטרמיננטות שונות. אז מה במבנה של הלפלסיאן מוסיף את הפקטור <span class="math">\(\frac{1}{n}\)</span> הזה?</p>
<p>ובכן, יש כמה דרכים להוכיח את זה. דרך מתבקשת אחת היא להגיד - שמעו, הלפליסאן הזה הוא מטריצה <strong>סימטרית</strong> ולכן קיים לו <strong>לכסון אוניטרי</strong> ולהשתמש בכל מני להטוטים <a href="https://gadial.net/2025/09/06/unitary_diagonalization/">שדיברתי עליהם ממש לא מזמן</a>. בהחלט אפשר לעשות את זה וזה כנראה גם יעבוד, אבל אני הולך לגשת לזה מכיוון שונה לגמרי שנראה לי במבט ראשון הזוי למדי, ולכן זה כיפי.</p>
<p>המושג שאני רוצה להכניס לתמונה הוא מה שנקרא <strong>המטריצה המצורפת </strong>(מה שנקרא באנגלית adjugate marix). <a href="https://gadial.net/2011/11/21/matrix_revolutions/">יש לי פוסט</a> שבו אני מזכיר את המושג הזה אבל בואו ניזכר. באופן כללי, אם יש לי מטריצה ריבועית <span class="math">\(A\)</span> , אני יכול לעשות את הפעולה שכבר ראינו: למחוק את השורה ה-<span class="math">\(i\)</span> והעמודה ה-<span class="math">\(j\)</span> , ואז לקחת דטרמיננטה של התוצאה. אני אסמן את זה ב-<span class="math">\(\left|A^{ij}\right|\)</span> . למספר הזה קוראים cofactor של <span class="math">\(A\)</span> , ואם <span class="math">\(A\)</span> היא מסדר <span class="math">\(n\times n\)</span> אז יש לנו אחד כזה לכל <span class="math">\(1\le i,j\le n\)</span> . כשמחשבים דטרמיננטה של <span class="math">\(A\)</span> דרך אחרת לעשות את זה היא לבחור שורה קונקרטית, נאמר <span class="math">\(i\)</span> , ואז לחשב את <span class="math">\(\left|A\right|=\sum_{j=1}^{n}\left(-1\right)^{i+j}\left|A^{ij}\right|\)</span> . כלומר, צריך לקחת את כל ה-cofactor-ים שמתאימים לשורה הזו ולחבר ולחסר אותם לסירוגין, ואיכשהו באופן קסום זה נותן את הדטרמיננטה.</p>
<p>עכשיו, המטריצה המצורפת של <span class="math">\(A\)</span> שמסומנת <span class="math">\(\text{adj}A\)</span> היא מה שמקבלים כשלוקחים את כל ה-<br />
<span class="math">\(\left(-1\right)^{i+j}\left|A^{ij}\right|\)</span><br />
הללו ושמים <strong>את כולם</strong> בתוך מטריצה משל עצמם - אבל שימו לב, מטריצה שבה התפקידים של <span class="math">\(i,j\)</span> הפוכים. פורמלית: <span class="math">\(\left[\text{adj}A\right]_{ji}=\left(-1\right)^{i+j}\left|A^{ij}\right|\)</span> . למה ההיפוך הזה? כי זה מבטיח שתתקיים התכונה המאוד יפה</p>
<p><span class="math">\(A\cdot\text{adj}A=\left|A\right|\cdot I\)</span> שהוכחתי בפוסט שקישרתי אליו. במילים אחרות, <span class="math">\(\frac{\text{adj}A}{\left|A\right|}\)</span> <br />
היא ההופכית של <span class="math">\(A\)</span> במקרה שהיא קיימת (ואם היא לא קיימת אז הכפל ב-<span class="math">\(\text{adj}A\)</span> מחזיר 0). התכונה הזו מראה ש-<span class="math">\(\text{adj}A\)</span> זה לא סתם משהו אקראי שהמצאנו כי שיעמם לנו, ועכשיו נראה איך המושג הזה שימושי לנו כדי לנתח את <span class="math">\(L_{G}\)</span> .</p>
<p>בואו נסמן ב-<span class="math">\(\kappa\)</span> את מספר העצים הפורשים של <span class="math">\(G\)</span> . מה שמשפט קירקהוף מראה הוא ש-<span class="math">\(\left|L_{G}^{ii}\right|=\kappa\)</span> ; את זה אני לא הולך להוכיח שוב, אבל אני רוצה לטעון שמתקיים משהו קצת יותר כללי: שגם אם מוחקים שורה ועמודה שלא מתאימות לאותו אינדקס מקבלים את <span class="math">\(\kappa\)</span> כל עוד כופלים ב"תיקון" הרגיל, כלומר <span class="math">\(\left(-1\right)^{i+j}\left|L_{G}^{ij}\right|=\kappa\)</span> . ואת זה אפשר לנסח בצורה הקומפקטית הבאה: <span class="math">\(\text{adj}L_{G}=\kappa J\)</span> כאשר <span class="math">\(J\)</span> כאן הוא הסימון הסטנדרטי למטריצה הריבועית (מאותו סדר כמו <span class="math">\(L_{G}\)</span> ) שכולה 1-ים (לא לבלבל עם ה-<span class="math">\(J\)</span> של ז'ורדן שהזכרתי קודם ולא נזדקק לה יותר בפוסט הזה). כלומר, <span class="math">\(\kappa J\)</span> היא בסך הכל המטריצה שכל הכניסות שלה שוות <span class="math">\(\kappa\)</span> . אני מקווה שברור למה - כי הכניסה ה-<span class="math">\(ji\)</span> שלה היא <span class="math">\(\left(-1\right)^{i+j}\left|L_{G}^{ij}\right|=\kappa\)</span> . כמובן, צריך להוכיח את זה; וזה כל העניין, שיהיה לי יותר קל להוכיח את זה על ידי עבודה ישירה מול <span class="math">\(\text{adj}L_{G}\)</span> .</p>
<p>ראשית, צריך להפריד לשני מקרים על פי <strong>הדרגה</strong> של <span class="math">\(L_{G}\)</span> (המימד של מרחב השורות/מרחב העמודות של <span class="math">\((L_{G}\)</span> . כזכור, הדרגה <span class="math">\(\text{rank} L_{G}\)</span> של מטריצה בפרט קובעת אם היא הפיכה או לא - אם למטריצה מסדר <span class="math">\(n\times n\)</span> יש דרגה קטנה מ-<span class="math">\(n\)</span> אז היא לא הפיכה, ולכן הדטרמיננטה שלה שווה לאפס. עכשיו, אנחנו כבר יודעים ש-<span class="math">\(L_{G}\)</span> לא הפיכה ולכן הדרגה שלה קטנה מ-<span class="math">\(n\)</span> , אבל אם מתקיים גם <span class="math">\(\text{rank} L_{G}\lt n-1\)</span> <br />
אז גם אחרי שנמחק מ-<span class="math">\(L_{G}\)</span> שורה ועמודה עדיין נקבל מטריצה מדרגה קטנה מ-<span class="math">\(n-1\)</span> כי אם אחרי המחיקה יש לנו קבוצה של <span class="math">\(n-1\)</span> שורות בלתי תלויות, אז גם אחרי שנוסיף להן עוד כניסה עבור העמודה שמחקנו הן עדיין יהיו בלתי תלויות וגם אם נוסיף למטריצה שורה חדשה הן עדיין יהיו בלתי תלויות, ולכן יוצא שכבר במטריצה המקורית הדרגה הייתה <span class="math">\(n-1\)</span> . אז הגענו לכך שאחרי המחיקה תהיה לנו מטריצה מסדר <span class="math">\(n-1\)</span> שהדרגה שלה קטנה מ-<span class="math">\(n-1\)</span> ולכן הדטרמיננטה שלה עדיין תהיה שווה לאפס, וזה עבור <strong>כל</strong> שורה ועמודה שנמחק, כלומר <span class="math">\(\text{adj}L_{G}=0\)</span> . מכיוון שבאופן כללי, <span class="math">\(\left|L_{G}^{11}\right|=\kappa\)</span> אז במקרה שלנו המסקנה היא ש-<span class="math">\(\kappa=0\)</span> ולכן באמת מתקיים <span class="math">\(\text{adj}L_{G}=\kappa J\)</span> ; לכן המקרה המעניין של ההוכחה הוא זה שבו <span class="math">\(\text{rank} L_{G}=n-1\)</span> (זה המקרה שבו <span class="math">\(G\)</span> הוא גרף מעניין שבאמת יש בו עצים פורשים).</p>
<p>בשביל המקרה הזה, לב העניין הוא הנוסחה <span class="math">\(A\cdot\text{adj}A=\left|A\right|\cdot I\)</span> <br />
שהראיתי קודם. במקרה שלנו התחלנו מזה של-<span class="math">\(L_{G}\)</span> יש ערך עצמי 0, ולכן <span class="math">\(\left|L_{G}\right|=0\)</span> , אז קיבלנו</p>
<p><span class="math">\(L_{G}\cdot\text{adj}L_{G}=0\)</span> <br />
זה אומר שכל <strong>עמודה</strong> של <span class="math">\(\text{adj}L_{G}\)</span> שייכת לגרעין של <span class="math">\(L_{G}\)</span> . מה הגרעין הזה? מכיוון ש-<span class="math">\(\text{rank} L_{G}=n-1\)</span> , המימד של הגרעין הוא 1 (זה עוד להטוט אלגברה לינארית סטנדרטית שאני מניח שאנחנו מכירים) ואנחנו <strong>כבר ראינו</strong> איבר ששייך לגרעין של <span class="math">\(L_{G}\)</span> , בהתחלה: הוקטור שכולו 1-ים. המסקנה היא שכל עמודה של <span class="math">\(\text{adj}L_{G}\)</span> היא כפל של הוקטור הזה בסקלר כלשהו ובפרט כל האיברים של העמודה שווים. העניין הוא שבעמודה ה-<span class="math">\(i\)</span> <br />
של <span class="math">\(\text{adj}L_{G}\)</span> יש לנו את <span class="math">\(\left|L_{G}^{ii}\right|\)</span> <br />
שאנחנו <strong>יודעים</strong> בזכות קירקהוף ששווה ל-<span class="math">\(\kappa\)</span> , ולכן כל האיברים בעמודה הזו שווים ל-<span class="math">\(\kappa\)</span> , ולכן כל המטריצה שווה ל-<span class="math">\(\kappa\)</span> וקיבלנו <span class="math">\(\text{adj}L_{G}=\kappa J\)</span> בדיוק כפי שרצינו.</p>
<p>אוקיי, זה היה די מגניב (ולא ידעתי את זה לפני שהתחלתי לכתוב את הפוסט - כלומר, את העניין הזה שלא חייבים להסיר שורה ועמודה שמתאימות לאותו <span class="math">\(i\)</span> אלא אפשר להסיר <span class="math">\(i,j\)</span> כלליות ומקסימום לכפול במינוס 1). אבל איך זה עוזר לי?</p>
<p>ובכן, הנה תוצאה מרהיבה (שלהבנתי מופיעה לראשונה במאמר עם השם הבלתי קשור בעליל, "On the mutual cancellation of cluster integrals in Mayer's fugacity series," של H. Temperley) שמאפשרת לנו לקבל את <span class="math">\(\kappa\)</span> מתוך <span class="math">\(L_{G}\)</span> בלי בכלל כל העניין השרירותי הזה של לבחור <span class="math">\(i\)</span> ולמחוק מ-<span class="math">\(L_{G}\)</span> <br />
את השורה והעמודה ה-<span class="math">\(i\)</span> :</p>
<p><span class="math">\(\kappa=\frac{\left|L_{G}+J\right|}{n^{2}}\)</span> <br />
כלומר, במקום למחוק אפשר <strong>לחבר</strong> 1 לכל כניסה של <span class="math">\(L_{G}\)</span> , לחשב דטרמיננטה, ובסוף לחלק ב-<span class="math">\(n^{2}\)</span> . לא רק שזו תוצאה יפהפייה בזכות עצמה, עוד רגע נראה שהיא גם נותנת לנו את <span class="math">\(\kappa=\frac{1}{n}\lambda_{1}\cdots\lambda_{n-1}\)</span> <br />
בלי כמעט מאמץ. אבל קודם כל בואו נוכיח אותה.</p>
<p>ההוכחה היא מאוד אלגברית - כלומר, כופלים ומחברים דברים והופס, פתאום מקבלים את הנוסחה משום מקום. בשביל זה קודם כל נשים לב לכך ש-<span class="math">\(J^{2}=nJ\)</span> (פשוט על פי ההגדרה הרגילה של כפל מטריצות וזה ש-<span class="math">\(J\)</span> היא מסדר <span class="math">\(n\times n\)</span> ) ו-<span class="math">\(JL_{G}=0\)</span> (כי כפי שכבר ראינו <span class="math">\(L_{G}J=0\)</span> ושתי המטריצות הללו סימטריות) ועכשיו נחשב אלגברית את</p>
<p><span class="math">\(\left(nI-J\right)\left(J+L_{G}\right)=nJ-J^{2}+nL_{G}-JL_{G}=nL_{G}\)</span> <br />
עכשיו, באופן כללי אם יש לנו את המכפלה <span class="math">\(AB\)</span> אז אפשר להראות ש-<span class="math">\(\text{adj}\left(AB\right)=\text{adj}B\cdot\text{adj}A\)</span> . זו תכונה סטנדרטית ולכן לא אוכיח אותה כאן, אבל תראו מה היא נותנת לנו:</p>
<p><span class="math">\(\text{adj}\left(J+L_{G}\right)\text{adj}\left(nI-J\right)=\text{adj}\left(nL_{G}\right)\)</span> <br />
עכשיו, <span class="math">\(nI-J\)</span> זו מטריצה מעניינת. יש לה <span class="math">\(n-1\)</span> על האלכסון הראשי, ו-<span class="math">\(-1\)</span> בכל מקום אחד - זה הלפליסאן של <strong>הגרף המלא</strong> על <span class="math">\(n\)</span> צמתים. מספר העצים הפורשים של הגרף המלא על <span class="math">\(n\)</span> צמתים הוא פשוט מספר העצים על <span class="math">\(n\)</span> צמתים - זו תוצאה סטנדרטית שנקראת <strong>נוסחת קיילי</strong> וכשכתבתי את הפוסט הזה גיליתי למרבה הזוועה שעוד אין לי פוסט עליה - <a href="https://gadial.net/2025/11/28/cayleys_formula/">אז עכשיו כבר יש</a>. ההוכחה של הנוסחה הזו מרהיבה, אבל היא עצמה מאוד פשוטה: יש <span class="math">\(n^{n-2}\)</span> עצים כאלו. לכן <span class="math">\(\text{adj}\left(nI-J\right)=n^{n-2}J\)</span> .</p>
<p>עוד איבר שמופיע בנוסחה הוא <span class="math">\(\text{adj}\left(nL_{G}\right)\)</span> . מה אני יכול להגיד עליו? האם אפשר להוציא את הסקלר <span class="math">\(n\)</span> החוצה מה-adj? ובכן, כן. באופן כללי אפשר להוציא סקלרים החוצה מדטרמיננטות: <span class="math">\(\left|\lambda A\right|=\lambda^{n}\left|A\right|\)</span> , כי מה שקורה פה הוא שהכלל עבור דטרמיננטות הוא שלכפול <strong>שורה</strong> בסקלר <span class="math">\(\lambda\)</span> מכפיל את כל הדטרמיננטה ב-<span class="math">\(\lambda\)</span> . לכן אם הכפלנו את <strong>כל</strong> המטריצה ב-<span class="math">\(\lambda\)</span> , ויש למטריצה <span class="math">\(n\)</span> שורות, האפקט יהיה להכפיל את הדטרמיננטה <span class="math">\(n\)</span> פעמים ב-<span class="math">\(\lambda\)</span> .</p>
<p>כשלוקחים adj של מטריצה <span class="math">\(A\)</span> מסדר <span class="math">\(n\)</span> , כל כניסה היא עצמה דטרמיננטה: <span class="math">\(\left[\text{adj}A\right]_{ji}=\left(-1\right)^{i+j}\left|A^{ij}\right|\)</span> , אבל זו לא הדטרמיננטה של <span class="math">\(A\)</span> אלא של <strong>המינור</strong><span class="math">\(A^{ij}\)</span> שהתקבל מ-<span class="math">\(A\)</span> על ידי מחיקת שורה ועמודה, כלומר זו מטריצה עם <span class="math">\(n-1\)</span> <br />
שורות. לכן <span class="math">\(\left[\text{adj}\lambda A\right]_{ji}=\left(-1\right)^{i+j}\left|\lambda A^{ij}\right|=\lambda^{n-1}\left(-1\right)^{i+j}\left|A^{ij}\right|\)</span> . זה מוביל לכך שבמקרה שלנו:</p>
<p><span class="math">\(\text{adj}\left(nL_{G}\right)=n^{n-1}\text{adj}\left(L_{G}\right)\)</span> <br />
וכזכור, ראינו גם</p>
<p><span class="math">\(\text{adj}L_{G}=\kappa J\)</span> <br />
אז בסך הכל <span class="math">\(\text{adj}\left(nL_{G}\right)=n^{n-1}\kappa J\)</span> <br />
אז בואו ניקח את הנוסחה <span class="math">\(\text{adj}\left(J+L_{G}\right)\text{adj}\left(nI-J\right)=\text{adj}\left(nL_{G}\right)\)</span> <br />
שקיבלנו ונכתוב אותה מחדש עם מה שלמדנו:</p>
<p><span class="math">\(\text{adj}\left(J+L_{G}\right)n^{n-2}J=n^{n-1}\kappa J\)</span> <br />
כלומר</p>
<p><span class="math">\(\text{adj}\left(J+L_{G}\right)J=n\kappa J\)</span> <br />
איך נתקדם מפה? ובכן, זכרו את הנוסחה שמעניקה ל-adj את הכוח שלה: <span class="math">\(A\cdot\text{adj}A=\left|A\right|\cdot I\)</span> . בואו נשתמש בה פה - ניקח את <span class="math">\(\text{adj}\left(J+L_{G}\right)J=n\kappa J\)</span> ונכפול את שני האגפים במטריצה <span class="math">\(J+L_{G}\)</span> . נקבל:</p>
<p><span class="math">\(\left(J+L_{G}\right)\text{adj}\left(J+L_{G}\right)J=\left(J+L_{G}\right)n\kappa J\)</span> <br />
נשתמש בנוסחה על אגף שמאל ונקבל</p>
<p><span class="math">\(\left|\left(J+L_{G}\right)\right|J=\left(J+L_{G}\right)n\kappa J\)</span> <br />
באגף ימין, בואו ניזכר שראינו <span class="math">\(J^{2}=nJ\)</span> ו-<span class="math">\(L_{G}J=0\)</span> ולכן אפשר לפתוח את הסוגריים שם, ולקבל</p>
<p><span class="math">\(\left|\left(J+L_{G}\right)\right|J=n^{2}\kappa J\)</span> <br />
קיבלנו שאותה מטריצה, מוכפלת בשני סקלרים, היא שווה - אז הסקלרים בהכרח שווים (כי אנחנו עובדים מעל שדה ממציין 0, אם רוצים להיות פדנטיים), כלומר </p>
<p><span class="math">\(\left|\left(J+L_{G}\right)\right|=n^{2}\kappa\)</span> <br />
או בסימון המקורי שלי:</p>
<p><span class="math">\(\kappa=\frac{\left|L_{G}+J\right|}{n^{2}}\)</span> <br />
זה מסיים את ההוכחה של התוצאה המאוד יפה הזו, אבל איך זה עוזר לנו עם התמונה הגדולה? כזכור, המטרה שלי היא להראות שעבור מטריצת הלפלסיאן, הדטרמיננטה של כל מינור שלה היא מכפלת הערכים העצמיים ששונה מאפס חלקי <span class="math">\(n\)</span> :</p>
<p><span class="math">\(\kappa=\frac{1}{n}\lambda_{1}\cdots\lambda_{n-1}\)</span> .</p>
<p>אז מספיק להראות ש-<span class="math">\(\left|L_{G}+J\right|=n\cdot\lambda_{1}\cdots\lambda_{n-1}\)</span> <br />
מה שצריך לזכור הוא שדטרמיננטה של מטריצה הוא מכפלת כל הערכים העצמיים שלה, כמו שהראיתי קודם. ומה הערכים העצמיים של <span class="math">\(L_{G}+J\)</span> ? או, כאן זה נהיה כיף. ראינו כזכור ש-<span class="math">\(L_{G}J=JL_{G}=0\)</span> , כלומר המטריצות הללו <strong>מתחלפות בכפל</strong>.</p>
<p>מטריצות לכסינות שמתחלפות בכפל הן <strong>לכסינות סימולטנית</strong>, כלומר <strong>אותה מטריצה</strong><span class="math">\(P\)</span> מלכסנת את שתיהן ביחד. אם <span class="math">\(A,B\)</span> שתיהן לכסינות ומקיימות <span class="math">\(AB=BA\)</span> זה אומר שקיימת מטריצה <strong>אחת</strong>, <span class="math">\(P\)</span> כך ש-<span class="math">\(P^{-1}AP=D_{A}\)</span> ו-<span class="math">\(P^{-1}BP=D_{B}\)</span> , והערכים שמופיעים באלכסונים של המטריצות האלכסוניות <span class="math">\(D_{A},D_{B}\)</span> הם הערכים העצמיים של <span class="math">\(A,B\)</span> בהתאמה. שימו לב שהערכים הללו לא מופיעים בסדר שרירותי; הערך העצמי ה-<span class="math">\(k\)</span> -י באלכסון הוא הערך העצמי שמתאים לוקטור העצמי ה-<span class="math">\(k\)</span> -י ב-<span class="math">\(P\)</span> (העמודות של <span class="math">\(P\)</span> כולן וקטורים עצמיים של <span class="math">\(A,B\)</span> ; הרעיון בלכסון סימולטני הוא שיש לנו <strong>את אותם וקטורים עצמיים</strong> לשתי המטריצות בו זמנית).</p>
<p>עכשיו, <span class="math">\(P^{-1}\left(A+B\right)P=D_{A}+D_{B}\)</span> , ולכן הערכים העצמיים של <span class="math">\(A+B\)</span> הם בדיוק אברי האלכסון של <span class="math">\(D_{A}+D_{B}\)</span> , כלומר, הערכים העצמיים הללו הם מה שמתקבל כשמחלקים את הערכים העצמיים של <span class="math">\(A,B\)</span> <br />
לזוגות, בהתאם לוקטורים העצמיים שלהם, וסוכמים כל זוג.</p>
<p>את כל זה אפשר לעשות גם במקרה שבו המטריצות לא לכסינות אלא רק ניתנות לשילוש בעזרת צורת ז'ורדן. במקרה הספציפי שלנו, אנחנו יודעים על וקטורים עצמי משותף אחד: הוקטור שכולו 1-ים, שמתאים לערך העצמי <span class="math">\(0\)</span> של <span class="math">\(L_{G}\)</span> ולערך העצמי <span class="math">\(n\)</span> של <span class="math">\(J\)</span> , ולכן הערך העצמי של <span class="math">\(L_{G}+J\)</span> שמתאים אליו יהיה <span class="math">\(n\)</span> . כל שאר הערכים העצמיים של <span class="math">\(J\)</span> הם 0 (כי זו מטריצה מדרגה 1) ולכן כל יתר הערכים העצמיים של <span class="math">\(L_{G}+J\)</span> יהיו פשוט הערכים העצמיים <span class="math">\(\lambda_{1},\ldots,\lambda_{n-1}\)</span> כשמחברים 0 לכל אחד מהם. קיבלנו שהערכים העצמיים של <span class="math">\(L_{G}+J\)</span> הם בדיוק <span class="math">\(n,\lambda_{1},\ldots,\lambda_{n-1}\)</span> ולכן <span class="math">\(\left|L_{G}+J\right|=n\cdot\lambda_{1}\cdots\lambda_{n-1}\)</span> וזה מסיים את ההוכחה.</p>
<p>יפה! סיימנו את... השלב הראשון בכל הסיפור הזה. נותרו לנו עוד שניים: הקטע הזה של גרף מכפלה, והקטע הזה של פולינומי צ'בישב.</p>
<h2>הקטע הזה של גרף מכפלה</h2>
<p>באופן כללי מתמטיקה זה מסובך ואובייקטים מתמטיים זה מסובך, אז המתמטיקאים מנסים בכל הזדמנות לקחת אובייקט מסובך ולהציג אותו בתור משהו שנבנה מאובייקטים פשוטים יותר, שקל לנו להבין יותר אותם ואת מה שקורה בעקבות הפעולות שביצענו עליהם כדי לקבל את הדבר המסובך. ככה זה עם הצגה של מספר טבעי בתור מכפלה של ראשוניים; של חבורה בתור מכפלה של תת-חבורות; של מרחב וקטורי בתור מכפלה של מרחבים וקטוריים; של... טוב, הבנתם, אני אוהב מכפלות. למה שלא יהיה משהו כזה גם לגרפים?</p>
<p>ובכן, לא רק שיש, יש הרבה. אני אדבר רק על ההגדרה הספציפית של מכפלה שאני צריך בפוסט הזה - לפעמים קוראים לה "מכפלה קרטזית" ולפעמים "מכפלת קופסה" . הרעיון הוא כזה: אם יש לנו שני גרפים, <span class="math">\(G_{1}=\left(V_{1},E_{1}\right)\)</span> ו-<span class="math">\(G_{2}=\left(V_{2},E_{2}\right)\)</span> <br />
אז נבנה גרף חדש, <span class="math">\(G_{1}\square G_{2}=\left(V,E\right)\)</span> כך ש-</p>
<p><span class="math">\(V=V_{1}\times V_{2}=\left\{ \left(v_{1},v_{2}\right)\ |\ v_{1}\in V_{1},v_{2}\in V_{2}\right\}\)</span> <br />
כלומר, הצמתים של הגרף החדש הם <strong>זוגות</strong> של צומת מכל אחד מהגרפים המקוריים - הקבוצה הזו היא בדיוק מה שנקרא "מכפלה קרטזית" של הקבוצות <span class="math">\(V_{1},V_{2}\)</span> ומכאן השם של המכפלה הזו גם כאן. אבל עוד לא סיימנו - גרף מוגדר לא רק על ידי הצמתים שלו אלא על ידי הקשתות, ובמקרה הזה <strong>לא</strong> יתקיים ש-<span class="math">\(E=E_{1}\times E_{2}\)</span> (למעשה, אין ממש משמעות להגדרה כזו - המכפלה של <span class="math">\(E_{1},E_{2}\)</span> לא נותנת לנו קבוצה של קשתות על צמתי <span class="math">\(V\)</span> ). ההגדרה, שתתאים בול למבוכים שאני ממדל בעזרת הגרפים הללו ואולי יהיה קל להבין אותה יותר באמצעותם, היא ששני צמתים מחוברים בקשת אם בקואורדינטה אחת שלהם הם <strong>זהים</strong> ובקואורדינטה השניה שלהם הם <strong>מחוברים בקשת</strong>. פורמלית (ואני לא בטוח שהכתיב הפורמלי עוזר לזה להיות ברור): </p>
<p><span class="math">\(E=\left\{ \left(\left(v_{1},v_{2}\right),\left(u_{1},v_{2}\right)\right)\ |\ \left(v_{1},u_{1}\right)\in E_{1}\right\} \cup\left\{ \left(\left(v_{1},v_{2}\right),\left(v_{1},u_{2}\right)\right)\ |\ \left(v_{2},u_{2}\right)\in E_{2}\right\}\)</span> <br />
הנה דרך אינטואיטיבית לחשוב על זה. נניח שלבי במזרח ואנוכי בסוף מערב ויש לי כוחות על שמאפשרים לי להתפצל תודעתית: חלק אחד שלי יצא לטיול בירושלים וחלק אחר מטייל בקורדובה בספרד. בשני המקרים הרחובות ארוכים וצרים ומתפתלים - אפשר למדל אותם עם גרף. צמתים הם מקומות שבהם אפשר לעצור ולהתפעל מהנוף, וקשתות הן הסמטאות שמחברות שני מקומות כאלו. אז יש לנו גרף <span class="math">\(G_{1}\)</span> עבור ירושלים וגרף <span class="math">\(G_{2}\)</span> עבור קורדובה. בדרך כלל כשאני מטייל אני נמצא רק במיקום גאוגרפי אחד, נאמר בירושלים, ואז הטיול שלי הוא סדרה של מעברים מצומת <span class="math">\(v\in V_{1}\)</span> אל צומת <span class="math">\(u\in V_{1}\)</span> בעזרת הקשת <span class="math">\(\left(v,u\right)\in E_{1}\)</span> . אבל עכשיו, כאמור, אני באורח פלא גם פה וגם שם: המיקום שלי הוא <span class="math">\(\left(v_{1},v_{2}\right)\)</span> <br />
כש-<span class="math">\(v_{1}\)</span> הוא המיקום שלי בירושלים ו-<span class="math">\(v_{2}\)</span> הוא המיקום שלי בקורדובה.</p>
<p>עכשיו, יש עלי רק מגבלה אחת למרות כוח העל המדהים שלי: כשאני <strong>זז</strong>, אני לא מסוגל לזוז גם פה וגם שם בו זמנית, הסמטאות המפותלות דורשות יותר מדי ריכוז. אז אם אני רוצה לזוז ממקום <span class="math">\(v_{1}\)</span> למקום <span class="math">\(u_{1}\)</span> <br />
בירושלים אני "מקפיא" לרגע את מה שאני עושה בקורדובה - הייתי ב-<span class="math">\(v_{2}\)</span> ואשאר לעת עתה ב-<span class="math">\(v_{2}\)</span> . אז המעבר שלי הוא מהצומת <span class="math">\(\left(v_{1},v_{2}\right)\)</span> אל הצומת <span class="math">\(\left(u_{1},v_{2}\right)\)</span> - זזתי בקואורדינטה הראשונה, והשניה נשארה ללא שינוי. באותו אופן גם הייתי יכול לזוז בקורדובה ולהישאר בירושלים.</p>
<p>כל זה עובד מצוין עבור המבוכים שלנו. אצלנו, הגרף שאנחנו רוצים לספור לו עצים פורשים הוא מהצורה <span class="math">\(G=\left(V,E\right)\)</span> עם <span class="math">\(V=\left\{ \left(i,j\right)\ |\ 1\le i\le n,1\le j\le m\right\}\)</span> (כאשר <span class="math">\(\left(i,j\right)\)</span> אומר "התא בשורה ה-<span class="math">\(i\)</span> בעמודה ה-<span class="math">\(j\)</span> "). הקשתות הן מהצורה <span class="math">\(\left(\left(i,j\right),\left(i+1,j\right)\right)\)</span> (כשזזים משורה אחת לאחרת, כלומר נעים בקו אנכי) ו-<span class="math">\(\left(\left(i,j\right),\left(i,j+1\right)\right)\)</span> (כשזזים מעמודה אחת לאחרת, כלומר נעים בקו אופקי). אי אפשר במבוך לזוז "באלכסון" כמו שהיה קורה אם היה מותר לזוז ב-<span class="math">\(G_{1},G_{2}\)</span> "בו זמנית" . אז אפשר לחשוב על <span class="math">\(G\)</span> בתור המכפלה <span class="math">\(G_{1}\square G_{2}\)</span> כאשר כל אחד מהמוכפלים הוא פשוט מאוד: <span class="math">\(G_{1}=\left(V_{1},E_{1}\right)\)</span> כך ש-<span class="math">\(V_{1}=\left\{ 1,2,\ldots,n\right\}\)</span> ו-<span class="math">\(E_{1}\)</span> כוללת את כל האיברים מהצורה <span class="math">\(\left(i,i+1\right)\)</span> עבור <span class="math">\(1\le i\lt n\)</span> , ו-<span class="math">\(G_{2}\)</span> מוגדר באותו אופן עם <span class="math">\(m\)</span> במקום <span class="math">\(n\)</span> . מכיוון שאני עצלן ביקשתי מבינה מלאכותית לאייר לי את זה והתוצאה הזויה בהתאם אבל מדויקת למדי:</p>
<p><img src="/img/2026/product_graph.png" alt=""/></p>
<p>מה שאני מתעניין בו בפוסט הזה הוא הלפלסיאן של גרפים, וספציפית הערכים העצמיים שלו כי כבר עברנו מהבעיה של חישוב הדטרמיננטה של הלפלסיאן לבעיה של מציאת הערכים העצמיים שלו. אז מה אני יכול לומר על הערכים העצמיים של <span class="math">\(L_{G_{1}\square G_{2}}\)</span> ? או, בשביל זה אני יכול להיעזר במה שאנחנו יודעים על תורת המטריצות, בתנאי שאני אבין איך לכתוב את <span class="math">\(L_{G_{1}\square G_{2}}\)</span> בעזרת <span class="math">\(L_{G_{1}},L_{G_{2}}\)</span> וזה, למרבה המזל, די קל: <span class="math">\(L_{G_{1}\square G_{2}}\)</span> הולך לצאת מה שנקרא <strong>סכום קרונקר</strong> של <span class="math">\(L_{G_{1}},L_{G_{2}}\)</span> , וזו הזדמנות טובה להציג את המושג הזה.</p>
<p>באופן כללי, אם <span class="math">\(A,B\)</span> הן שתי מטריצות ריבועיות מסדר <span class="math">\(n\times n\)</span> ו-<span class="math">\(m\times m\)</span> בהתאמה, אז <strong>מכפלת קרונקר</strong> שלהן, שמסומנת <span class="math">\(A\otimes B\)</span> , היא מה שמקבלים אם לוקחים את <span class="math">\(A\)</span> ובכל כניסה של <span class="math">\(A\)</span> שותלים <strong>עותק שלם</strong> של <span class="math">\(B\)</span> בתור בלוק, כשכל העותק הזה מוכפל במה שהיה בכניסה של <span class="math">\(A\)</span> במקור. הנה דוגמא פשוטה:</p>
<p><span class="math">\(A=\left(\begin{array}{cc}
a_{11} & a_{12}\\
a_{21} & a_{22}
\end{array}\right),B=\left(\begin{array}{cc}
b_{11} & b_{12}\\
b_{21} & b_{22}
\end{array}\right)\)</span> <br />
וכעת:</p>
<p><span class="math">\(A\otimes B=\left(\begin{array}{cc}
a_{11}B & a_{12}B\\
a_{21}B & a_{22}B
\end{array}\right)\)</span> <br />
שימו לב, אני לא אומר ש-<span class="math">\(a_{11}B\)</span> הוא <strong>איבר</strong> של המטריצה החדשה; אני אומר שזה תיאור של המטריצה החדשה בתור <strong>מטריצת בלוקים</strong>. כלומר, פורמלית קיבלנו את המטריצה</p>
<p><span class="math">\(A\otimes B=\left(\begin{array}{cccc}
a_{11}b_{11} & a_{11}b_{12} & a_{12}b_{11} & a_{12}b_{12}\\
a_{11}b_{21} & a_{11}b_{22} & a_{12}b_{21} & a_{12}b_{22}\\
a_{21}b_{11} & a_{21}b_{12} & a_{22}b_{11} & a_{22}b_{12}\\
a_{21}b_{21} & a_{21}b_{22} & a_{22}b_{21} & a_{22}b_{22}
\end{array}\right)\)</span> <br />
מקום אחד שבו המפלצת הזו צצה באופן טבעי והיא שימושית מאוד הוא חישוב קוונטי, <a href="https://gadial.net/2022/08/01/quantum_computing_math_3/">ויש לי פוסט</a> שבו אני מתאר אותה בהקשר הזה. אבל מן הסתם יש לה שלל שימושים שונים ומשונים - זה עתה נתקלנו באחד חדש. רק שצריך טיפה להיזהר - אני הגדרתי כרגע את <strong>מכפלת קרונקר</strong>, אבל עבור <span class="math">\(L_{G_{1}\square G_{2}}\)</span> אני צריך משהו שנקרא <strong>סכום קרונקר</strong> שהוא מושג קשור שמתבסס על המכפלה אבל לא זהה.</p>
<p>בואו נגדיר סכום קרונקר בצורה זהירה. יש לנו כאמור מטריצה ריבועית <span class="math">\(A\)</span> מסדר <span class="math">\(n\)</span> ומטריצה ריבועית <span class="math">\(B\)</span> מסדר <span class="math">\(m\)</span> . מכפלת קרונקר שלהם תהיה מטריצה ריבועית מסדר <span class="math">\(nm\)</span> . גם סכום קרונקר יהיה מהסדר הזה, אבל הוא מתקבל בצורה שונה: ניקח את מטריצת היחידה מסדר <span class="math">\(m\)</span> ונסמן אותה <span class="math">\(I_{m}\)</span> ובדומה נסמן ב-<span class="math">\(I_{n}\)</span> את מטריצת היחידה מסדר <span class="math">\(n\)</span> , ועכשיו נסתכל על הביטוי הזה:</p>
<p><span class="math">\(A\oplus B\triangleq A\otimes I_{m}+I_{n}\otimes B\)</span> <br />
כלומר, במקום לכפול את <span class="math">\(A,B\)</span> ישירות זה עם זה, אנחנו כופלים אותם עם מטריצות היחידה מהסדרים המתאימים, מקבלים שתי מטריצות מסדר <span class="math">\(nm\)</span> ומחברים אותן. אם נעשה את זה עבור שתי המטריצות מסדר <span class="math">\(2\times2\)</span> שהראיתי קודם, נקבל</p>
<p><span class="math">\(A\oplus B=A\otimes I_{2}+I_{2}\otimes B=\left(\begin{array}{cc}
a_{11}I_{2} & a_{12}I_{2}\\
a_{21}I_{2} & a_{22}I_{2}
\end{array}\right)+\left(\begin{array}{cc}
B & 0\\
0 & B
\end{array}\right)=\)</span></p>
<p><span class="math">\(=\left(\begin{array}{cccc}
a_{11}+b_{11} & b_{12} & a_{12} & 0\\
b_{21} & a_{11}+b_{22} & 0 & a_{12}\\
a_{21} & 0 & a_{22}+b_{11} & b_{12}\\
0 & a_{21} & b_{21} & a_{22}+b_{22}
\end{array}\right)\)</span> <br />
כדי להבין מה הקטע, כדאי לזכור מה בעצם מכפלת קרונקר של מטריצות באה להשיג. אני לא מציג בפוסט הזה את המושג של <strong>מכפלה טנזורית</strong> של מרחבים וקטוריים אבל הזכרתי את זה בפוסט של החישוב הקוונטי (שם מכפלות טנזוריות צצות באופן טבעי - אפשר לחשוב על קיוביט בתור מרחב וקטורי ממימד 2, ועל אוסף של <span class="math">\(n\)</span> קיוביטים בתור מכפלה טנזורית של <span class="math">\(n\)</span> מרחבים שכאלו) וגם <a href="https://gadial.net/2014/06/10/vector_space_tensor_product/">יש לי פוסט ייעודי</a> על הקונספט. עכשיו, בואו נגיד שיש לנו מכפלה טנזורית של שני מרחבים וקטוריים <span class="math">\(V\otimes U\)</span> ואיבר במכפלה הזו שהוא מהצורה <span class="math">\(v\otimes u\)</span> (לא כל איבר של <span class="math">\(V\otimes U\)</span> נראה ככה, אבל איברים מהצורה הזו פורשים את המרחב וזה מספיק טוב לנו). עכשיו, נניח שיש לנו טרנספורמציה לינארית על <span class="math">\(V\)</span> שמיוצגת על ידי <span class="math">\(A\)</span> וטרנספורמציה לינארית על <span class="math">\(U\)</span> שמיוצגת על ידי <span class="math">\(B\)</span> , אז מכפלת קרונקר שלהם משיגה את האפקט הבא:</p>
<p><span class="math">\(\left(A\otimes B\right)\left(v\otimes u\right)=\left(Av\right)\otimes\left(Bu\right)\)</span> <br />
בלשון של חישוב קוונטי, אם יש לנו שני שערים <span class="math">\(A,B\)</span> שפועלים כל אחד על קיוביט בודד, אז <span class="math">\(A\otimes B\)</span> יהיה השער שפועל על שני קיוביטים: על השער הראשון כמו <span class="math">\(A\)</span> ועל השער השני כמו <span class="math">\(B\)</span> . </p>
<p>עכשיו, שימו לב שאם <span class="math">\(v\)</span> הוא וקטור עצמי של <span class="math">\(A\)</span> עם הערך העצמי <span class="math">\(\lambda\)</span> , כלומר <span class="math">\(Av=\lambda v\)</span> , ואם <span class="math">\(u\)</span> הוא וקטור עצמי של <span class="math">\(B\)</span> עם הערך העצמי <span class="math">\(\rho\)</span> , כלומר <span class="math">\(Bu=\rho u\)</span> , אז יתקיים</p>
<p><span class="math">\(\left(A\otimes B\right)\left(v\otimes u\right)=\left(Av\right)\otimes\left(Bu\right)=\left(\lambda v\right)\otimes\left(\rho u\right)=\lambda\rho\left(v\otimes u\right)\)</span> (המעבר האחרון משתמש בכללים של מכפלה טנזורית שלא הצגתי כאן במפורש)</p>
<p>כלומר, <span class="math">\(\lambda\rho\)</span> הוא ערך עצמי של <span class="math">\(A\otimes B\)</span> , וזה מה שקורה באופן כללי: הערכים העצמיים של <span class="math">\(A\otimes B\)</span> הם <strong>המכפלות</strong> של כל הזוגות האפשריים של ערך עצמי של <span class="math">\(A\)</span> וערך עצמי של <span class="math">\(B\)</span> . זה מה שקורה עבור <strong>מכפלת</strong> קרונקר. ועבור סכום? כפי שאפשר לנחש, נקבל <strong>סכום</strong> של הערכים העצמיים:</p>
<p><span class="math">\(\left(A\otimes I_{m}+I_{n}\otimes B\right)\left(v\otimes u\right)=\left(A\otimes I_{m}\right)\left(v\otimes u\right)+\left(I_{n}\otimes B\right)\left(v\otimes u\right)=\)</span></p>
<p><span class="math">\(\left(Av\otimes Iu\right)+\left(Iv\otimes Bu\right)=\left(\lambda v\otimes u\right)+\left(v\otimes\rho u\right)=\lambda\left(v\otimes u\right)+\rho\left(v\otimes u\right)=\)</span></p>
<p><span class="math">\(\left(\lambda+\rho\right)\left(v\otimes u\right)\)</span> (שוב, כל זה בעזרת הכללים הסטנדרטיים של מכפלה טנזורית).</p>
<p>יפה, אז אפשר לחזור לגרפים. אם אני אראה שהלפלסיאן <span class="math">\(L_{G_{1}\square G_{2}}\)</span> של גרף המכפלה הוא סכום קרונקר של הלפלסיאנים <span class="math">\(L_{G_{1}},L_{G_{2}}\)</span> אני אקבל מייד שהערכים העצמיים שלו הם סכומים של זוגות של הערכים העצמיים שלהם - בדיוק מה שרציתי.</p>
<p>במבט ראשון, זה נראה ממש מעייף להתחיל להוכיח את זה - <span class="math">\(A\oplus B\)</span> היא מטריצה מעיקה כבר בדוגמא הקטנה שנתתי למעלה, אז לטפל בה באופן כללי יהיה סיוט של טיפול באינדקסים. הסיוט הזה די נעלם אם חושבים על <span class="math">\(A\oplus B\)</span> בתור מטריצה שהאינדקסים שלה הם לא מספרים אלא <strong>זוגות</strong> של מספרים. כלומר, נמספר את השורות והעמודות על ידי זוגות <span class="math">\(\left(i,j\right)\)</span> כך ש-<span class="math">\(1\le i\le n\)</span> ו-<span class="math">\(1\le j\le m\)</span> , ואז כניסה כללית של המטריצה תהיה מהצורה <span class="math">\(\left(i,j\right),\left(i^{\prime},j^{\prime}\right)\)</span> . הסדר שבו אנחנו מסדרים בו את האיברים הללו הוא לקסיקוגרפי - קודם כל מגדילים את הכניסה השניה ואז, כשהיא הגיעה לערך המקסימלי שלה, מחזירים אותה לערך המינימלי ומגדילים את הכניסה הראשונה. כלומר הסדר הוא <span class="math">\(\left(1,1\right),\left(1,2\right),\left(2,1\right),\left(2,2\right)\)</span> .</p>
<p>עכשיו, אם מסתכלים על הדוגמא למעלה עם האינדקסים מול העיניים</p>
<p><span class="math">\(\begin{array}{c}
\begin{array}{c}
\\\left(1,1\right)\\
\left(1,2\right)\\
\left(2,1\right)\\
\left(2,2\right)
\end{array}\begin{array}{cccc}
\left(1,1\right) & \left(1,2\right) & \left(2,1\right) & \left(2,2\right)\\
a_{11}+b_{11} & b_{12} & a_{12} & 0\\
b_{21} & a_{11}+b_{22} & 0 & a_{12}\\
a_{21} & 0 & a_{22}+b_{11} & b_{12}\\
0 & a_{21} & b_{21} & a_{22}+b_{22}
\end{array}\end{array}\)</span> <br />
רואים שהכללים של מהי <span class="math">\(A\otimes I_{2}+I_{2}\otimes B\)</span> הם די פשוטים: 1. על האלכסון יש לנו במקום <span class="math">\(\left(i,j\right),\left(i,j\right)\)</span> את <span class="math">\(a_{ii}+b_{jj}\)</span> .</p>
<ol>
<li>
<p>בשורה <span class="math">\(\left(i,j\right)\)</span> ובעמודה <span class="math">\(\left(i,j^{\prime}\right)\)</span> עבור <span class="math">\(j\ne j^{\prime}\)</span> יש לנו את <span class="math">\(b_{j,j^{\prime}}\)</span> .</p>
</li>
<li>
<p>בשורה <span class="math">\(\left(i,j\right)\)</span> ובעמודה <span class="math">\(\left(i^{\prime},j\right)\)</span> <br />
עבור <span class="math">\(i\ne i^{\prime}\)</span> יש לנו את <span class="math">\(a_{i,i^{\prime}}\)</span> </p>
</li>
<li>בכל מקום אחר יש לנו 0.</li>
</ol>
<p>כמובן, זה אפילו יותר פשוט מזה: הכלל הכללי ביותר הוא שהכניסה בשורה <span class="math">\(\left(i,j\right)\)</span> ועמודה <span class="math">\(\left(i^{\prime},j^{\prime}\right)\)</span> <br />
מקבלת את המחובר <span class="math">\(a_{i,i^{\prime}}\)</span> אם <span class="math">\(j=j^{\prime}\)</span> ואת המחובר <span class="math">\(b_{j,j^{\prime}}\)</span> אם <span class="math">\(i=i^{\prime}\)</span> .</p>
<p>קל במיוחד לראות את זה עבור <span class="math">\(I_{2}\otimes B\)</span> , כלומר המטריצה שנראית כמו <span class="math">\(\left(\begin{array}{cccc}
B & 0 & 0 & 0\\
0 & B & 0 & 0\\
0 & 0 & \ddots & 0\\
0 & 0 & 0 & B
\end{array}\right)\)</span> . כל בלוק של <span class="math">\(B\)</span> מתאים לאינדקסים מהצורה <span class="math">\(\left(1,j\right),\left(2,j\right),\ldots,\left(n,j\right)\)</span> עבור <span class="math">\(1\le j\le m\)</span> כלשהו. (האינדקסים הללו מתאימים לשורת/עמודות רצופות בגלל הסדר הלקסיקוגרפי). אז בהינתן כניסה כלשהי בשורה <span class="math">\(\left(i,j\right)\)</span> , הסיכוי היחידי שלה להיות שונה מאפס ב-<span class="math">\(I_{2}\otimes B\)</span> הוא שהעמודה תהיה באותו בלוק כמו השורה - כלומר העמודה צריכה להיות <span class="math">\(\left(i^{\prime},j\right)\)</span> (אותו ה-<span class="math">\(j\)</span> ).</p>
<p>עכשיו נחזור אל הלפלסיאנים. בלפלסיאן של גרף, כל כניסה מייצגת צומת. כשהגרף הוא מכפלה <span class="math">\(G_{1}\square G_{2}\)</span> , כל צומת הוא זוג <span class="math">\(\left(i,j\right)\)</span> <br />
כך ש-<span class="math">\(i\)</span> שייך לאינדקסים של צמתי <span class="math">\(G_{1}\)</span> ו-<span class="math">\(j\)</span> שייך לאינדקסים של צמתי <span class="math">\(G_{2}\)</span> - כבר טוב, כי ראינו שבסכום קרונקר גם כן נוח לנו לאנדקס דברים עם זוגות כאלו. עבור אברי האלכסון, כלומר זוגות מהצורה <span class="math">\(\left(i,j\right),\left(i,j\right)\)</span> , <strong>אמורה</strong> להיות לנו הדרגה של הצומת <span class="math">\(\left(i,j\right)\)</span> ובפועל כפי שראינו למעלה מה שיש לנו הוא את <span class="math">\(a_{ii}+b_{jj}\)</span> , כלומר את האיברים על האלכסון שמתאימים ל-<span class="math">\(i\)</span> ב-<span class="math">\(G_{1}\)</span> ול-<span class="math">\(j\)</span> ב-<span class="math">\(G_{2}\)</span> - כלומר את <strong>סכום הדרגות</strong> של הצמתים הללו בגרפים המקוריים שלהם. האם זה מה שצריך להיות? כן! כי מי השכנים של הצומת <span class="math">\(\left(i,j\right)\)</span> <br />
בגרף המכפלה? כל הצמתים מהצורה <span class="math">\(\left(i,j^{\prime}\right)\)</span> כך ש-<span class="math">\(j^{\prime}\)</span> היה שכן של <span class="math">\(j\)</span> ב-<span class="math">\(G_{2}\)</span> , וכל הצמתים מהצורה <span class="math">\(\left(i^{\prime},j\right)\)</span> כך ש-<span class="math">\(i^{\prime}\)</span> היה שכן של <span class="math">\(i\)</span> ב-<span class="math">\(G_{2}\)</span> . כלומר בדיוק סכום השכנים של שני הצמתים הללו בגרפים המקוריים.</p>
<p>עבור כניסה <span class="math">\(\left(i,j\right),\left(i^{\prime},j^{\prime}\right)\)</span> <br />
שלא על האלכסון, הלפלסיאן אמור לתת לנו את מינוס מספר הקשתות מהצומת <span class="math">\(\left(i,j\right)\)</span> לצומת <span class="math">\(\left(i^{\prime},j^{\prime}\right)\)</span> . אם גם <span class="math">\(i\ne i^{\prime}\)</span> וגם <span class="math">\(j\ne j^{\prime}\)</span> אז כפי שראינו המספר הזה הוא 0, וזה מה שהוא צריך להיות כי על פי הגדרת גרף מכפלה, אין קשת בין הצמתים הללו - יש קשת רק בין צמתים שנבדלים בדיוק ברכיב אחד. אז מה קורה אם למשל <span class="math">\(i=i^{\prime}\)</span> אבל <span class="math">\(j\ne j^{\prime}\)</span> ? במקרה הזה, הכניסה <span class="math">\(\left(i,j\right),\left(i,j^{\prime}\right)\)</span> היא <span class="math">\(b_{j,j^{\prime}}\)</span> , כלומר הכניסה המתאימה בלפלסיאן של <span class="math">\(G_{2}\)</span> <br />
- והכניסה הזו נותנת את מספר הקשתות מ-<span class="math">\(j\)</span> אל <span class="math">\(j^{\prime}\)</span> , שהוא גם בדיוק מספר הקשתות מ-<span class="math">\(\left(i,j\right)\)</span> אל <span class="math">\(\left(i,j^{\prime}\right)\)</span> . אז הכל מסתדר יפה.</p>
<p>נסכם: אם יש לנו גרף מכפלה <span class="math">\(G_{1}\square G_{2}\)</span> , הלפלסיאן שלו אכן יוצא סכום קרונקר של הלפלסיאנים המעורבים, מה שאפשר לכתוב בנוסחה קומפקטית בתור</p>
<p><span class="math">\(L_{G_{1}\square G_{2}}=L_{G_{1}}\oplus L_{G_{2}}\)</span> <br />
ואנחנו יודעים בדיוק מה הערכים העצמיים של סכום קרונקר - כל הסכומים של זוגות של ערכים עצמיים של המטריצות שאותן סוכמים.</p>
<p>עכשיו רק נשאר ליישם את זה למקרה הקונקרטי שלנו - גרף מכפלה שבנוי משני גרפים שהם "שרוך" ואפשר למצוא את הערכים העצמיים שלהם במפורש עם הקטע הזה של פולינומי צ'בישב.</p>
<h2>הקטע הזה של פולינומי צ'בישב</h2>
<p>לפני שאני מתחיל לשלוף את צ'בישב, בואו נבין מה בכלל אנחנו רוצים לעשות ולמה זה לא לגמרי טריוויאלי. הצלחנו לרדקץ את כל המהומה של המבוכים אל ההבנה של גרף אחד ספציפי: <span class="math">\(P_{n}=\left(V,E\right)\)</span> כך ש-<span class="math">\(V=\left\{ 1,2,\ldots,n\right\}\)</span> ו-<span class="math">\(E=\left\{ \left(1,2\right),\left(2,3\right),\ldots,\left(n-1,n\right)\right\}\)</span> . גרף שנראה כמו קו אחד ארוך - או בקיצור, "שרוך" . בואו נכתוב במפורש את הלפלסיאן של גרף כזה עם חמישה צמתים:</p>
<p><span class="math">\(\left(\begin{array}{ccccc}
1 & -1 & 0 & 0 & 0\\
-1 & 2 & -1 & 0 & 0\\
0 & -1 & 2 & -1 & 0\\
0 & 0 & -1 & 2 & -1\\
0 & 0 & 0 & -1 & 1
\end{array}\right)\)</span> <br />
זו מטריצה פשוטה מאוד, בצורה כמעט מרגיזה: שני האלכסונים המשניים שלה הם כולם <span class="math">\(-1\)</span> , האלכסון הראשי שלה הוא כמעט כולו 2 למעט שני הצדדים שהם 1. אולי אפשר לחשב את הפולינום האופייני שלה פשוט על ידי ההגדרה, באמצעות חישוב דטרמיננטה? אנחנו צריכים לחשב את הדטרמיננטה הבאה:</p>
<p><span class="math">\(\left|\begin{array}{ccccc}
x-1 & 1 & 0 & 0 & 0\\
1 & x-2 & 1 & 0 & 0\\
0 & 1 & x-2 & 1 & 0\\
0 & 0 & 1 & x-2 & 1\\
0 & 0 & 0 & 1 & x-1
\end{array}\right|\)</span> <br />
אפשר להתחיל לחשב אותה על ידי פיתוח של השורה העליונה. זה אומר שלוקחים את <span class="math">\(x-1\)</span> ומכיפילים בדטרמיננטה שמתקבלת ממחיקת השורה והעמודה הראשונים. אחר כך <strong>מפחיתים</strong> את ה-1 שבעמודה השניה בשורה הראשונה, כשהוא מוכפל בדטרמיננטית המינור שמתקבל ממחיקת השורה הראשונה והעמודה השניה, כלומר</p>
<p><span class="math">\(\left|\begin{array}{cccc}
1 & 1 & 0 & 0\\
0 & x-2 & 1 & 0\\
0 & 1 & x-2 & 1\\
0 & 0 & 1 & x-1
\end{array}\right|\)</span> <br />
את הדטרמיננטה <strong>הזו</strong> קל מאוד לפשט כי בעמודה הראשונה יש 1 רק ותו לא, אז מסירים את העמודה והשורה הראשונים ומקבלים</p>
<p><span class="math">\(\left|\begin{array}{ccc}
x-2 & 1 & 0\\
1 & x-2 & 1\\
0 & 1 & x-1
\end{array}\right|\)</span> <br />
וזה מה שמקבלים כשמסירים מהמטריצה <strong>המקורית</strong> את שתי השורות והעמודות הראשונות. כלומר יש לנו מעין רקורסיה להתבסס עליה כאן - נחשב את הדטרמיננטה של המטריצה המקורית על ידי חישוב של דטרמיננטות של תת-מטריצות שמתקבלות ממנה על ידי מחיקת כך-וכך השורות והעמודות הראשונות. מקרי הבסיס הם כשמחקנו את הכל חוץ מהתא הימני-תחתון <span class="math">\(x-1\)</span> - נסמן זאת בתור <span class="math">\(p_{1}\left(x\right)=x-1\)</span> , והמקרה העוד יותר מנוון כשמחקנו את הכל ולכן יש לנו את "המכפלה הריקה"<span class="math">\(1\)</span> , ואת זה נסמן ב-<span class="math">\(p_{0}\left(x\right)=1\)</span> .</p>
<p>עכשיו, החישוב שעשיתי קודם כלל להסיר שורה ועמודה אחת ולהכפיל ב-<span class="math">\(x-1\)</span> , אבל זה היה למעשה מקרה מיוחד כי היה <span class="math">\(x-1\)</span> בפינה השמאלית-עליונה של המטריצה; בדרך כלל יהיה שם <span class="math">\(x-2\)</span> . אז אני מקבל את הנוסחה הבאה:</p>
<p><span class="math">\(p_{k}=\left(x-2\right)p_{k-1}\left(x\right)-p_{k-2}\left(x\right)\)</span> <br />
הנוסחה הזו עובדת עד שאנחנו מגיעים לשלב האחרון, ואז צריך יהיה להכפיל ב-<span class="math">\(x-1\)</span> כדי לקבל את <span class="math">\(L_{G}\)</span> . כלומר אנחנו מקבלים את הנוסחה הכללית הזו לחישוב סדרת פולינומים <span class="math">\(p_{k}\)</span> עבור <span class="math">\(1\le k\lt n\)</span> :</p>
<p><span class="math">\(p_{0}\left(x\right)=1\)</span></p>
<p><span class="math">\(p_{1}\left(x\right)=x-1\)</span></p>
<p><span class="math">\(p_{k}\left(x\right)=\left(x-2\right)p_{k-1}\left(x\right)-p_{k-2}\left(x\right)\)</span> <br />
עבור <span class="math">\(2\le k\lt n\)</span> .</p>
<p>ואז מגיע השלב האחרון:</p>
<p><span class="math">\(L_{G}=\left(x-1\right)p_{n-1}\left(x\right)-p_{n-2}\left(x\right)\)</span> <br />
הנוסחה עבור <span class="math">\(p_{k}\)</span> <strong>מזכירה</strong> בצורה חשודה את הנוסחה של סדרת פולינומים מפורסמת - <strong>פולינומי צ'בישב</strong>. אלו פולינומים חשובים ומועילים בזכות עצמם - אני בכלל הכרתי אותם לראשונה בהקשר של אנליזה נומרית וקירובים - אבל בפוסט הזה אני לא אכנס לזה. עדיין, כדאי להבין מאיפה הם מגיעים. והם מגיעים מהזוועה שהטרידה אותי בשיעורי המתמטיקה בתיכון - <strong>זהויות טריגונומטריות</strong>. ספציפית, הזהות של קוסינוס של זווית כפולה:</p>
<p><span class="math">\(\cos\left(2\theta\right)=2\cos^{2}\theta-1\)</span> <br />
מה שאנחנו רואים כאן הוא שאפשר לבטא את קוסינוס של זווית כפולה בעזרת קוסינוס <strong>רגיל</strong> כל עוד אנחנו מרשים לכפול אותו בעצמו, ובמקדמים, ולחבר קבועים - זה מה שנקרא <strong>פולינום</strong>. אבל למה לעצור כאן? אפשר לנסות לטפל גם ב-<span class="math">\(\cos\left(3\theta\right)\)</span> . כאן זווית כפולה לא תעזור לנו אבל אפשר לכתוב <span class="math">\(3\theta=2\theta+\theta\)</span> ולהשתמש בנוסחה הכללית לסכום זוויות, שהיא...</p>
<p><span class="math">\(\cos\left(\theta+\varphi\right)=\cos\theta\cos\varphi-\sin\theta\sin\varphi\)</span> <br />
וזה... אה... לא טוב בכלל, כי יש לנו פה סינוס, ואני רציתי למצוא משהו שהוא פולינום אך ורק בקוסינוס. אבל רגע, לא להתאייש, אולי יש דרך לבטל את הסינוס כי הרי יש לנו גם נוסחה <strong>להפרש</strong> זוויות שנראית כמעט אותו דבר:</p>
<p><span class="math">\(\cos\left(\theta-\varphi\right)=\cos\theta\cos\varphi+\sin\theta\sin\varphi\)</span> <br />
אם אני <strong>אחבר</strong> את שתי הנוסחאות הללו אני אפטר לגמרי מהסינוס:</p>
<p><span class="math">\(\cos\left(\theta+\varphi\right)+\cos\left(\theta-\varphi\right)=2\cos\theta\cos\varphi\)</span> <br />
ואם אני אעביר אגף אני אקבל</p>
<p><span class="math">\(\cos\left(\theta+\varphi\right)=2\cos\theta\cos\varphi-\cos\left(\theta-\varphi\right)\)</span> <br />
יופי. עכשיו אפשר להציב <span class="math">\(\varphi=2\theta\)</span> ולקבל:</p>
<p><span class="math">\(\cos\left(3\theta\right)=2\cos\theta\cos\left(2\theta\right)-\cos\theta\)</span> <br />
וזו התקדמות! כי את <span class="math">\(\cos\left(2\theta\right)\)</span> אנחנו כבר יודעים לייצג בתור פולינום, אז יש לנו... רקורסיה! בואו נמצא את הנוסחה הכללית של הרקורסיה על ידי חזרה על הטריק של <span class="math">\(\cos\left(\theta+\varphi\right)\)</span> , רק במקום <span class="math">\(\varphi=2\theta\)</span> נציב <span class="math">\(\varphi=n\theta\)</span> עבור <span class="math">\(n\gt 1\)</span> כלשהו, ונקבל</p>
<p><span class="math">\(\cos\left(\left(n+1\right)\theta\right)=2\cos\theta\cos\left(n\theta\right)-\cos\left(\left(n-1\right)\theta\right)\)</span> <br />
וזה מוכיח לי את התוצאה הבאה: אם אני מגדיר סדרת פולינומים <span class="math">\(T_{n}\left(x\right)\)</span> <br />
על ידי</p>
<p><span class="math">\(T_{0}\left(x\right)=1\)</span></p>
<p><span class="math">\(T_{1}\left(x\right)=x\)</span></p>
<p><span class="math">\(T_{n+1}\left(x\right)=2xT_{n}\left(x\right)-T_{n-1}\left(x\right)\)</span> <br />
אז הסדרה תקיים <span class="math">\(\cos\left(n\theta\right)=T_{n}\left(\cos\theta\right)\)</span> . הפולינומים <span class="math">\(T_{n}\)</span> הללו נקראים <strong>פולינומי צ'בישב מן הסוג הראשון</strong>.</p>
<p>האם זו הסדרה שקיבלנו עם הלפלסיאן שלנו?! אה... לא. הנה מה שקיבלנו:</p>
<p><span class="math">\(p_{0}\left(x\right)=1\)</span></p>
<p><span class="math">\(p_{1}\left(x\right)=x-1\)</span></p>
<p><span class="math">\(p_{k}\left(x\right)=\left(x-2\right)p_{k-1}\left(x\right)-p_{k-2}\left(x\right)\)</span> <br />
עבור <span class="math">\(2\le k\lt n\)</span> .</p>
<p>זה <strong>דומה</strong> אבל זה בוודאי לא זהה. יש כאן בהחלט הליכה של שני צעדים אחורה וחיסור של הפולינום של השני צעדים אחורה, אבל הכפל פה ב-<span class="math">\(x-2\)</span> <br />
ולא ב-<span class="math">\(2x\)</span> . השאלה היא האם זה הבדל מהותי או שאפשר למצוא דרך לבטא את הפולינומים שלנו בעזרת צ'בישב - ובהחלט יש דרך כזו. הנה דרך מסודרת לעשות את זה על ידי ניחוש מושכל.</p>
<p>מה שאני מנחש הוא שעבור <span class="math">\(k\lt n\)</span> מתקיים <span class="math">\(p_{k}\left(x\right)=T_{k}\left(Ax+B\right)\)</span> , כלומר אני לוקח <strong>העתקה לינארית</strong>("אפינית" למי שרוצים להתקטנן) של הפרמטר של <span class="math">\(T\)</span> ובודק מה משתלם לי שהמקדמים <span class="math">\(A,B\)</span> יצאו. אני יודע שתחת ההנחה הזו מתקיים:</p>
<p><span class="math">\(T_{k}\left(Ax+B\right)=2\left(Ax+B\right)T_{k-1}\left(Ax+B\right)-T_{k-2}\left(Ax+B\right)=\left(2Ax+2B\right)p_{k-1}\left(x\right)-p_{k-2}\left(x\right)\)</span> ולכן עם השוואה לנוסחת הנסיגה שכבר ראיתי עבור <span class="math">\(p_{k}\left(x\right)\)</span> אני אקבל</p>
<p><span class="math">\(\left(x-2\right)p_{k-1}\left(x\right)-p_{k-2}\left(x\right)=\left(2Ax+2B\right)p_{k-1}\left(x\right)-p_{k-2}\left(x\right)\)</span> <br />
כלומר, אני צריך שיתקיים <span class="math">\(x-2=2Ax+2B\)</span> , אז יהיה לי הכי פשוט לבחור <span class="math">\(A=\frac{1}{2}\)</span> ו-<span class="math">\(B=-1\)</span> , כלומר לקוות שמתקיים</p>
<p><span class="math">\(p_{k}\left(x\right)=T_{k}\left(\frac{x-2}{2}\right)\)</span> <br />
לרוע המזל, זה לא קורה. אמנם נוסחת הנסיגה כן עובדת, אבל מה עם תנאי ההתחלה? אמנם <span class="math">\(T_{0}\left(\frac{x-2}{2}\right)=1=p_{0}\left(x\right)\)</span> אבל <span class="math">\(p_{1}\left(x\right)=x-1\)</span> ולעומת זאת <span class="math">\(T_{1}\left(\frac{x-2}{2}\right)=\frac{x-2}{2}\)</span> . החלוקה הזו ב-2 מקלקלת לנו קצת את הסיפור, אבל למרבה המזל אפשר לפתור את זה בקלות על ידי מעבר לפולינומי צ'בישב <strong>מן הסוג השני</strong>. זו סדרה שמוגדרת כמעט כמו הסוג הראשון, כולל אותה נוסחת נסיגה בדיוק, אבל אחד מתנאי ההתחלה טיפה שונה:</p>
<p><span class="math">\(U_{0}\left(x\right)=1\)</span></p>
<p><span class="math">\(U_{1}\left(x\right)=2x\)</span></p>
<p><span class="math">\(U_{n+1}\left(x\right)=2xU_{n}\left(x\right)-U_{n-1}\left(x\right)\)</span> <br />
כלומר ההבדל היחיד הוא ה-2 ב-<span class="math">\(U_{1}\left(x\right)=2x\)</span> . זה נותן לנו:</p>
<p><span class="math">\(U_{1}\left(\frac{x-2}{2}\right)=x-2\)</span> <br />
וזה... עדיין לא מה שאנחנו צריכים! כי אנחנו רוצים את <span class="math">\(p_{1}\left(x\right)=x-1\)</span> ! אבל אפשר להוסיף פה אקסטרה התחכמות אם שמים לב לכך ש-<span class="math">\(U_{0}\left(\frac{x-2}{2}\right)=1\)</span> , כלומר</p>
<p><span class="math">\(U_{1}\left(\frac{x-2}{2}\right)+U_{0}\left(\frac{x-2}{2}\right)=x-1=p_{1}\left(x\right)\)</span> <br />
ואם נסמן <span class="math">\(U_{-1}\left(x\right)=0\)</span> נקבל גם</p>
<p><span class="math">\(U_{0}\left(\frac{x-2}{2}\right)+U_{-1}\left(\frac{x-2}{2}\right)=1=p_{0}\left(x\right)\)</span> <br />
מה שיפה הוא שצירוף לינארי של אובייקטים שמקיימים נוסחת נסיגה יקיים את אותה נוסחת הנסיגה. אז נקבל באופן כללי:</p>
<p><span class="math">\(p_{k}\left(x\right)=U_{k}\left(\frac{x-2}{2}\right)+U_{k-1}\left(\frac{x-2}{2}\right)\)</span> <br />
ולסיום:</p>
<p><span class="math">\(L_{G}=\left(x-1\right)p_{n-1}\left(x\right)-p_{n-2}\left(x\right)=\)</span></p>
<p><span class="math">\(=\left(x-1\right)U_{n-1}\left(\frac{x-2}{2}\right)+\left(x-1\right)U_{n-2}\left(\frac{x-2}{2}\right)-U_{n-2}\left(\frac{x-2}{2}\right)-U_{n-3}\left(\frac{x-2}{2}\right)=\)</span></p>
<p><span class="math">\(=\left(x-1\right)U_{n-1}\left(\frac{x-2}{2}\right)+\left(x-2\right)U_{n-2}\left(\frac{x-2}{2}\right)-U_{n-3}\left(\frac{x-2}{2}\right)\)</span> <br />
הגענו עכשיו לביטוי שאפשר לפשט חלק נכבד ממנו, אם כי אולי קשה לראות את זה כרגע. ניקח את החלק הזה:</p>
<p><span class="math">\(\left(x-2\right)U_{n-2}\left(\frac{x-2}{2}\right)-U_{n-3}\left(\frac{x-2}{2}\right)\)</span> <br />
וכדי שיהיה ברור מה אפשר לעשות פה, נסמן <span class="math">\(t=\frac{x-2}{2}\)</span> , כלומר קיבלנו</p>
<p><span class="math">\(2tU_{n-2}\left(t\right)-U_{n-3}\left(t\right)=U_{n-1}\left(t\right)=U_{n-1}\left(\frac{x-2}{2}\right)\)</span> <br />
כלומר, קיבלנו</p>
<p><span class="math">\(\left(x-1\right)U_{n-1}\left(\frac{x-2}{2}\right)+\left(x-2\right)U_{n-2}\left(\frac{x-2}{2}\right)-U_{n-3}\left(\frac{x-2}{2}\right)=\)</span></p>
<p><span class="math">\(=\left(x-1\right)U_{n-1}\left(\frac{x-2}{2}\right)+U_{n-1}\left(\frac{x-2}{2}\right)=xU_{n-1}\left(\frac{x-2}{2}\right)\)</span> <br />
אחרי כל המהומה הזו, הנוסחה הסופית כמעט טריוויאלית: <span class="math">\(L_{G}=xU_{n-1}\left(\frac{x-2}{2}\right)\)</span> . גם אם איבדתם אותי בדרך, זה מה שאנחנו צריכים - קיבלנו שהלפלסיאן של השרוך מאורך <span class="math">\(n\)</span> הוא <span class="math">\(xU_{n-1}\left(\frac{x-2}{2}\right)\)</span> כש-<span class="math">\(U_{n-1}\)</span> הוא פולינום צ'בישב מן הסוג השני. עכשיו השאלה היא רק מה הערכים העצמיים של זה - כלומר, מה השורשים של הפולינום הזה. בבירור 0 הוא שורש - זו המשמעות של הכפל ב-<span class="math">\(x\)</span> , אבל כבר ידענו ש-0 הוא שורש. שאר השורשים הם השורשים של <span class="math">\(U_{n-1}\left(\frac{x-2}{2}\right)\)</span> - כלומר, אם <span class="math">\(t\)</span> הוא שורש של <span class="math">\(U_{n-1}\)</span> אז נסמן <span class="math">\(t=\frac{x-2}{2}\)</span> ונקבל ש-<span class="math">\(x=2t+2\)</span> הוא שורש של <span class="math">\(L_{G}\)</span> .</p>
<p>מי השורשים של פולינומי צ'בישב? קל להבין את זה עבור <span class="math">\(T_{n}\)</span> , הפולינום מהסוג הראשון. ראינו איך הוא נבנה בצורה שתבטיח שיתקיים הדבר הבא:</p>
<p><span class="math">\(T_{n}\left(\cos\theta\right)=\cos\left(n\theta\right)\)</span> <br />
כאן <span class="math">\(T_{n}\)</span> הוא פולינום ממעלה <span class="math">\(n\)</span> ולכן יש לו <span class="math">\(n\)</span> שורשים לכל היותר - ומהנוסחה הזו קל למצוא <span class="math">\(n\)</span> שורשים שונים שכאלו. קוסינוס זו פונקציה שאנחנו מבינים מצוין ויודעים בדיוק איפה השורשים שלה - <span class="math">\(\cos\left(x\right)=0\)</span> <br />
אם ורק אם <span class="math">\(x=\frac{\pi}{2}+k\pi\)</span> כאשר <span class="math">\(k\in\mathbb{Z}\)</span> (<a href="https://gadial.net/2010/03/31/sine_and_cosine_via_ode/">הנה פוסט שלי</a> על סינוסים וקוסינוסים שממנו אפשר להבין את זה) ואת זה אפשר לכתוב גם בתור <span class="math">\(x=\left(2k+1\right)\frac{\pi}{2}\)</span> . אז בואו נסתכל על סדרה <span class="math">\(\theta_{0},\theta_{1},\ldots,\theta_{n-1}\)</span> של ערכים כך ש-<span class="math">\(\theta_{k}=\frac{2k+1}{n}\frac{\pi}{2}\)</span> ; מובטח לנו ש-</p>
<p><span class="math">\(T_{n}\left(\cos\left(\theta_{k}\right)\right)=\cos\left(n\theta_{k}\right)=\cos\left(\left(2k+1\right)\frac{\pi}{2}\right)=0\)</span> <br />
כדי לראות שכל השורשים הללו שונים זה מזה, נשים לב לכך ש-<span class="math">\(\theta_{0}=\frac{\pi}{2}\)</span> <br />
ו-<span class="math">\(\theta_{n-1}=\frac{2n-1}{n}\frac{\pi}{2}\lt \pi\)</span> , כלומר כל ה-<span class="math">\(\theta\)</span> -ות הללו חיות בתוך הקטע <span class="math">\(\left[\frac{\pi}{2},\pi\right]\)</span> שבו <span class="math">\(\cos\)</span> <br />
היא פונקציה מונוטונית יורדת - ולכן <span class="math">\(\cos\left(\theta_{0}\right),\ldots\cos\left(\theta_{n-1}\right)\)</span> <br />
הם כולם ערכים שונים זה מזה, ומכאן שאלו כל השורשים של <span class="math">\(T_{n}\)</span> .</p>
<p>יופי, אבל רצינו את <span class="math">\(U_{n}\)</span> . פשוט קל יותר להבין את <span class="math">\(T_{n}\)</span> . השאלה היא איזו נוסחה דמויית <span class="math">\(T_{n}\left(\cos\theta\right)=\cos\left(n\theta\right)\)</span> מתקיימת עבור <span class="math">\(U_{n}\)</span> . אז בואו ננסה להבין את זה - מהו <span class="math">\(U_{n}\left(\cos\theta\right)\)</span> ?</p>
<p>ראשית, <span class="math">\(U_{0}\left(\cos\theta\right)=1\)</span> , זה בדיוק כמו עם <span class="math">\(T_{0}\)</span> . ההבדל הוא ב-<span class="math">\(U_{1}\left(x\right)=2x\)</span> . כלומר, <span class="math">\(U_{1}\left(\cos\theta\right)=2\cos\theta\)</span> . עכשיו, מה אני אמור לעשות עם <span class="math">\(2\cos\theta\)</span> ? את מה זה מזכיר לי? ובכן, זה מזכיר לי במעורפל את הזהות הטריגונומטרית</p>
<p><span class="math">\(\sin2\theta=2\sin\theta\cos\theta\)</span> <br />
כלומר:</p>
<p><span class="math">\(2\cos\theta=\frac{\sin2\theta}{\sin\theta}\)</span> <br />
כאשר כאן סימן החילוק מסתיר את המקרה הפרטי המיוחד שבו <span class="math">\(\theta=\pi k\)</span> , מה שמאפס גם את המונה וגם את המכנה. במקרה הזה אני פשוט מגדיר <span class="math">\(\frac{\sin2\theta}{\sin\theta}=2\)</span> (יש לזה הצדקה - קל לראות עם כלל לופיטל ש-<span class="math">\(\lim_{\theta\to\pi k}\frac{\sin2\theta}{\sin\theta}=2\)</span> ).</p>
<p>אז קיבלנו:</p>
<p><span class="math">\(U_{1}\left(\cos\theta\right)=\frac{\sin2\theta}{\sin\theta}\)</span> <br />
וגם מתקיים</p>
<p><span class="math">\(U_{0}\left(\cos\theta\right)=\frac{\sin\theta}{\sin\theta}\)</span> <br />
האם זה משהו שיכול להמשיך עם הרקורסיה הרגילה של פולינומי צ'בישב? ננסה להוכיח באינדוקציה ש-<span class="math">\(U_{n}\left(\cos\theta\right)=\frac{\sin\left(\left(n+1\right)\theta\right)}{\sin\theta}\)</span> :</p>
<p><span class="math">\(U_{n}\left(\cos\theta\right)=2\cos\theta U_{n-1}\left(\cos\theta\right)-U_{n-2}\left(\cos\theta\right)=\)</span></p>
<p><span class="math">\(=2\cos\theta\frac{\sin\left(n\theta\right)}{\sin\theta}-\frac{\sin\left(\left(n-1\right)\theta\right)}{\sin\theta}=\frac{2\cos\theta\sin\left(n\theta\right)-\sin\left(\left(n-1\right)\theta\right)}{\sin\theta}\)</span> <br />
עכשיו נשתמש בזהות <span class="math">\(2\cos\theta\sin\varphi=\sin\left(\theta+\varphi\right)+\sin\left(\varphi-\theta\right)\)</span> <br />
כדי לקבל</p>
<p><span class="math">\(\frac{2\cos\theta\sin\left(n\theta\right)-\sin\left(\left(n-1\right)\theta\right)}{\sin\theta}=\frac{\sin\left(\left(n+1\right)\theta\right)+\sin\left(\left(n-1\right)\theta\right)-\sin\left(\left(n-1\right)\theta\right)}{\sin\theta}=\frac{\sin\left(\left(n+1\right)\theta\right)}{\sin\theta}\)</span> <br />
הצלחה! אז קיבלנו את הנוסחה <span class="math">\(U_{n}\left(\cos\theta\right)=\frac{\sin\left(\left(n+1\right)\theta\right)}{\sin\theta}\)</span> . אנחנו כזכור רוצים את השורשים של <span class="math">\(U_{n-1}\left(\cos\theta\right)=\frac{\sin\left(n\theta\right)}{\sin\theta}\)</span> <br />
מה שטיפה מפשט לנו את הכתיבה - כל מה שאנחנו צריכים הוא למצוא מה <span class="math">\(n-1\)</span> <br />
הערכים שמאפסים את <span class="math">\(\sin\left(n\theta\right)\)</span> ולא מאפסים את <span class="math">\(\sin\theta\)</span> . סינוס הוא קל יותר מקוסינוס - הוא מתאפס בכל <span class="math">\(\theta=\pi k\)</span> , ולכן אנחנו צריכים את השורשים <span class="math">\(\theta_{1},\ldots,\theta_{n-1}\)</span> המוגדרים על ידי <span class="math">\(\frac{k}{n}\pi\)</span> . מצאנו את היעד שלנו! הערכים שמאפסים את <span class="math">\(U_{n-1}\)</span> הם מהצורה <span class="math">\(\cos\left(\frac{k}{n}\pi\right)\)</span> ולכן הערכים שמאפסים את <span class="math">\(L_{G}\)</span> הם מהצורה <span class="math">\(2\cos\left(\frac{k}{n}\pi\right)+2\)</span> . אלו הערכים העצמיים שחיפשתי!</p>
<p>...</p>
<p>בואו נפשט את זה עוד קצת.</p>
<p>בגדול מה שמפריע לי, כי אני ממש קטנוני, זה שיש לנו ביטוי עם חיבור. לא רוצה. כדי לפשט את זה אני שוב פושט על רשימת הזהויות הטריגונומטריות ומחפש משהו שיעזור לי. למרבה השמחה, יש כזה:</p>
<p><span class="math">\(\cos^{2}x=\frac{1+\cos2x}{2}\)</span> <br />
או במילים אחרות:</p>
<p><span class="math">\(1+\cos2x=2\cos^{2}x\)</span> <br />
נכפול את הכל ב-<span class="math">\(2\)</span> ונקבל באגף שמאל בדיוק את מה שרציתי לפשט:</p>
<p><span class="math">\(2\cos2x+2=4\cos^{2}x\)</span> <br />
עכשיו נציב <span class="math">\(x=\frac{k\pi}{2n}\)</span> ונקבל:</p>
<p><span class="math">\(2\cos\left(\frac{k}{n}\pi\right)+2=4\cos^{2}\left(\frac{k\pi}{2n}\right)\)</span> <br />
וזהו! זה מה שהבטחתי בהתחלה! הערכים העצמיים של <span class="math">\(L_{P_{n}}\)</span> עבור השרוך מאורך <span class="math">\(n\)</span> הם 0 וכל הערכים מהצורה <span class="math">\(4\cos^{2}\left(\frac{k\pi}{2n}\right)\)</span> <br />
עבור <span class="math">\(1\le k\le n-1\)</span> . זה מסיים את כל ההוכחות הכבדות ומשאיר רק את הסיכום.</p>
<h2>אז מה ראינו פה בעצם?</h2>
<p>זה היה פוסט ארוך ועמוס בשלל נושאים, אז רגע לפני הסיום בואו נעשה סיכום של מה שהלך פה בעצם. 1. רצינו לספור כמה מבוכים יש מסדר <span class="math">\(n\times m\)</span> (עבור הגדרה ספציפית של "מבוך").</p>
<ol>
<li>
<p>ראינו שזו בעיה שקולה לבעיה של ספירת עצים פורשים של גרף <span class="math">\(G\)</span> מסוים.</p>
</li>
<li>
<p>ראינו שספירת עצים פורשים שקולה לבעיה של חישוב דטרמיננטה של מינור של הלפלסיאן <span class="math">\(L_{G}\)</span> .</p>
</li>
<li>
<p>ראינו שכדי לחשב את הדטרמיננטה הזו מספיק למצוא את הערכים העצמיים השונים מאפס של <span class="math">\(L_{G}\)</span> .</p>
</li>
<li>
<p>ראינו ש-<span class="math">\(G=P_{n}\square P_{m}\)</span> כש-<span class="math">\(\square\)</span> הוא הסימון למכפלה של גרפים.</p>
</li>
<li>
<p>ראינו שנובע מזה ש-<span class="math">\(L_{G}=L_{P_{n}}\oplus L_{P_{m}}\)</span> כש-<span class="math">\(\oplus\)</span> <br />
הוא הסימון של סכום קרונקר של מטריצות.</p>
</li>
<li>
<p>ראינו שנובע מזה שהערכים העצמיים של <span class="math">\(L_{G}\)</span> הם סכומים של הערכים העצמיים של <span class="math">\(L_{P_{n}},L_{P_{m}}\)</span> .</p>
</li>
<li>
<p>ראינו שהערכים העצמיים של <span class="math">\(L_{P_{n}}\)</span> ששונים מאפס הם מהצורה <span class="math">\(4\cos^{2}\left(\frac{k\pi}{2n}\right)\)</span> <br />
עבור <span class="math">\(k=1,2,\ldots,n-1\)</span> .</p>
</li>
</ol>
<p>בואו נרכיב את כל זה ביחד כדי לקבל את הנוסחה שפותרת את הבעיה. ראשית, מה שראינו בשלב 4 הוא זה: שאם הערכים העצמיים של הלפלסיאן הם <span class="math">\(0=\lambda_{0},\lambda_{1},\ldots,\lambda_{t-1}\)</span> אז הדטרמיננטה של כל מינור שלו היא <span class="math">\(\frac{1}{t}\lambda_{1}\cdots\lambda_{t-1}\)</span> - מכפלת כל הערכים העצמיים חוץ מ-0, וחלוקה ב-<span class="math">\(t\)</span> שהוא המספר הכולל של ערכים עצמיים.</p>
<p>עכשיו, נסמן את הערכים העצמיים של <span class="math">\(P_{n}\)</span> ב-<span class="math">\(0=\tau_{0},\tau_{1},\ldots,\tau_{n-1}\)</span> . בואו נשתמש בתוצאה על מכפלת הערכים העצמיים השונים מאפס על הגרף <strong>הזה</strong>. זה גרף שרוך, ושרוך הוא בעצמו עץ, כלומר קיים לו בדיוק עץ פורש יחיד - זה אומר שמתקיים <span class="math">\(\frac{1}{n}\prod_{k=1}^{n-1}\tau_{k}=1\)</span> . באופן דומה עבור <span class="math">\(P_{m}\)</span> נסמן את הערכים העצמיים ב-<span class="math">\(0=\rho_{0},\rho_{1},\ldots,\rho_{m-1}\)</span> ונקבל שמתקיים <span class="math">\(\frac{1}{m}\prod_{h=1}^{m-1}\tau_{h}=1\)</span> . שני אלו הולכים לסייע לי עוד מעט.</p>
<p>עכשיו מצאנו את הערכים המפורשים של הערכים העצמיים הללו בשלב 8 ועוד נציב אותם, אבל זה יהיה בהמשך. בינתיים נשתמש בשלב 7 כדי להסיק שמתקיים ש-<span class="math">\(t=mn\)</span> , ושכל ערך עצמי הוא מהצורה <span class="math">\(\lambda_{kh}=\tau_{k}+\rho_{h}\)</span> <br />
עבור <span class="math">\(0\le k\lt n\)</span> ו-<span class="math">\(0\le h\lt m\)</span> . אז בעצם יש לנו שלושה סוגים שונים של ערכים עצמיים: - הערך העצמי <span class="math">\(\lambda_{00}=\tau_{0}+\rho_{0}=0\)</span> - לא מפתיע שהוא קיים, לכל לפלסיאן יש ערך עצמי 0.</p>
<ul>
<li>הערכים העצמיים מהצורה <span class="math">\(\lambda_{k0}=\tau_{k}\)</span> ו-<span class="math">\(\lambda_{0h}=\rho_{h}\)</span> </li>
<li>
<p>אלו שהם פשוט הערכים העצמיים של אחד משני הגרפים <span class="math">\(P_{n},P_{m}\)</span> .</p>
</li>
<li>
<p>כל היתר: <span class="math">\(\lambda_{kh}=\tau_{k}+\rho_{h}\)</span> עבור <span class="math">\(1\le k\lt n\)</span> ו-<span class="math">\(1\le h\lt m\)</span> .</p>
</li>
</ul>
<p>עכשיו נציב ב-<span class="math">\(\frac{1}{t}\lambda_{1}\cdots\lambda_{t-1}\)</span> את כל הערכים העצמיים חוץ מ-<span class="math">\(\lambda_{00}\)</span> שלא משתתף בנוסחה הזו, כשבמקום אינדקס רץ בודד <span class="math">\(t\)</span> אני משתמש באינדקסים <span class="math">\(k,h\)</span> כמו קודם. אבל - אני אפריד את הערכים העצמיים מהצורה <span class="math">\(\lambda_{0h},\lambda_{k0}\)</span> מכל היתר. נקבל:</p>
<p><span class="math">\(\frac{1}{mn}\prod_{k=1}^{n-1}\lambda_{k0}\cdot\prod_{h=1}^{m-1}\lambda_{0m}\cdot\prod_{k=1}^{n-1}\prod_{h=1}^{m-1}\lambda_{hk}\)</span> <br />
עכשיו, מה זה <span class="math">\(\prod_{k=1}^{n-1}\lambda_{k0}\)</span> ? זו פשוט המכפלה <span class="math">\(\prod_{k=1}^{n-1}\tau_{k}\)</span> של כל הערכים העצמיים השונים מאפס <strong>של הגרף</strong><span class="math">\(P_{n}\)</span> . אם נכפול אותה ב-<span class="math">\(\frac{1}{n}\)</span> שנמצא שם נקבל <span class="math">\(\frac{1}{n}\prod_{k=1}^{n-1}\tau_{k}=1\)</span> . באופן דומה נשתמש גם ב-<span class="math">\(\frac{1}{m}\prod_{h=1}^{m-1}\tau_{h}=1\)</span> , ועכשיו הביטוי הפך להיות משמעותית יותר פשוט:</p>
<p><span class="math">\(\prod_{k=1}^{n-1}\prod_{h=1}^{m-1}\lambda_{hk}=\prod_{k=1}^{n-1}\prod_{h=1}^{m-1}\left(\tau_{k}+\rho_{h}\right)\)</span> <strong>עכשיו</strong> זה זמן טוב להציב את הערכים המפורשים:</p>
<p><span class="math">\(\prod_{k=1}^{n-1}\prod_{h=1}^{m-1}\left(4\cos^{2}\left(\frac{k\pi}{2n}\right)+4\cos^{2}\left(\frac{h\pi}{2m}\right)\right)\)</span> <br />
וזהו! קיבלנו את הנוסחה מתחילת הפוסט!</p>
<p><span class="math">\(T\left(n,m\right)=\prod_{k=1}^{n-1}\prod_{h=1}^{m-1}\left(4\cos^{2}\left(\frac{k\pi}{2n}\right)+4\cos^{2}\left(\frac{h\pi}{2m}\right)\right)\)</span> <br />
האם סיימנו? סוג של... יש לנו נוסחה סגורה יפה, אבל אני עדיין רוצה <strong>לחשב</strong> את הפתרון למקרה הקונקרטי שלי, <span class="math">\(423\times855\)</span> . אם אני אנסה סתם לחשב את זה בפייתון זה לא יעבוד - הולכים לצאת מספרים גדולים מדי והוא לא יצליח לעבוד איתם (כשאני עובד עם הספרייה numpy אני אקבל את התוצאה המרגשת np.float64)inf( - ניסיתי). </p>
<p>אז אני אשתמש בטריק אחד אחרון ואוציא <strong>לוגריתם</strong> לשני האגפים. היופי בלוגריתמים הוא שהם הופכים מכפלות לסכומים, ולכן המספר שאני אקבל יהיה קטן משמעותית:</p>
<p><span class="math">\(\log T\left(n,m\right)=\sum_{k=1}^{n-1}\sum_{h=1}^{m-1}\log\left(4\cos^{2}\left(\frac{k\pi}{2n}\right)+4\cos^{2}\left(\frac{h\pi}{2m}\right)\right)\)</span> <br />
אבל מה המשמעות של מספר כזה? בואו ניקח לדוגמא את <span class="math">\(17,138,194\)</span> <br />
וניקח לו לוגריתם על בסיס 10 (שאני פשוט אסמן ב-<span class="math">\(\log\)</span> ):</p>
<p><span class="math">\(\log17138194=7.233965054625744\)</span> <br />
מה שקיבלנו פה הוא בעצם שני מספרים: ה-7 מספר לנו כמה ספרות יש במספר שלנו - יותר במדויק, הוא אומר שהמספר שלנו גדול מ-<span class="math">\(10^{7}\)</span> <br />
אבל קטן מ-<span class="math">\(10^{8}\)</span> , כלומר יש בו 8 ספרות (הוא קטן יותר מ-1 שאחריו 8 אפסים, כלומר המספר הקטן ביותר עם 9 ספרות). כל ה-<span class="math">\(.233965054625744\)</span> שאחרי הנקודה מספר לנו בכמה צריך לכפול את <span class="math">\(10^{7}\)</span> כדי "לתקן" אותו ולקבל את המספר המדויק <span class="math">\(17138194\)</span> . ליתר דיוק, לא צריך לכפול את <span class="math">\(10^{7}\)</span> במספר הזה אלא ב-10 בחזקת המספר הזה, מה שיוצא <strong>בערך</strong>  <span class="math">\(1.7138194\)</span> . למה זה עובד? פשוט כי אם באופן כללי <span class="math">\(\log a=n+x\)</span> כאשר <span class="math">\(n\in\mathbb{N}\)</span> ו-<span class="math">\(0\le x\lt 1\)</span> , אז </p>
<p><span class="math">\(a=10^{\log a}=10^{n+x}=10^{n}\cdot10^{x}\)</span> <br />
מכיוון ש-<span class="math">\(x\lt 1\)</span> אז <span class="math">\(10^{x}\)</span> הוא מספר קטן מ-10. זה מוביל אותנו לשיטה שבה אוהבים לתאר מספרים גדולים בצורה לא מדויקת: אם נסמן <span class="math">\(m=10^{x}\)</span> , אז נקבל <span class="math">\(a=m\cdot10^{n}\)</span> - כאן המספר <span class="math">\(m\)</span> נקרא <strong>מנטיסה</strong> ואילו <span class="math">\(n\)</span> נקרא <strong>אקספוננט</strong> ובמחשב נכתוב דברים כמו "1.7138e7" כדי לתאר את זה. אז אני לא באמת צריך לחשב את המספר המפלצתי שלי - אני צריך לחשב את הלוגריתם שלו, לקחת את הערך השלם שלו בתור האקספוננט, להעלות בחזקת 10 את היתר ולקבל את המנטיסה, להדפיס את זה יפה וסיימנו.</p>
<p>הנה קוד פייתון שמבצע את כל החישוב ב-4 שניות במחשב המקרטע שלי:</p>
<pre class="highlight"><code class="language-python">import numpy as np
import itertools
n = 423
m = 855
vals = [np.log10(4*(np.cos(k*np.pi/(2*n)))**2 + 4*(np.cos(h*np.pi/(2*m)))**2)
 for (k,h) in itertools.product(range(1,n), range(1,m))
 ]
a = sum(vals)
n = int(a)
m = 10**(a - n)
print(f&quot;{m}e{n}&quot;)
</code></pre>

<p>והתוצאה היא... תחזיקו חזק... זה:</p>
<p>3.142182277684719e182690</p>
<p>מה המספר הזה אומר, בעצם? כלום. פשוט כלום. אני לא רואה שום דבר שאפשר לעשות עם הידע הזה. זה סתם רצף אקראי של ספרות. אבל מה שיפה זה שאם אחרים ינסו לבצע את אותו חישוב, אבל בשיטות השונות שלהם, בסופו של דבר נגיע לאותו רצף ספרות אקראי ותתחזק אצלנו עוד יותר התחושה שמה שעשינו הוא נכון - שהנוסחה המגוחכת שהגענו אליה היא נכונה.</p>
<p>בואו נסתכל עליה שוב:</p>
<p><span class="math">\(\log T\left(n,m\right)=\sum_{k=1}^{n-1}\sum_{h=1}^{m-1}\log\left(4\cos^{2}\left(\frac{k\pi}{2n}\right)+4\cos^{2}\left(\frac{h\pi}{2m}\right)\right)\)</span> <br />
אם היו שואלים אותי על מבוכים לפני שהכרתי את כל הסיפור הזה ואז מראים לי את הנוסחה, הייתי חושב שהעולם השתגע ולא מבין מאיפה זה בא בכלל. אז בפוסט הזה ראינו בפירוט ניכר בדיוק מאיפה זה בא בכלל, ועכשיו אני מרגיש די מיודד עם הנוסחה הזו ועם מבוכים באופן כללי. כנראה שהנוסחה האמיתית הייתה המתמטיקה שפגשנו בדרך.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>