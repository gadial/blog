<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NL=coNL (&#34;משפט אימרמן&#34;) - מי, מה, כמה ולמה - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                text-align: center;
                margin-bottom: 10px;
            }
            
            .top-nav .nav-links {
                flex-direction: column;
                width: 100%;
            }
            
            .top-nav .nav-links a {
                text-align: center;
                padding: 8px;
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2011/03/01/communication_complexity/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">מה זו סיבוכיות תקשורת?</span>
            </a>
            

            
            <a href="/2011/03/17/ip_equals_pspace_overview/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">אז מה זה IP=PSPACE?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>NL=coNL (&#34;משפט אימרמן&#34;) - מי, מה, כמה ולמה</h1>
            <div class="post-meta">
                <span class="date">2011-03-05</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/סיבוכיות זכרון.html">סיבוכיות זכרון</a>
                    
                    <a href="/tags/פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;.html">פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;</a>
                    
                    <a href="/tags/תוצאות לא אינטואיטיביות.html">תוצאות לא אינטואיטיביות</a>
                    
                    <a href="/tags/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בשעה טובה אנו עוברים לתיאור התוצאה השניה ב"<a href="http://www.gadial.net/2011/01/09/surprising_results_in_complexity_prologue/">תוצאות מפתיעות בסיבוכיות</a>" - הטענה <span class="math">\(\text{NL=coNL}\)</span>, או בשמה הקליט יותר, משפט אימרמן-סזלפסני (Immerman–Szelepcsényi - אין לי מושג איך לתעתק נכון), ומכאן ואילך - משפט אימרמן. אז על מה מדובר בכלל?</p>
<p>ראשית כל תזכורת כללית למה אנחנו עושים בתורת הסיבוכיות. המטרה היא לסווג בעיות לפי כמות המשאבים הנדרשת כדי לפתור אותן (כמות שנמדדת תמיד ביחס לגודל הקלט שאיתו מנסים להתמודד). לצורך פשטות, אנחנו אוהבים להתעסק במיוחד בבעיות "כן/לא" - בעיות שבהן מביאים לנו קלט מסויים ושואלים אותנו האם הוא מקיים תכונה מסויימת (תכונה שהיא חלק מהגדרת הבעיה). למשל - נתון לנו גרף (מהו גרף? זה ידע קודם שנדרש למי שרוצה לקרוא פוסטים על מדעי המחשב) ושני צמתים בו - <span class="math">\(s,t\)</span> - ואנו רוצים לדעת אם קיים בגרף מסלול מ-<span class="math">\(s\)</span> אל <span class="math">\(t\)</span>. שימו לב לאופי ה"כן/לא"-י של הבעיה - לא ביקשנו לדעת <strong>מהו</strong> המסלול, אלא רק לדעת אם הוא קיים.</p>
<p>ייתכן שנראה לכם קצת מוזר שאפשר יהיה לגלות אם קיים מסלול בלי למצוא אותו במפורש, אבל יש בעיות שבהן זה קצת יותר ברור - למשל, בהינתן מספר <span class="math">\(n\)</span>, לגלות שהוא אינו ראשוני, כלומר קיים מספר בין 1 ל-<span class="math">\(n\)</span> שמחלק אותו - את זה אפשר לבצע ביעילות, בעוד שלא ברור איך אפשר למצוא ביעילות מספר שמחלק את <span class="math">\(n\)</span> (איך? יש כמה שיטות ותיארתי בעבר אחת מהן; אם מוצאים <span class="math">\(a\)</span> כך שבמהלך החישוב של <span class="math">\(a^{n}\)</span> מודולו <span class="math">\(n\)</span> מתגלה שורש יחידה לא טריוויאלי - זה אומר מייד ש-<span class="math">\(n\)</span> אינו ראשוני אף שזה כלל לא רומז על האופן שבו ניתן לפרק אותו).</p>
<p>כפי שמראה הדוגמה שלמעלה, בשאלות "כן/לא" רבות אפשר לתת תשובה חיובית בקלות אם נותנים לכם "רמז" לכך שהתשובה אכן חיובית. למשל, בשאלת הגרף - אם ייתנו לכם את מסלול בין <span class="math">\(s\)</span> ו-<span class="math">\(t\)</span>, החיים יהיו קלים יותר - במקום לחפש מסלול בעצמכם רק תצטרכו לבדוק שהמסלול שנתנו לכם הוא בסדר. שימו לב שאם התשובה היא "לא", לא ממש ברור איזה רמז אפשר לתת שישכנע אתכם בכך שהתשובה היא אכן שלילית.</p>
<p>התופעה הזו, של בעיות שאפשר לתת "רמז" - או בשם היותר מקובל של המונח, "עד", Witness - לכך שהתשובה להן חיובית, כה חשובה עד שזכתה לסימון מיוחד: NP היא מחלקת הבעיות שניתן בזמן חישוב יעיל (יעיל במשמעות של פולינומי - זו הגדרה טכנית שלא אכנס אליה כעת) לבדוק עדים עבור תשובות "כן" שלהן. מה שאנחנו דורשים הוא שני דברים: שאם התשובה היא כן, אז יהיה קיים עד שניתן לבדוק בזמן יעיל ולענות בחיוב, ושאם התשובה היא לא אז אי אפשר לרמות אותנו - כל "עד" שיתנו לנו יוביל לכך שניתן תשובה שלילית, כלומר נצליח לזהות שהעד שנתנו לנו לא שווה כלום. אני אוהב לחשוב על עדים בתור "הוכחות" לנכונות של טענה. השימוש במילה הזו קצת מסוכן כי במתמטיקה אנחנו רגילים לחשוב על הוכחה בתור סדרה של טענות שכל אחת מהן נובעת לוגית מהשנייה; ה"הוכחות" שלי הן משהו יותר כללי - כלי שמאפשר לך לוודא בקלות בעצמך שטענה היא נכונה. הכלי הזה יכול להיות כתוב כמו הוכחה מתמטית רגילה, אבל זה יכול להיות גם מסלול בגרף.</p>
<p>שימו לב לחוסר הסימטריה שהיה בכל ההגדרה הזו של NP. דיברתי על בעיות שיש עדים עבור תשובות <strong>כן</strong> שלהן, אבל כפי שראינו עם דוגמת המסלול, זה לא אומר שלתשובות "לא" יהיה עד באותה קלות. מצד שני, הבה ונתבונן בבעיה הבאה: נתון גרף ושני צמתים <span class="math">\(s,t\)</span> ואנו רוצים לדעת אם <strong>לא</strong> קיים מסלול מ-<span class="math">\(s\)</span> אל <span class="math">\(t\)</span>. כאן יש עד פשוט מאוד לכך שהטענה <strong>אינה</strong> נכונה עבור גרף נתון - פשוט מראים מסלול מ-<span class="math">\(s\)</span> אל <span class="math">\(t\)</span> וזה משכנע אותנו בודאות שהטענה "אין מסלול מ-<span class="math">\(s\)</span> אל <span class="math">\(t\)</span>" איננה נכונה. בוודאי תגידו שאני רמאי עלוב. בסך הכל לקחתי את הבעיה המקורית והפכתי קצת את הניסוח שלה. אבל זו לא באמת רמאות - כל בעיה שבה יש עד לתשובת "לא" אפשר להמיר לבעיה "משלימה" שבה יש עד לתשובת "כן" דווקא.</p>
<p>בואו נעבור לקצת טרמינולוגיה מדוייקת. במקום לדבר כל הזמן על "בעיות", מדעני מחשב מדברים על "שפות". שפה <span class="math">\(L\)</span> היא קבוצה של מילים - מחרוזות סופיות של תווים שמייצגות מידע כלשהו (יכול להיות קידוד של גרף, מספר, קוד של תוכנית מחשב וכדומה - תלוי בהקשר). למשל, אפשר לדבר על השפה שמכילה את כל השלשות <span class="math">\(\left(G,s,t\right)\)</span> של גרף <span class="math">\(G\)</span> עם צמתים <span class="math">\(s,t\)</span> שיש מסלול ביניהם. השפה המשלימה ל-<span class="math">\(L\)</span> מסומנת ב-<span class="math">\(\overline{L}\)</span> - זו שפת כל המחרוזות שאינן ב-<span class="math">\(L\)</span> (מראש אנחנו מניחים שמדובר רק על מחרוזות בינאריות, נאמר, כך שהשאלה מהי "קבוצת כל המחרוזות" שלוקחים משלים ביחס אליה איננה בעייתית). למשל, אם <span class="math">\(L\)</span> היא שפת השלשות <span class="math">\(\left(G,s,t\right)\)</span> שתיארתי קודם, אז <span class="math">\(\overline{L}\)</span> היא שפת השלשות <span class="math">\(\left(G,s,t\right)\)</span> של גרף <span class="math">\(G\)</span> עם צמתים <span class="math">\(s,t\)</span> שאין ביניהם מסלול. אולי תגידו עכשיו שיש גם הרבה מחרוזות שבכלל לא מייצגות שלשה <span class="math">\(\left(G,s,t\right)\)</span> וגם הן אמורות להיות ב-<span class="math">\(\overline{L}\)</span>; כדי להיפרד מהמטרד הלא חשוב הזה נוח להניח שכל מחרוזת שמייצגת ג'יבריש תיחשב על ידינו ככזו שמייצגת איזה קלט טריוויאלי - למשל <span class="math">\(\left(G,s,t\right)\)</span> כאשר <span class="math">\(G\)</span> הוא גרף ששני הצמתים היחידים בו הם <span class="math">\(s,t\)</span> ואין קשתות. הדברים הללו לא קריטייים ממילא ולא אחזור אליהם.</p>
<p>אומרים ש-<span class="math">\(L\in\text{NP}\)</span> אם קיימת מכונת טיורינג <span class="math">\(M\)</span> (ואם "מכונת טיורינג" לא אומר לכם כלום, תחשבו על "אלגוריתם" ותו לא; הסיבה שאומרים מכונת טיורינג במקום אלגוריתם היא אך ורק מכיוון שאין הגדרה מתמטית פורמלית ל"אלגוריתם") כך שאם <span class="math">\(x\in L\)</span> אז קיים <span class="math">\(y\)</span> כלשהו כך ש-<span class="math">\(M\left(x,y\right)=\text{ACCEPT}\)</span>, כלומר <span class="math">\(M\)</span>, כשהיא רצה על הקלטים <span class="math">\(x,y\)</span> יחדיו, מסיימת את ריצה עם הפלט "Accept''; ואם <span class="math">\(x\notin L\)</span> אז לכל <span class="math">\(y\)</span> <span class="math">\(M\left(x,y\right)=\text{REJECT}\)</span>, כלומר <span class="math">\(M\)</span> דוחה כל "נסיון הוכחה" לכך ש-<span class="math">\(x\in L\)</span> במקרה שבו <span class="math">\(x\notin L\)</span>. יש על <span class="math">\(M\)</span> דרישה אחת נוספת - שזמן הריצה שלה יהיה יעיל - פולינומי - ביחס לגודל של <span class="math">\(x\)</span>. הדרישה הזו אוטומטית גם מגבילה את <span class="math">\(y\)</span>; אם <span class="math">\(y\)</span> הוא יותר מאשר פולינומי בגודל של <span class="math">\(x\)</span>, אז <span class="math">\(M\)</span> פשוט לא תספיק לקרוא את כולו. לכן לפעמים כדי לפשט את החיים דורשים מראש ש-<span class="math">\(y\)</span> יהיה פולינומי ב-<span class="math">\(x\)</span>.</p>
<p>כעת אפשר להציג את <span class="math">\(\text{coNP}\)</span>: בפשטות, זו המחלקה של כל המשלימות של שפות ב-<span class="math">\(\text{NP}\)</span>: <span class="math">\(\text{coNP}=\left\{ \overline{L}|L\in\text{NP}\right\} \)</span>. כפי שתיארתי לעיל, זו מחלקת השפות שיש עבורן תהליך-בדיקת-עדים כך שעבור תשובת "לא" קיים <span class="math">\(y\)</span> שמוכיח זאת, ועבור תשובת "כן" אין אף <span class="math">\(y\)</span> שיעבוד עלינו ויגרום לנו לחשוב שהתשובה היא "לא". וכעת לשאלת המחץ: האם <span class="math">\(\text{NP}=\text{coNP}\)</span>?</p>
<p>האם העובדה שקל להוכיח שמשהו הוא "כן" גוררת שיהיה קל להוכיח אם הוא "לא", ולהפך? האם העולם סימטרי ונחמד? זו השאלה. נתון גרף ונשאלת השאלה אם אפשר לצבוע אותו בשלושה צבעים. אם מישהו יתן לי את הצביעה יהיה לי קל לבדוק שהגרף אכן ניתן לצביעה כזו; האם יש דרך פשוטה במידה דומה לשכנע אותי שהגרף לא ניתן ל<strong>שום</strong> צביעה? אםh תוכיחו את זה, הוכחתם כי <span class="math">\(\text{NP=coNP}\)</span>. אני מקווה שאתם מרגישים את חוסר הסימטריה המשווע שיש כאן; הוא הסיבה לכך שהאמונה הרווחת היא ש-<span class="math">\(\text{NP}\ne\text{coNP}\)</span>.</p>
<p>ייתכן שאתם תוהים מה הקשר של השאלה הזו לשאלה המפורסמת ביותר, האם <span class="math">\(\text{P=NP}\)</span> (<span class="math">\(\text{P}\)</span> היא מחלקת השפות שניתן להכריע עם אלגוריתם פולינומי שכלל לא נזקק לעדים). ובכן, אם <span class="math">\(\text{P=NP}\)</span> אז <span class="math">\(\text{NP=coNP=P}\)</span> (וזאת מכיוון ש-<span class="math">\(\text{P}\)</span> סגורה למשלים), אבל אם <span class="math">\(\text{P}\ne\text{NP}\)</span> (וכך סבורים כולם, כמעט) זה לא אומר ש-<span class="math">\(\text{NP}\ne\text{coNP}\)</span>. כך שזו שאלה "עדינה" יותר מאשר <span class="math">\(\text{P}\ne\text{NP}\)</span> והוכחה עבורה תהיה קשה יותר מאשר הוכחה ש-<span class="math">\(\text{P}\ne\text{NP}\)</span> (שכן הוכחה ש-<span class="math">\(\text{NP}\ne\text{coNP}\)</span> תוכיח בפרט ש-<span class="math">\(\text{P}\ne\text{NP}\)</span>).</p>
<p>עכשיו בואו ונבצע שינוי מחשבתי כלשהו. במקום לדבר על יעילות בצריכת משאב ה<strong>זמן</strong>, נדבר על יעילות בצריכת משאב ה<strong>זכרון</strong>. זמן ריצה נמדד במספר הצעדים שנדרשו לחישוב במודל הסטנדרטי של מכונת טיורינג - איך אפשר למדוד צריכת זכרון? הגישה הנאיבית מדברת על מודל של מכונת טיורינג עם סרט בודד שבו ראשית כל נכתב הקלט, ואחריו אפשר לכתוב עוד דברים לפי הצורך. אפשר להגדיר את כמות הזכרון שהמכונה צורכת בתור האינדקס של התא הקיצוני ביותר שאליו המכונה מגיעה במהלך החישוב (במילים אחרות - אם הזכרון היה סופי, מה כמות הזכרון המינימלית שלא הייתה גורמת לתוכנית להתרסק על הקלט הנתון). הבעיה עם הגישה הזו היא שאם התוכנית רוצה <strong>לקרוא</strong> את כל הקלט . (אפילו אם אינה רוצה לכתוב שום דבר) היא צריכה ללכת עד לקצה הקלט וזה כבר יניב שסיבוכיות הזכרון שלה היא לפחות <span class="math">\(\Omega\left(n\right)\)</span>. אלא שכאשר מדובר על סיבוכיות זכרון, סיבוכיות שנחשבת "יעילה" היא דווקא משהו מסדר גודל לוגריתמי ב-<span class="math">\(n\)</span>, ואת זה בשיטה שלנו אי אפשר למדוד בכלל. אז מה עושים?</p>
<p>הפתרון הסטנדרטי הוא להפריד בין הקלט, שנמצא בסרט "לקריאה בלבד" שעליו לא ניתן לכתוב, ובין זכרון העבודה של המכונה שהוא ריק בתחילת ריצתה ובו ניתן לקרוא ולכתוב באופן חופשי. סיבוכיות הזכרון נמדדת רק ביחס לניצול זכרון העבודה הזה. הסיפור מסתבך עוד יותר כשרוצים להכניס לתמונה את האפשר לבדיקת עדים לנכונות טענות - גם העדים נכתבים על סרט משל עצמם שהוא לקריאה בלבד ויותר מכך - לקריאה חד פעמית, במובן זה שהראש הקורא יכול לנוע רק ימינה, אחרת המודל הופך לחזק מדי. למרות כל הברחש הפורמלי הזה, ניתוח סיבוכיות הזכרון של אלגוריתמים הוא בדרך כלל לא מסובך במיוחד.</p>
<p>כעת אפשר להכניס לתמונה סוף סוף את <span class="math">\(\text{NL}\)</span>- זו מחלקת השפות שקיימת מכונה-בודקת-עדים עבורן שפועלת בסיבוכיות זכרון <span class="math">\(O\left(\log n\right)\)</span>. את <span class="math">\(\text{coNL}\)</span> מגדירים באותו אופן כמו <span class="math">\(\text{coNP}\)</span>. לא מדויק עד הסוף לומר שאלו האנלוגים של <span class="math">\(\text{NP}\)</span> ו-<span class="math">\(\text{coNP}\)</span> כי גם סיבוכיות זכרון של <span class="math">\(O\left(\log^{k}n\right)\)</span> ("פולי-לוגריתמית") נחשבת יעילה; אבל שתי המחלקות הללו הן הבסיס. ולכן זו הפתעה לא קטנה כשמתברר שהאנלוג לשאלת <span class="math">\(\text{NP=coNP}\)</span> עבור סיבוכיות זכרון זוכה לתשובה, ותשובה חיובית דווקא - <span class="math">\(\text{NL=coNL}\)</span>, ויותר מכך - לכל מחלקה דומה של סיבוכיות זכרון עבור חסם סיבוכיות גדול יותר, השוויון עדיין מתקיים (פורמלית, <span class="math">\(\text{NSPACE}\left(f\left(n\right)\right)=\text{coNSPACE}\left(f\left(n\right)\right)\)</span> לכל <span class="math">\(f\left(n\right)\ge\log n\)</span> שהיא מה שנקרא Space Constructible, כלומר ניתן לחשב את <span class="math">\(f\left(n\right)\)</span> מתוך <span class="math">\(1^{n}\)</span> תוך שימוש ב-<span class="math">\(f\left(n\right)\)</span> זכרון - זו דרישה טכנית שלא ניכנס כעת אליה). הטענה הוכחה בנפרד בידי אימרמן ובידי סזלפסני, ואין לי מושג מי מהם המציא את ההוכחה שאציג כעת (או אפילו אם מישהו מהם המציא אותה ולא שמדובר על המצאה מאוחרת יותר).</p>
<p>ראשית כל צריך להבין שכמו ש-<span class="math">\(\text{NP}\)</span> קמה ונופלת על הפתרון של בעיות ספציפיות - הבעיות ה-<span class="math">\(\text{NP}\)</span>-שלמות - גם כאן המשפט מסתכם בפתרון מוצלח עבור בעיה ספציפית - בעיית הישיגות בגרף שהזכרתי קודם. בעיית הישיגות היא טריוויאלית לפתרון בזמן יעיל - אלגוריתם DFS פותר אותה חיש קל, בזמן לינארי - אבל פתרון ב<strong>זכרון</strong> לוגריתמי זה סיפור שונה לגמרי - לא מוכר כיום פתרון שכזה עבור גרפים מכוונים (אבל, וזו תוצאה מפתיעה מאוד בפני עצמה וגם חדשה למדי - עבור גרפים <strong>לא מכוונים</strong> יש פתרון).</p>
<p>הסיבה לכך שהבעיה הזו כל כך חשובה היא שניתן לתאר חישובים של מכונות (ובפרט מכונות לבדיקת עדים) על קלט כלשהו באמצעות גרף - <strong>גרף הקונפיגורציות</strong> של המכונה, שכל צומת בו מתאר את המצב הנוכחי של המכונה - תוכן סרט הזכרון, מצב הבקרה הנוכחי, מיקום הראשים הקוראים בכל הסרטים - כל זה מידע שניתן לייצג בזכרון לוגריתמי, כך שניתן לשמור צומת בודד של הגרף בזכרון בכל עת. בגרף יש קשת מצומת א' לצומת ב' אם אפשר להגיע בצעד בודד מהקונפיגורציה א' לקונפיגורציה ב' (השאלה אם זה באמת קורא תלויה בשאלה מה רואים הראשים הקוראים בסרטי הקלט והעד). בפועל בהינתן הקידוד של צומת בגרף, אפשר לחשב בזכרון לוגריתמי את הצמתים שאליהם ניתן לעבור ממנו. לכן השאלה האם המכונה מקבלת קלט כלשהו מצטמצמת לשאלה אם קיים מסלול בגרף הקונפיגורציות שלה מהקונפיגורציה ההתחלתית לאיזו שהיא קונפיגורציה שבה המכונה עוצרת ומקבלת. אפשר להנדס את המכונה כך שתהיה רק קונפיגורציה אחת כזו (למשל, כזו שבה כל סרט העבודה מחוק והראשים הקוראים בתחילת כל הסרטים) ולכן אנחנו מצטמצמים לשאלה האם קיים מסלול בגרף בין שני צמתים - בדיוק בעיית הישיגות, <span class="math">\(\text{CON}\)</span>.</p>
<p>כפי שאמרתי, הדרך הסטנדרטית לבדוק אם בגרף יש מסלול בין שני צמתים היא אלגוריתם כמו DFS, שפשוט מטייל לו בגרף ומסמן צמתים שהוא כבר ביקר בהם, נמנע מלהיכנס שוב לצמתים שהוא ביקר בהם, וחוזר אחורה אם הוא נתקע. לרוע המזל, סיבוכיות הזכרון של האלגוריתם הזה היא לינארית בגודל הגרף - בגלל עניין סימון הצמתים. לכן כל הרעיון הזה לא רלוונטי לנו.</p>
<p>לבדוק שיש מסלול מ-<span class="math">\(s\)</span> אל <span class="math">\(t\)</span> בסיבוכיות זכרון יעילה, <strong>בהינתן עד לכך</strong>, את זה קל לעשות. העד יהיה תיאור המסלול עצמו, ולכן כל המידע שצריך לזכור בכל שלב הוא מה הצומת הנוכחי שלנו, לקרוא את הצומת הבא בתור מהעד, ולבדוק אם אכן יש קשת מהצומת הנוכחי שלנו אל הצומת הבא בתור שהעד מדבר עליו. מכיוון שלייצג צומת או שניים בודדים דורש רק כמות לוגריתמית של זכרון, זה מראה ש-<span class="math">\(\text{CON}\in\text{NL}\)</span>. האתגר הוא להראות ש-<span class="math">\(\text{CON}\in\text{coNL}\)</span> - שיש עד לכך ש<strong>לא קיים</strong> מסלול מ-<span class="math">\(s\)</span> אל <span class="math">\(t\)</span>. איך עושים דבר כזה? התשובה פשוטה - אומרים את האמת, רק האמת, ו<strong>כל האמת</strong>.</p>
<p>נניח שידוע לנו שיש <strong>בדיוק</strong> <span class="math">\(k\)</span> צמתים שאליהם אפשר להגיע מ-<span class="math">\(s\)</span> תוך לכל היותר <span class="math">\(n\)</span> צעדים. אנחנו לא יודעים מיהם הצמתים הללו, אבל כוח משמיים הבטיח לנו כי יש בדיוק <span class="math">\(k\)</span> כאלו. אז קל מאוד יהיה לשכנע אותנו שמ-<span class="math">\(s\)</span> אי אפשר להגיע אל <span class="math">\(t\)</span> תוך <span class="math">\(n\)</span> צעדים באופן הבא: יתנו לנו כעדים <span class="math">\(k\)</span> מסלולים, שכל אחד מוביל לצומת כלשהו שאינו <span class="math">\(t\)</span>, וכל הצמתים שונים אלו מאלו. זה יבטיח שלא ניתן להגיע מ-<span class="math">\(s\)</span> אל <span class="math">\(t\)</span> תוך <span class="math">\(n\)</span> צעדים לכל היותר, כי יש בדיוק <span class="math">\(k\)</span> צמתים שאפשר להגיע אליהם, ו"כיסינו" את כולם. כמה זכרון זה דורש? ובכן, כבר אמרנו שלבדוק מסלול דורש רק כמות לוגריתמית של זכרון. אבל, בעיה: איך נדע שכל <span class="math">\(k\)</span> הצמתים שהביאו אותנו אליהם <strong>שונים</strong> זה מזה? בשביל זה צריך יהיה לזכור את כולם, וייתכן ש-<span class="math">\(k\)</span> כבר יהיה גדול מדי מכדי להיות לוגריתמי (נניח, חצי מהצמתים בגרף). מה עושים?</p>
<p>הפתרון פשוט: העד יורכב מסדרה של טענות מהצורה "הצומת <span class="math">\(v\)</span> ישיג מהצומת <span class="math">\(s\)</span> לכל היותר ב-<span class="math">\(n\)</span> צעדים, והרי הוכחה לכך...", כאשר הסדר שבו מופיעות הטענות בתוך העד מתאים לסדר לקסיקוגרפי כלשהו שנקבע על הצמתים <span class="math">\(v\)</span> (בסופו של דבר, צמתים, כמו כל מידע אחר, מיוצגים בידי מחרוזות בינאריות, ועל מחרוזות כאלו יש סדר באופן טבעי). בכל שלב נצטרך לזכור מה הצומת האחרון שעליו כבר הוכיחו שהוא ישיג מ-<span class="math">\(s\)</span> ולבדוק אם החדש אכן גדול ממנו. אם הוא אכן גדול יותר, אפשר לשכוח את הקודם ולזכור רק את הנוכחי; אם הוא לא גדול יותר, אפשר להפסיק את בדיקת העד ולהכריז שמרמים אותנו. זה מבטיח שלא נספור אף צומת פעמיים, ולכן כל מה שצריך לשמור בנוסף הוא את <strong>מספר</strong> הצמתים שכבר שוכנענו שהם ישיגים מ-<span class="math">\(s\)</span>, וכדי לאחסן מספר שהוא לכל היותר מספר הצמתים הכולל בגרף דרוש רק זכרון לוגריתמי.</p>
<p>אז מה ראינו? שבזכרון לוגריתמי אפשר לבדוק הוכחה לטענה מהצורה "<strong>לפחות</strong> <span class="math">\(k\)</span> הצמתים הללו ישיגים מ-<span class="math">\(s\)</span> ב-<span class="math">\(n\)</span> צעדים", ושאם זה משולב בטענה מהצורה "<strong>בדיוק</strong> <span class="math">\(k\)</span> צמתים ישיגים מ-<span class="math">\(s\)</span> ב-<span class="math">\(n\)</span> צעדים" אפשר להוכיח שמשהו לא ישיג מ-<span class="math">\(s\)</span> ב-<span class="math">\(n\)</span> צעדים. אבל איך אפשר להראות ש<strong>בדיוק</strong> <span class="math">\(k\)</span> צמתים ישיגים מ-<span class="math">\(s\)</span> ב-<span class="math">\(n\)</span> צעדים? ובכן, באינדוקציה על <span class="math">\(n\)</span>.</p>
<p>בואו נסמן ב-<span class="math">\(C_{n}\)</span> את מספר הצמתים שישיגים מ-<span class="math">\(s\)</span> לכל היותר ב-<span class="math">\(n\)</span> צעדים. ראשית, ברור ש-<span class="math">\(C_{1}\)</span> ניתן לחישוב באופן עצמאי לגמרי ובלי שום עזרה - פשוט עוברים איכשהו על רשימת הקשתות של הגרף וסופרים כמה מחוברות ל-<span class="math">\(s\)</span>. האתגר הוא להראות שאפשר לתת כעד את <span class="math">\(C_{n+1}\)</span> באופן כזה שאם <span class="math">\(C_{n}\)</span> כבר נתון, אפשר לבדוק שהעד נכון. איך עושים את זה?</p>
<p>בואו נעצור לרגע כדי לקחת אוויר ולסכם את מה שראינו עד כה. ראינו כי ניתן להוכיח (באופן שיהיה ניתן לבדיקה בזכרון לוגריתמי) שצומת כלשהו ישיג מ-<span class="math">\(s\)</span> ב-<span class="math">\(n\)</span> צעדים. כמו כן, ראינו כי אם <span class="math">\(C_{n}\)</span> נתון, אז אפשר להוכיח שצומת כלשהו <strong>אינו</strong> ישיג מ-<span class="math">\(s\)</span> ב-<span class="math">\(n\)</span> צעדים. למעשה, אפשר גם להוכיח באופן דומה מאוד שצומת <span class="math">\(v\)</span> אינו ישיג מ-<span class="math">\(s\)</span> ב-<span class="math">\(n+1\)</span> צעדים - פשוט מוכיחים שאף שכן של <span class="math">\(v\)</span> אינו ישיג מ-<span class="math">\(s\)</span> ב-<span class="math">\(n\)</span> צעדים (ולמי שנזקק לפירוט - ההוכחה כוללת את רשימת כל <span class="math">\(C_{n}\)</span> השכנים שכן ישיגים ואת המסלול שמוביל להם; בזמן שבודקים שההוכחה נכונה גם בודקים שכל אחד מהשכנים הללו אינו שכן של <span class="math">\(v\)</span>).</p>
<p>עכשיו בואו נעצור לרגע ונחשוב - איך כל המרכיבים הללו פותרים לנו את הבעיה של חישוב <span class="math">\(C_{n+1}\)</span>? תנסו לחשוב על זה בעצמכם לרגע. תזכרו שאנחנו כלל לא צריכים להיות חסכוניים בזמן ריצה, רק בזכרון.</p>
<p>התשובה פשוטה: ההוכחה לערך החדש של <span class="math">\(C_{n+1}\)</span> תהיה מורכבת מרשימת <strong>כל</strong> הצמתים בגרף לפני הסדר, כשאחרי כל צומת ההוכחה או טוענת שהוא ישיג מ-<span class="math">\(s\)</span> ב-<span class="math">\(n+1\)</span> צעדים ומספקת תת-הוכחה שמראה זאת, או טוענת שהוא אינו ישיג מ-<span class="math">\(s\)</span> ב-<span class="math">\(n+1\)</span> צעדים, ומספקת תת-הוכחה שמראה זאת. הגאונות כאן היא בכך שאחרי שאנחנו גומרים עם צומת, אנחנו לא צריכים לזכור אם הוא היה ישיג או לא היה ישיג (זה ידרוש מאיתנו הרבה יותר מדי זכרון לתחזק רשימה כזו) אלא רק להוסיף או לא להוסיף 1 למונה של <span class="math">\(C_{n+1}\)</span> שאנחנו מתחזקים. אחרי שנסיים לקרוא את ההוכחה (שכאמור, אומרת פרטנית מה קורה לכל אחד מהצמתים בגרף), יהיה ברשותנו הערך הנכון של <span class="math">\(C_{n+1}\)</span>.</p>
<p>מכאן הפתרון לבעיה טריוויאלי. ההוכחה לכך ש-<span class="math">\(t\)</span> לא ישיג מ-<span class="math">\(s\)</span> ראשית כוללת הוכחות לסדרת הערכים <span class="math">\(C_{1},C_{2},\dots,C_{\left|V\right|}\)</span>, ולבסוף היא כוללת הוכחה לכך ש-<span class="math">\(t\)</span> אינו ישיג מ-<span class="math">\(s\)</span> ב-<span class="math">\(\left|V\right|\)</span> צעדים, שמסתמכת על <span class="math">\(C_{\left|V\right|}\)</span>. אם <span class="math">\(t\)</span> לא ישיג מ-<span class="math">\(s\)</span> ב-<span class="math">\(\left|V\right|\)</span> צעדים, הוא לא ישיג בכלל (למה?).</p>
<p>מה שיפה בהוכחה הזו היא השימוש האינטנסיבי משהו שהיא עושה ב"הוכחות". אנחנו לא סתם מספקים מסלול וזהו, אלא לכל שלב של חישוב <span class="math">\(C_{i}\)</span>, אנחנו מספקים (שוב ושוב ושוב) את ההוכחה שצומת מסויים ישיג או לא ישיג מ-<span class="math">\(s\)</span>, לכל צומת בגרף. האינטנסיביות הזו מצליחה להניב בסיום פתרון שהוא מאוד חסכוני בזכרון (על משקל בזבוז אדיר של זמן הריצה, כמובן), וזה נראה מפתיע - ויותר מכך, מעלה את השאלה איך לעזאזל בכלל חשבו על פתרון כמו זה (אם כי אני חייב להודות - ביחס למשפט ברינגטון, משפט אימרמן עוד נראה מתבקש איכשהו). פרט לכך, המשפט הוא המחשה יפה מאוד לטעמי של האופן הכל כך שונה שבו סיבוכיות זכרון מתנהגת ביחס לסיבוכיות זמן.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>