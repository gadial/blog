<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>תורת המספרים האלגברית על קצה המזלג, חלק ג&#39; - שובו של הפירוק היחיד - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <meta name="description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב" />
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://gadial.net/2011/08/23/algebraic_number_theory_intro_3/">
    <meta property="og:title" content="תורת המספרים האלגברית על קצה המזלג, חלק ג&#39; - שובו של הפירוק היחיד">
    <meta property="og:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta property="og:site_name" content="לא מדויק">
    <meta property="og:image" content="http://gadial.net/img/main/default-card.png" />
        
    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://gadial.net/2011/08/23/algebraic_number_theory_intro_3/">
    <meta name="twitter:description" content="לא מדויק - בלוג על מתמטיקה ומדעי המחשב">
    <meta name="twitter:site" content="@" />
    <meta property="twitter:title" content="תורת המספרים האלגברית על קצה המזלג, חלק ג&#39; - שובו של הפירוק היחיד">
    <meta property="twitter:image" content="http://gadial.net/img/main/default-card.png" />
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="לא מדויק - RSS Feed" href="/feed.xml">
       
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <a href="/categories/">קטגוריות</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2011/08/21/algebraic_number_theory_intro_2/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">תורת המספרים האלגברית על קצה המזלג, חלק ב&#39; - מתקפת האידאלים</span>
            </a>
            

            
            <a href="/2011/08/30/algebraic_number_theory_intro_4/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">תורת המספרים האלגברית על קצה המזלג, חלק ד&#39; - השיבה אל חוג השלמים</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>תורת המספרים האלגברית על קצה המזלג, חלק ג&#39; - שובו של הפירוק היחיד</h1>
            <div class="post-meta">
                <span class="date">2011-08-23</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אלגברה מופשטת.html">אלגברה מופשטת</a>
                    
                    <a href="/categories/תורת המספרים.html">תורת המספרים</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/גם טכני זה כיף!.html">גם טכני זה כיף!</a>
                    
                    <a href="/tags/הוכחות.html">הוכחות</a>
                    
                    <a href="/tags/חוגי דדקינד.html">חוגי דדקינד</a>
                    
                    <a href="/tags/תורת המספרים האלגברית.html">תורת המספרים האלגברית</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>בפוסט הקודם הצגתי את הפתרון של דדקינד (שהלך בעקבות קומר) לבעיה של אי-פריקות יחידה בחוגי שלמים. הרעיון היה לעבור מדיבור על אברי החוג לדיבור על <strong>אידאלים</strong> של החוג - כשאידאל הייתה קבוצה של אברי החוג שסגורה לחיבור ו"בולעת" כפל באיבר כלשהו מהחוג. פורמלית, אם <span class="math">\(R\)</span> הוא חוג אז <span class="math">\(I\)</span> הוא אידאל אם לכל <span class="math">\(x,y\in I\)</span> מתקיים <span class="math">\(x+y\in I\)</span> (למעשה, צריך לדרוש באופן כללי שיתקיים דווקא <span class="math">\(x-y\in I\)</span> שכן גם סגירות לחיסור חשובה וממנה נובעת סגירות לחיבור, אבל במקרה שלנו זה נובע מתכונת הבליעה) ולכל <span class="math">\(r\in R\)</span> מתקיים ש-<span class="math">\(xr\in I\)</span>.</p>
<p>הגדרנו גם פעולות על האידאלים. כפל הוגדר על ידי <span class="math">\(AB=\left\{ \sum_{i=1}^{n}a_{i}b_{i}|a_{i}\in A,b_{i}\in B,n\in\mathbb{N}\right\} \)</span>, חיבור הוגדר על ידי <span class="math">\(A+B=\left\{ a+b|a\in A,b\in B\right\} \)</span> וראינו כי כאשר חושבים על <span class="math">\(A,B\)</span> בתור מעין מספרים הפעולה הזו מתאימה לא לחיבור מספרים אלא ללקיחת המחלק המשותף המקסימלי שלהם. לסיום דיברנו על אידאלים ראשוניים ומקסימליים - הכללות של המושגים של ראשוניות ואי-פריקות של איברי החוג, והזכרתי שבחוגי שלמים מתקיימת התופעה הנחמדה שבה כל אידאל ראשוני הוא גם מקסימלי, וציינתי שזו אחת מבין שלוש תכונות שמבטיחות שבחוג תהיה פריקות יחידה לאידאלים. עכשיו אני רוצה לתאר את שתי התכונות האחרות - החוג צריך להיות נתרי, והוא צריך להיות סגור בשלמים.</p>
<p>אינטואיטיבית, חוג נתרי הוא חוג שבו תהליך חלוקה של מספר חייב להסתיים מתישהו. פורמלית התכונה מנוסחת כך: <span class="math">\(R\)</span> הוא נתרי אם לכל סדרה של אידאלים ב-<span class="math">\(R\)</span> שמקיימת <span class="math">\(I_{1}\subseteq I_{2}\subseteq I_{3}\subseteq\dots\)</span> הסדרה "נעצרת" מתישהו, במובן זה שקיים <span class="math">\(n\)</span> כך ש-<span class="math">\(I_{n}=I_{n+1}=I_{n+2}=\dots\)</span> וכן הלאה.</p>
<p>כדי להבין את התכונה הזו כדאי להיזכר שוב בכך שאם <span class="math">\(A,B\)</span> אידאלים כך ש-<span class="math">\(A\subseteq B\)</span>, אנחנו חושבים על כך כאילו ה"מספר" <span class="math">\(B\)</span> מחלק את ה"מספר" <span class="math">\(A\)</span>. כדי להקל על הדמיון אנחנו משתמשים בסימונים כמו <span class="math">\(\mathfrak{a}\)</span> ו-<span class="math">\(\mathfrak{b}\)</span> לאידאלים (סימנים שיותר נראים כמו מספרים - מוזרים - מאשר קבוצות) ומשתמשים בסימון כמו <span class="math">\(\mathfrak{b}|\mathfrak{a}\)</span> כדי לציין בדיוק את זה ש-<span class="math">\(\mathfrak{a}\subseteq\mathfrak{b}\)</span>. נתריות של חוג אומרת שלא קיימת סדרה <span class="math">\(\mathfrak{a}_{1},\mathfrak{a}_{2},\mathfrak{a}_{3},\dots\)</span> שבה כל איבר מחלק את קודמו (<span class="math">\(\mathfrak{a}_{2}|\mathfrak{a}_{1}\)</span>, <span class="math">\(\mathfrak{a}_{3}|\mathfrak{a}_{1}\)</span> וכן הלאה) ואינה עוצרת אף פעם. בואו נסתכל על דוגמה קונקרטית מתוך <span class="math">\(\mathbb{Z}\)</span> - למשל, האידאל <span class="math">\(\left(60\right)\)</span>. מי מכיל אותו? למשל, <span class="math">\(\left(30\right)\)</span>. ומי מכיל אותו? למשל, <span class="math">\(\left(15\right)\)</span>. ואותו? למשל, <span class="math">\(\left(3\right)\)</span>. ואותו? הממ, אותו מכיל רק <span class="math">\(\left(1\right)\)</span>. ומי מכיל את <span class="math">\(\left(1\right)\)</span>? אהה... מכיוון ש-<span class="math">\(\left(1\right)=\mathbb{Z}\)</span>, אז האידאל היחיד שמכיל אותו זה הוא עצמו. קיבלנו את הסדרה <span class="math">\(\left(60\right)\subseteq\left(30\right)\subseteq\left(15\right)\subseteq\left(3\right)\subseteq\left(1\right)\subseteq\left(1\right)\subseteq\left(1\right)\subseteq\dots\)</span>.</p>
<p>חייבים להודות שזו תכונה טבעית למדי והכרחית כדי שנוכל בכלל לדבר על פירוק לאידאלים; שהרי אחרת קיימת הסכנה שנתחיל לפרק אידאל כלשהו, ונפרק ונפרק ונפרק וזה לעולם לא יסתיים.</p>
<p>התכונה השלישית היא סגירות בשלמים. אמרנו שאם <span class="math">\(K\)</span> היא הרחבה אלגברית סופית של הרציונליים, אז <span class="math">\(\mathcal{O}_{K}\)</span> היא בדיוק אותם מספרים ב-<span class="math">\(K\)</span> שמאפסים פולינום מתוקן עם מקדמים <strong>שלמים</strong>. צריך לחשוב על זה כאילו לקחנו את <span class="math">\(\mathbb{Z}\)</span> והרחבנו אותו, באופן דומה לזה שבו הרחבנו את <span class="math">\(\mathbb{Q}\)</span> כדי לקבל את <span class="math">\(K\)</span>. כעת אפשר לדבר על פולינום עם מקדמים "שלמים פלוס פלוס" - מקדמים מתוך <span class="math">\(\mathcal{O}_{K}\)</span>. האם יש איברים "חדשים" ב-<span class="math">\(K\)</span> שמאפסים פולינומים מתוקנים עם מקדמים מתוך <span class="math">\(\mathcal{O}_{K}\)</span>, או שב-<span class="math">\(\mathcal{O}_{K}\)</span> יש כבר את כל המספרים שעושים זאת? התשובה היא שב-<span class="math">\(\mathcal{O}_{K}\)</span> יש את כל האיברים שעושים זאת. הדבר דומה לסגירות האלגברית של <span class="math">\(\mathbb{C}\)</span> - העובדה שכל פולינום עם מקדמים מרוכבים מאופס רק על ידי מספרים מרוכבים, ולא צריך להרחיב עוד את מערכת המספרים המרוכבים רק שכעת אנו מדברים במפורש על פולינומים מתוקנים. הערה קטנה למתקדמים: באופן כללי עבור חוג <span class="math">\(R\)</span>, ה-<span class="math">\(K\)</span> הרלוונטי לצורך דיבורים על סגירות בשלמות הוא שדה השברים שלו; כאשר עוסקים בשדות מספרים אפשר להראות ששדה השברים של <span class="math">\(\mathcal{O}_{K}\)</span> הוא אכן <span class="math">\(K\)</span>.</p>
<p>שלוש התכונות הללו של חוג - נתרי, סגור בשלמים וכל אידאל ראשוני בו הוא מקסימלי - הן שלוש התכונות שנדרשות כדי לקבל פריקות יחידה של אידאלים. הם מתקיימות על ידי <span class="math">\(\mathcal{O}_{K}\)</span>, אבל גם על ידי חוגים אחרים, כלליים יותר. ראשית, החוגים שאנחנו מדברים עליהם חייבים להיות תחומי שלמות קומוטטיביים עם יחידה: "תחום שלמות" פירושו שאם מכפלה של שני איברים היא אפס, אחד מהם הוא אפס (בלי התכונה הזו אי אפשר לדבר על שדה השברים של החוג), "קומוטטיבי" אומר ש-<span class="math">\(ab=ba\)</span> לכל שני איברים בחוג (זה לא נכון, למשל, עבור חוגי מטריצות) ועם יחידה אומר שקיים איבר שמסומן ב-<span class="math">\(1\)</span> כך ש-<span class="math">\(a\cdot1=1\cdot a=a\)</span> לכל איבר בחוג. התכונות הללו מובנות מאליהן בחוגי שלמים אבל לא בחוגים כלליים יותר.</p>
<p>חוגים שבנוסף לדרישות הסטנדרטיות הללו מקיימים את שלוש התכונות שלעיל (נתרי, סגור, ראשוני-מקסימלי) נקראים <strong>חוגי דדקינד</strong>. הנקודה שבה חוגי שלמים הם "מעניינים יותר" מחוגי דדקינד כלליים היא לא בפריקות היחידה אלא בתכונה אחרת שקשורה למשהו שנקרא "מספר המחלקה" (Class Number) שאתאר בהמשך.</p>
<p>סיימנו את ההקדמה. עכשיו נשאלות שתי שאלות באופן טבעי - ראשית, למה כל חוג שלמים הוא חוג דדקינד? שנית, למה בחוג דדקינד יש פריקות יחידה לאידאלים? ההוכחות לדברים הללו אינן טריוויאליות ודורשות ידע מוקדם כלשהו במתמטיקה; אנסה לתת סקיצות שיבהירו את רוח הדברים גם אם לא יהוו הוכחות מדויקות. נתחיל דווקא מלראות מדוע חוג דדקינד הוא בעל פריקות יחידה; אחרי שרואים למה התכונות הדדיקנדיות עוזרות לנו, יש קצת יותר סבלנות להבין מדוע הן נכונות.</p>
<p>ההוכחה עצמה תהיה דומה מאוד באופיה להוכחה ה"קלאסית" לכך שב-<span class="math">\(\mathbb{Z}\)</span> יש פריקות יחידה ("המשפט היסודי של האריתמטיקה"), ולכן אציג קודם כל את ההוכחה הזו. אנחנו צריכים להוכיח שני דברים: שלכל מספר <span class="math">\(a\in\mathbb{N}\)</span> כך ש-<span class="math">\(a\ne0,1\)</span> <strong>קיים</strong> פירוק למכפלה של מספרים ראשוניים חיוביים <span class="math">\(a=p_{1}\cdot p_{2}\dots p_{k}\)</span> (אותו ראשוני עשוי להופיע כמה פעמים במכפלה), ושהפירוק הזה הוא <strong>יחיד</strong> עד כדי סדר האיברים במכפלה. שימו לב לכך שיש לנו כאן שני דברים שצריך להוכיח - זו דוגמה קלאסית למשפט קיום ויחידות (דבר נפוץ למדי במתמטיקה).</p>
<p>נתחיל מקיום. מכיוון שאני רוצה לתת הוכחה שתהיה דומה באופיה להוכחה עבור אידאלים בהמשך, מה שאעשה ייראה אולי טיפה מוזר במבט ראשון. אני מניח בשלילה שלא כל המספרים הטבעיים הגדולים מ-1 ניתנים להצגה כמכפלה של ראשוניים, ובוחר את <span class="math">\(a\)</span> להיות <strong>המינימלי</strong> מביניהם. לא ייתכן שהוא עצמו ראשוני, שהרי אז הוא כן היה ניתן להצגה כמכפלה של ראשוניים (המכפלה <span class="math">\(a\)</span>). מה שאני כן יודע הוא שקיים ראשוני <span class="math">\(p<a\)</span> כך ש-<span class="math">\(p|a\)</span> (זו טענה שצריך להוכיח, כמובן; כשאדבר על אידאלים גם אסביר איך מוכיחים אותה במקרה הכללי יותר הזה). אם נחלק את <span class="math">\(a\)</span> ב-<span class="math">\(p\)</span>, נקבל את המספר <span class="math">\(ap^{-1}\)</span> שהוא עדיין מספר טבעי, אבל קטן מ-<span class="math">\(a\)</span>; אם הוא קטן מ-<span class="math">\(a\)</span>, אז על פי המינימליות של <span class="math">\(a\)</span>, את <span class="math">\(ap^{-1}\)</span> בהכרח אפשר לתאר כמכפלה של ראשוניים: <span class="math">\(ap^{-1}=p_{1}\cdots p_{k}\)</span>. נכפול את שני האגפים ב-<span class="math">\(p\)</span> ונקבל: <span class="math">\(a=pp_{1}\cdots p_{k}\)</span> וסיימנו (קיבלנו סתירה לכך ש-<span class="math">\(a\)</span> לא ניתן להצגה כמכפלת ראשוניים ולכן אין מספרים שלא ניתנים להצגה כזו).</p>
<p>כעת נעבור להוכיח יחידות. יהא <span class="math">\(a\)</span> מספר טבעי גדול מ-1 כלשהו כך ש-<span class="math">\(a=p_{1}\cdots p_{k}\)</span> וגם <span class="math">\(a=q_{1}\cdots q_{t}\)</span> כשכל האיברים במכפלות הם ראשוניים. הבה ונתבונן ב-<span class="math">\(p_{1}\)</span>: הוא מחלק את <span class="math">\(a\)</span> ולכן את <span class="math">\(q_{1}\cdots q_{t}\)</span>. כזכור, לראשוני יש את התכונה המופלאה שאם הוא מחלק מכפלה הוא מחלק אחד מהמוכפלים (הגדרתי זאת עבור שני מוכפלים; קל להראות שזה נכון עבור מספר סופי כלשהו של מוכפלים). לכן קיים <span class="math">\(q_{i}\)</span> כך ש-<span class="math">\(p_{1}|q_{i}\)</span>. אבל <span class="math">\(q_{i}\)</span> הוא ראשוני ולכן אם הוא מתחלק ב-<span class="math">\(p_{1}\)</span> (שהוא בתורו גדול מ-1), הם חייבים להיות שווים - <span class="math">\(p_{1}=q_{i}\)</span>. כעת נכפול את שני אגפי המשוואה <span class="math">\(p_{1}\cdots p_{k}=q_{1}\cdots q_{t}\)</span> ב-<span class="math">\(p_{1}^{-1}\)</span> ונקבל ש-<span class="math">\(p_{2}\cdots p_{k}=q_{1}\cdots q_{i-1}q_{i+1}\cdots q_{t}\)</span>, ואת התהליך הזה ניתן להמשיך באינדוקציה (על מספר האיברים במכפלה) ולקבל בסופו של דבר שכולם שווים עד כדי שינוי סדר.</p>
<p>אני מקווה שההוכחה הזו הייתה פשוטה דיו כדי שכל קוראי הפוסט יבינו אותה; אם הבנתם אותה, הבנתם גם את ההוכחה על פירוק יחיד לאידאלים ורק נותר לגהץ קצת את הפרטים.</p>
<p>החלק היחיד בכל מה שעשיתי שלא עובר בצורה פשוטה ומיידית לאידאלים הוא ההכפלה ב-<span class="math">\(p^{-1}\)</span> שאני מבצע גם בהוכחת הקיום וגם בהוכחת היחידות. אם תתבוננו היטב בהוכחה, תראו שאני משתמש ב-<span class="math">\(p^{-1}\)</span> בשתי דרכים שונות: גם בטענה ש-<span class="math">\(p^{-1}a\)</span> קטן יותר מ-<span class="math">\(a\)</span>, וגם בכך ש-<span class="math">\(p^{-1}p=1\)</span>, כך שאפשר "לבטל" את <span class="math">\(p\)</span> מהמשוואה על ידי כפל ב-<span class="math">\(p^{-1}\)</span>. ברור שכשעוברים לאידאלים צריך להגדיר בחוכמה את האנלוג של <span class="math">\(p^{-1}\)</span> כדי שיקיים תכונות אלו; וההוכחה שהאנלוג אכן עובד היא עיקר הסיבוך הטכני שלנו כאן.</p>
<p>נעבור כעת לדבר על חוגי דדקינד כלליים. <span class="math">\(\mathcal{O}\)</span> יהיה חוג דדקינד - תחום שלמות שהוא נתרי, סגור בשלמות וכל אידאל ראשוני בו הוא מקסימלי. ב-<span class="math">\(K\)</span> אסמן את שדה השברים של <span class="math">\(\mathcal{O}\)</span> - אוסף כל האיברים מהצורה <span class="math">\(\frac{a}{b}\)</span> כאשר <span class="math">\(a,b\in\mathcal{O}\)</span> ו-<span class="math">\(b\ne0\)</span>, עם כללי החיבור והכפל הרגילים עבור שברים והכלל ש-<span class="math">\(\frac{a}{b}=\frac{c}{d}\)</span> אם <span class="math">\(ad=bc\)</span>. בהינתן אידאל ראשוני <span class="math">\(\mathfrak{p}\)</span> של <span class="math">\(\mathcal{O}\)</span>, נסמן ב-<span class="math">\(\mathfrak{p}^{-1}\)</span> את הקבוצה הבאה: <span class="math">\(\mathfrak{p}^{-1}=\left\{ x\in K|x\mathfrak{p}\subseteq\mathcal{O}\right\} \)</span>. במילים - <span class="math">\(\mathfrak{p}^{-1}\)</span> כולל את כל אברי שדה השברים של <span class="math">\(\mathcal{O}\)</span> שכל איבר באידאל <span class="math">\(\mathfrak{p}\)</span> "מצמצם להם את המכנה" - כשכופלים אותם בכל אברי <span class="math">\(\mathfrak{p}\)</span> תמיד מקבלים שלם. למשל, אם <span class="math">\(\mathfrak{p}=\left(3\right)\)</span> בחוג <span class="math">\(\mathbb{Z}\)</span>, נקבל ש-<span class="math">\(\mathfrak{p}^{-1}\)</span> כולל את כל השלמים (באופן כללי <span class="math">\(\mathfrak{p}^{-1}\)</span> תמיד כולל את כל <span class="math">\(\mathcal{O}\)</span>, ישירות מההגדרה) אבל גם כולל את <span class="math">\(\frac{1}{3}\)</span>. שימו לב שזה כלל לא אידאל של <span class="math">\(\mathcal{O}\)</span> - הוא כולל איברים שלא בהכרח נמצאים ב-<span class="math">\(\mathcal{O}\)</span>.</p>
<p>התוצאה החשובה על <span class="math">\(\mathfrak{p}^{-1}\)</span>, לצרכנו, היא ש-<span class="math">\(\mathfrak{a}\cdot\mathfrak{p}^{-1}\ne\mathfrak{a}\)</span> לכל אידאל <span class="math">\(\mathfrak{a}\ne0\)</span>, כאשר כפל מוגדר בדיוק כמו כפל של אידאלים (סכומים סופיים של מכפלות). לא אוכיח את התוצאה הזו כרגע; לב לבה הטכני של ההוכחה טמון בה ואני מעדיף לדחות את זה לסוף. זה המקום שבו משתמשים בכך ש-<span class="math">\(\mathcal{O}\)</span> הוא סגור בשלמים. בינתיים בואו ננסה להבין טיפה את המסקנות ממנה.</p>
<p>ראשית, מכיוון ש-<span class="math">\(\mathcal{O}\subseteq\mathfrak{p}^{-1}\)</span> נקבל ש-<span class="math">\(\mathfrak{a}\subset\mathfrak{a}\cdot\mathfrak{p}^{-1}\)</span> (למה?). שנית, באופן כללי <span class="math">\(\mathfrak{a}\cdot\mathfrak{p}^{-1}\)</span> לא חייב להיות אידאל (ייתכן שיהיו בו איברים שאינם ב-<span class="math">\(\mathcal{O}\)</span>) אבל אם <span class="math">\(\mathfrak{a}\subseteq\mathfrak{p}\)</span>, אז <span class="math">\(\mathfrak{a}\cdot\mathfrak{p}^{-1}\)</span> אכן יהיה אידאל (בדוק זאת!)</p>
<p>שלישית, במקרה שבו <span class="math">\(\mathfrak{a}=\mathfrak{p}\)</span> נקבל מהתוצאה לעיל ש-<span class="math">\(\mathfrak{p}\subset\mathfrak{p}\cdot\mathfrak{p}^{-1}\subseteq\mathcal{O}\)</span>; אבל <span class="math">\(\mathfrak{p}\)</span> הוא אידאל ראשוני ולכן מקסימלי (כי <span class="math">\(\mathcal{O}\)</span> הוא חוג דדקינד) ולכן מהגדרת המקסימליות של אידאלים נובע ש-<span class="math">\(\mathfrak{p}\cdot\mathfrak{p}^{-1}=\mathcal{O}\)</span> - אז במובן כלשהו זהו אכן ההופכי, והוא אכן מקיים את תכונת ה"הקטנה" של <span class="math">\(\mathfrak{a}\)</span> שרצינו (<span class="math">\(\mathfrak{a}\subset\mathfrak{a}\mathfrak{p}^{-1}\)</span> משמעו ש-<span class="math">\(\mathfrak{a}\mathfrak{p}^{-1}\)</span> מחלק ממש את <span class="math">\(\mathfrak{a}\)</span>).</p>
<p>עוד דבר שאזדקק לו הוא האבחנה שאם <span class="math">\(\mathfrak{p}\)</span> הוא אידאל ראשוני שמחלק מכפלה כלשהי של אידאלים <span class="math">\(\mathfrak{a}_{1}\cdots\mathfrak{a}_{k}\)</span> אז הוא מחלק את אחד מאבריה, בדיוק כמו שקורה עם מספרים שלמים. ההוכחה לכך פשוטה ואלגנטית: נניח ש-<span class="math">\(\mathfrak{p}\)</span> לא מחלק אף אחד מאברי המכפלה, כלומר הוא לא מכיל אף אחד מהאידאלים <span class="math">\(\mathfrak{a}_{1},\cdots,\mathfrak{a}_{k}\)</span>; אז קיימים <span class="math">\(a_{1},\dots,a_{k}\in\mathcal{O}\)</span> השייכים לאידאלים המתאימים כך ש-<span class="math">\(a_{1},\dots,a_{k}\notin\mathfrak{p}\)</span>. אבל מכפלתם שייכת ל-<span class="math">\(\mathfrak{a}_{1}\cdots\mathfrak{a}_{k}\)</span> ולכן שייכת ל-<span class="math">\(\mathfrak{p}\)</span>, ומהגדרתו של אידאל ראשוני עולה שאחד מאבריה צריך להיות שייך ל-<span class="math">\(\mathfrak{p}\)</span>. באופן הזה תכונת ה"אם ראשוני מחלק מכפלה הוא מחלק את אחד המוכפלים" מפעפעת מאיברים של החוג לאידאלים שלו.</p>
<p>נותר לי עוד חור אחד לסגור. נניח ש-<span class="math">\(\mathfrak{a}\)</span> הוא אידאל כלשהו, אז אני רוצה לטעון שקיים אידאל ראשוני <span class="math">\(\mathfrak{p}\)</span> שמחלק אותו, ובניסוח אחר אני רוצה להראות ש-<span class="math">\(\mathfrak{a}\)</span> מוכל באידאל מקסימלי. זו טענה שניתן להוכיח באופן כללי על חוגים - כל אידאל מוכל באידאל מקסימלי; אבל ההוכחה מתבססת על <a href="http://www.gadial.net/2007/07/04/axiom_of_choice/">אקסיומת הבחירה</a> ולכן אנו מעדיפים להחליש את הדרישות עד כמה שניתן, וכאן ניתן להיעזר בכך שהחוג <span class="math">\(\mathcal{O}\)</span> שלנו הוא נתרי. בחוג נתרי מתקיימת תכונה חזקה קצת יותר מאשר "כל אידאל מוכל באידאל מקסימלי" - מתקיימת התכונה שבכל קבוצה לא ריקה של אידאלים קיים איבר מקסימלי. התכונה הזו קריטית בהמשך, לא רק כאן, ולכן כדאי לומר משהו על איך מוכיחים אותה.</p>
<p>ההוכחה טבעית למדי. ניקח אידאל <span class="math">\(I_{1}\)</span> כלשהו בקבוצת האידאלים שנתונה לנו. אם הוא מקסימלי, טוב; אחרת קיים אידאל אחר בקבוצה, <span class="math">\(I_{2}\)</span>, שמכיל אותו. אם הוא מקסימלי, טוב; אחרת, קיים אידאל אחר בקבוצה <span class="math">\(I_{3}\)</span>, שמכיל אותו. ניקח... הבנתם את הרעיון. מתקבלת הסדרה <span class="math">\(I_{1}\subset I_{2}\subset I_{3}\subset\dots\)</span>, אבל מכיוון שהחוג נתרי הסדרה חייבת להיעצר מתישהו - והאיבר שהיא תיעצר בו יהיה איבר מקסימלי (שכן אם לא היה מקסימלי אפשר היה להמשיך את הסדרה גם אחריו). כאן אנחנו משתמשים, באופן כמעט לא מורגש, בגרסה מוחלשת של אקסיומת הבחירה (Axiom of dependent choice); מי שרוצה להיפטר גם מהאקסיומה הזו ייאלץ להגדיר "חוג נתרי" בתור חוג בעל התכונה "לכל קבוצת אידאלים יש איבר מקסימלי", כי היא קריטית לנו.</p>
<p>יפה, עכשיו אפשר לעבור סוף סוף להוכחת משפט הקיום והיחידות של פירוק אידאל לא טריוויאלי <span class="math">\(\mathfrak{a}\ne\left(0\right),\left(1\right)\)</span> בחוג דדקינד למכפלה של אידאלים ראשוניים. נתחיל בקיום: נניח בשלילה שקיימים אידאליים לא טריוויאליים שלא קיים להם להם פירוק למכפלת ראשוניים - זוהי קבוצה לא ריקה של אידאלים ולכן קיים בה איבר <strong>מקסימלי</strong> ביחס להכלה, <span class="math">\(\mathfrak{a}\)</span>. לא ייתכן שהוא עצמו ראשוני, שהרי אז הוא כן היה ניתן להצגה כמכפלה של ראשוניים (המכפלה <span class="math">\(\mathfrak{a}\)</span>). מה שאני כן יודע הוא שקיים ראשוני <span class="math">\(\mathfrak{p}\)</span> שמכיל אותו: <span class="math">\(\mathfrak{a}\subset\mathfrak{p}\)</span>. הבה ונכפול את שני האגפים ב-<span class="math">\(\mathfrak{p}^{-1}\)</span>: נקבל <span class="math">\(\mathfrak{a}\subset\mathfrak{a}\mathfrak{p}^{-1}\subset\mathfrak{p}\mathfrak{p}^{-1}=\mathcal{O}\)</span>. אם כן, מצד אחד <span class="math">\(\mathfrak{a}\mathfrak{p}^{-1}\)</span> הוא אידאל לא טריוויאלי (מוכל ממש ב-<span class="math">\(\mathcal{O}\)</span>) ומצד שני הוא מכיל ממש את <span class="math">\(\mathfrak{a}\)</span> ולכן מהמקסימליות ביחס להכלה של <span class="math">\(\mathfrak{a}\)</span> נובע ש-<span class="math">\(\mathfrak{a}\mathfrak{p}^{-1}\)</span> כן ניתן לתיאור כמכפלה של ראשוניים: <span class="math">\(\mathfrak{a}\mathfrak{p}^{-1}=\mathfrak{p}_{1}\cdots\mathfrak{p}_{t}\)</span>. נכפול את שני האגפים ב-<span class="math">\(\mathfrak{p}\)</span>, נקבל את <span class="math">\(\mathfrak{a}=\mathfrak{p}\mathfrak{p}_{1}\cdots\mathfrak{p}_{t}\)</span> וסיימנו. שימו לב עד כמה ההוכחה הזו דומה להוכחה של המשפט עבור <span class="math">\(\mathbb{Z}\)</span>.</p>
<p>גם הוכחת היחידות זה פחות או יותר אותו דבר. נניח ש-<span class="math">\(\mathfrak{a}=\mathfrak{p}_{1}\cdots\mathfrak{p}_{k}=\mathfrak{q}_{1}\cdots\mathfrak{q}_{t}\)</span> כשכל האיברים במכפלות הם ראשוניים, ונתבונן ב-<span class="math">\(\mathfrak{p}_{1}\)</span>: הוא מחלק את <span class="math">\(\mathfrak{q}_{1}\cdots\mathfrak{q}_{t}\)</span> ולכן <span class="math">\(\mathfrak{p}_{1}|\mathfrak{q}_{i}\)</span> עבור <span class="math">\(i\)</span> כלשהו. המשמעות של חלוקה היא, כזכור, ש-<span class="math">\(\mathfrak{q}_{i}\subseteq\mathfrak{p}_{1}\)</span>, אבל <span class="math">\(\mathfrak{q}_{i}\)</span> ראשוני ולכן מקסימלי ולכן אם <span class="math">\(\mathfrak{p}_{1}\ne\mathcal{O}\)</span> מכיל אותו, בהכרח <span class="math">\(\mathfrak{p}_{1}=\mathfrak{q}_{i}\)</span>. כעת נכפול את שני אגפי המשוואה <span class="math">\(\mathfrak{p}_{1}\cdots\mathfrak{p}_{k}=\mathfrak{q}_{1}\cdots\mathfrak{q}_{t}\)</span> ב-<span class="math">\(\mathfrak{p}_{1}^{-1}\)</span> וקיבלנו ש-<span class="math">\(\mathfrak{p}_{2}\cdots\mathfrak{p}_{k}=\mathfrak{q}_{1}\cdots\mathfrak{q}_{i-1}\mathfrak{q}_{i+1}\cdots\mathfrak{q}_{t}\)</span> ואת התהליך הזה ניתן להמשיך באינדוקציה (על מספר האיברים במכפלה, שהוא תמיד מספר טבעי) ולקבל בסופו של דבר שכולם שווים עד כדי שינוי סדר. ממש אותה הוכחה כמו עבור <span class="math">\(\mathbb{Z}\)</span>.</p>
<p>איך זה יצא לנו כל כך פשוט, ממש אותו הדבר? ובכן, ראשית כל בגלל תכונות הנתריות וה"ראשוני גורר אי פריק" שנכונות כאן עבור אידאלים גם אם הן לא נכונות עבור איברים ב-<span class="math">\(\mathcal{O}\)</span> (אפשר לחשוב על חוג דדקינד בתור חוג שבו "האידאלים מתנהגים כמו מספרים נחמדים"), אבל שנית - זה לא פשוט. את החלק היחסית טכני טאטאתי מתחת לשטיח: ההוכחה ש-<span class="math">\(\mathfrak{a}\mathfrak{p}^{-1}\ne\mathfrak{a}\)</span> לכל <span class="math">\(\mathfrak{a}\)</span>. כדי שהפוסט הזה יהיה שלם אני רוצה להוכיח גם את זה, למרות שעכשיו באמת לא יהיה מנוס מנפנופי ידיים כלשהם.</p>
<p>האבחנה הראשונה בדרך להוכחה דווקא לא קשורה בכלל ל-<span class="math">\(\mathfrak{p}^{-1}\)</span>; זוהי האבחנה שלכל אידאל <span class="math">\(\mathfrak{a}\ne0\)</span>, הוא <strong>מחלק</strong> מכפלה של אידאלים ראשוניים: <span class="math">\(\mathfrak{a}\supseteq\mathfrak{p}_{1}\mathfrak{p}_{2}\dots\mathfrak{p}_{k}\)</span>. זה כמובן נובע באופן טריוויאלי מכך שראינו שכל ראשוני ניתן להצגה כמכפלה כזו, אבל אני לא יכול להשתמש בזה - אני עכשיו מוכיח טענת עזר שבה השתמשתי בהוכחה של המשפט על פריקות יחידה! (וההסתרבלות הזו היא כנראה הסיבה שבגללה בספרי מתמטיקה מוכיחים דברים לפי הסדר - קודם הלמות הטכניות והמשעממות ואז האקשן שדורש אותן).</p>
<p>אם כן, מה עושים? משהו לא שונה כל כך ממה שכבר ראינו. אני מניח שקיימים אידאלים שלא מקיימים את התכונה הזו ("לחלק מכפלה של ראשוניים") ובוחר את <span class="math">\(\mathfrak{a}\)</span> להיות המקסימלי שבהם. הוא עצמו לא יכול להיות ראשוני (כי אז היה מכיל מכפלה של ראשוניים - הוא עצמו) ועל פי ההגדרה זה אומר שיש איברים <span class="math">\(b_{1},b_{2}\in\mathcal{O}\)</span> כך ש-<span class="math">\(b_{1}b_{2}\in\mathfrak{a}\)</span> אבל <span class="math">\(b_{1}\notin\mathfrak{a}\)</span> וגם <span class="math">\(b_{2}\notin\mathfrak{a}\)</span>. אז אפשר להרחיב את <span class="math">\(\mathfrak{a}\)</span>: ניקח את <span class="math">\(\mathfrak{a}_{1}\)</span> להיות האידאל הקטן ביותר שמכיל את <span class="math">\(\mathfrak{a}\)</span> ואת <span class="math">\(b_{1}\)</span> (פורמלית: <span class="math">\(\mathfrak{a}_{1}=\mathfrak{a}+\left(b_{1}\right)\)</span>) ואת <span class="math">\(\mathfrak{a}_{2}\)</span> להיות הקטן ביותר שמכיל את <span class="math">\(\mathfrak{a}\)</span> ואת <span class="math">\(b_{2}\)</span>. מתקיים ש-<span class="math">\(\mathfrak{a}\subset\mathfrak{a}_{1}\)</span> ו-<span class="math">\(\mathfrak{a}\subset\mathfrak{a}_{2}\)</span> (הכלה ממש בשני המקרים), ומצד שני <span class="math">\(\mathfrak{a}_{1}\mathfrak{a}_{2}\subseteq\mathfrak{a}\)</span> (כי כל איבר של <span class="math">\(\mathfrak{a}_{1}\mathfrak{a}_{2}\)</span> הוא סכום של מכפלות שאו שכוללות איבר מ-<span class="math">\(\mathfrak{a}\)</span> ש"בולע" את השני, או שהן מהצורה <span class="math">\(b_{1}b_{2}\)</span> והנחנו הרי ש-<span class="math">\(b_{1}b_{2}\in\mathfrak{a}\)</span>). כעת, בגלל תכונת המקסימליות של <span class="math">\(\mathfrak{a}\)</span> נובע ש-<span class="math">\(\mathfrak{a}_{1},\mathfrak{a}_{2}\)</span> שניהם כן מכילים מכפלה של אידאלים ראשוניים, ולכן <span class="math">\(\mathfrak{a}_{1}\mathfrak{a}_{2}\)</span> מכיל את מכפלת שתי המכפלות הללו, ולכן היא מוכלת ב-<span class="math">\(\mathfrak{a}\)</span> וסיימנו.</p>
<p>גם את המשפט הזה אפשר לנסח קודם עבור <span class="math">\(\mathbb{Z}\)</span> ולקבל קצת יותר אינטואיציה - נסו לעשות זאת אם לא הבנתם את ההוכחה.</p>
<p>עכשיו בואו נראה שלכל <span class="math">\(\mathfrak{p}\)</span> ראשוני, <span class="math">\(\mathfrak{p}^{-1}\ne\mathcal{O}\)</span>. כלומר, שתמיד אפשר למצוא איבר "שברי" ב-<span class="math">\(K\)</span> שמכפלתו ב-<span class="math">\(\mathfrak{p}\)</span> תיתן רק שלמים. כאן כבר אין חוכמות - ההוכחה תהיה טכנית למדי.</p>
<p>ניקח איזה שהוא<span class="math">\(a\in\mathfrak{p}\)</span> כך ש-<span class="math">\(a\ne0\)</span>. נשים לב לכך ש-<span class="math">\(\left(a\right)\)</span> מכיל מכפלה של אידאלים ראשוניים - זה מה שהראינו לפני רגע. ייתכן ש-<span class="math">\(\left(a\right)\)</span> מכיל הרבה מכפלות שכאלו - נבחר מכפלה <span class="math">\(\mathfrak{p}_{1}\cdots\mathfrak{p}_{k}\)</span> כזו שעבורה <span class="math">\(k\)</span> מינימלי (כלומר, אין מכפלה של פחות אידאלים שמוכלת ב-<span class="math">\(\left(a\right)\)</span>). מכיוון ש-<span class="math">\(\mathfrak{p}_{1}\cdots\mathfrak{p}_{k}\subseteq\left(a\right)\subseteq\mathfrak{p}\)</span> עולה ש-<span class="math">\(\mathfrak{p}\)</span> מחלק את המכפלה ולכן מחלק את אחד מאבריה - בלי הגבלת הכלליות נניח שהוא מחלק את <span class="math">\(\mathfrak{p}_{1}\)</span>, ומכיוון ש-<span class="math">\(\mathfrak{p}_{1}\)</span> ראשוני בהכרח <span class="math">\(\mathfrak{p}=\mathfrak{p}_{1}\)</span> (שימו לב איך אותם טיעונים צצים שוב ושוב).</p>
<p>כעת, לא ייתכן ש-<span class="math">\(\mathfrak{p}_{2}\cdots\mathfrak{p}_{k}\subseteq\left(a\right)\)</span> כי במכפלה הזו יש רק <span class="math">\(k-1\)</span> מוכפלים וזה יסתור את המינימליות של <span class="math">\(k\)</span>. לכן יש <span class="math">\(b\in\mathfrak{p}_{2}\cdots\mathfrak{p}_{k}\)</span> כך ש-<span class="math">\(b\notin a\cdot\mathcal{O}\)</span> (זו פשוט דרך אחרת לכתוב ש-<span class="math">\(b\)</span> לא שייך ל-<span class="math">\(\left(a\right)\)</span>), וזה אומר ש-<span class="math">\(a^{-1}b\notin\mathcal{O}\)</span> (כאן <span class="math">\(a^{-1}\)</span> הוא ההופכי של <span class="math">\(a\)</span> בשדה השברים <span class="math">\(K\)</span> - קיים כזה כי <span class="math">\(a\ne0\)</span>). מצד שני, <span class="math">\(b\mathfrak{p}\subseteq\left(a\right)\)</span> (למה?) ולכן <span class="math">\(a^{-1}b\mathfrak{p}\subseteq\mathcal{O}\)</span>, כלומר <span class="math">\(a^{-1}b\in\mathfrak{p}^{-1}\)</span>. קיבלנו שיש ב-<span class="math">\(\mathfrak{p}^{-1}\)</span> איבר שאיננו ב-<span class="math">\(\mathcal{O}\)</span>, כלומר <span class="math">\(\mathfrak{p}^{-1}\ne\mathcal{O}\)</span>, כפי שרצינו.</p>
<p>עכשיו אפשר סוף סוף להגיע לפאנץ': ניקח <span class="math">\(\mathfrak{a}\ne0\)</span> כלשהו ונראה ש-<span class="math">\(\mathfrak{a}\ne\mathfrak{a}\mathfrak{p}^{-1}\)</span>. לצערי, זה גם השלב שבו נפנופי הידיים הופכים להיות הכרח ויש סיכוי סביר שגם חלק מהשורדים עד פה יאבדו אותי. מה שנעשה הוא להניח שמתקיים דווקא <span class="math">\(\mathfrak{a}=\mathfrak{a}\mathfrak{p}^{-1}\)</span> ולהגיע מכך לסתירה על ידי כך שנוכיח ש-<span class="math">\(\mathfrak{p}^{-1}=\mathcal{O}\)</span>. אז ניקח לנו <span class="math">\(b\in\mathfrak{p}^{-1}\)</span>; מטרתנו להוכיח ש-<span class="math">\(b\in\mathcal{O}\)</span>. כאן נכנסת לתמונה הסגירות-בשלמים של <span class="math">\(\mathcal{O}\)</span>: אם נוכיח ש-<span class="math">\(b\)</span> הוא שורש של פולינום מתוקן שמקדמיו נלקחים מתוך <span class="math">\(\mathcal{O}\)</span>, סיימנו.</p>
<p>כאן אני שולף עוד שימוש של הנתריות של <span class="math">\(\mathcal{O}\)</span>. ראינו כבר שהנתריות אומרת שלכל קבוצת אידאלים יש אידאל מקסימלי; היא גם אומרת שכל אידאל <span class="math">\(\mathfrak{a}\)</span> הוא <strong>נוצר סופית</strong>, במובן זה שקיימת קבוצת איברים <span class="math">\(\alpha_{1},\dots,\alpha_{n}\in\mathfrak{a}\)</span> כך שכל איבר של <span class="math">\(\mathfrak{a}\)</span> ניתן לכתיבה כצירוף לינארי של <span class="math">\(\alpha_{1},\dots,\alpha_{n}\)</span> עם מקדמים מ-<span class="math">\(\mathcal{O}\)</span> (למה זה נכון? כי אם האידאל לא היה נוצר סופית אפשר היה לבנות שרשרת עולה של אידאלים - היינו בונים קבוצה של יוצרים ובכל פעם היינו מוסיפים לה איבר שטרם נפרש על ידה).</p>
<p>עכשיו נכנסת לתמונה אלגברה לינארית, ואני אניח ידע בסיסי בה כי יהיה סיפור להסביר את זה כאן מחדש.</p>
<p>כעת, מה קורה כשכופלים את <span class="math">\(b\)</span> ביוצרים הללו? בשל תכונת הבליעה של אידאלים, <span class="math">\(b\alpha_{i}\in\mathfrak{a}\)</span> לכל <span class="math">\(i\)</span>, ולכן אפשר לכתוב <span class="math">\(b\alpha_{i}=\sum_{j=1}^{n}a_{ij}\alpha_{j}\)</span> עם מקדמים <span class="math">\(a_{ij}\in\mathcal{O}\)</span>. את הדבר הזה אפשר לכתוב בצורה קומפקטית בעזרת מטריצות: נגדיר את המטריצה <span class="math">\(A\)</span> כך ש-<span class="math">\(A_{ij}=b\delta_{ij}-a_{ij}\)</span> כש-<span class="math">\(\delta_{ij}\)</span> היא הדלתא של קרונקר (<span class="math">\(\delta_{ii}=1\)</span> ו-<span class="math">\(\delta_{ij}=0\)</span> אם <span class="math">\(i\ne j\)</span>), אז <span class="math">\(A\cdot\overline{\alpha}=0\)</span> כש-<span class="math">\(\alpha\)</span> הוא וקטור היוצרים <span class="math">\(\alpha=\left(\alpha_{1},\dots,\alpha_{n}\right)\)</span>. מכיוון שקיים וקטור שכשכופלים את <span class="math">\(A\)</span> בו מקבלים 0, המטריצה <span class="math">\(A\)</span> היא סינגולרית, כלומר <span class="math">\(\det A=0\)</span>. במילים אחרות, <span class="math">\(b\)</span> הוא שורש של הפולינום המתוקן <span class="math">\(f\left(x\right)=\det\left(x\delta_{ij}-a_{ij}\right)\)</span> שמקדמיו הם מ-<span class="math">\(\mathcal{O}\)</span>, ולכן סיימנו.</p>
<p>אם כן, זה גומר את ההוכחה הכללית שבחוג דדקינד יש פריקות יחידה לאידאלים ראשוניים. עכשיו יהיה צורך לחזור ולדבר על חוגי שלמים ולהסביר מדוע הם חוגי דדקינד, ומהו אותו "מספר המחלקה" המסתורי שהזכרתי בתחילת הפוסט.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>