<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>האלגוריתם האוקלידי וחוגים אוקלידיים - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2011/09/02/turan_theorem/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">משפט טורן והולדת תורת הגרפים האקסטרמלית</span>
            </a>
            

            
            <a href="/2011/09/13/kirkhoffs_matrix_tree_theorem/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">משפט המטריצה-עץ של קירכהוף</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>האלגוריתם האוקלידי וחוגים אוקלידיים</h1>
            <div class="post-meta">
                <span class="date">2011-09-12</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/אלגברה מופשטת.html">אלגברה מופשטת</a>
                    
                    <a href="/categories/תורת המספרים.html">תורת המספרים</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/אלגברה קומוטטיבית.html">אלגברה קומוטטיבית</a>
                    
                    <a href="/tags/האלגוריתם האוקלידי.html">האלגוריתם האוקלידי</a>
                    
                    <a href="/tags/חוג אוקלידי.html">חוג אוקלידי</a>
                    
                    <a href="/tags/תורת המספרים האלגברית.html">תורת המספרים האלגברית</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>האלגוריתם האוקלידי הוא אחד מאותם דברים שכל מי שמתעניין ולו קצת במתמטיקה צריך לדעת. הוא גם אחת מהדוגמאות העתיקות ביותר לאלגוריתם לא טריוויאלי, גם אחד מאבני היסוד של תורת המספרים האלגוריתמית, וגם רעיון בסיסי בעל הכללות חשובות בתורת החוגים. למרות ש<a href="http://www.gadial.net/2010/05/29/continued_fractions_1/">הזכרתי אותו</a> קצת בעבר בבלוג הגיע הזמן לתת לו (ולהכללה הרעיונית שלו) פוסט משל עצמו.</p>
<p>"אלגוריתם" הוא פשוט תהליך בעל תיאור מדויק ופשוט (טוב, לא בהכרח פשוט, אבל סופי). הרעיון באלגוריתם הוא לפשט חישובים מסובכים על ידי תיאור שלהם כסדרה של חישובים פשוטים, וזה גם בדיוק מה שהאלגוריתם האוקלידי עושה. המטרה שלו לא נשמעת גרנדיוזית כל כך ממבט ראשון - בהינתן שני מספרים טבעיים <span class="math">\(a,b\)</span>, אנחנו רוצים למצוא את המחלק המשותף המקסימלי של שניהם, שמסומן <span class="math">\(\text{gcd}\left(a,b\right)\)</span> ובקיצור <span class="math">\(\left(a,b\right)\)</span>. המחלק המשותף המקסימלי הוא בדיוק מה שהוא נשמע שהוא - המספר הגדול ביותר שמחלק גם את <span class="math">\(a\)</span> וגם את <span class="math">\(b\)</span>. כך למשל <span class="math">\(\left(30,20\right)=10\)</span> ו-<span class="math">\(\left(7,22\right)=1\)</span>.</p>
<p>לרוב רוצים משהו קצת יותר מחוכם מחישוב של המחלק המשותף המקסימלי. המשפט הרלוונטי הוא זה: אם <span class="math">\(d=\left(a,b\right)\)</span> אז קיימים <span class="math">\(x,y\)</span> שלמים (שיכולים להיות גם שליליים) כך ש-<span class="math">\(d=ax+by\)</span>, כלומר המחלק המשותף המקסימלי ניתן לכתיבה כ<strong>צירוף לינארי בשלמים</strong> של <span class="math">\(a,b\)</span> והאלגוריתם האוקלידי מוצא את מקדמי הצירוף הזה.</p>
<p>בשביל מה זה טוב? הדוגמה הקלאסית ביותר, ש<a href="http://www.gadial.net/2011/07/11/fields_and_how_can_they_be_finite/">כבר הוזכרה בבלוג</a>, היא זו של אריתמטיקה מודולרית. באריתמטיקה מודולו <span class="math">\(n\)</span> אנחנו מבצעים פעולות חשבון רגילות על מספרים טבעיים אבל אחרי כל פעולה אנחנו מחלקים ב-<span class="math">\(n\)</span> ולוקחים את השארית. למה? טוב, זה סיפור שלם, אבל די אם נאמר שמערכת ההצפנה RSA פועלת בעולם שאלו חוקי החשבון שלו. בעולם הזה צריך גם לחלק, ולחלק ב-<span class="math">\(a\)</span> פירושו בעצם לכפול במספר אחר, <span class="math">\(a^{-1}\)</span>, שמקיים את התכונה ש-<span class="math">\(aa^{-1}=1\)</span> (עם כלל הכפל-ואז-חילוק-ב-<span class="math">\(n\)</span>-ולקיחת-שארית). כדי למצוא את <span class="math">\(a^{-1}\)</span> מפעילים את האלגוריתם האוקלידי על <span class="math">\(a,n\)</span> כדי למצוא <span class="math">\(ax+ny=1\)</span> ואז <span class="math">\(x\)</span> הוא <span class="math">\(a^{-1}\)</span> המבוקש (זה דורש שיתקיים <span class="math">\(\left(a,n\right)=1\)</span> אחרת כלל לא ניתן לחלק ב-<span class="math">\(a\)</span> מודולו <span class="math">\(n\)</span>).</p>
<p>בקיצור, סמכו עלי, זה טוב.</p>
<p>שתי דרכים קופצות לראש מייד כשחושבים על איך למצוא את המחלק המשותף המקסימלי של <span class="math">\(a,b\)</span>. הראשונה היא פשוט לעבור אחד אחד על כל המספרים שקטנים מ-<span class="math">\(a,b\)</span> ולבדוק מי מחלק את שניהם (לצורך אופטימיזציה עדיף להתחיל מהקטן שבין <span class="math">\(a,b\)</span> ולרדת עוד ועוד). האלגוריתם הזה איטי מדי ולכן חסר ערך. באופן כללי בתורת המספרים, אלגוריתם על מספר שזמן הריצה שלו הוא בערך כגודל המספר הוא בעייתי מאוד עד חסר ערך (זה אומר שעל מספרים בני מאות ספרות - מה שקורה ב-RSA למשל - המחשב שעליו האלגוריתם רץ יפסיק לעבוד הרבה לפני שהאלגוריתם יסיים לרוץ).</p>
<p>הדרך השניה היא לפרק את <span class="math">\(a,b\)</span> לגורמים ראשוניים. הגורמים הראשוניים של <span class="math">\(\left(a,b\right)\)</span> יהיו בדיוק הגורמים של <span class="math">\(a,b\)</span> כשכל גורם מופיע בחזקה הנמוכה יותר מבין אלו שבה הוא מופיע בשני המספרים. נשמע מבלבל? טוב מאוד - אני רוצה שתבינו בעצמכם מה אמרתי פה. אין טעם להרחיב על השיטה הזו כי פירוק לגורמים הוא בעייתי; אנחנו לא מכירים אלגוריתם יעיל לפירוק לגורמים גם כיום, והאלגוריתם האוקלידי קיים עוד מימי היוונים (ואולי עוד לפני כן?) כך שודאי יש דרך אחרת.</p>
<p>אם כן, איך האלגוריתם פועל? כפי שאמרתי, אלגוריתם פירושו פירוק פעולת חישוב מסובכת לפעולות יותר פשוטות. כאן הפעולה הפשוטה יותר היא כזו שלומדים בבית הספר היסודי - חילוק עם שארית. לא אכנס הפעם לדיון על איך עושים את זה בפועל (למרות שזו שאלה מרתקת בפני עצמה - כשהיינו ילדים ולמדנו את זה לא ממש עצרנו - לפחות לא אני - ושאלנו את עצמנו למה זה עובד) אלא רק אגיד מה נובע מזה: בהינתן מספרים טבעיים <span class="math">\(a,b\)</span> אנחנו יודעים למצוא מספרים טבעיים <span class="math">\(q,r\)</span> כך ש-<span class="math">\(a=bq+r\)</span>. ל-<span class="math">\(q\)</span> קוראים <strong>המנה</strong> של <span class="math">\(a\)</span> חלקי <span class="math">\(b\)</span> ול-<span class="math">\(r\)</span> קוראים <strong>השארית</strong>. התכונה הכי הכי הכי הכי חשובה כאן, שלפעמים אנחנו בקושי נותנים עליה את הדעת, היא ה<strong>גודל</strong> של השארית: מובטח לנו שיתקיים <span class="math">\(0\le r<b\)</span>, כלומר השארית תמיד קטנה מהמספר שבו מחלקים. על הפרט הזה קם ונופל הפוסט כולו.</p>
<p>עכשיו אפשר להציג את האלגוריתם האוקלידי. האבחנה המרכזית היא שאם <span class="math">\(a=bq+r\)</span> אז <span class="math">\(\left(a,b\right)=\left(b,r\right)\)</span>. למה? כי אם מישהו מחלק את <span class="math">\(a,b\)</span> הוא יחלק גם את <span class="math">\(a-bq\)</span>, כלומר את <span class="math">\(r\)</span>; ואם מישהו מחלק את <span class="math">\(b,r\)</span> אז הוא מחלק גם את <span class="math">\(bq+r\)</span>, כלומר את <span class="math">\(a\)</span>. בפרט, <span class="math">\(\left(a,b\right)\)</span> מחלק גם את <span class="math">\(r\)</span> ולכן <span class="math">\(\left(a,b\right)\le\left(b,r\right)\)</span> (כי <span class="math">\(\left(a,b\right)\)</span> מחלק את <span class="math">\(b,r\)</span> ולכן קטן או שווה מהמקסימלי שמחלק אותם שהוא <span class="math">\(\left(b,r\right)\)</span>) ובאופן דומה <span class="math">\(\left(b,r\right)\le\left(a,b\right)\)</span>.</p>
<p>זה מעניק לנו את האלגוריתם האוקלידי הפשוט, על המספרים <span class="math">\(a\ge b\)</span>:</p>
<ol>
    <li> אם <span class="math">\(b=0\)</span> החזר את <span class="math">\(a\)</span>.</li>
    <li> חשב את <span class="math">\(a=bq+r\)</span>.</li>
    <li> הצב <span class="math">\(a\leftarrow b,b\leftarrow r\)</span>.</li>
    <li> חזור אל 1.</li>
</ol>
<p>אני אישית חושב שלראות קוד אמיתי אפילו יותר ברור כאן, אז הנה קוד בשפת רובי, שמשתמש ברקורסיה:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">def gcd(a,b)
  return a if b == 0
  return gcd(b, a % b)
end
</code></pre>


</div>

<p>בעולם האמיתי רצוי לשפר את הקוד כך שיטפל גם במקרים שבהם <span class="math">\(a<b\)</span> או שהמספרים לא בהכרח חיוביים, אבל נעזוב את זה.</p>
<p>קצת פחות ברור הוא איך מרחיבים את האלגוריתם הזה כדי למצוא את אותם <span class="math">\(x,y\)</span> שמקיימים <span class="math">\(ax+by=\left(a,b\right)\)</span>. כאן חשיבה רקורסיבית היא מאוד מועילה.</p>
<p>נניח שקיבלנו <span class="math">\(a,b\)</span> ואנחנו רוצים למצוא <span class="math">\(x,y\)</span> כך ש-<span class="math">\(\left(a,b\right)=ax+by\)</span>. מה עושים? ראשית, מחשבים את <span class="math">\(a=qb+r\)</span> כרגיל. כעת החשיבה הרקורסיבית תבוא לידי ביטוי בגישה הבאה: אני אראה איך מוצאים את <span class="math">\(x,y\)</span> עבור <span class="math">\(a,b\)</span> תוך שאני מניח שאני <strong>כבר יודע</strong> איך מוצאים אותם עבור <span class="math">\(b,r\)</span>. אם כן, נניח שמצאתי <span class="math">\(x,y\)</span> כך ש-<span class="math">\(\left(b,r\right)=bx+ry\)</span>. זכרו כעת ש-<span class="math">\(\left(a,b\right)=\left(b,r\right)\)</span>, ולכן בעצם מצאתי <span class="math">\(x,y\)</span> כך ש-<span class="math">\(\left(a,b\right)=bx+ry\)</span>. זה כמעט מה שאני רוצה: רק צריך להיפטר איכשהו מ-<span class="math">\(r\)</span> ולהכניס למשחק את <span class="math">\(a\)</span>. אז נשים לב לכך ש-<span class="math">\(r=a-qb\)</span> ולכן אפשר לכתוב:</p>
<p><span class="math">\(\left(a,b\right)=\left(b,r\right)=bx+\left(a-qb\right)y=ay+\left(x-qy\right)b\)</span></p>
<p>וכאן אני מקווה שהעיקרון כבר אמור להיות ברור - אני <strong>מאוד</strong> ממליץ לכם להפסיק לקרוא לרגע ולכתוב בעצמכם את האלגוריתם שמבצע את החישוב הכללי. למי שמתעצל, הנה הקוד שאני כתבתי:</p>
<div class="code-block">

<pre class="highlight"><code class="language-ruby">def extended_gcd(a,b)
  return [a,1,0] if b == 0
  q = a / b
  r = a % b
  gcd, x, y = extended_gcd(b,r)
  return [gcd, y, x-q*y]
end
</code></pre>


</div>
<p>אם כן, בסופו של דבר גם האלגוריתם האוקלידי המורחב הוא פשוט מאוד למימוש. בספרים בדרך כלל לא נכנסים לפירוט הזה אלא מסתפקים בלהראות איזו דוגמה ולהגיד שאפשר למצוא את <span class="math">\(x,y\)</span> על ידי "חזרה לאחור" בחישוב של האלגוריתם האוקלידי הרגיל, וחבל.</p>
<p>זה מסיים את נושא האלגוריתם האוקלידי. לטעמי הוא דוגמה קלאסית לנושא שפשוט חייבים ללמד בבית הספר ופשוט לא עושים את זה, וחבל. כעת אעבור לדבר על נושא שלא מלמדים בבית הספר, ומזל, כי זה כבר כנראה קצת יותר מדי - מה קורה כשרוצים להכליל את האלגוריתם האוקלידי גם לדברים שאינם המספרים השלמים.</p>
<p>כדי שלא נרחיק לכת יותר מדי, אנחנו מגבילים מראש את הדיון לדברים ש"בבסיסם הם כמו המספרים השלמים". מה זה אומר? פורמלית, חוגים קומוטטיביים עם יחידה שהם תחומי שלמות; לא פורמלית, קבוצות של "איברים" (עוד מעט יהיו דוגמאות) שמוגדרות עליהן פעולות חיבור וכפל שמתנהגות כמו במספרים השלמים (כללי הקיבוץ, החילוף והפילוג). קבוצות כאלו נקראות "חוגים". בנוסף, דורשים שבחוג שלנו יהיה קיים איבר נייטרלי לכפל (כמו 1 במספרים הטבעיים) ועוד תכונה חשובה וכבר לא מובנת מאליה - אי אפשר לכפול שני איברים שונים מאפס ולקבל אפס. זה נכון במספרים השלמים, אבל בחוג השלמים מודולו 6 זה כבר לא כך: 3 כפול 2 שווה 0 (כי השארית שמתקבלת כשמחלקים את 3 כפול 2 ב-6 היא 0). לאיבר שונה מאפס שאפשר לכפול אותו במישהו אחר ששונה מאפס ולקבל אפס קוראים "מחלק אפס". פורמלית כל מספר מחלק את אפס, כי <span class="math">\(a\cdot0=0\)</span> תמיד; זה נהיה מעניין רק כשיש <span class="math">\(b\ne0\)</span> כך ש-<span class="math">\(a\cdot b=0\)</span> התופעה הזו גורמת לדברים מוזרים: אנחנו רגילים לכך שאם <span class="math">\(ax=ay\)</span> עבור <span class="math">\(a\ne0\)</span> אז <span class="math">\(x=y\)</span>; אבל אם <span class="math">\(a\)</span> הוא מחלק אפס אז זה כבר לא יהיה נכון. למשל, אנחנו יודעים שאם <span class="math">\(a\)</span> הוא מחלק אפס אז <span class="math">\(a\cdot b=a\cdot0=0\)</span> עבור <span class="math">\(b\ne0\)</span> כלשהו. ואם נחזור לדוגמה של השלמים מודולו 6, הרי ש-<span class="math">\(2\cdot4=2\cdot1\)</span>, למשל.</p>
<p>לעומת זאת, אם אנחנו דורשים במפורש שלא יהיו מחלקי אפס בחוג שלנו נובע מכך שאכן אם <span class="math">\(ax=ay\)</span> אז <span class="math">\(x=y\)</span> לכל <span class="math">\(a\ne0\)</span>, כי על ידי העברת אגפים וחוק הפילוג מקבלים <span class="math">\(a\left(x-y\right)=0\)</span> ומכיוון ש-<span class="math">\(a\ne0\)</span> בהכרח <span class="math">\(x-y=0\)</span>, כלומר <span class="math">\(x=y\)</span>. כלומר, החשבון מתנהג פחות או יותר כפי שאנחנו מצפים שיתנהג. לחוגים שבהם מתקיימת התכונה הזו קוראים "תחומי שלמות" (לרוב דורשים במפורש שהם גם יהיו קומוטטיביים ועם יחידה אבל נעזוב את זה). אם כן, ההכללה שאציג תניח מראש שבחוגים שאנחנו מדברים עליהם מתקיימות התכונות הללו.</p>
<p>שתי הדוגמאות המרכזיות שאני רוצה לעבוד איתן הן חוג השלמים הגאוסיים, <span class="math">\(\mathbb{Z}\left[i\right]\)</span>, שהוא אוסף המספרים מהצורה <span class="math">\(a+bi\)</span> כאשר <span class="math">\(a,b\)</span> הם שלמים ו-<span class="math">\(i\)</span> הוא מספר מדומה שמקיים <span class="math">\(i^{2}=-1\)</span>; וחוג הפולינומים עם מקדמים ממשיים <span class="math">\(\mathbb{R}\left[x\right]\)</span> (למעשה מה שאגיד יהיה תקף לחוג הפולינומים מעל כל שדה, אבל יותר קל לחשוב על מקרה קונקרטי כמו הממשיים). תרגיל טוב לקוראים הוא לוודא שהחוגים הללו הם אכן תחומי שלמות - בפרט עבור השלמים הגאוסיים זה לא מובן מאליו כי מינוסים יכולים לצוץ במקומות שלא ציפינו להם.</p>
<p>המרכיב הנוסף שחסר לנו כדי להתחיל להריץ את האלגוריתם האוקלידי גם על החוגים הללו הוא חילוק עם שארית. אם <span class="math">\(\alpha,\beta\)</span> הם שלמים גאוסיים, היינו רוצים לומר שאפשר לכתוב <span class="math">\(\alpha=\beta\cdot\gamma+\rho\)</span> (האותיות היווניות מטרתן להבהיר שמדובר על שלמים גאוסיים ולא על מספרים "רגילים") כך ש-<span class="math">\(\rho\)</span> "קטן מ-<span class="math">\(\beta\)</span>". אבל זה מעלה את השאלה - קטן באיזה מובן? איך מודדים?</p>
<p>התשובה היא פשוטה - אפשר למדוד באיזו דרך שבא לנו כל עוד המטרה שלנו - האלגוריתם האוקלידי - עדיין תעבוד. דבר אחד שהוא קריטי לאלגוריתם האוקלידי הוא שעניין הגדלים מבטיח שהוא יסתיים מתישהו, כי כל שארית קטנה מקודמתה ולכן מתישהו נגיע לשארית עם גודל אפס, שאומר שהשארית גם היא אפס. בשורה המסכנה הזו יש הנחות מכאן ועד להודעה חדשה. בואו נפרק אותן לגורמים:</p>
<p>ראשית, אם ה"גודל" יכול להיות מספר רציונלי כלשהו, לא קשה לראות שאפשר לבנות סדרה יורדת אינסופית של גדלים שאף פעם לא מגיעה לאפס: <span class="math">\(1,\frac{1}{2},\frac{1}{4},\frac{1}{8},\dots\)</span>. כדי למנוע עיוותים כאלו אנחנו רוצים שהגדלים שלנו יהיו בעלי <strong>סדר טוב</strong>, או כדי לחסוך כאב ראש - אנחנו רוצים ש"גודל" יהיה תמיד מספר טבעי (חיובי או אפס).</p>
<p>שנית, אנחנו רוצים לדרוש במפורש שהגודל של 0 יהיה 0. עניין הגדרתי שכזה (למעשה, כפי שנראה בקרוב, ה"גודל" של 0 פשוט לא מעניין אותנו לרוב).</p>
<p>שלישית, יש לנו התחבטות האם להתיר לאיברים אחרים להיות בעלי "גודל 0" או רק לאפס. כפי שנראה בקרוב, מאוד נוח לפעמים להתיר לעוד איברים להיות בעלי "גודל 0"; זה ידרוש מאיתנו לשנות טיפה את ההגדרה של חלוקה עם שארית.</p>
<p>השם המפורש במתמטיקה ל"גודל" המדובר הוא <strong>נורמה</strong>. זה שם מבלבל כי המילה "נורמה" מופיעה בהרבה הקשרים במתמטיקה, אבל בפוסט הזה אדבר רק על ההקשר הזה כך שלא יהיה חשש לבלבול. בהגדרה הפשוטה שלנו, אנו דורשים רק שהנורמה של איבר <span class="math">\(a\)</span> של החוג, שאסמן כ-<span class="math">\(N\left(a\right)\)</span>, תהיה מספר שלם אי שלילי ותו לא; הדרישה הנוספת היחידה שיש לי היא זו של חילוק עם שארית:</p>
<p>אם <span class="math">\(a,b\)</span> איברים של החוג כך ש-<span class="math">\(b\ne0\)</span> אז קיימים <span class="math">\(q,r\)</span> בחוג כך ש-<span class="math">\(a=bq+r\)</span> ובנוסף, או ש-<span class="math">\(r=0\)</span>, או ש-<span class="math">\(N\left(r\right)<N\left(b\right)\)</span>.</p>
<p>ההגדרה הזו עוקפת את ה"בעיה" בכך שיש איברים בעלי נורמה 0. אנחנו מרשים להם להתקיים, אבל אם הם מחלקים מישהו, מובטח שהשארית באותה חלוקה תהיה אפס. למה? כי אם <span class="math">\(N\left(b\right)=0\)</span> ו-<span class="math">\(a=bq+r\)</span> ו-<span class="math">\(N\left(r\right)<N\left(b\right)\)</span> או ש-<span class="math">\(r=0\)</span>, בהכרח האופציה השניה חייבת להתקיים כי לא ייתכן ש-<span class="math">\(N\left(r\right)<0\)</span> שהרי הנורמה היא מספר אי שלילי. זה מבטיח לנו שהאלגוריתם האוקלידי ניתן להפעלה בחוג ושהוא מסתיים אחרי מספר צעדים סופי (כשצצה השארית 0).</p>
<p>לחוגים שבהם קיימת נורמה שעונה על הדרישות שהצגתי קוראים <strong>חוגים אוקלידיים</strong>. אם כן, <span class="math">\(\mathbb{Z}\)</span> הוא חוג אוקלידי עם הנורמה <span class="math">\(N\left(a\right)=\left|a\right|\)</span> - הערך המוחלט. אולי אתם שואלים את עצמכם איך <strong>מוכיחים פורמלית</strong> את העובדה הזו שידענו עוד מאז שהיינו ילדים - איך מוכיחים שיש חילוק עם שארית ב-<span class="math">\(\mathbb{Z}\)</span>? ובכן, הנה הוכחה פשוטה באינדוקציה. נ</p>
<p>ניח שאנחנו רוצים לחלק את <span class="math">\(n\)</span> ב-<span class="math">\(b\)</span>. נניח ש-<span class="math">\(b\)</span> קבוע ונבצע אינדוקציה על <span class="math">\(n\)</span>. ראשית, עבור <span class="math">\(n=0,1,\dots,b-1\)</span> הטענה נובעת מייד: <span class="math">\(n=b\cdot0+n\)</span>, וזה חוקי כי <span class="math">\(0\le n<b\)</span>. אם כן, זה הבסיס שלנו. צעד האינדוקציה הוא כדלהלן: בהינתן <span class="math">\(n\)</span>, ניתן להפעיל את הנחת האינדוקציה על <span class="math">\(n-b\)</span> ולקבל ש-<span class="math">\(n-b=qb+r\)</span>, כך ש-<span class="math">\(0\le r<b\)</span>; מכאן נובע ש-<span class="math">\(n=\left(q+1\right)b+r\)</span>. פשוט, לא?</p>
<p>נעבור כעת לחוגים <span class="math">\(\mathbb{Z}\left[i\right]\)</span> ו-<span class="math">\(\mathbb{R}\left[x\right]\)</span>. שניהם אוקלידיים, אבל עם אילו נורמות? הנורמה ב-<span class="math">\(\mathbb{Z}\left[i\right]\)</span> היא ההכללה הטבעית של הערך המוחלט עבור מספרים מרוכבים: <span class="math">\(N\left(a+bi\right)=a^{2}+b^{2}\)</span>. כאן עלול להתקבל הרושם השגוי לפיו הנורמה הזו מראה שכל חוג שלמים הוא אוקלידי עם הנורמה הזו, או שכל חוג שלמים אוקלידי, אוקלידי עם הנורמה הזו. <strong>זה לא נכון</strong>! זה עובד ב-<span class="math">\(\mathbb{Z}\left[i\right]\)</span> כי יש לנו מזל וכי זה חוג נחמד במיוחד, לא כחלק מאיזה עקרון גורף.</p>
<p>עבור פולינומים, הנורמה פשוטה עוד יותר. <span class="math">\(N\left(p\left(x\right)\right)\)</span> היא פשוט הדרגה של <span class="math">\(p\left(x\right)\)</span>, כלומר החזקה הגבוהה ביותר של <span class="math">\(x\)</span> שמופיעה בו. כאן באופן טבעי צצים איברים מנורמה 0: כל פולינום קבוע (כלומר, מספר ממשי). למעשה, הדרגה של פולינום האפס לרוב אינה מוגדרת, או מוגדרת להיות אינסוף, או מינוס אינסוף, או אלף ואחד דברים הזויים שאינם אפס, כך שזו דוגמה טובה לחוג שבו אנחנו ממש רוצים להימנע מלדבר על "הנורמה של אפס" (למרות שאפשר גם להגדיר אותה להיות אפס וזה לא ישנה כלום).</p>
<p>כמובן, סתם להגיד את הנורמה זה לא רציני. צריך גם להוכיח שקיים חילוק עם שארית בחוגים שתיארתי, עם הנורמה שתיארתי. אין כאן ארוחות חינם - כל הוכחה שכזו היא אתגר בפני עצמו עם טריקים משל עצמה. עם נורמות מתאימות גם <span class="math">\(\mathbb{Z}\left[\sqrt{-2}\right],\mathbb{Z}\left[\sqrt{-3}\right],\mathbb{Z}\left[\sqrt{-7}\right],\mathbb{Z}\left[\sqrt{-11}\right]\)</span> הם חוגים אוקלידיים, אבל למשל החוג <span class="math">\(\mathbb{Z}\left[\sqrt{-5}\right]\)</span> אינו חוג אוקלידי! למעשה, יש רק מספר סופי של חוגים אוקלידיים מהצורה <span class="math">\(\mathbb{Z}\left[\sqrt{D}\right]\)</span> עבור <span class="math">\(D\)</span> שלם. אני אסיים את הפוסט עם הצגת ההוכחות ש-<span class="math">\(\mathbb{Z}\left[i\right]\)</span> ו-<span class="math">\(\mathbb{R}\left[x\right]\)</span> הם חוגים אוקלידיים, אבל לפני כן אני רוצה לדבר קצת על מה שנובע מכך.</p>
<p><a href="http://www.gadial.net/2011/08/19/algebraic_number_theory_intro_1/">בפוסט קודם</a> דיברתי על פריקות יחידה לגורמים בחוגי שלמים וכמה היא חשובה. בהקשר הזה הצגתי את המושג של אידאלים של חוג - תת-קבוצות של החוג שסגורות לחיבור ו"בולעות" בכפל (כלומר, סכום שני איברים מהאידאל גם הוא באידאל, וכפל איבר מהאידאל באיבר כלשהו מהחוג גם הוא שייך לאידאל). אידאלים הובאו בתור מעין אבסטרקטיזציה של מחלקים - אידאל היה קבוצת כל האיברים שמתחלקים על ידי "מישהו" (כשבמהלך מחשבתי שאני מאוד מחבב, ה"מישהו" הזה הוא פשוט האידאל עצמו). כמו כן ראינו שב-<span class="math">\(\mathbb{Z}\)</span> כל אידאל היה ניתן לזיהוי בצורה פשוטה עם מספר: לכל מספר <span class="math">\(a\)</span> הותאם האידאל ש-<span class="math">\(a\)</span> יוצר - אוסף כל הכפולות של <span class="math">\(a\)</span> באיבר כלשהו של <span class="math">\(\mathbb{Z}\)</span> - וראינו שכל אידאל הוא בהכרח מהצורה הזו (ואז האיברים באידאל הם אכן בדיוק האיברים ש-<span class="math">\(a\)</span> מחלק). לחוג שבו כל אידאל נוצר כך בידי איבר מסויים קוראים <strong>תחום ראשי</strong>, ותוצאה מרכזית שלא הוכחתי (עדיין, לפחות) היא שכל תחום ראשי הוא גם בעל פריקות יחידה לראשוניים.</p>
<p>מה שאני רוצה להראות עכשיו הוא שכל חוג אוקלידי הוא בפרט תחום ראשי. ההוכחה קלילה עד להפתיע. יהא <span class="math">\(I\subseteq R\)</span> אידאל (<span class="math">\(I\)</span> הוא האידאל, <span class="math">\(R\)</span> הוא חוג אוקלידי כלשהו). אז קיים ב-<span class="math">\(I\)</span> איבר בעל נורמה מינימלית, <span class="math">\(d\)</span>. למה קיים כזה? כי הנורמות הן מספרים שלמים אי שליליים ולכן קיים להן מינימום. כמובן, ייתכן שיש באידאל הרבה איברים מנורמה מינימלית, אז נבחר אחד באופן שרירותי. אני טוען שאותו <span class="math">\(d\)</span> יוצר את האידאל. כיוון אחד הוא מובן מאליו: בשל תכונת הבליעה, <span class="math">\(dr\in I\)</span> לכל <span class="math">\(r\in R\)</span>, כך שהאידאל ש-<span class="math">\(d\)</span> יוצר מוכל ב-<span class="math">\(I\)</span>. אבל למה כל איבר ב-<span class="math">\(I\)</span> מתחלק ב-<span class="math">\(d\)</span>? ובכן, יש לנו חילוק עם שארית כי <span class="math">\(R\)</span> אוקלידי - הבה ונשתמש בו: אם <span class="math">\(a\in I\)</span> הוא איבר כלשהו של האידאל, אז <span class="math">\(a=qd+r\)</span>, כך ש-<span class="math">\(r=0\)</span> או ש-<span class="math">\(N\left(r\right)<N\left(d\right)\)</span>. כעת, <span class="math">\(a\in I\)</span> וגם <span class="math">\(qd\in I\)</span> (מבליעה) ולכן <span class="math">\(r=a-qd\in I\)</span>. אבל בחרנו את <span class="math">\(d\)</span> להיות איבר מנורמה מינימלית ב-<span class="math">\(I\)</span>, אז לא ייתכן ש-<span class="math">\(r\)</span> (שראינו ששיך ל-<span class="math">\(I\)</span>) הוא בעל נורמה קטנה מ-<span class="math">\(d\)</span>; מכאן ש-<span class="math">\(r=0\)</span> ולכן <span class="math">\(d\)</span> מחלק את <span class="math">\(a\)</span>.</p>
<p>אם ההוכחה נשמעת לכם מוכרת (ולא למדתם אותה אף פעם), זה כנראה לא במקרה: ב<a href="http://www.gadial.net/2011/08/21/algebraic_number_theory_intro_2/">פוסט</a> שבו הצגתי אידאלים הצגתי גם את ההוכחה הזו, עבור <span class="math">\(\mathbb{Z}\)</span>. עד כדי שינויי ניסוח קלים, זו אותה ההוכחה בדיוק.</p>
<p>כעת אני רוצה לדבר טיפה על פולינומים. מה שמעניין בכך שהפולינומים (במקדמים ממשיים, או באופן כללי יותר מעל שדה כלשהו; זה לא נכון לפולינומים מעל קבוצה שאיננה שדה) הם חוג אוקלידי הוא שזה מצביע על דמיון לא מבוטל שלהם למספרים השלמים, ודמיון שכזה עשוי להיות מפתיע למדי במבט ראשון. זה אומר שאפשר לחלק פולינומים כמו שמחלקים שלמים (ואפילו יש אלגוריתם חילוק ארוך בדיוק כמו עם שלמים), ואפשר למצוא מחלק משותף מקסימלי לפולינומים (אותו קוד שכתבתי למעלה עובד באותה מידה גם לפולינומים; רק צריך לשנות את המימוש של פעולת החילוק ופעולת המודולו) ואפשר גם לפרק פולינומים לגורמים. באופן מפתיע למדי, פירוק של פולינומים לגורמים הוא <strong>קל יותר</strong> מבחינה חישובית מאשר פירוק של מספרים שלמים (לא ידוע כיום אלגוריתם יעיל לפירוק שלמים, אבל לפירוק של פולינומים יש אלגוריתמים לא רעים). כדי לקבל אינטואיציה כלשהי לגבי הסיבה לכך, בואו נבין איך נראה פירוק שכזה.</p>
<p>ראשית כל, פולינום הוא יצור שחי חיים כפולים: <span class="math">\(p\left(x\right)=x^{3}+2x+17\)</span> הוא מצד אחד ביטוי פורמלי עם איקס וחזקות וסכומים; ומצד שני הוא פונקציה - אפשר "להציב" בו ערכים ולראות מה מקבלים. אם <span class="math">\(p\left(a\right)=0\)</span> עבור <span class="math">\(a\)</span> כלשהו, <span class="math">\(a\)</span> נקרא "שורש" של הפולינום (לא במשמעות של <span class="math">\(\sqrt{p\left(x\right)}\)</span>, חלילה; זה עוד שימוש כפול מבלבל באותה מילה). השורשים של הפולינום הם המפתח לפירוק לגורמים שלו: אם <span class="math">\(p\left(x\right)\)</span> הוא פולינום ו-<span class="math">\(a\)</span> שורש שלו, אז <span class="math">\(\left(x-a\right)\)</span> מחלק את <span class="math">\(p\left(x\right)\)</span>. בואו נראה איך מוכיחים את הטענה הזו, שנובעת ישירות מכך שהפולינומים הם חוג אוקלידי.</p>
<p>חוג אוקלידי אומר שניתן לחלק עם שארית, אז בואו נעשה את זה: <span class="math">\(p\left(x\right)=\left(x-a\right)\cdot q\left(x\right)+r\left(x\right)\)</span>. כעת, <span class="math">\(r\left(x\right)\)</span> הוא אפס או פולינום מדרגה נמוכה יותר מ-<span class="math">\(x-a\)</span> ומכיוון ש-<span class="math">\(x-a\)</span> הוא פולינום מדרגה 1, אז <span class="math">\(r\left(x\right)\)</span> הוא פולינום קבוע ולכן הוא בעצם מספר ממשי <span class="math">\(r\)</span>. כעת, אם נציב <span class="math">\(x=a\)</span> במשוואה שקיבלנו, נקבל: <span class="math">\(0=p\left(a\right)=\left(a-a\right)q\left(a\right)+r=r\)</span>, כלומר השארית חייבת להיות אפס, וזה מסיים בזריזות את ההוכחה.</p>
<p>התוצאה הזו מלמדת אותנו שכל פולינום <span class="math">\(p\left(x\right)\)</span> ניתן לפירוק יחיד מהצורה <span class="math">\(p\left(x\right)=a\left(x-a_{1}\right)\left(x-a_{2}\right)\cdots\left(x-a_{n}\right)\)</span> (ה-<span class="math">\(a\)</span> שמחוץ לסוגריים הוא מספר ממשי ששווה למקדם של החזקה הגבוהה ביותר ב-<span class="math">\(p\left(x\right)\)</span>; מנקודת מבט אלגברית זה איבר הפיך ולכן "לא רלוונטי" כמו שכפל ב-1 ובמינוס 1 לא רלוונטי בפירוק לגורמים ראשוניים ב-<span class="math">\(\mathbb{Z}\)</span>). לרוע המזל, החיים לא בהכרח פשוטים עד כדי כך - אני מסתמך כאן במובלע על ההנחה שלכל פולינום קיים שורש (ואז אפשר לחלק באיקס פחות השורש, לקבל פולינום מנה <span class="math">\(q\left(x\right)\)</span> קטן יותר, גם לו למצוא שורש וכן הלאה) אבל זה תלוי ב"עולם" שבו אנו חיים. כך למשל לפולינום <span class="math">\(x^{2}+1\)</span> אין שורשים ממשיים ולכן כאיבר של <span class="math">\(\mathbb{R}\left[x\right]\)</span>, הוא עצמו ראשוני וזהו הפירוק שלו לגורמים. לעומת זאת, מעל <span class="math">\(\mathbb{C}\left[x\right]\)</span> הפירוק שלו לגורמים ראשוניים יהיה <span class="math">\(\left(x+i\right)\left(x-i\right)\)</span>. אחת התוצאות החשובות באלגברה היא שלכל פולינום קיים שדה שבו הוא מתפרק לגורמים ממעלה 1 - <strong>שדה הפיצול</strong> של הפולינום; אבל לא אכנס לכך כעת.</p>
<p>לסיום, בואו נבין למה פולינומים ושלמים גאוסיים הם חוגים אוקלידיים. נתחיל מפולינומים. יש לנו שני פולינומים <span class="math">\(a\left(x\right),b\left(x\right)\)</span>; אנחנו רוצים למצוא שני פולינומים <span class="math">\(q\left(x\right),r\left(x\right)\)</span> כך ש-<span class="math">\(a\left(x\right)=b\left(x\right)q\left(x\right)+r\left(x\right)\)</span> ודרגת <span class="math">\(r\left(x\right)\)</span> קטנה מדרגת <span class="math">\(b\left(x\right)\)</span> (או ש-<span class="math">\(r\left(x\right)=0\)</span>). מה עושים?</p>
<p>ובכן, ההוכחה מאוד דומה למה שהראיתי קודם עבור שלמים: "מקפיאים" את <span class="math">\(b\left(x\right)\)</span> ומוכיחים לכל <span class="math">\(a\left(x\right)\)</span> באינדוקציה על דרגת <span class="math">\(a\left(x\right)\)</span>. הבסיס הוא דרגה שקטנה מדרגת <span class="math">\(b\left(x\right)\)</span>: עבורה <span class="math">\(a\left(x\right)=b\left(x\right)\cdot0+a\left(x\right)\)</span> (כי <span class="math">\(a\left(x\right)\)</span> הוא שארית לגיטימית). הצעד הוא קצת יותר מחוכם מאשר בשלמים: אם דרגת <span class="math">\(a\left(x\right)\)</span> גדולה או שווה לדרגת <span class="math">\(b\left(x\right)\)</span>, אז על ידי כפל של <span class="math">\(b\left(x\right)\)</span> בפולינום כלשהו <span class="math">\(t\left(x\right)\)</span> אפשר לקבל פולינום <span class="math">\(b\left(x\right)t\left(x\right)\)</span> שדרגתו שווה לדרגת <span class="math">\(a\left(x\right)\)</span> והמקדם המוביל של שניהם זהה. מכך עולה ש-<span class="math">\(a\left(x\right)-b\left(x\right)t\left(x\right)\)</span> הוא פולינום מדרגה קטנה מדרגת <span class="math">\(a\left(x\right)\)</span> ולכן אפשר להשתמש עליו בהנחת האינדוקציה. מקבלים: <span class="math">\(a\left(x\right)-b\left(x\right)t\left(x\right)=b\left(x\right)q\left(x\right)+r\left(x\right)\)</span>, ולכן <span class="math">\(a\left(x\right)=b\left(x\right)\left[t\left(x\right)+q\left(x\right)\right]+r\left(x\right)\)</span>. כלומר, השלב היחיד כאן שבו היה עלינו לפעול בצורה שונה מבהוכחה עבור <span class="math">\(\mathbb{Z}\)</span> היה האופן שבו "הקטנו" את <span class="math">\(a\left(x\right)\)</span>.</p>
<p>עבור שלמים גאוסיים זה כבר לא עובד ככה. הרבה פחות ברור איך לבצע "הקטנה" שכזו. לכן ההוכחה גם יותר מסובכת.</p>
<p>אם כן, יהיו <span class="math">\(\alpha=a+bi\)</span> ו-<span class="math">\(\beta=c+di\)</span> שני שלמים גאוסיים כך ש-<span class="math">\(\beta\ne0\)</span>. מה שנעשה יהיה לחלק אותם בכוח, ואז לאסוף את השברים מהרצפה. כשאני אומר לחלק בכוח, הכוונה היא לכך שנחשב את <span class="math">\(\frac{\alpha}{\beta}\)</span> באופן ישיר:</p>
<p><span class="math">\(\frac{\alpha}{\beta}=\frac{a+bi}{c+di}=\frac{a+bi}{c+di}\frac{c-di}{c-di}=\frac{ac+bd}{c^{2}+d^{2}}+\frac{bc-ad}{c^{2}+d^{2}}i=t+si\)</span></p>
<p>כלומר, קיבלנו ש-<span class="math">\(\frac{\alpha}{\beta}\)</span> הוא מהצורה <span class="math">\(t+si\)</span> כאשר <span class="math">\(t,s\)</span> הם מספרים רציונליים (לא בהכרח שלמים, אחרת היינו יכולים לסיים כאן). למרבה המזל, לכל רציונלי יש מספר שלם שקרוב אליו - לכל היותר במרחק <span class="math">\(\frac{1}{2}\)</span> ממנו. אז בואו וניקח את <span class="math">\(p,q\)</span> להיות השלמים המתאימים: <span class="math">\(\left|t-p\right|\le\frac{1}{2}\)</span> ו-<span class="math">\(\left|s-q\right|\le\frac{1}{2}\)</span>. אם כן, השלם הגאוסי <span class="math">\(p+qi\)</span> נראה כמו הימור טוב להיות המנה של <span class="math">\(\alpha\)</span> ו-<span class="math">\(\beta\)</span> שתותיר את השארית הכי קטנה שאפשר (מבחינת הנורמה). אם כן, נכתוב <span class="math">\(\alpha=\left(p+qi\right)\beta+\gamma\)</span> ומה שעלינו לברר הוא ש-<span class="math">\(N\left(\gamma\right)<N\left(\beta\right)\)</span>.</p>
<p>למקרה שזה לא ברור - <span class="math">\(\gamma\)</span> <strong>מוגדר</strong> על ידי הנוסחה <span class="math">\(\gamma=\alpha-\left(p+qi\right)\beta\)</span>, ולכן גם מובטח לנו שהוא שלם גאוסי. מה שלא ברור הוא איך לחשב את הנורמה שלו. כדי להקל על החישוב הזה נמצא <span class="math">\(\theta\)</span> מרוכב (לא בהכרח שלם גאוסי בעצמו) כך שיתקיים <span class="math">\(\gamma=\theta\beta\)</span>. זה יקל עלינו שכן הנורמה שבה אנו משתמשים בשלמים הגאוסים וניתנת להגדרה עבור כל מספר מרוכב מקיימת תכונה נחמדה (שבאופן כללי לא נהוג במיוחד לדרוש, למרות שלפעמים עושים זאת) - היא <strong>כפלית</strong>. כלומר בפרט <span class="math">\(N\left(\gamma\right)=N\left(\theta\right)N\left(\beta\right)\)</span> (הכפליות ניתנת להוכחה בקלות יחסית אם שמים לב לכך שהנורמה הזו מקיימת <span class="math">\(N\left(\alpha\right)=\alpha\cdot\overline{\alpha}\)</span> - כפל בצמוד המרוכב).</p>
<p>טוב, אז מהו אותו <span class="math">\(\theta\)</span> מסתורי? לא קשה למצוא אותו אם שמים לב לכך ש-<span class="math">\(\alpha=\left(t+si\right)\beta\)</span>, כלומר <span class="math">\(\gamma=\left(t+si\right)\beta-\left(p+qi\right)\beta=\left[\left(t-p\right)+\left(s-q\right)i\right]\beta\)</span>, כלומר <span class="math">\(\theta=\left(t-p\right)+\left(s-q\right)i\)</span>. נותר רק לחסום את גודל הנורמה של <span class="math">\(\theta\)</span> ולהראות שהוא קטן מ-1: <span class="math">\(N\left(\theta\right)=\left(t-p\right)^{2}+\left(s-q\right)^{2}\le\left|\frac{1}{2}\right|^{2}+\left|\frac{1}{2}\right|^{2}\le\frac{1}{2}&lt;1\)</span>. זה מסיים את ההוכחה (וגם מסביר למה עניין ה"קרוב עד כדי חצי" היה חשוב לנו).</p>
<p>לטעמי ההוכחה הזו <strong>מגעילה</strong>. אמנם, אין בה קסמים וכל הצעדים בה ברורים יחסית, אבל היא מאוד מותאמת לנורמה הספציפית הזו ולשלמים הגאוסיים. זו גם בדיוק הסיבה שהבאתי אותה - רק כך מקבלים תחושה כלשהי של הקושי בהוכחה שחוגים מסויימים הם אוקלידיים ומבינים מדוע זה לא עובד לכל חוג שלמים, ולכן גם למה חוגים אוקלידיים זו תופעה נדירה ונפלאה יותר משנדמה במבט ראשון.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>