<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מעגלים בוליאניים - מה זה בכלל? - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/blog/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/blog/">דף הבית</a>
                <a href="/blog/random.html">פוסט אקראי</a>
                <a href="/blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/blog/2011/01/16/derivative_and_extremal_problems_1-2/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">נגזרת - בשביל מה זה טוב? (בעיות קיצון, חלק ב&#39;)</span>
            </a>
            

            
            <a href="/blog/2011/01/20/box_riddle/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">חידת קופסאות</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>מעגלים בוליאניים - מה זה בכלל?</h1>
            <div class="post-meta">
                <span class="date">2011-01-18</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/מודלים חישוביים.html">מודלים חישוביים</a>
                    
                    <a href="/tags/מעגלים בוליאניים.html">מעגלים בוליאניים</a>
                    
                    <a href="/tags/פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;.html">פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;</a>
                    
                    <a href="/tags/שאלת P=NP.html">שאלת P=NP</a>
                    
                    <a href="/tags/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אני מתחיל את פרוייקט "<a href="http://www.gadial.net/2011/01/09/surprising_results_in_complexity_prologue/">תוצאות מפתיעות בסיבוכיות</a>" עם תיאור של משפט ברינגטון, שכמו רוב המשפטים בסיבוכיות הוא יחסי - אומר ששתי מחלקות סיבוכיות בעלות הגדרה שונה הן זהות - ועל כן נשמע לקורא מבחוץ כמו "ג'יבריש ג'יבריש בלה בלה שווה לבלה בלה ג'יבריש ג'יבריש". אין מנוס, לפני שמציגים את המשפט, להציג את מחלקות הסיבוכיות המתאימות ולמה הן מעניינות. מילת אזהרה כללית: למרות שאני מייעד את הפוסטים הללו לכל קוראי הבלוג, אני בהחלט עשוי לזרוק פה ושם מושגים שנראים לי ברורים ולקורא לא. במקרה כזה אפשר לשאול שאלה בתגובות, אפשר לחפש בפוסטים ישנים יותר בבלוג, ואפילו להיעזר בויקיפדיה.</p>
<p>באופן כללי, <strong>מחלקת סיבוכיות</strong> היא אוסף של פונקציות שניתן לחשב בעזרת מודל חישובי מסויים שעל כמות המשאבים שלו יש מגבלה כלשהי. המודל הקלאסי נקרא <a href="http://www.gadial.net/2007/09/23/turing_machine/">מכונת טיורינג</a> והמגבלה הקלאסית עליו היא זמן ריצה פולינומי (שניתן לחסום על ידי פולינום). אנחנו לא הולכים לדבר על המודל הזה. הפעם אני הולך לדבר על מודל שונה למדי - <strong>מעגלים בוליאניים</strong> (Boolean Circuits).</p>
<p>ראשית, המטרה שלנו. אנחנו הולכים לדבר רק על פונקציות בוליאניות - כאלו שמקבלות קלט שהוא סדרה של 0 ו-1, ומוציאות פלט שהוא ביט בודד - או 0 או 1. פורמלית, <span class="math">\(f:\left\{ 0,1\right\} ^{n}\to\left\{ 0,1\right\} \)</span>. בהקשר של מדעי המחשב מספיק לדבר על פונקציות כאלו כי כל פונקציה אחרת שניתן לחשב במחשב ניתנת לתיאור באמצעות פונקציות בוליאניות. על ערכים בוליאניים אוהבים להגדיר פעולות של "וגם" ו"או", מתוך מחשבה על ערך 1 כמייצג "אמת" וערך 0 כמייצג "שקר". אם <span class="math">\(x,y\)</span> הם שני ביטים, אז <span class="math">\(x\wedge y\)</span> (<span class="math">\(x\)</span> וגם <span class="math">\(y\)</span>) הוא 1 אם ורק אם <span class="math">\(x=y=1\)</span>, אחרת הוא 0; ואילו <span class="math">\(x\vee y\)</span> (<span class="math">\(x\)</span> או <span class="math">\(y\)</span>) הוא 0 אם ורק אם <span class="math">\(x=y=0\)</span> ואחרת הוא 1. ה"או" הזה קצת שונה מהמשמעות שלו בחיי היום יום, כי הוא יכול לקבל "אמת" גם אם שני המשתנים קיבלו "אמת" ("או שאלך לים או שאקרא ספר" נשמע כאילו הוא אומר "אעשה אחד משני אלו אך לא את שניהם בו זמנית"). יש אופרטור אחר, Exclusive Or, או בשמו המקוצר XOR, ובסימון <span class="math">\(x\oplus y\)</span>, שמקבל 1 אם ורק אם בדיוק אחד משני המשתנים מכיל 1, שממדל את ה"או" היומיומי. כמו כן יש אופרטור שלילה שפועל רק על משתנה יחיד: <span class="math">\(\neg x\)</span> הוא 1 אם ורק אם <span class="math">\(x\)</span> היה 0.</p>
<p>אלו פונקציות בסיסיות, אבל אפשר להגדיר פונקציות מורכבות יותר על הרבה יותר ביטים. החל ממשהו מטופש כמו <span class="math">\(f\left(x_{1},\dots,x_{n}\right)=\bigwedge x_{i}\)</span> שמקבל 1 אם ורק אם כל <span class="math">\(n\)</span> הקלטים הם 1, עבור בדברים יותר מתוחכמים כמו <span class="math">\(\text{MAJORITY}\left(x_{1},\dots,x_{n}\right)\)</span> שמקבלת 1 אם ורק אם רוב הביטים בקלט הם 1, וכלה בדברים ממש מתוחכמים כמו הפונקציה שמוציאה 1 רק אם הביטים של הקלט שלה, כשמפרשים אותם על ידי קידוד כלשהו בתור גרף, מייצגים גרף שמכיל מעגל המילטוני. למעשה, אפשר לכמת ולהגיד בדיוק כמה פונקציות יש מ-<span class="math">\(n\)</span> ביטים אל שני ביטים: <span class="math">\(2^{2^{n}}\)</span>. כבר עבור ערכים לא גדולים של <span class="math">\(n\)</span> המספר הזה הוא עצום - יש עושר רב של פונקציות בינאריות. השאלה שאנו שואלים את עצמנו היא - אילו פונקציות ניתן לתאר באמצעות שימוש בפונקציות בסיסיות ופשוטות בלבד, ובאופן חסכוני במשאבים?</p>
<p>כאן נכנסים המעגלים הבוליאניים לתמונה. ההשראה לשימוש בהם בתורת הסיבוכיות הכל כך תיאורטית הגיעה ישירות מהשימוש בהם כדי לתאר (מודל מופשט של) חומרה. שערים לוגיים הם הבסיס למחשב אמיתי; אם כן, למה לא להשתמש בהם כדי לתאר חישובים? כתמיד בתורת הסיבוכיות, צריך לזכור מה המטרה שלנו. היא איננה להציג מעגלים לחישוב של כל מני פונקציות מגניבות - כשמדעני מחשב מנסים <strong>לפתור</strong> בעיה הם עושים את זה תמיד במודל מופשט ככל העניין, ורק בסוף מתחילים לשאול את עצמם האם ניתן "לתרגם" את הפתרון למודלים פשוטים וקונקרטיים יותר - המטרה היא בדיוק ההפך, להראות ש<strong>אי אפשר</strong> לפתור בעיות מסויימות. שהמודל של מעגלים בוליאניים הוא חלש במידה מסויימת, וכפועל יוצא מכך - שיש בעיות שהן קשות <strong>אינהרנטית</strong>, ובאף מודל מציאותי לא ניתן יהיה לפתור אותן. בתחילת שנות השבעים, שהמעגלים הבוליאניים נכנסו לתמונה כמודל חישוב אלטרנטיבי למודל הסטנדרטי של מכונת טיורינג, התקווה הייתה שבגלל הפשטות הרבה שלהם והאופי הקונקרטי יותר שלהם, יהיה קל יותר להוכיח חסמים תחתונים עבורם מאשר עבור מכונת טיורינג. התקווה הזו התבדתה למדי במהלך השנים כשהתברר עד כמה הוכחת חסמים תחתונים אפילו עבור המודל הזה היא קשה. תוצאה מפורסמת ביותר בהקשר הזה היא זו של רזבורוב ורודיץ' מ-94, שהראתה כי "<a href="http://en.wikipedia.org/wiki/Natural_proof">הוכחות טבעיות</a>" (לא אכנס כרגע להסבר של המושג) לא מסוגלות להוכיח חסמים תחתונים עבור מעגלים בוליאניים. ובניסוח יומיומי: יש הוכחה מתמטית לכך שיהיה מאוד, מאוד קשה להוכיח חסמים תחתונים על מעגלים בוליאניים. מכיוון שאחד מהיעדים הבסיסיים של חסמים תחתונים על מעגלים בוליאניים הוא להוכיח ש-<span class="math">\(\text{P}\ne\text{NP}\)</span>, זוהי <a href="http://www.gadial.net/2010/08/16/p_vs_np_hard_to_diagonalize/">עוד דוגמה</a> לכך ששאלת <span class="math">\(\text{P}\ne\text{NP}\)</span> היא שאלה קשה בצורה יוצאת דופן, וגם פתרונה כנראה יצטרך להיות יוצא דופן - גישה שונה לגמרי למושג הסיבוכיות ולאופן שבו מוכיחים חסמים תחתונים לגביו.</p>
<p>בואו נעבור להגדרה של מעגל בוליאני - מה זה בכלל? כרגיל בעניינים כאלו, תמונה אחת שווה אלף מילים:</p>
<p><strong><a href="/blog/img/2011/01/Boolean-Circuit.png"><img class="alignnone size-medium wp-image-982" title="Boolean Circuit" src="/blog/img/2011/01/Boolean-Circuit.png" alt="" width="224" height="300" /></a><br />
</strong></p>
<p>פורמלית, מעגל בוליאני הוא גרף מכוון וחסר מעגלים (מהו המושג הזה? יש לי <a href="http://www.gadial.net/2008/05/06/eulerian_graphs/">פוסטים על גרפים</a>, אבל אני מקווה שגם מבט בתמונה מספיק כדי להבהיר את זה), שכל צומת "כניסה" שלו (צומת שאין קשתות שנכנסות אליו) מסומן במשתנה, כל צומת פנימי שלו מסומן ב-<span class="math">\(\wedge\)</span> או ב-<span class="math">\(\vee\)</span> או ב-<span class="math">\(\neg\)</span>, וכל צומת שאין ממנו קשתות יוצאות נחשב צומת פלט. כדי לפשט את העניינים מניחים שיש רק צומת פלט יחיד, אבל רוב מה שמדברים עליו עובד גם עבור מספר צמתי פלט (שמאפשרים לדבר על פונקציות שמוציאות כפלט יותר מביט בודד). לצמתי <span class="math">\(\neg\)</span> יכולה להיכנס רק קשת בודדה, אבל לצמתי <span class="math">\(\wedge\)</span> ו-<span class="math">\(\vee\)</span> יכול להיכנס מספר קשתות כלשהו, אם כי עוד מעט נגיד למה כן צריך להגביל את זה לפעמים.</p>
<p>בהינתן השמה כלשהי למשתנים, כלומר סדרה של 0 ו-1 לכל אחד מהמשתנים שבצמתי הכניסה של המעגל, הערך של צומת הפלט נקבע באופן הבא: כל צומת שטרם קבענו את ערכו אבל כן קבענו את ערכם של כל הבנים שלו - הצמתים שיש קשת מהם <strong>אליו</strong> - הערך שלו מחושב בהתאם לערך הבנים ולסימן שלו. למשל, צומת שמסומן ב-<span class="math">\(\wedge\)</span> מקבל את הערך 1 אם ורק אם כל בניו קיבלו 1, ואחרת הוא מקבל 0. זה הכל. פלט המעגל על ההשמה הוא ערך של צומת הפלט. בדרך כלל מסמנים מעגל ב-<span class="math">\(C\)</span> ואת הערך שלו על השמה מסויימת <span class="math">\(x\)</span> ב-<span class="math">\(C\left(x\right)\)</span> (כאן צריך לחשוב על <span class="math">\(x\)</span> כעל מחרוזת ביטים שאורכה כמספר המשתנים של המעגל).</p>
<p>עכשיו משהמודל הבסיסי הובהר, הגיע הזמן להניח את הקלפים על השולחן ולהתייחס לאספקט שבמבט ראשון נראה מוזר ובעייתי של מעגלים, אל מול מכונות טיורינג. מכונת טיורינג היא מה שנקרא "מודל חישוב יוניפורמי" (למה "יוניפורמי" ולא המילה העברית הנאה "אחיד"? אין לי תשובה טובה יותר מ"ככה"). המשמעות של יוניפורמיות כאן היא שאותה המכונה מתמודדת עם קלטים מכל גודל שהוא. אין לי בעיה לבנות מכונת טיורינג בודדת לחישוב הפונקציה <span class="math">\(\text{MAJORITY}\)</span> שהזכרתי קודם, והיא תדע להתמודד עם קלטים מגודל <span class="math">\(n\)</span> לכל <span class="math">\(n\)</span> טבעי שרק תרצו. לעומת זאת, מעגל בוליאני בנוי מראש עבור <span class="math">\(n\)</span> ספציפי; עבור <span class="math">\(n\)</span>-ים אחרים נזדקק למעגלים אחרים. אולי כולם ייראו דומים אחד לשני, אבל הם לא יהיו אותו מעגל - בפרט, הגודל שלהם יהיה שונה (ולו רק בגלל שיצטרכו להיות בהם יותר צמתי קלט).</p>
<p>אפשר היה לעקוף את הקושי הזה ולהגיד שמראש אנחנו רוצים לדבר רק על <span class="math">\(n\)</span> קונקרטי אחד וחסל. אלא מה, כל מהותה של תורת הסיבוכיות הוא לעסוק בחסמים <strong>אסימפטוטיים</strong> על סיבוכיות - כלומר, לשאול שאלות כמו "עבור <span class="math">\(n\)</span>-ים הולכים וגדלים, כמה מהר יגדל זמן החישוב שנדרש למכונת טיורינג כדי להתמודד עם קלט בגודל <span class="math">\(n\)</span> כשהיא מנסה לחשב את הפונקציה הזו והזו?". לכן כשמדברים על בעיה חישובית שאנו רוצים לפתור באמצעות מעגלים, אנחנו לא מדברים על פונקציה <span class="math">\(f\)</span> בודדת שאנו רוצים לחשב אלא על <strong>משפחת</strong> פונקציות <span class="math">\(f_{1},f_{2},\dots,f_{n},\dots\)</span> כאשר <span class="math">\(f_{n}\)</span> היא פונקציה על <span class="math">\(n\)</span> קלטים. מן הסתם בדרך כלל כל הפונקציות <span class="math">\(f_{n}\)</span> הללו יהיו דומות זו לזו באופיין - אבל הן לא זהות, כי מספר הקלטים שלהן שונה. בהתאם לכך, לא ניתן יהיה להציג מעגל בודד שמטפל בכל משפחת הפונקציות, אלא <strong>משפחת</strong> מעגלים <span class="math">\(C_{1},C_{2},\dots,C_{n},\dots\)</span> כך שהמעגל <span class="math">\(C_{n}\)</span> מחשב את הפונקציה <span class="math">\(f_{n}\)</span>. לכאורה זה רעיון פשוט ומובן, ולא ברור למה אני מייחס לו כל כך הרבה חשיבות, עד שמתברר עד כמה החוסר-יוניפורמיות הזה גורם לתופעות מוזרות. הנה הדוגמה הקלאסית לעניין. שפה <strong>אונרית</strong> היא קבוצה של מילים (מילה, לצורך העניין, היא רצף של ביטים) שכל המילים בה הן סדרה של 1-ים, כלומר 0 לא מופיע בכלל. מה שמאפיין את המילים בשפה, אם כן, הוא רק האורך שלהן. לכל <span class="math">\(n\)</span>, אחד משניים: או ש-<span class="math">\(1^{n}\)</span> (סדרה של <span class="math">\(n\)</span> פעמים 1) מופיע בשפה, או שלא. זה אומר שלכל שפה אונרית קיימת משפחת מעגלים ש"מזהה" אותה (מוציאה 1 על מילים ששייכות לשפה ו-0 על מילים שלא). למה? כי קל לבנות מעגל שמוציא 1 על הקלט <span class="math">\(1^{n}\)</span> - פשוט מבצעים <span class="math">\(\wedge\)</span> על כל ביטי הקלט. גם קל לבנות מעגל שמוציא <span class="math">\(0\)</span> על כל הקלטים - למשל <span class="math">\(x_{1}\wedge\neg x_{1}\)</span>. לכן לכל <span class="math">\(n\)</span> קיים מעגל, ומעגל <strong>קטן ופשוט</strong> שעונה את התשובה הנכונה לכל המילים מאורך <span class="math">\(n\)</span>. אבל זה לחלוטין לא המצב עם מכונות טיורינג - קיימות שפות אונרית שמכונת טיורינג לא יכולה לזהות (כלומר, לעצור ולומר "כן" או "לא, בהתאם לשייכות המילה לשפה או לא). זה נובע מכך שבכלל קיימות שפות <strong>כלשהן</strong> שמכונת טיורינג לא יכולה לזהות, ואפשר לקודד שפות כאלו בעזרת מילים אונריות (איך? תרגיל). בקיצור, המודל הלא-יוניפורמי של מעגלים מסוגל לעשות דברים שמכונת טיורינג לא מסוגלת (זה לא אומר שהוא חזק יותר - אם המעגלים מוגבלים, ונראה דוגמאות להגבלות בקרוב, יהיו דברים שמכונת טיורינג יכולה לעשות ומעגלים לא).</p>
<p>אז איך פותרים את ה"בעיה" הזו? אפשר להצטמצם לדיון על משפחות <strong>יוניפורמיות</strong> של מעגלים - אלו משפחות מעגלים שאפשר לייצר באופן אלגוריתמי. כלומר, יש מכונת טיורינג שעל קלט <span class="math">\(n\)</span> מייצרת את המעגל <span class="math">\(C_{n}\)</span> המתאים. זה חיש קל פותר אותנו מאנומליות כמו שיש לעיל. עם זאת, לרוב אין צורך ביוניפורמיות הזו ולכן לא טורחים לדרוש אותה. הסיבה לכך היא שאין בעיה עם זה שמעגלים יהיו מסוגלים לקבל שפות שמכונת טיורינג לא, כל עוד השפות המעניינות באמת לא שם. אם ניתן יהיה להוכיח שמעגלים <strong>לא מסוגלים</strong> לעשות דבר מה, וינבע מכך שגם מכונות טיורינג לא יכולות לעשות זאת, למי אכפת שמעגלים מסוגלים לפתור כמה דברים שמכונות טיורינג לא?</p>
<p>הסיפור לא נגמר כאן - אפשר גם להתאים את המודל של מכונת טיורינג כדי שימדל "חוסר יוניפורמיות" שכזה. המודל המתאים הוא של "מכונות שמקבלות עצה". על קצה המזלג, הרעיון הוא שלכל מספר טבעי <span class="math">\(n\)</span> תותאם מחרוזת של "עצה" <span class="math">\(a_{n}\)</span>, ומכונת טיורינג שמתמודדת עם קלט <span class="math">\(x\)</span> מאורך <span class="math">\(n\)</span> תקבל, פרט ל-<span class="math">\(x\)</span>, גם את <span class="math">\(a_{n}\)</span> ותוכל להיעזר בו במהלך החישוב. אם אתם אוהבים את הדברים הללו קחו כמה דקות לחשוב למה השינוי הזה אכן מתאים בול לסיטואציה של מעגלים לא יוניפורמיים (ואם אתם ממש שוחים בחומר, נסו לחשוב איך עניין העצה שונה מעניין הזיהוי-יעיל שמגדיר את <span class="math">\(\text{NP}\)</span>). למכונות שמקבלות עצה יש יתרון נוסף, והוא שניתן להשתעשע עם הגודל של העצה ולדרוש עליו חסמים שונים ומשונים ולראות מה מקבלים (למשל, מה אפשר לעשות עם ביט בודד של עצה? די הרבה, מסתבר - בפרט להכריע כל שפה אונרית בשיטה שתיארתי לעיל). בדרך כלל דורשים שגודל העצה יהיה פולינומי ב-<span class="math">\(n\)</span>, ולמחלקת השפות שאפשר להכריע עם מכונות שמקבלות עצה וזמן הריצה שלהן הוא פולינומי קוראים <span class="math">\(\text{P}/\text{poly}\)</span> (מה שמשמאל ללוכסן מייצג את סוג המכונה, ומה שמימין ללוכסן מציין את גודל העצה). זו גם בדיוק מחלקת השפות שאפשר להכריע עם מעגלים בוליאניים שגודלם פולינומי ב-<span class="math">\(n\)</span>, ולכן השם המוזר והלכאורה לא קשור <span class="math">\(\text{P}/\text{poly}\)</span> צץ לרוב כשמתחילים לדבר על מעגלים.</p>
<p>בואו נעבור עכשיו לדבר על ההגבלות שמשיתים על מעגלים בוליאניים. כבר רמזתי שמגבילים את גודל המעגל, כלומר את מספר השערים שבו, וזה טבעי לגמרי - אם אתם בונים מעגל חשמלי אמיתי לחישוב פונקציה, תרצו להשתמש בכמה שפחות שערים מכיוון שהם תופסים מקום, צורכים חשמל ומייצרים חום. אבל אני רוצה לדבר גם על הגבלה אחרת - <strong>עומק</strong> המעגל. עומק המעגל הוא אורך המסלול הארוך ביותר בו - מסלול משערי הכניסה אל שער הפלט. אפשר לחשוב על האורך הזה בתור ה<strong>זמן</strong> שלוקח למעגל לבצע את החישוב שלו, בעוד שעל כמות השערים אפשר לחשוב בתור ה<strong>זכרון</strong> שנדרש לו לצורך החישוב (זה לא מדויק אבל זו אנלוגיה טובה מספיק שתעזור לי בהמשך). במובן הזה אפשר לחשוב על מעגל כאילו הוא מסמלץ חישוב <strong>מקבילי</strong>: כל השערים במרחק 1 משער הכניסה מבצעים את החישוב שלהם "בו זמנית", את תוצאות החישוב הם מעבירים לשערים שבמרחק 2 (ואף לשערים מרוחקים יותר), אלו מעבדים את המידע ומעבירים אותו קדימה וכן הלאה. העניין הוא בכך ששער במרחק <span class="math">\(n\)</span> מהכניסה לא תלוי בשום צורה בפלט של שערים אחרים שבמרחק <span class="math">\(n\)</span> מהכניסה, ולכן כל השערים במרחק <span class="math">\(n\)</span> מהכניסה יכולים לבצע את החישוב שלהם בו זמנית.</p>
<p>וכאן מתחיל להתברר לנו שצריך לחזק קצת את המגבלות שלנו אחרת לא נצליח לתאר שום דבר מעניין. נתחיל מכך שכל פונקציה בוליאנית - <strong>כל</strong> פונקציה - ניתן לחשב עם מעגל שעומקו המביך הוא 2. הסיבה לכך היא שכל פונקציה בוליאנית ניתן לתאר בצורה <strong>קנונית</strong>: לתאר אותה בתור <span class="math">\(\vee\)</span> אחד גדול על המון <span class="math">\(\wedge\)</span>-ים. מה הרעיון? אם <span class="math">\(f\)</span> היא פונקציה בוליאנית, אפשר לחלק את הקלטים בעולם לשניים - אלו שמחזירים 0 ואלו שמחזירים 1. אז אפשר לתאר את הפונקציה בתור "החזירי אחד אם הקלט שלך הוא <span class="math">\(a\)</span>, או אם הוא <span class="math">\(b\)</span>, או אם הוא <span class="math">\(c\)</span>, או..." כש-<span class="math">\(a,b,c\)</span> וכדומה כולן סדרות ביטים שעבורן <span class="math">\(f\)</span> מקבלת 1. את זה מתארים בתור <span class="math">\(\vee\)</span>. כדי לתאר את "הקלט <span class="math">\(x\)</span> שווה ל-<span class="math">\(a\)</span>" צריך בעצם להגיד משהו בסגנון "הביט הראשון של <span class="math">\(x\)</span> שווה לביט הראשון של <span class="math">\(a\)</span>, <strong>וגם</strong> הביט השני של <span class="math">\(x\)</span> שווה לביט השני של <span class="math">\(a\)</span>, וגם..." - את זה מתארים בתור <span class="math">\(\wedge\)</span>. זה הכל. לצורה הקנונית המתקבלת קוראים DNF.</p>
<p>בתור דוגמה, הנה דרך לתאר את <span class="math">\(\oplus\)</span> כ-DNF. כזכור, זו פונקציה שמקבלת 1 אם ורק אם שני הקלטים (שנסמן כ-<span class="math">\(x_{1},x_{2}\)</span>) שונים זה מזה. כלומר, הקלט הוא <span class="math">\(01\)</span> או <span class="math">\(10\)</span>. הצורה הנורמלית המתאימה היא <span class="math">\(\left(x_{1}\wedge\neg x_{2}\right)\vee\left(\neg x_{1}\wedge x_{2}\right)\)</span>.</p>
<p>אם כן, יש לנו כאן מעגל מעומק 2: בשכבה הראשונה יהיו לנו שערי <span class="math">\(\wedge\)</span> עבור כל ההשמות שנותנות 1, ובשכבה השניה יהיה לנו שער בודד, שער הפלט, עם <span class="math">\(\vee\)</span> עליו. אז למה הסתבכנו כל כך עד כה? הסיבה היא שהמעגל שלנו אולי לא עמוק, אבל הוא מאוד לא יעיל: עבור רוב הפונקציות, מספר שערי ה-<span class="math">\(\wedge\)</span> שנזדקק להם הוא <strong>אקספוננציאלי</strong> ב-<span class="math">\(n\)</span>, כי יהיה מספר אקספוננציאלי ב-<span class="math">\(n\)</span> של קלטים עליהם <span class="math">\(f\)</span> מחזירה 1. בעצם אמרנו שאם יש לנו המון, המון מעבדים, אז אפשר לחשב כל פונקציה מהר. טוב ויפה, אבל אז המודל שלנו לא ריאליסטי; אנחנו רוצים לבדוק מה מעגלים יכולים לבצע גם בזמן יעיל וגם בזכרון יעיל. לכן מראש בכל הדיון שלנו מגבילים את גודל המעגלים להיות <strong>פולינומי</strong>, ואז כל הבניה שהצגנו לא שווה כלום, ועבור רוב הפונקציות לא נצליח למצוא מעגל מעומק 2, או אפילו מעומק קבוע.</p>
<p>חישוב מקבילי הוא מעניין רק אם הוא משיג שיפורים משמעותיים בזמן הריצה אל מול חישובים לא מקביליים. אם חישוב לא מקבילי יעיל הוא כזה שזמן הריצה שלו הוא פולינומי, אין טעם לקרוא גם לחישוב מקבילי "יעיל" אם זמן הריצה שלו פולינומי; לעומת זאת, זמן ריצה <strong>לוגריתמי</strong> זה כבר משהו מרשים. גם לוגריתמי-בריבוע זה עדיין טוב, ובאופן כללי זמן ריצה פולי-לוגריתמי (שהוא פולינום, אבל לא ב-<span class="math">\(n\)</span> אלא ב-<span class="math">\(\log n\)</span> - למשל <span class="math">\(\log^{7}n+3\log^{3}n+7\)</span> הוא דוגמה לפולינום ב-<span class="math">\(\log n\)</span>) הוא זמן ריצה מקבילי טוב. כמובן, ככל שהחזקה של הלוגריתם גבוהה יותר כך החישוב טוב פחות. זה מוביל אותנו להגדרה הבאה: <span class="math">\(\text{AC}^{k}\)</span> הוא אוסף כל הפונקציות שניתן לחשב על ידי מעגל בוליאני (בעצם משפחת מעגלים בוליאניים אבל כבר הבנתם את העיקרון) מגודל פולינומי ב-<span class="math">\(n\)</span> ובעומק שהוא <span class="math">\(O\left(\log^{k}n\right)\)</span>. כך למשל <span class="math">\(\text{AC}^{0}\)</span> הוא הפונקציות שניתן לחשב על ידי מעגל מגודל פולינומי ועומק קבוע; <span class="math">\(\text{AC}^{1}\)</span> הוא הפונקציות שניתן לחשב על ידי מעגל פולינומי מעומק לוגריתמי, וכן הלאה. ב-<span class="math">\(\text{AC}\)</span> מסמנים את איחוד כל המחלקות הללו.</p>
<p>גם המחלקה <span class="math">\(\text{AC}\)</span> היא לא ריאליסטית עד הסוף, מהטעם הפשוט שלשערי ה-<span class="math">\(\wedge\)</span> ו-<span class="math">\(\vee\)</span>יכולים להיכנס כמה קלטים שרק נרצה. בפועל, לחשב <span class="math">\(\wedge\)</span> של 100 קלטים לוקח יותר זמן מלחשב <span class="math">\(\wedge\)</span> של 2 כאלו. לכן מוגדרת מחלקה מקבילה ל-<span class="math">\(\text{AC}\)</span>, שנקראת <span class="math">\(\text{NC}\)</span>. <span class="math">\(\text{NC}^{k}\)</span> זהה ל-<span class="math">\(\text{AC}^{k}\)</span> בהגדרתו פרט לכך שדורשים שלשערי <span class="math">\(\wedge,\vee\)</span> ייכנסו ביטים משני שערים בדיוק (מה שמכונה Fan-in 2). זו לא מגבלה עד כדי כך חמורה: אפשר לסמלץ שער <span class="math">\(\vee\)</span> שנכנסים אליו המוני קלטים באמצעות סדרה של שערי <span class="math">\(\vee\)</span> שפועלים הדרגתית על זוגות מתוך הקלטים הללו. דבר כזה יוצר ניפוח לוגריתמי בעומק של המעגל (כי כל צעד קבוע מוחלף על ידי סדרת צעדים שגודלה עשוי להיות פולינומי) ומכאן מתקבלת סדרת ההכלות הבאה: <span class="math">\(\text{NC}^{0}\subseteq\text{AC}^{0}\subseteq\text{NC}^{1}\subseteq\text{AC}^{1}\subseteq\text{NC}^{2}\subseteq\dots\)</span>. כדי לראות שכן יש הבדל כלשהו שימו לב ש-<span class="math">\(\text{NC}^{0}\)</span> מכיל רק פונקציות שתלויות במספר קבוע (שאינו תלוי ב-<span class="math">\(n\)</span>) של ביטים מהקלט שלהן, בעוד שב-<span class="math">\(\text{AC}^{0}\)</span> זה לא כך.</p>
<p>המחלקה <span class="math">\(\text{AC}^{0}\)</span> מעניינת במיוחד מכיוון שהיא שדה הקרב שבו תורת הסיבוכיות נחלה את אחד מנצחונותיה הגדולים עד כה - הוכחה לכך שהפונקציה <span class="math">\(\oplus\)</span> (כשהיא מוגדרת על <span class="math">\(n\)</span> משתנים ולא רק שניים - אפשר לחשוב עליה כאילו היא מבצעת חיבור מודולו 2) לא שייכת ל-<span class="math">\(\text{AC}^{0}\)</span> (ולכן גם פונקציות מסובכות יותר רבות אחרות לא - כל מה שאפשר היה להשתמש בו כדי לחשב גם את <span class="math">\(\oplus\)</span>). זו דוגמה לסוג החסמים התחתונים שאחריהם תורת הסיבוכיות מחפשת - הוכחה שיש בעיות קונקרטיות שהן קשות עד כדי כך שפשוט לא ניתן לפתור אותן עם מעגל בוליאני מעומק קבוע. לרוע המזל, זה פחות או יותר כל מה שאפשר לומר על <span class="math">\(\text{AC}\)</span> ו-<span class="math">\(\text{NC}\)</span> מבחינת חסמים תחתונים קונקרטיים, לפחות כיום. ישנן עוד מספר תוצאות מעניינות על מעגלים, אך הן מתייחסות למקרים עוד יותר ספציפיים שלא מעגלים שלא אכנס אליהן כרגע. הקרב עודנו בעיצומו, גם בימים אלו, אבל לתחושתי המאוד בלתי מלומדת, עיקר התקווה כיום הוא במציאת מודל חדש שיוכל להתמודד עם הבעיות ה"גדולות", ופחות בכך שמעגלים - מעניינים וחשובים בפני עצמם כמו שהם - יהיו מה שיוביל להתמודדות הזו.</p>
<p>בפוסט הבא נתאר מהן תוכניות מתפצלות ונחזור, הפעם באופן יותר פורמלי ומדויק, על מהו משפט ברינגטון.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>