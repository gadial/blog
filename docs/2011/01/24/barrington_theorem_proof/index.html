<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט ברינגטון - ההוכחה - לא מדויק</title>
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2011/01/23/branching_programs_and_barrington_theorem/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">תוכניות מתפצלות ומשפט ברינגטון</span>
            </a>
            

            
            <a href="/2011/02/09/banach_tarski_paradox_1/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">הפרדוקס של בנך-טרסקי (חלק א&#39;)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט ברינגטון - ההוכחה</h1>
            <div class="post-meta">
                <span class="date">2011-01-24</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/גם טכני זה כיף!.html">גם טכני זה כיף!</a>
                    
                    <a href="/tags/הוכחות יפות.html">הוכחות יפות</a>
                    
                    <a href="/tags/מאיפה זה הגיע?.html">מאיפה זה הגיע?</a>
                    
                    <a href="/tags/משפט ברינגטון.html">משפט ברינגטון</a>
                    
                    <a href="/tags/פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;.html">פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;</a>
                    
                    <a href="/tags/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p><a href="http://www.gadial.net/2011/01/23/branching_programs_and_barrington_theorem/">בפוסטים הקודמים</a> הסברתי מה אומר משפט ברינגטון, וכעת אפשר להגיע לחלק היפה ביותר בכל העניין - ההוכחה שלו. האתגר הוא להראות שכל פונקציה שנמצאת ב-<span class="math">\(\mbox{NC}^{1}\)</span>, כלומר ניתנת לחישוב על ידי מעגל בוליאני מגודל פולינומי ועומק לוגריתמי, ניתנת לחישוב על ידי תוכנית מתפצלת מאורך פולינומי וגודל קבוע, ואפילו קבוע "מאוד" - 5, תמיד. הכיוון ההפוך גם נכון - אם פונקציה ניתנת לחישוב על ידי תוכנית מתפצלת שכזו, אז היא ב-<span class="math">\(\mbox{NC}^{1}\)</span>, ולכן אנחנו משיגים תוצאה סגורה ויפה - מחלקת הפונקציות שניתנות לחישוב על ידי תוכניות מתפצלות מרוחב קבוע היא בדיוק <span class="math">\(\mbox{NC}^{1}\)</span> - מחלקה גדולה בהרבה ממה שניתן היה לצפות. ההוכחה היא יפה מאוד לטעמי, אבל לא טריוויאלית, ומי שאינו משופשף קצת בהוכחות כאלו בהחלט עלול לאבד אותי.</p>
<p>בתור חימום בואו נראה את הכיוון הקל. הוא אמנם קל, אבל גם כאן בוודאי אאבד קוראים - מי שיישבר, אני מציע לו לפחות לקפוץ לתחילת ההוכחה של הכיוון השני כדי לראות את "הרעיון הגדול" של ההוכחה.</p>
<p>אם כן, אם יש לנו תוכנית מתפצלת מרוחב <span class="math">\(d\)</span> כלשהו ומאורך <span class="math">\(t\)</span>, איך בונים מעגל בוליאני שמסמלץ אותה? הרעיון הוא לבנות נוסחה שאומרת "בגרף הזה והזה יש מסלול מהצומת <span class="math">\(a\)</span> לצומת <span class="math">\(b\)</span>" - נסמן נוסחה כזו ב-<span class="math">\(R\left(a,b\right)\)</span>. הגרף שעליו מדובר יהיה תמיד הגרף שמתקבל מהתוכנית המתפצלת אחרי שמציבים במשתנים ערכים - אנחנו נראה תכף איך זה בא לידי ביטוי.</p>
<p>את <span class="math">\(R\left(a,b\right)\)</span> קל לבנות במקרה שבו <span class="math">\(a,b\)</span> הם צמתים משכבות סמוכות (הגרף של התוכנית המתפצלת הוא גרף שכבות, זוכרים?). במקרה כזה יש מסלול מ-<span class="math">\(a\)</span> אל <span class="math">\(b\)</span> אם ורק אם יש קשת מ-<span class="math">\(a\)</span> ל-<span class="math">\(b\)</span>, מה שמצריך שני דברים: ראשית, שבתוכנית המתפצלת המקורית הייתה קשת מ-<span class="math">\(a\)</span> אל <span class="math">\(b\)</span> (שמסומנת או ב-0 או ב-1) ושנית, שהיא "שרדה" את ההשמה. אם הצומת <span class="math">\(a\)</span> מסומן במשתנה <span class="math">\(x_{i}\)</span>, אז נגדיר את הנוסחה באופן הבא: <span class="math">\(R\left(a,b\right)=x_{i}\)</span> אם הקשת <span class="math">\(a\to b\)</span> מסומנת ב-1, <span class="math">\(R\left(a,b\right)=\neg x_{i}\)</span> אם הקשת <span class="math">\(a\to b\)</span> מסומנת ב-0, ו-<span class="math">\(R\left(a,b\right)=0\)</span> אם אין קשת.</p>
<p>נוסחה כללית עבור <span class="math">\(a,b\)</span> שיכולים להיות מרוחקים זה מזה יותר מאשר שכבה אחת נבנית ברקורסיה. הטיעון הבסיסי הוא זה: אם המרחק בין <span class="math">\(a\)</span> ל-<span class="math">\(b\)</span> גדול מ-1 אבל יש מסלול ביניהם, אז יש צומת <span class="math">\(c\)</span> שנמצא "באמצע הדרך" ביניהם. במילים אחרות, יש מסלול מ-<span class="math">\(a\)</span> אל <span class="math">\(b\)</span> אם ורק אם <strong>קיים</strong> צומת <span class="math">\(c\)</span> בשכבה שהיא באמצע הדרך בין <span class="math">\(a\)</span> ל-<span class="math">\(b\)</span>, כך ש-<span class="math">\(R\left(a,c\right)\)</span> וגם <span class="math">\(R\left(c,b\right)\)</span>. לאלו מכם שמכירים קצת סיבוכיות כל זה ודאי מזכיר את ההוכחה של משפט סביץ', שמשתמש בתעלול דומה.</p>
<p>מה לכאורה הבעיה? שבשכבת הביניים בין <span class="math">\(a\)</span> ל-<span class="math">\(b\)</span> יכולים להיות המון <span class="math">\(c\)</span>-ים ואז הנוסחה שלנו, שצריכה לקחת בחשבון את כולם, תהיה ענקית. אלא שאנחנו מתעסקים כאן עם תוכניות שהרוחב שלהם <strong>חסום</strong>, ולכן יש רק <span class="math">\(d\)</span> צמתים <span class="math">\(c\)</span> אפשריים לכל היותר, מה שאומר שהנוסחה שלנו לא תהיה עד כדי כך גדולה. נכתוב אותה במפורש: <span class="math">\(R\left(a,b\right)=\bigvee_{c}\left(R\left(a,c\right)\wedge R\left(c,b\right)\right)\)</span>.</p>
<p>נותר להבין מהו גודל הנוסחה. נניח שהמרחק בין <span class="math">\(a\)</span> ו-<span class="math">\(b\)</span> הוא <span class="math">\(k\)</span>. נסמן ב-<span class="math">\(S\left(k\right)\)</span> את הגודל המקסימלי של נוסחה שנבנית בשיטה שלנו עבור צמתים במרחק <span class="math">\(k\)</span>. אז ראינו כי <span class="math">\(S\left(1\right)\)</span> הוא קבוע קטן, וכי <span class="math">\(S\left(k\right)\le2d\cdot S\left(\frac{k}{2}\right)\)</span> (כי בנוסחה עבור <span class="math">\(R\left(a,b\right)\)</span> שכתבנו, כל <span class="math">\(R\left(a,c\right)\)</span> ו-<span class="math">\(R\left(c,b\right)\)</span> שמופיעים שם עוסקים בזוג צמתים שהמרחק ביניהם הוא בערך <span class="math">\(\frac{k}{2}\)</span> - זאת מכיוון שבחרנו את <span class="math">\(c\)</span> להיות באמצע הדרך). פתרון נוסחת הנסיגה שלעיל מניב ש-<span class="math">\(S\left(k\right)=O\left(\left(2d\right)^{\lg k}\right)=O\left(k^{\lg\left(2d\right)}\right)\)</span>, ולכן נקבל שגודל הנוסחה <span class="math">\(R\left(s,t\right)\)</span> עבור התוכנית המתפצלת כולה, גודל המעגל המתאים יהיה <span class="math">\(O\left(t^{\lg\left(2d\right)}\right)\)</span> - זהו פולינום ב-<span class="math">\(t\)</span>, שכן <span class="math">\(d\)</span> קבוע. זה סוף הכיוון הזה - עד כה לא ראינו רעיונות מעניינים חריגים.</p>
<p>נעבור להוכחת הכיוון השני, המעניין. הרעיון המרכזי בחלק הזה של ההוכחה הוא להגביל <strong>עוד יותר</strong> את מה שלתוכנית המתפצלת מותר לעשות: בכל שכבה שלה, כל הצמתים יסומנו באותו משתנה (זה לא משהו שנדרש בהגדרה המקורית), והקשתות יהיו כאלו כך שכל הקשתות המסומנות ב-0 יהוו <strong>פרמוטציה</strong>, וגם כל הקשתות שמסומנות ב-1 יהוו פרמוטציה. מה? מי? מאיפה זה בא? הפרמוטציות הן מה שנותן לפתרון את הכוח שלו. הן האופן שבו ברינגטון מכניס כוח וגמישות לתוך מודל שנראה פרימיטיבי ומוגבל - בזכות העובדה שפרמוטציות הן מצד אחד יצורים פשוטים למדי מעצמם, ומצד שני הם יצורים מורכבים ביותר.</p>
<p>בואו נעשה קצת סדר בעניינים. אצל ברינגטון, כל שכבה בתוכנית המתפצלת כוללת חמישה צמתים <strong>בדיוק</strong>. נמספר אותם <span class="math">\(1,2,3,4,5\)</span>. עכשיו, מהצומת <span class="math">\(1\)</span> יוצאות שתי קשתות - אחת שמסומנת ב-0 ואחת שמסומנת ב-1. הקשת שמסומנת ב-0 נכנסת לאחד מהצמתים בשכבה הבאה, שגם בה כל הצמתים מסומנים ב-1 עד 5. נניח שהקשת נכנסת ל-3, אז אנחנו אומרים ש-"1 עובר ל-3 עם הקשת 0". באותו אופן כל אחד מחמשת המספרים עובר למספר בשכבה הבאה עם קשת ה-0 שלו. ברינגטון מוודא שלא יהיו שני מספרים שעוברים לאותו צומת בשכבה הבאה, ולכן אכן מתקבלת כאן פרמוטציה. באותו אופן, אם שוכחים מהקשתות שמסומנות ב-0 ומסתכלים רק על אלו שמסומנות ב-1, מקבלים פרמוטציה אחרת, אולי שונה מהראשונה.</p>
<p>על כן, אומר ברינגטון, אפשר לאפיין כל שכבה בגרף באמצעות השלשה הבאה: <span class="math">\(\left(k,\pi^{0},\pi^{1}\right)\)</span>. <span class="math">\(k\)</span> הוא מספרו של המשתנה <span class="math">\(x_{k}\)</span> אשר מופיע על כל צומת בשכבה הזו. <span class="math">\(\pi^{1}\)</span> היא הפרמוטציה שמתאימה לקשתות שמסומנות ב-0, ו-<span class="math">\(\pi^{1}\)</span> היא הפרמוטציה שמתאימה לקשתות שמסומנות ב-1. בצורה הזו אפשר לבנות את כל התוכנית, ולקבל סדרה של שלשות: <span class="math">\(\left(k_{1},\pi_{1}^{0},\pi_{1}^{1}\right),\left(k_{2},\pi_{2}^{0},\pi_{2}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0},\pi_{t}^{1}\right)\)</span>. זוהי תוכנית מאורך <span class="math">\(t\)</span>.</p>
<p>כעת, השמה של ערכים למשתנים כמוה בעצם כבחירה של פרמוטציה אחת מכל זוג, והכפלת כל הפרמוטציות שנבחרו כדי לקבל פרמוטציה שמייצגת את הגרף כולו. אם <span class="math">\(\pi\)</span> היא מה שהתקבל מהכפל הזה, אז <span class="math">\(\pi\left(1\right)\)</span> הוא מספרו של הצומת שאליו מגיעים בשכבה האחרונה אם מתחילים את הטיול מצומת 1 בשכבה הראשונה והולכים עם הקשתות שההשמה הותירה בחיים עד שמגיעים לשכבה האחרונה. בדומה <span class="math">\(\pi\left(2\right)\)</span> זה אותו הדבר אם מתחילים מצומת 2 בשכבה הראשונה, וכן הלאה. פורמלית זה מוגדר כך: <span class="math">\(\pi=\prod_{i=1}^{t}\pi_{i}^{x_{k_{i}}}\)</span>.</p>
<p>אם כן, אפשר לחשוב על תוכנית מתפצלת <span class="math">\(P\)</span> כעל פונקציה שמקבלת קלט <span class="math">\(\overline{x}\)</span> של ביטים ופולטת פרמוטציה ב-<span class="math">\(S_{5}\)</span>: <span class="math">\(P\left(\overline{x}\right)=\pi\)</span>. אבל איך כל זה קשור לפלט של 0 או 1? פשוט מאוד: נבחר מראש פרמוטציה ספציפית <span class="math">\(\sigma\in S_{5}\)</span> ששונה מפרמוטציית הזהות, שאותה אסמן ב-<span class="math">\(e\)</span> (הפרמוטציה שמעבירה כל איבר לעצמו). אז נגדיר ש-<span class="math">\(P\)</span> מחזירה 1 על קלט <span class="math">\(\overline{x}\)</span> אם <span class="math">\(P\left(\overline{x}\right)=\sigma\)</span>, ושהיא מחזירה 0 אם <span class="math">\(P\left(\overline{x}\right)=e\)</span>. בניסוח שיהיה נוח בהמשך - <span class="math">\(P\)</span> <span class="math">\(\sigma\)</span>-מחשבת את <span class="math">\(f\)</span> אם מתקיים הדבר הבא: עבור ערכים של <span class="math">\(\overline{x}\)</span> שעבורם מתקיים <span class="math">\(f\left(\overline{x}\right)=1\)</span>, <span class="math">\(P\)</span> מקיימת ש-<span class="math">\(P\left(\overline{x}\right)=\sigma\)</span>, ואילו עבור ערכים שעבורם מתקיים <span class="math">\(f\left(\overline{x}\right)=0\)</span>, <span class="math">\(P\)</span> מקיימת ש-<span class="math">\(P\left(\overline{x}\right)=e\)</span>.</p>
<p>זה שהגדרנו את זה כך זה טוב ויפה אבל לא מתאים להגדרה המקורית של תוכנית מתפצלת - כזכור, תוכנית מתפצלת מחזירה 1 אם יש מסלול מ-<span class="math">\(s\)</span> ל-<span class="math">\(t\)</span> אחרי ההשמה למשתנים, ו-0 אם אין מסלול כזה. אצלנו טרם בחרנו את <span class="math">\(s\)</span> ו-<span class="math">\(t\)</span>, והרעיון הוא לבחור אותם באופן שמתאים ל-<span class="math">\(\sigma\)</span>. מכיוון ש-<span class="math">\(\sigma\ne e\)</span> קיים <span class="math">\(i\)</span> כך ש-<span class="math">\(\sigma\left(i\right)\ne i\)</span>; אם כן, נגדיר את <span class="math">\(s\)</span> להיות הצומת מס' <span class="math">\(i\)</span> בשכבה הראשונה, ואת <span class="math">\(t\)</span> להיות הצומת מס' <span class="math">\(\sigma\left(i\right)\)</span> בשכבה האחרונה, וסיימנו: אם <span class="math">\(P\left(\overline{x}\right)=\sigma\)</span> אז אכן יש מסלול מ-<span class="math">\(i\)</span> אל <span class="math">\(\sigma\left(i\right)\)</span>, ואם <span class="math">\(P\left(\overline{x}\right)=e\)</span> אז המסלול היחיד מ-<span class="math">\(i\)</span> הוא אל <span class="math">\(e\left(i\right)=i\ne\sigma\left(i\right)\)</span>, כלומר אין מסלול מ-<span class="math">\(s\)</span> אל <span class="math">\(t\)</span>.</p>
<p>מסקנת ביניים, למי שאיבד אותי: אנחנו יכולים לשכוח מתוכניות מתפצלות ולעבור לדבר על "תוכניות פרמוטציה" - תוכניות שמתוארת על ידי שלשות של משתנה וזוג פרמוטציות כפי שתיארתי לעיל. מספיק להראות ש<strong>הן</strong> מסוגלות לסמלץ כל מעגל <span class="math">\(\mbox{NC}^{1}\)</span> ולעשות זאת תוך שמירה על אורך לא גדול במיוחד (כלומר, <span class="math">\(t\)</span> קטן).</p>
<p>אולי קצת יותר ברור כעת המספר 5 - הוא אומר שהפרמוטציות שמשתתפות במשחק כולן מ-<span class="math">\(S_{5}\)</span>. אבל למה דווקא <span class="math">\(S_{5}\)</span> ולא <span class="math">\(S_{4}\)</span> או <span class="math">\(S_{6}\)</span>? ובכן, עוד מעט נראה.</p>
<p>אמרתי שהסיבה שפרמוטציות מועילות לנו היא כי הן מצד אחד יצורים פשוטים ומצד שני מורכבים - בואו ננסה להבין איך זה מתבטא. ראשית, כמו שכבר ראינו, קיימת פעולת "כפל" של פרמוטציות שפירושה הוא פשוט להפעיל אותן בזו אחר זו: <span class="math">\(\sigma\tau\)</span> זו הפרמוטציה שבה מפעילים את <span class="math">\(\tau\)</span> ואחר כך את <span class="math">\(\sigma\)</span>. באופן כללי זה לא חייב להיות שווה ל-<span class="math">\(\tau\sigma\)</span> - נסו למצוא דוגמה שבה אכן <span class="math">\(\tau\sigma\ne\sigma\tau\)</span>. כמו כן לכל פרמוטציה קיימת <span class="math">\(\sigma^{-1}\)</span> פרמוטציה הפוכה שעבורה <span class="math">\(\sigma\sigma^{-1}=\sigma^{-1}\sigma=e\)</span>. לא קשה לראות שהפרמוטציות מהוות מה שנקרא <strong>חבורה</strong> עם פעולת הכפל המדוברת, אבל זה לא יהיה קריטי יותר מדי עבורנו כאן.</p>
<p>פרמוטציות פשוטות במיוחד הן <strong>מעגלים</strong>: אם למשל <span class="math">\(\sigma\left(1\right)=3\)</span> ו-<span class="math">\(\sigma\left(3\right)=5\)</span> ו-<span class="math">\(\sigma\left(5\right)=1\)</span> אז <span class="math">\(\sigma\)</span> כוללת בתוכה את המעגל <span class="math">\(\left(1\ 3\ 5\right)\)</span> ("1 עובר ל-3 שעובר ל-5 שעובר ל-1"). לא קשה להוכיח שכל פרמוטציה אפשר לכתוב כמכפלה של מעגלים זרים, כלומר כאלו שכל מספר מופיע רק באחד מהם. למשל, <span class="math">\(\left(1\ 4\right)\left(2\ 5\right)\left(3\right)\)</span> היא הפרמוטציה שמעבירה את 1 ל-4, את 4 ל-1, את 2 ל-5, את 5 ל-2, ואת 3 לעצמו. אנחנו מדברים על פרמוטציות על חמישה איברים, אז לפרמוטציה שהיא מעגל על כל חמשת האיברים הללו אקרא "5-מעגל" (צריך לא להתבלבל עם המושג השני של מעגל שעליו אנחנו מדברים פה - מעגל בוליאני, שהוא יצור שונה לגמרי - אבל אני בטוח שיהיה בסדר).</p>
<p>פעולה בסיסית בחבורות, ולכן גם בפרמוטציות, היא <strong>הצמדה</strong>. אם <span class="math">\(\sigma,\tau\)</span> הן שתי פרמוטציות, אז הצמדה של <span class="math">\(\sigma\)</span> על ידי <span class="math">\(\tau\)</span> היא הפרמוטציה <span class="math">\(\tau\sigma\tau^{-1}\)</span>. אפשר לחשוב על זה כעל "מה שקורה כשמפעילים את <span class="math">\(\sigma\)</span>, אבל לא על הדבר המקורי שעליו רצינו להפעיל אותה אלא עליו אחרי שהוא "מוזז" ובסוף מתקנים את ה"הזזה" הזו" (באלגברה לינארית, למשל, הצמדה של מטריצות היא בעלת המשמעות של <strong>שינוי מערכת הקוארדינטות</strong>, הפעלת הטרנספורמציה הלינארית שהמטריצה האמצעית מייצגת בתוך מערכת הקוארדינטות החדשה, ואז חזרה למערכת הקוארדינטות הישנה - מי שכל זה נשמע לו כמו ג'יבריש, לא נורא; אני מקווה שהפלתי למישהו אסימון כרגע).</p>
<p>להצמדת פרמוטציות יש פירוש קל ונחמד. בואו נניח לשניה ש-<span class="math">\(\sigma\)</span> היא מעגל: <span class="math">\(\sigma=\left(a_{1}\ a_{2}\ \dots a_{k}\right)\)</span>. אז <span class="math">\(\tau\sigma\tau^{-1}=\left(\tau\left(a_{1}\right)\ \tau\left(a_{2}\right)\ \dots\tau\left(a_{k}\right)\right)\)</span>. כלומר, עדיין קיבלנו מעגל, רק שבמקום המספרים המקוריים של <span class="math">\(\sigma\)</span> אנחנו מקבלים את המספרים הללו אחרי שערבבנו אותם באופן ש-<span class="math">\(\tau\)</span> מתאר. אם למשל <span class="math">\(\sigma=\left(1\ 4\ 2\right)\)</span> ו-<span class="math">\(\tau=\left(1\ 3\right)\left(2\ 5\right)\)</span> אז <span class="math">\(\tau\sigma\tau^{-1}=\left(3\ 4\ 5\right)\)</span>. נסו והיווכחו בעצמכם. לא אוכיח את הטענה הזו כעת למרות שהיא אינה מסובכת במיוחד (האינטואיציה גם כאן היא לחשוב על <span class="math">\(\tau\)</span> כמעין "שינוי קוארדינטות").</p>
<p>המסקנה שמעניינת אותנו כאן היא זו: אם <span class="math">\(\sigma_{1},\sigma_{2}\)</span> הן שתי פרמוטציות ששתיהן 5-מעגל, אז יש <span class="math">\(\tau\)</span> כך ש-<span class="math">\(\tau\sigma_{1}\tau^{-1}=\sigma_{2}\)</span> (למה? האם אתם יכולים להגיד איך מוצאים את <span class="math">\(\tau\)</span>?). בהתבסס על המסקנה הזו, אפשר סוף סוף להתחיל ולראות את הכוח והגמישות שהשימוש בפרמוטציות נותן לנו. נניח ש-<span class="math">\(P\)</span> היא תוכנית פרמוטציות אשר <span class="math">\(\sigma\)</span>-מחשבת איזו פונקציה <span class="math">\(f\)</span>, כאשר <span class="math">\(\sigma\)</span> היא 5-מעגל, אז קיימת תוכנית פרמוטציות <span class="math">\(P^{\prime}\)</span> <strong>מאותו אורך כמו</strong> <span class="math">\(P\)</span> אשר <span class="math">\(\sigma^{\prime}\)</span>-מחשבת את <span class="math">\(f\)</span> <strong>לכל</strong> <span class="math">\(\sigma^{\prime}\)</span> שהיא 5-מעגל. זה מפחית מאוד את התלות שלנו ב-<span class="math">\(\sigma\)</span>הספציפית שאיתה אנחנו מחשבים את <span class="math">\(f\)</span>, וכפי שנראה בקרוב, זה מאוד מועיל.</p>
<p>ההוכחה של הטענה הזו היא פשוט מקסימה. אז נניח ש-<span class="math">\(\sigma^{\prime}=\tau\sigma\tau^{-1}\)</span>. בואו נכתוב במפורש את התוכנית <span class="math">\(P\)</span>: <span class="math">\(P=\left(k_{1},\pi_{1}^{0},\pi_{1}^{1}\right),\left(k_{2},\pi_{2}^{0},\pi_{2}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0},\pi_{t}^{1}\right)\)</span>. מה שנעשה יהיה "לתקן" את <span class="math">\(P\)</span> באופן הבא: <span class="math">\(P^{\prime}=\left(k_{1},\tau\pi_{1}^{0},\tau\pi_{1}^{1}\right),\left(k_{2},\pi_{2}^{0},\pi_{2}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0}\tau^{-1},\pi_{t}^{1}\tau^{-1}\right)\)</span> - כלומר, השינוי הוא רק בפרמוטציות הראשונות והאחרונות. בפרט לא שינינו את אורך התוכנית.</p>
<p>כעת, מה קורה? אם <span class="math">\(f\left(\overline{x}\right)=1\)</span> אז <span class="math">\(P\left(\overline{x}\right)=\prod_{i=1}^{t}\pi_{i}^{x_{k_{i}}}=\sigma\)</span>. ומהו <span class="math">\(P^{\prime}\left(\overline{x}\right)\)</span>? ובכן, על פי ההגדרה, זהו <span class="math">\(P^{\prime}\left(\overline{x}\right)=\tau\left(\prod_{i=1}^{t}\pi_{i}^{x_{k_{i}}}\right)\tau^{-1}=\tau\sigma\tau^{-1}=\sigma^{\prime}\)</span>.</p>
<p>ואם <span class="math">\(f\left(x\right)=0\)</span>, מה אז? ובכן, <span class="math">\(P^{\prime}\left(\overline{x}\right)=\tau\left(\prod_{i=1}^{t}\pi_{i}^{x_{k_{i}}}\right)\tau^{-1}=\tau e\tau^{-1}=\tau\tau^{-1}=e\)</span>, שכן כאשר מצמידים את <span class="math">\(e\)</span> תמיד מקבלים את <span class="math">\(e\)</span>. קיבלנו בדיוק את מה שרצינו.</p>
<p>הטענה הזו תעזור לנו עוד מעט בהמשך, אבל עכשיו אפשר סוף סוף לגשת להוכחה עצמה. המטרה שלנו היא לבצע סימולציה של מעגל <span class="math">\(\mbox{NC}^{1}\)</span> באמצעות תוכנית פרמוטציות. הרעיון יהיה לתקוף את המעגל באופן אינדוקטיבי - נראה כיצד ניתן להמיר צומת כניסה למעגל לתוכנית פרמוטציות, וכיצד ניתן להמיר את צמתי השערים הלוגיים בתוכניות פרמוטציות. בכל אחד מהמקרים העיקרון יהיה שעל קלטים שעבורם השער פולט <span class="math">\(1\)</span>, תוכנית הפרמוטציות תפלוט <span class="math">\(\sigma\)</span> עבור פרמוטציה כלשהי שהיא 5-מעגל, ועל קלטים שעבורם הוא פולט <span class="math">\(0\)</span>, תוכנית הפרמוטציות תפלוט <span class="math">\(e\)</span>.</p>
<p>כדי לפשוט לנו את החיים, נניח שבמעגל הבוליאני יש רק שני סוגי שערים: שער <span class="math">\(\neg\)</span> ושער <span class="math">\(\wedge\)</span>. שער <span class="math">\(\vee\)</span> ניתן לסימולציה בעזרת כללי דה-מורגן: <span class="math">\(x\vee y=\neg\left(\neg x\wedge\neg y\right)\)</span>. אמנם, זה יגדיל קצת את עומק המעגל, אבל לא באופן משמעותי - רק פי 2, כלומר הכפלה בקבוע.</p>
<p>נתחיל, אם כן, משער קלט של המעגל. שער כזה תמיד מסומן במשתנה <span class="math">\(x_{i}\)</span> ומקבל 1 או 0 בהתאם לערך ש-<span class="math">\(x_{i}\)</span> מקבל בהשמה. תוכנית פרמוטציות עבור שער כזה היא פשוטה מאוד - מאורך 1: <span class="math">\(P=\left(i,e,\sigma\right)\)</span>. נסו להבהיר לעצמכם למה זה עובד.</p>
<p>שער <span class="math">\(\neg\)</span> מסובך מעט יותר ויש בו תעלול נחמד. זכרו שלשער <span class="math">\(\neg\)</span> יש כניסה אחת בלבד, ולכן אפשר לתאר את הסיטואציה כך: יש לנו שער שמחשב פונקציה <span class="math">\(f\)</span> כלשהי וכבר בנינו עבורו תוכנית פרמוטציות <span class="math">\(P\)</span> אשר <span class="math">\(\sigma\)</span>-מחשבת את <span class="math">\(f\)</span> עבור <span class="math">\(\sigma\)</span> שהיא 5-מעגל כלשהו. כעת אנו רוצים לבנות תוכנית פרמוטציות <span class="math">\(\neg P\)</span> אשר <span class="math">\(\tau\)</span>-מחשבת את <span class="math">\(\neg f\)</span> עבור <span class="math">\(\tau\)</span> שגם היא 5-מעגל (לא בהכרח שווה ל-<span class="math">\(\sigma\)</span>). הרעיון הוא זה: אם <span class="math">\(P=\left(k_{1},\pi_{1}^{0},\pi_{1}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0},\pi_{t}^{1}\right)\)</span> אז <span class="math">\(\neg P=\left(k_{1},\pi_{1}^{0},\pi_{1}^{1}\right),\dots,\left(k_{t},\pi_{t}^{0}\sigma^{-1},\pi_{t}^{1}\sigma^{-1}\right)\)</span>. כלומר, שינינו במעט את השלב האחרון בתוכנית - שימו לב כי לא שינינו את <strong>אורך</strong> התוכנית כלל. למה זה עובד? כי אם <span class="math">\(f\left(\overline{x}\right)=1\)</span> אז <span class="math">\(P\left(\overline{x}\right)=\sigma\)</span> ולכן <span class="math">\(\neg P\left(\overline{x}\right)=\sigma\cdot\sigma^{-1}=e\)</span>, בהתאם לכך ש-<span class="math">\(\neg f\left(\overline{x}\right)=0\)</span>; ואילו אם <span class="math">\(f\left(\overline{x}\right)=0\)</span> אז <span class="math">\(P\left(\overline{x}\right)=e\)</span> ולכן <span class="math">\(\neg P\left(\overline{x}\right)=e\cdot\sigma^{-1}=\sigma^{-1}\)</span>. כלומר, <span class="math">\(\neg P\)</span> <span class="math">\(\sigma^{-1}\)</span>-מקבלת את <span class="math">\(\neg f\)</span>, וזה מצויין כי אם <span class="math">\(\sigma\)</span> היא 5-מעגל, כך גם <span class="math">\(\sigma^{-1}\)</span> (כלומר, <span class="math">\(\sigma^{-1}\)</span> היא ה-<span class="math">\(\tau\)</span> שלנו).</p>
<p>עכשיו הגענו לקליימקס - שער <span class="math">\(\wedge\)</span>. נניח שיש לנו את <span class="math">\(f_{1},f_{2}\)</span> אשר <span class="math">\(\sigma_{1},\sigma_{2}\)</span>-מחושבות בידי <span class="math">\(P_{1},P_{2}\)</span> בהתאמה - ושוב, <span class="math">\(\sigma_{1},\sigma_{2}\)</span> שתיהן 5-מעגלים. אנחנו רוצים לבנות <span class="math">\(P\)</span> אשר <span class="math">\(\sigma\)</span>-תחשב את <span class="math">\(f_{1}\wedge f_{2}\)</span>. מה עושים?</p>
<p>כאן נשלף תעלול נוסף: ב-<span class="math">\(S_{5}\)</span> יש שתי פרמוטציות <span class="math">\(\sigma_{1},\sigma_{2}\)</span> שהן 5-מעגלים וגם <span class="math">\(\sigma=\sigma_{1}\sigma_{2}\sigma_{1}^{-1}\sigma_{2}^{-1}\)</span> - מה שנקרא <strong>הקומוטטור</strong> של <span class="math">\(\sigma_{1},\sigma_{2}\)</span> - הוא 5-מעגל. לעובדה הזו יש חשיבות קריטית, והיא הסיבה שבגללה מתעסקים עם <span class="math">\(S_{5}\)</span> דווקא - עבור <span class="math">\(S_{n}\)</span> עם <span class="math">\(n\le4\)</span> פשוט לא קיימות שתי פרמוטציות שהן מעגלים וגם הקומוטטור שלהן הוא מעגל מאותו האורך.</p>
<p>מיהן אותן תמורות שמקיימות את התכונה המדוברת? ובכן, למשל: <span class="math">\(\left(1\ 2\ 3\ 4\ 5\right)\)</span> ו-<span class="math">\(\left(1\ 3\ 5\ 4\ 2\right)\)</span> שהקומוטטור שלהן הוא <span class="math">\(\left(1\ 3\ 2\ 5\ 4\right)\)</span>. לא צריך יותר מזה.</p>
<p>אנחנו יכולים להניח כי <span class="math">\(P_{1},P_{2}\)</span> אכן מחשבות את הפונקציות שלהן בעזרת אותן <span class="math">\(\sigma_{1},\sigma_{2}\)</span> המדוברות בזכות הטיעון שהראינו קודם - שאפשר להחליף בחופשיות את ה-<span class="math">\(\sigma\)</span> של התוכנית כל עוד ממשיכים לדבר על 5-מעגלים. יותר מזה: אנחנו גם יכולים לבנות מ-<span class="math">\(P_{1}\)</span> תוכנית חדשה, <span class="math">\(P_{1}^{-1}\)</span>, שאורכה זהה לזה של <span class="math">\(P_{1}\)</span> אבל היא <span class="math">\(\sigma_{1}^{-1}\)</span>-מקבלת את <span class="math">\(f_{1}\)</span>. כנ"ל עבור <span class="math">\(P_{2}\)</span>. וכעת אפשר להציג את התוכנית עבור <span class="math">\(f_{1}\wedge f_{2}\)</span>: היא תהיה פשוט <span class="math">\(P=P_{1}P_{2}P_{1}^{-1}P_{2}^{-1}\)</span>. כלומר, שרשור של הסדרות של כל ארבע התוכניות הללו. כאן, סוף כל סוף, אורך התוכנית שאנו בונים גדל.</p>
<p>מדוע זה עובד? ובכן, אם <span class="math">\(f_{1}\left(\overline{x}\right)=f_{2}\left(\overline{x}\right)=1\)</span> אז <span class="math">\(P\left(\overline{x}\right)=\sigma_{1}\sigma_{2}\sigma_{1}^{-1}\sigma_{2}^{-1}=\sigma\)</span>, כפי שרצינו. אבל אם למשל <span class="math">\(f_{1}\left(\overline{x}\right)=0\)</span> ו-<span class="math">\(f_{2}\left(\overline{x}\right)=1\)</span> אז <span class="math">\(P_{1}\left(\overline{x}\right)=P_{1}^{-1}\left(\overline{x}\right)=e\)</span> ולכן <span class="math">\(P\left(\overline{x}\right)=e\cdot\sigma_{2}\cdot e\cdot\sigma_{2}^{-1}=e\)</span>. באופן דומה מקבלים <span class="math">\(e\)</span> גם עבור הסיטואציות שבהן <span class="math">\(f_{2}\left(\overline{x}\right)=0\)</span>. זה הסוף. אני לא יודע מה איתכם, אבל לדעתי הטריק הזה ממש מקסים, ואלוהים יודע מאיפה הוא הגיע.</p>
<p>טוב, מכאן נגמר רעיון הבניה וכל מה שנשאר הוא חשבון מכולת. אם נפעיל את הטרנספורמציות שתיארתי כאן על כל שער במעגל ה-<span class="math">\(\mbox{NC}^{1}\)</span> בסופו של דבר נגיע גם לשער הפלט, והתוכנית שמתאימה לשער הפלט היא התוכנית שמתאימה לפונקציה שאותה המעגל כולו מחשב. השאלה היא רק מה אורך התוכנית הזו.</p>
<p>כפי שכבר ראינו, אורך תוכנית שמתאימה לשער קלט היא 1, ושער שלילה לא משנה כלל את אורך התוכנית. רק שער <span class="math">\(\wedge\)</span> מאריך אותה. בואו נסמן ב-<span class="math">\(S\left(d\right)\)</span> את האורך המקסימלי של תוכנית עבור מעגל מעומק <span class="math">\(d\)</span>.</p>
<p>אם יש לנו בתוכנית שער <span class="math">\(\wedge\)</span> בעומק <span class="math">\(d\)</span>, אז שני הצמתים שנכנסים אליו מהווים כל אחד מעגל בעומק <span class="math">\(d-1\)</span>. לכן גודל התוכניות <span class="math">\(P_{1},P_{2}\)</span> עבורם הוא לכל היותר <span class="math">\(S\left(d-1\right)\)</span> לכל אחד מהם. מכיוון שאנו משרשרים את <span class="math">\(P_{1},P_{2}\)</span> ואז גם את שתי התוכניות עם הפרמוטציה ההופכית, אנחנו בסך הכל מגדילים פי 4 את האורך לכל היותר, כלומר <span class="math">\(S\left(d\right)=4\cdot S\left(d-1\right)\)</span>. אם נפתור את נוסחת הנסיגה הזו נקבל <span class="math">\(S\left(d\right)=4^{d}\)</span>. שזה, חייבים להודות, לא נראה מרשים במבט ראשון - זה נראה אקספוננציאלי.</p>
<p>אלא מה, צריך לזכור שאנו מדברים כאן על מעגל <span class="math">\(\mbox{NC}^{1}\)</span> - מעגל שהעומק שלו הוא לוגריתמי ב-<span class="math">\(n\)</span>, כלומר במספר הביטים שעליהם פועלת הפונקציה שמחשבים. לכן <span class="math">\(4^{d}\)</span> הוא בעצם <span class="math">\(O\left(4^{\log n}\right)=O\left(n^{\log4}\right)\)</span> - פולינומי לגמרי (אבל, אם ניקח מעגל <span class="math">\(\mbox{NC}^{2}\)</span>, שבו העומק הוא <span class="math">\(O\left(\log^{2}n\right)\)</span>, כבר לא נקבל אורך פולינומי). זה מסיים את ההוכחה.</p>
<p>אני מקווה שהצלחתם לשרוד את כל ההוכחה. היא אינה קשה במיוחד וגם אינה עמוסה ביותר מדי פרטים, אך קצת נסיון בתחום בהחלט עוזר להבין אותה. מה שקשה להבין, ואני עדיין לא מבין בעצמי, הוא מאיפה הגיע הרעיון להוכחה הזו בכלל ולמה זה עובד (שאלה שכמובן, גם לראות הוכחה פורמלית לא עוזר לענות עליה לחלוטין). אבל לדעתי, גם בלי להבין, התוצאה הזו מהנה מאוד - כמו לשבת במופע של קוסם וליהנות מהשפן שנשלף מהשרוול. לשמחתי, תורת הסיבוכיות עשירה בקסמים שכאלו.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>