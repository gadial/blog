<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>תוכניות מתפצלות ומשפט ברינגטון - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.5em 10px;
            quotes: "\201C""\201D""\2018""\2019";
        }
        
        blockquote:before {
            color: #ccc;
            content: open-quote;
            font-size: 4em;
            line-height: 0.1em;
            margin-left: 0.25em;
            vertical-align: -0.4em;
        }
        
        blockquote p {
            display: inline;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/">דף הבית</a>
                <a href="/random.html">פוסט אקראי</a>
                <a href="/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/2011/01/20/box_riddle/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">חידת קופסאות</span>
            </a>
            

            
            <a href="/2011/01/24/barrington_theorem_proof/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">משפט ברינגטון - ההוכחה</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>תוכניות מתפצלות ומשפט ברינגטון</h1>
            <div class="post-meta">
                <span class="date">2011-01-23</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/משפט ברינגטון.html">משפט ברינגטון</a>
                    
                    <a href="/tags/פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;.html">פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;</a>
                    
                    <a href="/tags/תוכניות מתפצלות.html">תוכניות מתפצלות</a>
                    
                    <a href="/tags/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p><a href="http://www.gadial.net/2011/01/18/what_are_boolean_circuits/">בפוסט הקודם</a> בסדרת הפוסטים של פרוייקט "תוצאות מפתיעות בסיבוכיות" הצגתי מודל חישובי מרכזי בתורת הסיבוכיות - מעגלים בוליאניים. עכשיו אני רוצה להציג מודל קצת יותר אזוטרי אבל עדיין חשוב ומעניין בזכות עצמו - תוכניות מתפצלות. משפט ברינגטון, שאת הניסוח שלו אציג בסוף הפוסט, הוא הסיבה שבגללה אני מתאר כאן תוכניות מתפצלות. הוא אומר, בפשטות, שתוכניות מתפצלות הן חזקות הרבה יותר ממה שנדמה במבט ראשון, כשההשוואה של הכוח שלהן הוא לכוח שיש למעגלים בוליאניים.</p>
<p>כמו שמעגל בוליאני הוגדר כגרף, כך גם תוכנית מתפצלת מוגדרת כגרף מכוון וחסר מעגלים. אלא שבמעגל בוליאני חשבנו על הצמתים בתור יחידות עיבוד למידע: מידע (בדמות ביטים - אפסים ואחדים) נכנס לכל צומת, עבר עיבוד כלשהו (למשל, פונקציית "וגם"), ונפלט מהיציאה של הצומת. בתוכנית מתפצלת אנחנו חושבים על הצמתים כמעין "שורות קוד" בתוכנית מחשב. כל שורה בתוכנית מכילה פקודות לקפיצה לאחת מכמה שורות אפשריות אחרות, כשההחלטה לאן לקפוץ תלויה בקלט. יותר במדויק, כל צומת מסומן על ידי משתנה <span class="math">\(x_{i}\)</span>, והקשתות שיוצאות מהצומת מסומנות ב-0 וב-1. יש לתוכנית שני צמתים מיוחדים: צומת התחלה <span class="math">\(s\)</span> (שגם הוא מסומן במשתנה) וצומת סיום <span class="math">\(t\)</span>. עבור השמה כלשהי למשתנים, אנחנו מוחקים קשתות בהתאם להשמה - אם למשל המשתנה <span class="math">\(x_{3}\)</span> קיבל 0, אז מכל צומת שמסומן ב-<span class="math">\(x_{3}\)</span> (יכולים להיות הרבה כאלו) אנו מוחקים את כל הקשתות היוצאות שמסומנות ב-1. פלט התוכנית על קלט הוא 1 אם לאחר מחיקת הקשתות הזו עדיין קיים מסלול מ-<span class="math">\(s\)</span> ל-<span class="math">\(t\)</span> בגרף, ואחרת הפלט שלה הוא 0.</p>
<p>כרגיל, תמונה אחת שווה אלף מילים. הנה תוכנית מתפצלת עבור הפונקציה <span class="math">\(\text{MAJORITY}\left(x_{1},x_{2},x_{3}\right)\)</span> שמחזירה את הערך הבוליאני שמצוי אצל רוב הקלטים. נסו "לסמלץ" את הריצה של התוכנית על כמה קלטים ובדקו מה קורה.</p>
<p><a href="/img/2011/01/bp_maj.png"><img class="alignnone size-full wp-image-996" title="bp_maj" src="/img/2011/01/bp_maj.png" alt="" width="392" height="166" /></a></p>
<p>אולי אתם תוהים למה הגדרתי הגדרה מסובכת שכזו לתוכנית מתפצלת - כל העסק עם מחיקת הקשתות ועם "אם <strong>קיים</strong> מסלול...". למה לא אמרתי פשוט "בהינתן קלט נצא לטיול בגרף - כאשר אנחנו בצומת <span class="math">\(x_{i}\)</span> נתבונן בערך המשתנה <span class="math">\(x_{i}\)</span> והצעד הבא שלנו ייקבע על פי ערך זה, ואם אין לנו קשת יוצאת מתאימה ניתקע"? ובכן, זה אכן מספיק עבור מה שנתעסק בו, אבל באופן כללי ייתכן שמאותו צומת תצא יותר מקשת אחת שמסומנת ב-1 (או יותר מקשת אחת שמסומנת ב-0) וכל מה שיעניין אותו הוא ש<strong>קיימת</strong> דרך כלשהי להגיע מ-<span class="math">\(s\)</span> אל <span class="math">\(t\)</span>. מי שזה מבלבל אותו - לא נורא, אתם בהחלט יכולים לחשוב על ההגדרה שהצגתי כרגע כאילו היא הגדרה שקולה.</p>
<p>תוכנית מתפצלת היא מודל מאוד נאיבי ופשוט של חישוב: אין לה סרט שעליו היא יכולה לכתוב מידע ביניים - ה"מידע" שיש לה צריך להיות מיוצג איכשהו על ידי הצמתים של הגרף ותו לא. זה שונה מהותית ממה שקורה במעגל בוליאני שבו כמות גדולה של מידע "זורמת" בתוך הגרף. בנוסף, תוכנית מתפצלת מבצעת את החישוב שלה בצורה שנראית מגבילה מאוד - בכל צעד פועלת על פי ביט בודד של הקלט ותו לא. בקיצור, זה נראה כמו מודל חלש מאוד. בשל כך, הוא מועמד טבעי להיות קורבן להוכחות של חסמים תחתונים - וזה, כזכור, הדבר שאנשי תורת הסיבוכיות הכי אוהבים להוכיח.</p>
<p>כדי להוכיח חסמים תחתונים על מודל חישובי, צריך קודם כל להגדיר מדדי סיבוכיות כלשהם עבורו. אם אנחנו רוצים להגיד "קשה לחשב את <span class="math">\(f\)</span> בעזרת תוכניות מתפצלות" צריך קודם כל להבהיר מה זה בכלל אומר, "קשה", בהקשר של תוכניות מתפצלות. המדד האלמנטרי הוא הגודל של התוכנית - מספר הצמתים שבה. מחשב אמיתי שרוצה להריץ תוכנית מתפצלת צריך לזכור את כל הצמתים שלה - ולכן מספר אקספוננציאלי של צמתים (כתלות במספר הביטים של הקלט לפונקציה שאותה רוצים לחשב) הוא לא ריאלי - חשבו על תוכנית שכדי לחשב את הפלט של פונקציה על 50 ביטים דורשת <span class="math">\(1,125,899,906,842,624\)</span> שורות קוד! (<span class="math">\(2^{50}\)</span>). לכן הדרישה האלמנטרית מתוכנית מתפצלת הוא שגודלה יהיה פולינומי. כמו שקרה עם מעגלים בוליאניים, כך גם כאן, תוכנית מתפצלת תמיד מוגדרת עבור מספר נתון של ביטי קלט. לכן מדברים לרוב על <strong>משפחות</strong> של פונקציות, שמחושבות על ידי <strong>משפחות</strong> של תוכניות מתפצלות, והשאלה ששואלים היא כמה מהר צומח הגודל של התוכנית המתפצלת עבור קלט מאורך <span class="math">\(n\)</span> כאשר מגדילים את <span class="math">\(n\)</span>. לא אחזור שוב על הדיון הזה בשלמותו.</p>
<p>יפה. אם כן, רצו להם מדעני המחשב בשמחה ובששון לאכול בלי מלח תוכניות מתפצלות בעלות גודל פולינומי ולהוכיח שכך וכך וכך אי אפשר לעשות בהן. כפי שבדרך כלל קורה בעניינים הללו, הנסיונות הללו נסתיימו בלא כלום. להוכיח חסמים תחתונים זה <strong>קשה</strong>.</p>
<p>אז מה עושים עכשיו? מגבילים עוד קצת את המודל. אפשר לדבר, בלי להגביל את עצמנו במיוחד, על תוכניות מתפצלות שהגרף שלהן הוא גרף <strong>שכבות</strong>: כל צומת שייך לשכבה כלשהי, ויש קשת רק בין צומת בשכבה אחת לצומת בשכבה העוקבת. על יצור כזה אפשר להגדיר שני מדדי סיבוכיות חדשים - אורך (מספר השכבות הכולל) ורוחב (מספר הצמתים המקסימלי בשכבה כלשהי). ככל שתוכנית היא קצרה יותר כך "זמן הריצה" שלה קצר יותר; וככל שהרוחב של תוכנית קטן יותר, כך הזכרון שנדרש כדי לסמלץ אותה קטן יותר. הפרמטר המקורי שלנו - גודל - עדיין חבוי בין שני הפרמטרים הללו - הוא חסום על ידי מכפלת האורך ברוחב (למה?)</p>
<p>להגביל את האורך יותר מדי - אי אפשר. עבור רוב הפונקציות סביר להניח שנרצה להתיר לתוכנית המתפצלת לקרוא את כל הביטים של הקלט לפחות פעם אחת, וכל ביט קלט נקרא במעבר משכבה אחת לשכבה הבאה אחריה. אז מספר פולינומי של שכבות הוא המינימום שצריך (שימו לב להבדל בין זה ובין מעגלים בוליאניים, שבהם האורכים שעניינו אותנו היו <strong>לוגריתמיים</strong>: זה התאפשר מכיוון שהמעגל ביצע חישוב מקבילי וכל שכבה טיפה בהרבה ביטי קלט בבת אחת). אם כן, הפרמטר שמעניין להגביל אותו - ולהגביל בצורה קיצונית ביותר - הוא הרוחב. שאלו את עצמם מדעני המחשב - מה יכולה לעשות תוכנית מתפצלת עם אורך פולינומי ורוחב <strong>קבוע</strong>?</p>
<p>רוחב קבוע נראה כמו דבר מגביל. מאוד. זה בעצם אומר שהזכרון של התוכנית הוא חסום בגודלו ולא תלוי בכלל בקלט. ייתכן שהקלט יהיה בן מיליארדי ביטים, ועדיין לתוכנית יהיה מותר להיות בכל שכבה רק באחד מבין, נאמר, חמישה מצבים שונים. תחשבו על זה רגע. <strong>מיליארדי</strong> ביטי קלט שונים! זה אומר שכאשר הגעתי לשכבה ה-<span class="math">\(k\)</span>-ית, מה שקרה "בעבר" של התוכנית יכל להיות בן זילארדי זיליארדים (זה מספר בכלל?) אפשרויות שונות. ועכשיו מבקשים ממני לקחת את כל האפשרויות הללו ואיכשהו לתמצת אותן לאחד מבין חמישה מקרים - חמשת המצבים האפשריים של השכבה ה-<span class="math">\(k\)</span>. בעצם, זה אומר שמרבית ההיסטוריה שלנו חייבת "להימחק". מה כבר אפשר לחשב באופן הזה?</p>
<p>כדי להבהיר את הקושי כדאי לשכוח שנייה מתוכניות מתפצלות ולדבר על מה שקורה למודל החישובי הסטנדרטי, מכונת טיורינג, אם דורשים מהזכרון שלה להיות חסום באופן שאינו תלוי בקלט. מה שמקבלים הוא שקילות למודל פשוט בהרבה, שמכונה <strong>אוטומט סופי דטרמיניסטי</strong>. לא אציג את המודל הזה כרגע, אבל רק אבהיר עד כמה הוא חלש: אם נותנים לו מספר, הוא לא מסוגל לבדוק האם המספר ראשוני. אם נותנים לו מחרוזת מהצורה <span class="math">\(0^{*}1^{*}\)</span> (סדרת אפסים ואז סדרת אחדות - הכוכבית מציינת "0 או 1 או 2 או...") הוא לא מסוגל לבדוק האם מספר האפסים שווה למספר האחדות. אם נותנים לו שלשה <span class="math">\(\left(a,b,c\right)\)</span> הוא לא מסוגל לבדוק האם <span class="math">\(c=a-b\)</span> (זה בעצם נובע מיידית ממה שאמרתי קודם...). זה מודל מאוד, מאוד חלש. ותוכניות מתפצלות מרוחב קבוע הן בדיוק האנלוג המתאים לאוטומטים סופיים דטרמיניסטיים בתוך עולם התוכניות המתפצלות.</p>
<p>כדי להראות חסם תחתון על תוכניות מתפצלות, כדאי לתקוף קודם כל פונקציה קונקרטית אחת ולהראות שהיא קשה. עבור מעגלים בוליאניים הצליחו להשתמש ב-<span class="math">\(\bigoplus\)</span> (שמבצעת XOR של כל הביטים שלה) בתור פונקציה שכזו - הוכיחו כי היא אינה ב-<span class="math">\(\text{AC}^{0}\)</span> (מעגלים בוליאניים מעומק <strong>קבוע</strong> - שוב ה"קבוע" הזה - עם דרגת כניסה לא מוגבלת של הצמתים). אחרי שיש דוגמה קונקרטית אחת ביד, אפשר לרוב להראות עבור פונקציות רבות אחרות שהן לא שייכות למחלקה על ידי טיעון בסגנון "אם הן כן היו שייכות, אפשר היה להשתמש בהן כדי לחשב גם את <span class="math">\(\bigoplus\)</span>". לרוע המזל, את <span class="math">\(\bigoplus\)</span> קל מאוד לחשב עם תוכנית מתפצלת מרוחב 2: קוראים ביט ביט, וכל המידע שצריך לזכור הוא "האם סכום הביטים עד כה היה 0 או 1 מודולו 2". הנה התוכנית המתפצלת המתאימה עבור <span class="math">\(\bigoplus\left(x_{1},x_{2},x_{3},x_{4},x_{5}\right)\)</span>:</p>
<p><strong><a href="/img/2011/01/xor_bp.png"><img class="alignnone size-full wp-image-999" title="xor_bp" src="/img/2011/01/xor_bp.png" alt="" width="605" height="229" /></a><br />
</strong></p>
<p>ובכן, מי כן מועמד טוב להיות פונקציה שתוכניות מתפצלות לא יכולות לחשב? רצוי שזו תהיה פונקציה פשוטה, כזו שאפשר לחשב ביעילות במודלים פשוטים אחרים - זכרו שבסופו של דבר אנחנו רוצים להצביע על קושי של בעיות שנראות פשוטות יחסית (זהו למשל העניין בשאלת <span class="math">\(\text{P=NP}\)</span>; המחלקה <span class="math">\(\text{NP}\)</span> מורכבת מבעיות שבמובן מסויים הן קלות, ולכן חשוב לנו להוכיח שלמרות זאת הן קשות; את זה שקיימות בכלל בעיות שאינן ב-<span class="math">\(\text{P}\)</span> קל להוכיח). לצורך העניין, מחלקה פשוטה מספיק שעדיין נראית כמו כר מתאים לחיפוש אחר פונקציות קשות לחישוב היא <span class="math">\(\text{NC}^{1}\)</span> - מה שבא בתור אחרי <span class="math">\(\text{AC}^{0}\)</span>. ב-<span class="math">\(\text{NC}^{1}\)</span>, כזכור, נמצאות כל הפונקציות שניתנות לחישוב על ידי מעגל מעומק <strong>לוגריתמי</strong> וגודל פולינומי, שבו דרגת הכניסה של כל שער היא לכל היותר 2. הרבה פונקציות פשוטות (למשל, הפונקציות האריתמטיות) נמצאות שם; וגם הפונקציה <span class="math">\(\text{MAJORITY}\)</span> שהזכרתי בהתחלה. אותה <span class="math">\(\text{MAJORITY}\)</span> נראתה כבעלת פוטנציאל רב לתקיפת תוכניות מתפצלות; כמו שאפשר לראות בתוכנית המתפצלת שציירתי בהתחלה, נראה שהרוחב תלוי בצורה חזקה בכמות המשתנים. ובאמת, צריך "לזכור" כמה משתנים היו 0 וכמה משתנים היו 1 עד כה, או לפחות מה היה ההפרש ביניהם, והוא יכול להיות גדול באופן שרירותי, לא? זה לא נראה כמו משהו שאפשר לתפוס עם תוכניות מתפצלות מרוחב קבוע. זה הוביל להשערה בראשית שנות השמונים לפיה כל תוכנית מתפצלת מרוחב חסום עבור <span class="math">\(\text{MAJORITY}\)</span> לא תהיה פולינומית באורכה. די מהר הוכיחו גם חסם תחתון נאיבי יחסית - שתוכנית מתפצלת מרוחב חסום עבור פונקציה זו לא יכולה להיות <strong>לינארית</strong> באורכה (כלומר, <span class="math">\(O\left(n\right)\)</span>). על פניו כיוון המחקר הזה נראה מבטיח.</p>
<p>ואז, בשנת 1989 בא ברינגטון ופוצץ את הכל כשהוכיח שלא רק את <span class="math">\(\text{MAJORITY}\)</span> אפשר לחשב באמצעות תוכניות מתפצלות מרוחב חסום, אלא כל פונקציה ב-<span class="math">\(\text{NC}^{1}\)</span>. ולא רק שאפשר, אלא שמספיק שהרוחב החסום יהיה 5 (<strong>לכל</strong> פונקציה ב-<span class="math">\(\text{NC}^{1}\)</span>). אני מקווה שביצעתי מספיק עבודת הכנה כדי שתתקבל תחושה כלשהי עד כמה זו תוצאה מפתיעה. גם אני, למרות שאני מכיר את ההוכחה, עדיין מתקשה להבין איך בכלל אפשר לתפוס משהו כמו <span class="math">\(\text{MAJORITY}\)</span> עם רוחב חסום. וכמובן, יש את עניין מספר הקסם 5 - מאיפה הוא צץ? למה דווקא 5 ולא 4 או 6? גם לשאלה הזו יש תשובה מצויינת. כל התשובות - בפוסט הבא, שבו אציג במפורט את ההוכחה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>