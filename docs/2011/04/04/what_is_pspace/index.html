<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>אז מהי PSPACE? - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Hamburger menu button */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .menu-toggle:hover {
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .top-nav .nav-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .top-nav .site-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0;
                padding: 10px 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            /* Hide nav links by default on mobile */
            .top-nav .nav-links {
                display: none;
                flex-direction: column;
                width: 100%;
                margin-top: 10px;
            }
            
            /* Show when expanded */
            .top-nav .nav-links.expanded {
                display: flex;
            }
            
            .top-nav .nav-links > a {
                text-align: center;
                padding: 12px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box {
                width: 100%;
                flex-direction: column;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .top-nav .search-box input {
                width: 100%;
                margin-bottom: 5px;
                min-width: 0;
            }
            
            .top-nav .search-box button {
                width: 100%;
            }
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        /* Force KaTeX content to wrap by overriding its internal structure */
        .katex-html {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .base {
            display: inline !important;
            white-space: normal !important;
        }
        
        .katex .mord,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct,
        .katex .minner {
            display: inline !important;
            white-space: normal !important;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
            
            /* Hide post navigation on mobile */
            .post-navigation {
                display: none;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <div class="site-title">
                <a href="/blog/" style="color: white; text-decoration: none;">לא מדויק</a>
                <button class="menu-toggle" onclick="toggleMobileMenu()" aria-label="תפריט">
                    ☰
                </button>
            </div>
            <div class="nav-links" id="navLinks">
                <a href="/blog/">דף הבית</a>
                <a href="/blog/random.html">פוסט אקראי</a>
                <a href="/blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/blog/2011/03/30/nim/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">המשחק נים</span>
            </a>
            

            
            <a href="/blog/2011/04/07/bad_math_mystery_arithmetic_phenomenon/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">התופעה החשבונית המסתורית של שנת 2011 (היא שהטמטום של חדשות 2 הוא אינסופי)</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>אז מהי PSPACE?</h1>
            <div class="post-meta">
                <span class="date">2011-04-04</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/תורת הסיבוכיות.html">תורת הסיבוכיות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/PSPACE.html">PSPACE</a>
                    
                    <a href="/tags/מחלקות סיבוכיות.html">מחלקות סיבוכיות</a>
                    
                    <a href="/tags/משחקים מתמטיים.html">משחקים מתמטיים</a>
                    
                    <a href="/tags/פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;.html">פרוייקט &#34;תוצאות מפתיעות בסיבוכיות&#34;</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>שני המשאבים המרכזיים שמדברים עליהם בתורת הסיבוכיות הם זמן וזכרון. בכל הנוגע לזמן, הפורמליסטיקה בוחרת להגדיר "זמן יעיל" כזמן שהוא פולינומי בגודל הקלט של האלגוריתם - כלומר, אם <span class="math">\(x\)</span> הוא הקלט וב-<span class="math">\(\left|x\right|\)</span> אנחנו מסמנים את אורכו (מספר הביטים שמקודדים אותו), אז אלגוריתם הוא "יעיל" בכל הנוגע לזמן הריצה אם קיים פולינום <span class="math">\(p\)</span> כך שלכל <span class="math">\(x\)</span>, זמן הריצה של האלגוריתם על <span class="math">\(x\)</span> אינו עולה על <span class="math">\(p\left(\left|x\right|\right)\)</span>. זו בחירה שנראית מוזרה למדי במבט ראשון - זמן ריצה של <span class="math">\(n^{1000}\)</span> הוא ממש לא מה שהיינו חושבים עליו בתור יעיל מלכתחילה, בפרט בהתחשב בכך שבעולם מדעי המחשב נעשים <a href="http://en.wikipedia.org/wiki/Matrix_multiplication#Algorithms_for_efficient_matrix_multiplication">מאמצים לא מבוטלים</a> לרדת מזמן כמו <span class="math">\(n^{3}\)</span> אל <span class="math">\(n^{2}\)</span>.</p>
<p>אבל תורת הסיבוכיות מתעניינת בחסמים תחתונים. היא רוצה להראות שבעיות מסויימות הן <strong>קשות</strong>. כל כך קשות, שלא משנה כמה נרשה לפולינום להיות גדול, עדיין לא יהיה ניתן לפתור אותן בזמן פולינומי. הוכחה ש-<span class="math">\(\text{P}\ne\text{NP}\)</span> תראה כי אלפי בעיות שצצות ועולות בכל תחומי מדעי המחשב הן אכן קשות במובן הזה. כך שה"ויתור" שאנחנו מבצעים בכך שאנו מרשים לזמן הריצה להיות פולינום גדול מאוד אינו מהותי; רק חשוב לזכור ששייכות ל-<span class="math">\(\text{P}\)</span> עדיין אינה אומרת שקיים פתרון <strong>טוב</strong> לבעיה. יש לבחירה בפולינומים דווקא גם סיבות טובות נוספות ובראשן הרצון להימנע מהתלות של סיבוכיות זמן הריצה במודל החישוב הספציפי שאנו בוחרים לעבוד איתו, אך נעזוב את זה לבינתיים.</p>
<p>כשאנו באים לדבר על סיבוכיות זכרון, נראה טבעי לגמרי לנקוט באותה הגדרה בדיוק - זכרון "יעיל" הוא זכרון שהוא פולינומי בגודל הקלט. למחלקה המתאימה קוראים <span class="math">\(\text{PSPACE}\)</span>, ובפוסט הזה ננסה להבין איך בדיוק היא נראית ומתנהגת ביחס לשאר מחלקות הסיבוכיות. נתחיל מהשורה התחתונה - <span class="math">\(\text{PSPACE}\)</span> היא מחלקה <strong>ענקית</strong>. היא כוללת את רוב העולם ה"מעניין". הגדרות יותר זהירות של סיבוכיות זכרון עשויות להצביע על כך שעדיף לדבר על מחלקות של זכרון לוגריתמי, דוגמת <span class="math">\(\text{NL}\)</span> שהוזכרה ב<a href="http://www.gadial.net/2011/03/05/immerman_theorem/">פוסט על משפט אימרמן</a>; אבל זה לא אומר ש-<span class="math">\(\text{PSPACE}\)</span> היא לא מחלקה מעניינת לכשעצמה, גם אם קשה להגיד שהיא ממדלת חישובים "יעילים".</p>
<p>האבחנה הראשונה היא ש-<span class="math">\(\text{P}\subseteq\text{PSPACE}\)</span>, מהטעם הפשוט שכדי "לבזבז" זכרון, צריך לבזבז זמן על הגישה אליו. אם הולכים להגדרה הפורמלית על ידי מכונת טיורינג, זמן חישוב מוגדר כמספר הצעדים שמכונת הטיורינג מבצעת, ואילו הזכרון שהיא השתמשה בו מוגדר בתור אינדקס התא הרחוק ביותר שהראש שלה הגיע אליו - וכדי להגיע למרחק כזה, צריך לבצע צעדים, וזה גוזל זמן. אם כל הזמן שאפשר לבזבז הוא פולינומי, אי אפשר לבזבז יותר מאשר זכרון פולינומי. הגיון סביר (כל עוד לא עובדים עם מודלים מוזרים שבהם אפשר לגשת לכמות עצומה של זכרון בכל צעד חישוב).</p>
<p>מכיוון שאמרתי ש-<span class="math">\(\text{PSPACE}\)</span> היא מחלקה ענקית ומפחידה, מתבקש להאמין לי ולהגיע למסקנה ש-<span class="math">\(\text{P}\ne\text{PSPACE}\)</span>, אך כאן אנו נתקלים באכזבה רבתי - אין שום הוכחה כיום לכך ש-<span class="math">\(\text{P}\ne\text{PSPACE}\)</span>, אף שעולם מדעי המחשב התיאורטיים יוכה בתדהמה אם יתברר ש-<span class="math">\(\text{P=PSPACE}\)</span>, ותדהמה גדולה משמעותית מהתדהמה ש-<span class="math">\(\text{P}=\text{NP}\)</span> יגרום לה. למעשה, אם יתברר כי <span class="math">\(\text{P=PSPACE}\)</span> כל מחלקות הסיבוכיות שאני עומד לדבר עליהן בהמשך הפוסט יהיו מיותרות לחלוטין כי כולן יהיו שוות ל-<span class="math">\(\text{P}\)</span>. זה מאוד, מאוד לא סביר; העובדה שעוד אין הוכחה ש-<span class="math">\(\text{P\ensuremath{\ne}PSPACE}\)</span> רק מעידה עד כמה מדעי המחשב התיאורטיים עדיין בחיתוליהם.</p>
<p>בשביל חימום, בואו נדבר על <span class="math">\(\text{NP}\)</span>. ההגדרה שאני אוהב ל-<span class="math">\(\text{NP}\)</span> מדברת על שפות שיש "עדים" לשייכות מילים אליהן. פורמלית, יש אלגוריתם "מוודא" פולינומי <span class="math">\(V\)</span> שמקבל זוג <span class="math">\(\left(w,\pi\right)\)</span>, ועונה כן או לא, כך שאם <span class="math">\(w\in L\)</span> קיים <span class="math">\(\pi\)</span> כך ש-<span class="math">\(V\)</span> מקבל את <span class="math">\(\left(w,\pi\right)\)</span>, ואם <span class="math">\(w\notin L\)</span> אז לכל <span class="math">\(\pi\)</span> שלא יהיה, <span class="math">\(V\)</span> ידחה את <span class="math">\(\left(w,\pi\right)\)</span>. המגבלה היחידה על <span class="math">\(\pi\)</span> היא שיהיה פולינומי בגודלו ביחס ל-<span class="math">\(w\)</span>, אחרת <span class="math">\(V\)</span> ממילא לא יוכל לקרוא את כולו.</p>
<p>מכונת <span class="math">\(\text{PSPACE}\)</span> עבור <span class="math">\(L\in\text{NP}\)</span> תשתמש בכוח הגס האלים והברוטלי ביותר שיש: בהינתן <span class="math">\(w\)</span>, היא תעבור סדרתית על כל הזוגות <span class="math">\(\left(w,\pi\right)\)</span> עבור <span class="math">\(\pi\)</span> שאינו גדול מדי (לא חורג מהחסם הפולינומי שמאפיין את <span class="math">\(L\)</span>), ולכל אחד מהם היא תריץ את <span class="math">\(V\)</span> על <span class="math">\(\left(w,\pi\right)\)</span> ותקבל רק אם <span class="math">\(V\)</span> מקבל מתישהו. מכיוון ש-<span class="math">\(V\)</span> פולינומי בזמן, הסימולציה שלו דורשת זכרון פולינומי, ואת המקום הזה אפשר <strong>למחזר</strong> בין הרצות שונות. זה גורם לכך שכל האלגוריתם הזה, למרות שהוא עובר על מספר אקספוננציאלי של <span class="math">\(\pi\)</span>-ים שיש לבדוק, דורש רק זכרון פולינומי, ומכריע את אותה השפה. זה מראה ש-<span class="math">\(\text{NP}\subseteq\text{PSPACE}\)</span> (ולכן אם <span class="math">\(\text{P=PSPACE}\)</span> זה גם גורר מיידית ש-<span class="math">\(\text{P=NP}\)</span>).</p>
<p>הגישה האלימה הזו - פשוט לעבור על כל האפשרויות וזו לא בעיה כי כל אפשרות בפני עצמה צורכת מעט זכרון ואפשר למחזר - עובדת שוב ושוב עבור מחלקות סיבוכיות שונות ומשונות. כך למשל קחו את <span class="math">\(\text{BPP}\)</span> - המחלקה של חישובים הסתברותיים יעילים. לא ברור הקשר שלה ל-<span class="math">\(\text{NP}\)</span> (בפרט לא ברור אם אחת מהמחלקות מכילה את השניה), אבל חיפוש ממצה מוחץ כמו זה שנעשה עבור <span class="math">\(\text{NP}\)</span> מראה גם ש-<span class="math">\(\text{BPP}\subseteq\text{PSPACE}\)</span>. ומה עם חישובים קוונטיים? המחלקה הרלוונטית של חישובים קוונטיים יעילים נקראת <span class="math">\(\text{BQP}\)</span>. יש תקווה גדולה ש-<span class="math">\(\text{P}\ne\text{BQP}\)</span> ולכן חישובים קוונטיים (שאולי יהיה ניתן לממש יום אחד במציאות) מסוגלים לעשות יותר משחישובים רגילים מסוגלים; אבל יש לכל העניין הזה גבול - אפשר להראות גם ש-<span class="math">\(\text{BQP}\subseteq\text{PSPACE}\)</span> (ולכן אם יתגלה ש-<span class="math">\(\text{P=PSPACE}\)</span> בפרט זה יוכיח שחישובים קוונטיים אינם יעילים יותר מחישובים קלאסיים - מתחילים להבין למה כל זה נתפס כ"לא סביר"?)</p>
<p>את <span class="math">\(\text{NP}\)</span> אפשר להכליל באופן הבא: אם אפשר לתאר כל שפה ב-<span class="math">\(\text{NP}\)</span> בתור <span class="math">\(L=\left\{ x|\exists y:\left(x,y\right)\in S\right\} \)</span> כאשר <span class="math">\(S\)</span> הוא יחס כלשהו שניתן לזהות בזמן פולינומי, אפשר גם לדבר על שפות שאפשר לתאר, למשל, על ידי <span class="math">\(L=\left\{ x|\exists y_{1}\forall y_{2}\exists y_{3}\forall y_{4}:\left(x,y_{1},y_{2},y_{3},y_{4}\right)\in S\right\} \)</span>. המשחק הזה של הכמתים - מעבר מ"קיים" ל"לכל" וכן הלאה - מוסיף כוח חישובי כאשר מגדירים שפות ללא מגבלות סיבוכיות (כלומר, דורשים רק ש-<span class="math">\(S\)</span> תהיה ניתנת לזיהוי, לא בהכרח בזמן פולינומי). כאשר אנחנו עוברים לעולם הפולינומי, לא ידוע לנו אם אכן כל החלפת כמתים מוסיפה כוח, אבל ההשערה היא שאכן כך המצב. ב-<span class="math">\(\Sigma_{n}^{p}\)</span> מסמנים את כל השפות שאפשר לתאר בצורה כזו עם <span class="math">\(n\)</span> חילופי כמתים (כך למשל <span class="math">\(\text{NP}=\Sigma_{1}^{p}\)</span>. לאוסף המחלקות <span class="math">\(\Sigma_{n}^{p}\)</span> שמתקבל כך קוראים <strong>ההירכייה הפולינומית</strong>, ואת האיחוד של כולן מסמנים ב-<span class="math">\(\text{PH}\)</span>.</p>
<p>ההיררכייה הפולינומית היא עולם מרתק שראוי בהחלט לפוסט נפרד. כאן תיארתי אותה רק בשביל לתאר את הכוח של <span class="math">\(\text{PSPACE}\)</span>. כן, ניחשתם נכון - כל ההיררכייה מוכלת בתוך <span class="math">\(\text{PSPACE}\)</span>. שוב, פתרון הכוח הגס עובד כאן.</p>
<p>בואו נעבור לדבר על משהו שונה לגמרי - משחקים. המשחקים שארצה לדבר עליהם כאן הם משחקים לשני שחקנים עם ידיעה שלמה - כלומר, אין הגרלות (להבדיל ממשחקי קלפים, למשל) ואין מידע שהשחקנים מחביאים זה מזה (כמו ב"צוללות" - שם אין הגרלות, אבל אף שחקן לא יודע איפה הצוללות של השחקן השני). אפשר לדבר גם על משחקים בלי ידיעה שלמה אבל בואו נעזוב את זה לבינתיים. בואו גם נניח לצורך פשטות שתוצאת תיקו אינה אפשרית במשחקים הללו. בפוסט הקודם שעסק במשחק נים ראינו בדיוק דוגמה למשחק שכזה.</p>
<p>כעת, משפט צרמלו (שהזכרתי בעבר וגם בפוסט הקודם) קובע שבמשחק כזה תמיד יש לאחד השחקנים אסטרטגיית ניצחון - דרך פעולה שתבטיח לו ניצחון בלי תלות במה שעושה השחקן השני. הדרך להוכיח זאת היא באמצעות <strong>עץ המשחק</strong> - עץ שצמתיו הם עמדות במשחק, והבנים של כל צומת הם העמדות שאפשר להגיע אליהן על ידי ביצוע מהלך על ידי השחקן שכרגע תורו. את העלים בעץ מסמנים ב-1 או 0, כאשר 1 מסמן ניצחון עבור אליס, ו-0 הפסד עבור אליס, ולכן ניצחון עבור בוב (אליס ובוב הם השמות שאני נותן לשחקנים). כעת ניתן סימון לשאר הצמתים בעץ בדרך הבאה: אם כל הבנים של צומת כבר מסומנים, ואם בצומת הזה תורה של אליס לשחק, אז נסמן אותה ב-1 אם ולו אחד מהבנים מסומן ב-1, ואחרת נסמן ב-0. אם תורו של בוב לשחק, אז נסמן ב-0 אם ולו אחד מהבנים מסומן ב-0, ואחרת נסמן ב-1. כעת כל שנותר לעשות הוא לבדוק באיזה מספר סומן השורש של העץ כדי לדעת למי יש אסטרטגיית ניצחון במשחק. נסו להבהיר לעצמכם למה זה עובד.</p>
<p>שימו לב שההוכחה הזו קונסטרוקטיבית לגמרי - היא נותנת אלגוריתם, ואלגוריתם פשוט למדי, שבהינתן משחק מאפשר לחשב את אסטרטגיית הניצחון בו. רק צריך להיות מסוגלים לייצג באופן יעיל את עץ המשחק ולטייל עליו. האלגוריתם הפשוט ביותר לסריקת גרפים - חיפוש לעומק, DFS - עובד כאן. סיבוכיות הזכרון של האלגוריתם הזה היא כעומק העץ כפול כמות הזכרון שנדרשת כדי לייצג צומת; המסקנה היא שאם כל צומת ניתנת לייצוג בזכרון פולינומי (פולינומי ביחס למה? לפרמטר כלשהו של המשחק) והאורך המקסימלי של משחק הוא מספר פולינומי של צעדים, אז הבעיה של הכרעה למי יש אסטרטגיית ניצחון במשחק היא - ניחשתם נכון, ב-<span class="math">\(\text{PSPACE}\)</span>.</p>
<p>עבור משחק כמו נים המהומה הזו לא הכרחית - ראינו בפוסט הקודם שקל מאוד להכריע (בזמן פולינומי) עבור עמדה במשחק למי יש אסטרטגיית ניצחון. אבל הנה משחק קשה יותר - גאוגרפיה. במשחק המטופש הזה כל שחקן אומר שם של עיר, והשחקן השני צריך להגיד עיר חדשה, שהאות הראשונה בה היא האות האחרונה בשם העיר הקודמת. מפסיד מי שלא יודע איך להמשיך. המשחק הזה לא קשה כל כך, אבל יש לו הכללה רחבה למדי - "גאוגרפיה מוכללת", Generalized Geography. במשחק הזה נתון גרף מכוון. מתחילים מאיזו צומת, ובכל סיבוב אחד השחקנים בוחר צומת שכנה ועובר אליה. אסור לחזור לאותה צומת פעמיים, ומפסיד מי שלא יכול לנוע עוד. איך זה קשור לגאוגרפיה המקורית? הנה תרגיל - נסו למדל את גאוגרפיה בתור משחק בגאוגרפיה-מוכללת. זה לא קשה במיוחד.</p>
<p>מקרה פרטי נחמד של גאוגרפיה מוכללת היא זו: על לוח שחמט שמים מלך (לא משנה איפה), ועכשיו כל אחד מהשחקנים מזיז אותו בתורו, תחת האילוצים שאסור להיכנס פעמיים לאותה משבצת, וגם אסור לנוע באלכסון (כלומר, זה לא בדיוק מלך אלא מלך נכה). כאן אפשר להוכיח מייד שלשחקן שמתחיל יש אסטרטגיית נצחון וההכללה למחלקה רחבה יותר של משחקים נובעת מאליה (רמז עבה לבקיאים בגרפים: שידוך).</p>
<p>בגאוגרפיה מוכללת הקלט הוא הגרף (והצומת שמתחילים בו, אם כי זה פחות קריטי), ומכיוון שבבירור אורך המשחק הוא פולינומי (כי בכל צעד שורפים צומת בגרף) אז הכרעה למי יש אסטרטגיית נצחון במשחק היא ב-<span class="math">\(\text{PSPACE}\)</span>. זה כנראה כבר לא מפתיע אתכם בשלב הזה; ההפתעה האמיתית היא שהבעיה הזו היא במובן מאוד קונקרטי "הבעיה הכי קשה ב-<span class="math">\(\text{PSPACE}\)</span>" - זו בעיה שמאפיינת באופן מושלם למדי את הרעיון של <span class="math">\(\text{PSPACE}\)</span>. בניסוח קצת יותר פורמלי - זוהי בעיה <span class="math">\(\text{PSPACE}\)</span>-שלמה, באותו אופן שבו בעיות כמו <span class="math">\(\text{SAT}\)</span> או מעגל המילטוני או 3-צביעה של גרפים הן <span class="math">\(\text{NP}\)</span>-שלמות. פורמלית זה אומר שאם נתונה שפה כלשהי - <strong>כלשהי</strong> ששייכת ל-<span class="math">\(\text{PSPACE}\)</span>, אז אפשר להמיר כל קלט למשחק גאוגרפיה מוכללת, כך שאם הקלט המקורי היה שייך לשפה, אז במשחק המתקבל ממנו יהיה מהלך נצחון ללבן, ואם הוא לא היה שייך לשפה, אז במשחק המתקבל ממנו יהיה מהלך ניצחון לשחור.</p>
<p>איך מוכיחים את זה? ובכן, בעקיפין. כמו שאף אחד לא מוכיח באופן ישיר ש-3-צביעה היא בעיה <span class="math">\(\text{NP}\)</span>-שלמה, כך גם כאן - יש בעיה "קנונית" שיחסית קל להוכיח עבורה באופן ישיר שהיא <span class="math">\(\text{PSPACE}\)</span>-שלמה, וכדי להראות שבעיות אחרות דוגמת <span class="math">\(\text{GG}\)</span> הן <span class="math">\(\text{PSPACE}\)</span>-שלמות, פשוט מראים איך פותרים את אותה בעיה קנונית באמצעותן. השפה הקנונית עבור <span class="math">\(\text{PSPACE}\)</span> נקראת <span class="math">\(\text{TQBF}\)</span> - ראשי תיבות של True Quantified Boolean Formulas.</p>
<p>נוסחה בוליאנית מורכבת ממשתנים שיכולים לקבל "אמת" ו"שקר" - <span class="math">\(\text{T}\)</span> ו-<span class="math">\(\text{F}\)</span> - ומחוברים ביניהם עם "וגם" (<span class="math">\(\wedge\)</span>), "או" (<span class="math">\(\vee\)</span>) ו"לא" (<span class="math">\(\neg\)</span>). למשל, <span class="math">\(\left(x_{1}\vee x_{2}\right)\wedge\left(\neg x_{1}\vee\neg x_{2}\right)\)</span> היא נוסחה שמקבלת ערך אמת רק אם מציבים ערך אמת לאחד מהמשתנים וערך שקר לשני (זו דרך לתאר את פונקציית ה-XOR באמצעות <span class="math">\(\wedge,\vee,\neg\)</span>). השפה <span class="math">\(\text{SAT}\)</span> שהזכרתי קודם מורכבת מאוסף כל הנוסחאות הללו שהן ספיקות - כלומר, שיש השמה שמספקת אותן. <span class="math">\(\text{TQBF}\)</span> היא הכללה כלשהי של העסק: אם <span class="math">\(\varphi\left(x_{1},\dots,x_{n}\right)\)</span> היא נוסחה בוליאנית כלשהי במשתנים <span class="math">\(x_{1},\dots,x_{n}\)</span>, אז פסוק ה-<span class="math">\(\text{QBF}\)</span> המתאים הוא פסוק מהצורה <span class="math">\(\exists x_{1}\forall x_{2}\dots\exists x_{n}\varphi\left(x_{1},\dots,x_{n}\right)\)</span>. כלומר, פסוק שאומר "קיימת השמה ל-<span class="math">\(x_{1}\)</span> כך שלכל השמה ל-<span class="math">\(x_{2}\)</span> קיימת השמה ל-<span class="math">\(x_{3}\)</span>... קיימת השמה ל-<span class="math">\(x_{n}\)</span> כך ש-<span class="math">\(\varphi\)</span> מקבל ערך אמת תחת ההשמה הזו". ה"לכל" הוא בדיוק מה שמסבך את העניינים כאן, וכמו שאמרתי קודם על ההיררכייה הפולינומית, הפינג-פונג הזה בין "לכל" ו"קיים" מגדיל עוד ועוד את כושר הביטוי של הפסוקים הללו. שימו לב שבניגוד לפסוקי <span class="math">\(\text{SAT}\)</span> חסרי הכמתים, כאן לפסוק יש ערך אמת מוגדר - הוא או נכון או לא נכון.</p>
<p><span class="math">\(\text{TQBF}\)</span> היא בדיוק שפת כל הפסוקים המכומתים שערך האמת שלהם הוא <span class="math">\(\text{T}\)</span>. הבדל מהותי בינה לבין שפות שמופיעות בהיררכייה הפולינומית הוא שאין מגבלה על מספר ההחלפות של כמתים - בתוך <span class="math">\(\text{TQBF}\)</span> אפשר למצוא פסוקים שבהם יש 100 החלפות, או זיליארד, או <span class="math">\(10^{100^{100^{100}}}\)</span> וכל מה שתרצו. וכפי שודאי כבר ניחשתם, קל מאוד להראות ש-<span class="math">\(\text{TQBF}\)</span> שייכת ל-<span class="math">\(\text{PSPACE}\)</span> על ידי אותם שיקולי כוח גס שכבר דיברנו עליהם. הפאנץ' הוא שזהו סוף הדרך - <span class="math">\(\text{TQBF}\)</span> היא שפה <span class="math">\(\text{PSPACE}\)</span>-שלמה, ולכן "הקשה ביותר" ב-<span class="math">\(\text{PSPACE}\)</span> (כפי שכבר הבנתם, התואר הזה לא מוחזק על ידי שפה יחידה; גם <span class="math">\(\text{GG}\)</span> מחזיקה בו). במובן מסויים, <span class="math">\(\text{TQBF}\)</span> היא משחק מאורך פולינומי בצורתו המזוקקת ביותר: בתור הראשון, השחקן הלבן בוחר ערך (<span class="math">\(\text{T}\)</span> או <span class="math">\(\text{F}\)</span>) למשתנה הראשון; בתור השני השחור בוחר ערך למשתנה השני; וכן הלאה. בסוף המשחק (כשנגמרים המשתנים) מחשבים את ערך האמת של <span class="math">\(\varphi\)</span> ובודקים מי ניצח.</p>
<p>למה <span class="math">\(\text{TQBF}\)</span> היא <span class="math">\(\text{PSPACE}\)</span>-שלמה? זה שייך לפוסט נפרד. ההוכחה היא יפה ומחוכמת, גם אם לא מסובכת במיוחד. את הפוסט הזה אני רוצה לסיים בשכנוע ש-<span class="math">\(\text{GG}\)</span> קשה לפחות כמו <span class="math">\(\text{TQBF}\)</span>, כלומר להראות איך אפשר לתרגם פסוק <span class="math">\(\text{TQBF}\)</span> כללי לגרף שעליו משחקים <span class="math">\(\text{GG}\)</span>.</p>
<p>ראשית, אפשר להגביל קצת את <span class="math">\(\text{TQBF}\)</span> ולדרוש ש-<span class="math">\(\varphi\)</span> יהיה <span class="math">\(\text{CNF}\)</span> - פסוק שהוא <span class="math">\(\wedge\)</span> של פסוקיות שכל אחת מהן היא <span class="math">\(\vee\)</span> של ליטרלים (ליטרל הוא משתנה או שלילה של משתנה) השמה מספקת פסוק <span class="math">\(\varphi\)</span> שכזה רק אם בכל פסוקית, יש לפחות ליטרל אחד שמקבל <span class="math">\(\text{T}\)</span>. באופן שקול ומסובך יותר (אבל יש סיבה שאני מציין אותו), השמה מספקת פסוק <span class="math">\(\varphi\)</span> אם לא ניתן למצוא פסוקית שבה אף אחד מהמשתנים לא קיבל <span class="math">\(\text{T}\)</span> בהשמה. נניח גם שהכמת האחרון בפסוק ה-<span class="math">\(\text{TQBF}\)</span> הוא תמיד <span class="math">\(\exists\)</span>, כלומר יש מספר אי זוגי של משתנים (למעשה, זו הייתה הצורה הכללית של הפסוקים שהצגתי קודם - כמה מכם שאלו את עצמם "רגע, האם אפשר שסדרת הכמתים תסתיים גם ב-<span class="math">\(\forall\)</span>"?).</p>
<p>כעת, הגרף שעליו ישחקו את ה-<span class="math">\(\text{GG}\)</span> (בהינתן פסוק ה-<span class="math">\(\text{TQBF}\)</span> שהוא אמור לסמלץ) יהיה בנוי משני רכיבים - הראשון מסמלץ את השלב שבו השחקנים בוחרים השמה למשתנים של <span class="math">\(\varphi\)</span>, והשני יסמלץ נסיון של השחקן השני להראות לשחקן הראשון ש-<span class="math">\(\varphi\)</span> לא סופק, כלומר להציג בפני השחקן הראשון פסוקית ב-<span class="math">\(\varphi\)</span> שהשחקן הראשון, לכאורה, לא יכול לספק. כרגיל, תמונה אחת שווה אלף מילים אז הנה איך הגרף נראה, ואנסה גם להסביר קצת מה הולך פה במילים:</p>
<p><a href="/blog/img/2011/04/TQBF_to_GG.png"><img class="alignnone size-full wp-image-1075" title="TQBF_to_GG" src="/blog/img/2011/04/TQBF_to_GG.png" alt="" width="700" height="1020" /></a></p>
<p>הרכיב הראשון (השמאלי) מסמלץ את הבחירות באופן הבא: לכל משתנה <span class="math">\(x_{i}\)</span> יש צומת. מהצומת הזה יוצאות שתי קשתות, אל צמתים שמסומנים ב-<span class="math">\(x_{i}=\text{F}\)</span> ו-<span class="math">\(x_{i}=\text{T}\)</span>. הבחירה של השחקן לאיזה משני הצמתים ללכת תתורגם, בסופו של דבר, להשמה למשתנה <span class="math">\(x_{i}\)</span>.</p>
<p>אחרי שמסתיים המשחק בחלק הראשון, עוברים בחלק השני לתת-גרף שבו יש צומת לכל פסוקית של <span class="math">\(\varphi\)</span>. השחקן השני בוחר לאיזה מהצמתים הללו ללכת. כעת, אם בפסוקית הזו מופיע המשתנה <span class="math">\(x_{i}\)</span>, אז תהיה קשת מהצומת של הפסוקית אל הצומת <span class="math">\(x_{i}=\text{F}\)</span>, ואילו אם יש בה את <span class="math">\(\neg x_{i}\)</span>, תהיה קשת ממנה אל <span class="math">\(x_{i}=\text{T}\)</span>. זה אולי נראה לכם הפוך ממה שאמור להיות, וזה לא מקרי - הנקודה היא שאם בחלק הראשון של המשחק נבחר, למשל <span class="math">\(x_{i}=\text{T}\)</span>, אז הצומת הזה "שרוף" ואי אפשר להיכנס אליו שוב. את הכניסה לצומת <span class="math">\(x_{i}=\text{F}\)</span> מתוך הצומת של הפסוקית שמכילה את <span class="math">\(x_{i}\)</span> צריך לראות לא בתור בחירה של <span class="math">\(\text{F}\)</span> עבור <span class="math">\(x_{i}\)</span>, כי כבר בחרנו ש-<span class="math">\(x_{i}=\text{T}\)</span> בתחילת המשחק; צריך לראות אותה בתור כניסה לצומת פנוי ותו לא. מכיוון שהצומת פנוי, שחקן 1 שרד את הסיבוב הזה - ושחקן 2 הפסיד, כי הצומת שאליו חייבים להיכנס אחרי <span class="math">\(x_{i}=\text{F}\)</span> כבר נשרף. במילים אחרות, אם לכל צומת פסוקית ששחקן 2 יבחר, שחקן 1 יכול להמשיך לבצע עוד צעד אחד במשחק (והוא יכול רק אם הפסוקית הזו הסתפקה על ידי ליטרל כלשהו), אז שחקן 2 הפסיד, ואחרת הוא ניצח.</p>
<p>עם הרדוקציה הזו מגיע הזמן לסיים את הפוסט. לא שהתחלתי אפילו לספר את כל הדברים המעניינים שיש לספר על <span class="math">\(\text{PSPACE}\)</span>, אבל אני מקווה שלפחות נתתי תחושה כלשהי של מה זה בכלל; ובפרט, הצגתי את <span class="math">\(\text{TQBF}\)</span> שהולכת להיות השחקנית החשובה בהמשך.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('expanded');
        }
        
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>