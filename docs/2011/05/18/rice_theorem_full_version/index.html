<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משפט רייס - הגרסה המלאה - לא מדויק</title>
    <link rel="icon" type="image/x-icon" href="/new_blog/favicon.ico">
    
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', 'David', 'Tahoma', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        /* Top navigation bar */
        .top-nav {
            background: #2c3e50;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .top-nav .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .top-nav .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .top-nav .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .top-nav .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .top-nav .nav-links a:hover {
            background: #34495e;
        }
        
        .top-nav .search-box {
            display: flex;
            gap: 5px;
        }
        
        .top-nav .search-box input {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 150px;
        }
        
        .top-nav .search-box button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .top-nav .search-box button:hover {
            background: #2980b9;
        }
        
        /* Blockquote styling */
        blockquote {
            background: #f9f9f9;
            border-right: 5px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.75em 16px;
            position: relative;
            font-style: italic;
        }
        
        blockquote:before {
            content: '"';
            position: absolute;
            top: -10px;
            right: 8px;
            font-size: 3.5em;
            color: #ccc;
            line-height: 1;
        }
        
        blockquote p {
            display: block;
            margin: 0 0 0.75em 0;
        }
        
        blockquote p:last-child {
            margin-bottom: 0;
        }
        
        
        body {
            line-height: 1.8;
        }
        
        .container {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        header {
            margin-bottom: 40px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .post-meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .post-meta .date {
            margin-left: 15px;
        }
        
        .post-meta .categories,
        .post-meta .tags {
            display: inline;
        }
        
        .post-meta .categories a,
        .post-meta .tags a {
            color: #3498db;
            text-decoration: none;
            margin: 0 5px;
        }
        
        .post-meta .categories a:hover,
        .post-meta .tags a:hover {
            text-decoration: underline;
        }
        
        article {
            font-size: 1.1em;
        }
        
        article h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
            font-size: 1.8em;
        }
        
        article h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #34495e;
            font-size: 1.4em;
        }
        
        article p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        article ul, article ol {
            margin-right: 30px;
            margin-bottom: 15px;
        }
        
        article li {
            margin-bottom: 8px;
        }
        
        article code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        article pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 20px;
            direction: ltr;
            text-align: left;
        }
        
        article pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        /* Image styles - responsive and contained */
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        
        /* Math rendering styles */
        .math {
            direction: ltr;
        }
        
        span.math {
            direction: ltr;
        }
        
        /* Override RTL for KaTeX */
        .katex {
            direction: ltr;
            unicode-bidi: embed;
        }
        
        div.math {
            display: block;
            text-align: center;
            padding: 15px 0;
            direction: ltr;
        }
        
        /* RTL adjustments for code blocks */
        .highlight {
            direction: ltr;
            text-align: left;
        }
        
        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            article {
                font-size: 1em;
            }
        }
        
        /* Post navigation */
        .post-navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            gap: 20px;
        }
        
        .post-navigation .nav-link {
            flex: 1;
            text-decoration: none;
            color: #2c3e50;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .post-navigation .nav-link:hover {
            background: #e9ecef;
        }
        
        .post-navigation .nav-prev {
            text-align: right;
        }
        
        .post-navigation .nav-next {
            text-align: left;
        }
        
        .post-navigation .nav-label {
            font-size: 0.85em;
            color: #7f8c8d;
            display: block;
            margin-bottom: 5px;
        }
        
        .post-navigation .nav-title {
            font-weight: bold;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="nav-container">
            <a href="/new_blog/" class="site-title">לא מדויק</a>
            <div class="nav-links">
                <a href="/new_blog/">דף הבית</a>
                <a href="/new_blog/random.html">פוסט אקראי</a>
                <a href="/new_blog/post_list.html">כל הפוסטים</a>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="חיפוש...">
                    <button onclick="searchPosts()">חפש</button>
                </div>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <!-- Post Navigation -->
        
        <nav class="post-navigation">
            
            <a href="/new_blog/2011/05/14/ip_equals_pspace_proof_1-2/" class="nav-link nav-prev">
                <span class="nav-label">פוסט ישן יותר →</span>
                <span class="nav-title">IP=PSPACE - ההוכחה (חלק ב&#39;)</span>
            </a>
            

            
            <a href="/new_blog/2011/05/23/cantor_inventing_ordinals/" class="nav-link nav-next">
                <span class="nav-label">← פוסט חדש יותר</span>
                <span class="nav-title">איך קנטור המציא את הסודרים?</span>
            </a>
            
        </nav>
        
        
        <header>
            <h1>משפט רייס - הגרסה המלאה</h1>
            <div class="post-meta">
                <span class="date">2011-05-18</span>
                
                <span class="categories">
                    | קטגוריות:
                    
                    <a href="/categories/חישוביות.html">חישוביות</a>
                    
                </span>
                
                
                <span class="tags">
                    | תגיות:
                    
                    <a href="/tags/גם טכני זה כיף!.html">גם טכני זה כיף!</a>
                    
                    <a href="/tags/הוכחות יפות.html">הוכחות יפות</a>
                    
                    <a href="/tags/חישוביות.html">חישוביות</a>
                    
                    <a href="/tags/משפט רייס.html">משפט רייס</a>
                    
                </span>
                
            </div>
        </header>
        
        <article>
            <p>אי שם בראשית ימי הבלוג, כשדיברתי על תורת החישוביות <a href="http://www.gadial.net/2007/10/09/rice_theorem/">הזכרתי גם את משפט רייס</a>. באופן אינטואיטיבי, משפט רייס אומר שלא קיים אלגוריתם כללי שמסוגל, בהינתן קוד מחשב לחישוב של פונקציה כלשהי, לקבוע אם הפונקציה מקיימת תכונה "לא טריוויאלית" כלשהי, כשלא טריוויאלי פירושו "נכון לחלק מהפונקציות, אך לא לכולן". בשעתו נתתי הוכחה לגרסה הבסיסית והנפוצה של המשפט, אך מאז בגרתי והחכמתי ולמדתי על גרסה מלאה יותר ואני רוצה לנצל את הפוסט הזה כדי לתאר את המשפט עד הסוף.</p>
<p>ראשית, על אף שאפשר לנסח את המשפט עבור פונקציות כפי שעשיתי למעלה, הניסוח הסטנדרטי שלו הוא על <strong>שפות</strong>. שפה היא קבוצת מילים, כשמילה היא סדרת אותיות מתוך א"ב נתון כלשהו. בדרך כלל מניחים שהא"ב הוא הקבוצה <span class="math">\(\left\{ 0,1\right\} \)</span>; זה לא ממש משנה משהו, מכיוון שפחות או יותר כל אובייקט מתמטי שבכלל אפשר להתעסק בו במחשב ניתן לתיאור כך - מספרים, גרפים, חבורות, קבצי מוזיקה, קידודים של תוכניות מחשב - בסופו של דבר כולם מיוצגים במחשב על ידי מילים שהאותיות שלהן הן 0 ו-1. שפה היא דרך לחלק את קבוצת כל המילים בעולם לשתיים - אלו שכן בשפה, ואלו שלא. למשל, אפשר לדבר על "שפת המספרים הראשוניים", או על "שפת הקבצים שמייצגים סרט וידאו שבאמצע שלו טום קרוז צץ ומתחיל לקפוץ על ספות", וכדומה.</p>
<p>נשתמש ב-<span class="math">\(M\)</span> כדי לסמן תוכנית מחשב (ולפורמליים שמביניכם - מכונת טיורינג; אך לא נזדקק להבדל הזה כאן) שמה שהיא עושה בחיים הוא לקבל קלט כלשהו בתחילת ריצתה, לעשות חישוב כלשהו (מבלי לקבל קלט נוסף מהמשתמש), ובסוף לפלוט "כן" או "לא". נסמן בתור <span class="math">\(L\left(M\right)\)</span> את קבוצת המילים ש-<span class="math">\(M\)</span> אומרת עליהן כן - "מקבלת" אותן; ל-<span class="math">\(L\left(M\right)\)</span> קוראים "השפה ש-<span class="math">\(M\)</span> מקבלת". לקבוצת השפות שקיימת <span class="math">\(M\)</span> שמקבלת אותן קוראים <span class="math">\(\text{RE}\)</span>. שימו לב לאבחנה חשובה כאן - <span class="math">\(M\)</span> לא חייבת לעצור תמיד! אם היא לא עוצרת על קלט מסויים, ודאי שהיא אינה מקבלת אותו (כי לקבל פירושו <strong>לעצור</strong> ולהגיד "כן") ולכן הוא אינו בשפה שלה. אם <span class="math">\(M\)</span> דווקא כן עוצרת על כל קלט, אומרים שהיא <strong>מכריעה</strong> את <span class="math">\(L\left(M\right)\)</span>, ולקבוצת השפות שקיימת מכונה שמכריעה אותן קוראים <span class="math">\(\text{R}\)</span>. כפי שאתם ודאי מנחשים כבר (או יודעים כבר...), <span class="math">\(\text{R}\ne\text{RE}\)</span>, כלומר היכולת של התוכנית לא לעצור על קלטים שעליהם התשובה שלילית מוסיפה לה כוח.</p>
<p>הדוגמה הקלאסית ביותר לשפה שנמצאת ב-<span class="math">\(\text{RE}\)</span> אבל לא ב-<span class="math">\(\text{R}\)</span>, ולכן גם מראה שיש בעיות שלא ניתן לפתור באופן חד משמעי (כי "אני יושב ומחכה לראות אם החישוב אי פעם יסתיים..." זו לא תשובה מספקת למי שרוצה תשובת כן או לא חד משמעית) מכונה "בעיית העצירה". <span class="math">\(\text{HP}\)</span> בלועזית (מלשון Halting Problem) היא שפת כל תוכניות המחשב (זכרו - תוכנית מחשב היא בסך הכל סדרה ארוכה של אפסים ואחדים) שעוצרות מתישהו. שימו לב שאני לא מניח שהתוכנית מקבלת קלט - למעשה, אני מניח במוצהר שהתוכנית לא מקבלת קלט או מבצעת הגרלות כלשהן, כך שהריצה שלה היא תמיד אותו דבר. אפשר גם לדבר על גרסה שבה המכונה מקבלת קלט וכדומה (ולרוב זה מה שעושים) אבל איני צריך את זה כאן ואני די מעדיף את הגרסה הפשוטה הזו.</p>
<p>ראשית, שימו לב שבעיית העצירה ב-<span class="math">\(\text{RE}\)</span> די בבירור - בהינתן <span class="math">\(M\)</span>, אני פשוט אריץ אותה ואחכה לראות אם החישוב נגמר. אם הוא נגמר, אגיד "כן". אם הוא לא נגמר - ובכן, בעסה לי, אחכה לנצח; אבל על פי ההגדרה של <span class="math">\(\text{RE}\)</span> זה לגיטימי.</p>
<p>מדוע בעיית העצירה אינה ב-<span class="math">\(\text{R}\)</span>? כבר <a href="http://www.gadial.net/2007/09/27/halting_problem_proof/">הקדשתי פוסט לעניין הזה</a>, אך הנה הסבר חפוז: נניח שהיא כן, כלומר ניתן, בהינתן קוד של תוכנית מחשב, לקבוע אחרי חישוב שעוצר תמיד האם התוכנית הזו עוצרת או לא. אז אבנה תוכנית מחשב <span class="math">\(M\)</span> שעושה את הדבר הבא: בודקת, באמצעות התוכנית שפותרת את בעיית העצירה, האם <span class="math">\(M\)</span> עצמה עוצרת או לא. כלומר, <span class="math">\(M\)</span> מעבירה את הקוד של עצמה לאותה תוכנית שפותרת את בעיית העצירה. כעת, אם התשובה הייתה "כן, <span class="math">\(M\)</span> עוצרת" אז <span class="math">\(M\)</span> תכף ומייד תיכנס ללולאה אינסופית; ואם התשובה הייתה "לא, <span class="math">\(M\)</span> לא עוצרת" אז <span class="math">\(M\)</span> תכף ומייד תעצור.</p>
<p>למה הדבר דומה? לכך שנלך ברחוב ויבוא נביא ויטען "אני יודע איזו יד אתם הולכים להרים כעת!". אתם שואלים "כן? איזו יד?". הוא אומר "אה... שמאל?" ואתם מרימים מייד את ימין. כל עוד הדבר הבא שתעשו <strong>נקבע לפי התשובה של הנביא</strong>, אתם מסוגלים להפוך את הנביא לנביא שקר. לב ההוכחה כאן הוא בכך ש-<span class="math">\(M\)</span> מסוגלת לשאול את הנביא על עצמה; לא הוכחתי שהדבר אפשרי וזו אינה הוכחה טריוויאלית, אך כבר תיארתי את העניין ב<a href="http://www.gadial.net/2009/11/27/quine_and_recursion_theorem/">פוסט שזה בדיוק היה נושאו</a>. בדרך כלל כשמדברים על בעיית העצירה מציגים גרסה קצת שונה שלה מבחינת הניסוח כדי לעקוף את הקושי הזה.</p>
<p>עכשיו אפשר להציג את משפט רייס. המשפט עוסק בתכונות של שפות. למשל, "אני מכילה את כל המספרים הזוגיים" היא תכונה של שפה, כמו גם "יש בי רק מספר סופי של מילים" או "לא קיימת תוכנית מחשב שמקבלת אותי". שפה טבעית היא דרך נהדרת לתאר תכונות של שפות, אבל איך אפשר לתאר תכונות באופן מתמטי כללי ככל הניתן? ובכן, כמו ששפה היא קבוצה של מילים שכולן מקיימות קריטריון מסויים, כך גם על תכונה אפשר לחשוב בתור <strong>קבוצה של שפות</strong> שכולן מקיימות קריטריון מסויים; ולמעשה, אין הכרח לציין את הקריטריון במפורש - אפשר פשוט להגדיר "תכונה של שפות" בתור קבוצה <span class="math">\(S\)</span> כלשהי של שפות.</p>
<p>השאלה שבה משפט רייס עוסק היא זו - האם אנחנו מסוגלים, בהינתן קוד של תוכנית מחשב <span class="math">\(M\)</span> כלשהי, לקבוע האם <span class="math">\(L\left(M\right)\in S\)</span>?</p>
<p>כדי לפשט קצת את העניינים, מראש נגביל את <span class="math">\(S\)</span> להיות תת קבוצה של <span class="math">\(\text{RE}\)</span> - כלומר, במשחק שלנו כלל לא משתתפות שפות שאין מכונה שמקבלת אותן (ולכן הן ממילא לא רלוונטיות לשאלה אם <span class="math">\(L\left(M\right)\in S\)</span>, שהרי הן אינן מהצורה <span class="math">\(L\left(M\right)\)</span> עבור אף <span class="math">\(M\)</span>). השאלה שלנו, בניסוח הכי פורמלי שאפשר, היא זו - בהינתן <span class="math">\(S\subseteq\text{RE}\)</span>, נגדיר שפה <span class="math">\(L_{S}=\left\{ M|L\left(M\right)\in S\right\} \)</span>. האם <span class="math">\(L_{S}\in\text{R}\)</span>? ואם לא, האם <span class="math">\(L_{S}\in\text{RE}\)</span>, לכל הפחות? (כלומר, האם נוכל לפחות לעצור תמיד ולהגיד "כן" אם <span class="math">\(L\left(M\right)\in S\)</span>, הגם שאם התשובה שלילית לא בהכרח נעצור?)</p>
<p>משפט רייס אומר ש-<span class="math">\(L_{S}\in\text{R}\)</span> רק במקרה שבו <span class="math">\(S\)</span> טריוויאלית - <span class="math">\(S=\emptyset\)</span> או <span class="math">\(S=\text{RE}\)</span> (התכונה לא מתקיימת לאף שפה, או שהיא מתקיימת לכל שפה ב-<span class="math">\(\text{RE}\)</span>). במקרה הראשון, <span class="math">\(L_{S}\)</span> היא שפה ריקה ולכן תוכנית מחשב שמכריעה אותה פשוט אומרת מייד "לא"; במקרה השני תוכנית המחשב שמכריעה את <span class="math">\(L_{S}\)</span> פשוט אומרת מייד "כן". זה לא ממש מעניין, כמובן.</p>
<p>הבה ונוכיח בזריזות את משפט רייס (כבר עשיתי זאת בעבר, כאמור). ההוכחה היא באמצעות <strong>רדוקציה</strong> מ-<span class="math">\(\text{HP}\)</span> אל <span class="math">\(L_{S}\)</span>. רדוקציה היא פשוט דרך להראות איך, אם <span class="math">\(L_{S}\)</span> ניתנת להכרעה, אפשר לנצל זאת גם כדי להכריע את <span class="math">\(\text{HP}\)</span> (ואת זה כבר אמרנו שאי אפשר לעשות). אם כן, נניח שיש לנו תוכנית מחשב שמכריעה את <span class="math">\(L_{S}\)</span>. נניח לרגע כי השפה הריקה, <span class="math">\(\emptyset\)</span> אינה ב-<span class="math">\(S\)</span> (השפה הריקה היא פשוט השפה שאין בה כלל מילים; היא מתקבלת, למשל, על ידי תוכנית מחשבת שפולטת "לא" מייד לכל קלט). מכיוון ש-<span class="math">\(S\)</span> אינה טריוויאלית, יש בה לפחות שפה אחת - נאמר, <span class="math">\(L\in S\)</span>. מכיוון ש-<span class="math">\(S\)</span> מכילה רק שפות ב-<span class="math">\(\text{RE}\)</span>, אז יש תוכנית מחשב שמקבלת את <span class="math">\(L\)</span>; נסמנה <span class="math">\(M_{L}\)</span>.</p>
<p>כעת, מטרתנו היא לפתור את בעיית העצירה. אז נותנים לנו <span class="math">\(M\)</span> כלשהי ושואלים אותנו אם היא עוצרת או לא. מה שאנו עושים הוא לקחת את הקוד של <span class="math">\(M\)</span> ולהשתיל אותו בתוך תוכנית מחשב קצת יותר גדולה ומחוכמת, <span class="math">\(U\)</span>. <span class="math">\(U\)</span> מקבלת קלט <span class="math">\(w\)</span> כלשהו, ואז עושה שני דברים:</p>
<ol>
    <li> מריצה את <span class="math">\(M\)</span>.</li>
    <li> מריצה את <span class="math">\(M_{L}\)</span> על הקלט <span class="math">\(w\)</span> ועונה כמוה.</li>
</ol>
<p>מה הולך כאן? ובכן, אם <span class="math">\(M\)</span> עוצרת מתישהו, אז שלב 1 יסתיים מתישהו ושלב 2 יתחיל. לכן <span class="math">\(U\)</span> תתנהג על כל <span class="math">\(w\)</span> בדיוק כמו <span class="math">\(M_{L}\)</span>, כלומר <span class="math">\(L\left(U\right)=L\left(M_{L}\right)=L\in S\)</span>. במילים אחרות, אם <span class="math">\(M\)</span> עוצרת, השפה של <span class="math">\(U\)</span> היא בעלת התכונה <span class="math">\(S\)</span>.</p>
<p>לעומת זאת, אם <span class="math">\(M\)</span> אינה עוצרת אף פעם גם <span class="math">\(U\)</span> לא תעצור אף פעם - היא נתקעת בשלב 1 ולא מגיעה כלל לשלב 2. לכן השפה של <span class="math">\(U\)</span> היא השפה הריקה, שאמרנו שאינה מקיימת את התכונה <span class="math">\(S\)</span>. מכאן שאפשר להכריע אם <span class="math">\(M\)</span> עוצרת או לא על ידי כך שמכריעים אם השפה של <span class="math">\(U\)</span> היא בעלת התכונה או לא; סוף הסיפור.</p>
<p>מה קורה אם <span class="math">\(S\)</span> דווקא כן מכילה את השפה הריקה? כמעט אותו דבר. הפעם נבחר בתור <span class="math">\(L\)</span> שפה כלשהי שאינה ב-<span class="math">\(S\)</span> (קיימת כזו כי <span class="math">\(S\)</span> לא טריוויאלית), ונשים לב שכעת אם <span class="math">\(M\)</span> עוצרת, אז <span class="math">\(U\)</span> דווקא <strong>איננה</strong> בעלת התכונה, ואם <span class="math">\(M\)</span> אינה עוצרת אז <span class="math">\(U\)</span> היא כן בעלת התכונה; אבל עדיין - ברגע שהכרענו אם <span class="math">\(U\)</span> בעלת התכונה או לא, הסיפור נגמר.</p>
<p>זה מסיים את משפט רייס הבסיסי, וכעת אני רוצה לעבור אל מה שהוא מטרת הפוסט הזה - ההרחבה שלו. טיפלתי לחלוטין בשאלה מתי <span class="math">\(L_{S}\in\text{R}\)</span>, אבל עדיין נותרה השאלה מתי <span class="math">\(L_{S}\in\text{RE}\)</span>. כאן פתאום הסימטריה היפה של ההוכחה מתחילה להישבר. ראשית, אם <span class="math">\(S\)</span> אינה מכילה את השפה הריקה (המקרה הראשון בו טיפלנו) אז ההוכחה פשוט לא עובדת יותר אם כל מה שאנו מניחים הוא ש-<span class="math">\(L_{S}\in\text{RE}\)</span>; אמנם, על ידי בדיקה אם <span class="math">\(U\)</span> בעלת התכונה עדיין נוכל להשתכנע ש-<span class="math">\(M\)</span> עוצרת, וזה מראה ש-<span class="math">\(\text{HP}\in\text{RE}\)</span>, אבל את זה כבר ידענו - זה לא מוביל לסתירה כלשהי. אם <span class="math">\(M\)</span> לא עוצרת, אז <span class="math">\(L\left(U\right)\)</span> לא תהיה בעלת התכונה, ולכן אין שום דבר שמבטיח לנו שהתוכנית שמקבלת את <span class="math">\(L_{S}\)</span> תעצור בכלל על <span class="math">\(U\)</span>.</p>
<p>לעומת זאת, אם <span class="math">\(S\)</span> כן מכילה את השפה הריקה, הסיפור שונה; במקרה הזה, אם <span class="math">\(M\)</span> <strong>לא</strong> עוצרת, אז <span class="math">\(L\left(U\right)\)</span> <strong>כן</strong> תהיה בעלת התכונה, ולכן התוכנית שמקבלת את <span class="math">\(L_{S}\)</span> <strong>כן</strong> תעצור מתישהו על <span class="math">\(U\)</span> ותגיד "כן". זה פותח לנו פתח ל<strong>הכרעה</strong> של <span class="math">\(\text{HP}\)</span>: בהינתן <span class="math">\(M\)</span>, ראשית נבנה ממנה את <span class="math">\(U\)</span> כמו קודם, ואז נעשה שני דברים במקביל - גם נבדוק אם <span class="math">\(U\in L_{S}\)</span>, וגם נריץ את <span class="math">\(M\)</span> ונראה אם היא עוצרת. אפשר לבצע הרצות במקביל - המחשב שלכם עושה זאת כל הזמן (כמובן שהסיפור האמיתי מסובך יותר - לרוב מריצים תוכנית אחת לזמן מה, ואז מעבירים את הבקרה לתוכנית השניה, ואז חוזרים לראשונה, וכן הלאה). כעת מובטח לנו כי אחת משתי ההרצות תעצור מתישהו - אם <span class="math">\(M\)</span> עוצרת, אז ההרצה של <span class="math">\(M\)</span> עצמה תעצור; ואם היא לא עוצרת ולכן <span class="math">\(L\left(U\right)\)</span> בעלת התכונה, אז הבדיקה אם <span class="math">\(U\in L_{S}\)</span> תעצור מתישהו. במקרה הראשון (אם <span class="math">\(M\)</span> עצרה), נעצור גם אנחנו ונאמר "כן"; במקרה השני נעצור ונאמר "לא", והנה הכרענו את <span class="math">\(\text{HP}\)</span> - סתירה. לכן אם <span class="math">\(\emptyset\in S\)</span> הרי ש-<span class="math">\(L_{S}\notin\text{RE}\)</span>. אבל זה כל מה שניתוח נאיבי של ההוכחה נתן לנו; אנחנו רוצים אפיון מוחלט, טענת "אם ורק אם". להבין בדיוק אילו תנאים על <span class="math">\(S\)</span> מבטיחים ש-<span class="math">\(L_{S}\in\text{RE}\)</span> ואילו תנאים מבטיחים כי <span class="math">\(L_{S}\notin\text{RE}\)</span>.</p>
<p>ובכן, פשוט אציג את התנאים, ואז אוכיח שהם עובדים. נקווה שלא אאבד יותר מדי קוראים.</p>
<p>בהינתן <span class="math">\(S\subseteq\text{RE}\)</span>, השפה <span class="math">\(L_{S}\in\text{RE}\)</span> אם ורק אם <span class="math">\(S\)</span> מקיימת בו זמנית את שלוש התכונות הבאות:</p>
<ol>
    <li> אם <span class="math">\(L_{1}\in S\)</span>, <span class="math">\(L_{2}\in\text{RE}\)</span> ו-<span class="math">\(L_{1}\subseteq L_{2}\)</span> אז <span class="math">\(L_{2}\in S\)</span>.</li>
    <li> אם <span class="math">\(L_{1}\in S\)</span> אז יש ל-<span class="math">\(L_{1}\)</span> תת-שפה סופית <span class="math">\(L_{2}\subseteq L_{1}\)</span> כך ש-<span class="math">\(L_{2}\in S\)</span>.</li>
    <li> שפת כל השפות הסופיות שב-<span class="math">\(S\)</span> היא ב-<span class="math">\(\text{RE}\)</span>.</li>
</ol>
<p>התנאי השלישי דורש הסבר כלשהו. שפה סופית - שפה שמכילה רק מספר סופי של מילים - תמיד אפשר לקודד כמחרוזת סופית. אם המילים שלה הן <span class="math">\(w_{1},w_{2},\dots,w_{n}\)</span> אז המחרוזת <span class="math">\(\left(w_{1},w_{2},\dots,w_{n}\right)\)</span> (הסוגריים והפסיקים הם חלק מהמחרוזת - הם מקודדים על ידי תווי ASCII שמקודדים על ידי ספרות בינאריות) היא דרך לייצג את השפה בתור מילה סופית (עבור שפות אינסופיות אי אפשר לעשות תעלול דומה). התנאי השלישי, אם כן, אומר שבהינתן מחרוזת שמייצגת קבוצת מילים שכזו, אם היא מקיימת את התכונה <span class="math">\(S\)</span> אפשר לעצור ולומר זאת לאחר זמן סופי.</p>
<p>בואו נראה רגע איך המשפט הזה מתיישב עם מה שכבר ראינו. ראינו שאם <span class="math">\(S\)</span> לא טריוויאלית ו-<span class="math">\(\emptyset\in S\)</span> אז <span class="math">\(L_{S}\notin\text{RE}\)</span>. מה המשפט החדש אומר? ובכן, <span class="math">\(\emptyset\)</span> היא בעלת התכונה שלכל <span class="math">\(L\)</span> מתקיים <span class="math">\(\emptyset\subseteq L\)</span>, ולכן אם <span class="math">\(S\)</span> היא כזו ש-<span class="math">\(L_{S}\in\text{RE}\)</span> ובפרט היא מקיימת את תנאי 1, אז <span class="math">\(L\in S\)</span> לכל <span class="math">\(L\in\text{RE}\)</span>, כלומר <span class="math">\(S=\text{RE}\)</span> ולכן זוהי תכונה טריוויאלית. כלומר, או ש-<span class="math">\(S\)</span> טריוויאלית, או ש-<span class="math">\(L_{S}\notin\text{RE}\)</span>. אז אנחנו רואים בבירור שהמשפט שזה עתה הצגתי הוא הכללה של מה שכבר ראינו.</p>
<p>אז איך מוכיחים את המשפט? אני ממליץ לאלו מכם שיש להם נסיון כלשהו עם חישוביות לנסות ולהוכיח בעצמכם. זה מהמשפטים הללו שעיקר הקושי בהם הוא הגילוי של הקריטריון המתאים (איך בדיוק הגיעו לשלושת התנאים הללו? כנראה שהרבה ניסויים ובדיקה של מקרים פרטיים והתעמקות ומחשבה - כמו כל משפט מתמטי בערך), ומרגע שהניסוח הנכון קיים ההוכחה אינה כה נוראית.</p>
<p>הבה ונעבור להוכחה. ראשית נראה כי שלוש התכונות הללו הן הכרחיות, כלומר שאם משמיטים ולו אחת מהן, <span class="math">\(L_{S}\notin\text{RE}\)</span> בודאות.</p>
<p>ראשית נשמיט את תכונה 1, כלומר נניח שיש <span class="math">\(L_{1},L_{2}\)</span> כך ש-<span class="math">\(L_{1}\subseteq L_{2}\)</span> וגם <span class="math">\(L_{1},L_{2}\in\text{RE}\)</span> וגם <span class="math">\(L_{1}\in S\)</span> אבל <span class="math">\(L_{2}\notin S\)</span>. כעת נכריע את <span class="math">\(\text{HP}\)</span> בדרך דומה למה שעוללנו קודם - בהינתן <span class="math">\(M\)</span>, נבנה מכונה <span class="math">\(U\)</span> ששפתה תהיה <span class="math">\(L_{1}\)</span> אם <span class="math">\(M\)</span> אינה עוצרת, ו-<span class="math">\(L_{2}\)</span> אם היא כן עוצרת. אם <span class="math">\(L_{S}\in\text{RE}\)</span> זה אומר שנוכל לזהות מתי <span class="math">\(M\)</span> אינה עוצרת; וכאמור, לזהות מתי היא כן עוצרת אפשר לזהות פשוט על ידי הרצתה.</p>
<p>מה <span class="math">\(U\)</span> עושה, על קלט <span class="math">\(w\)</span>? ובכן, היא מריצה את המכונה שמקבלת את <span class="math">\(L_{1}\)</span> על הקלט <span class="math">\(w\)</span>, ובמקביל היא מריצה את <span class="math">\(M\)</span>. אם בשלב כלשהו המכונה של <span class="math">\(L_{1}\)</span> עצרה וקיבלה את <span class="math">\(w\)</span>, אז גם <span class="math">\(U\)</span> מקבלת את <span class="math">\(w\)</span>; ואם בשלב כלשהו <span class="math">\(M\)</span> עצרה, אז <span class="math">\(U\)</span> מפסיקה את הרצת המכונה של <span class="math">\(L_{1}\)</span> על <span class="math">\(w\)</span> ותחת זאת מריצה את המכונה של <span class="math">\(L_{2}\)</span> על <span class="math">\(w\)</span> ועונה כמוה. מה הולך כאן?</p>
<p>ובכן, אם <span class="math">\(M\)</span> <strong>אינה עוצרת</strong>, אז <span class="math">\(U\)</span> תקבל את <span class="math">\(w\)</span> אם ורק אם <span class="math">\(w\in L_{1}\)</span>; במילים אחרות, <span class="math">\(L\left(U\right)=L_{1}\)</span>, כפי שרצינו; ואילו אם <span class="math">\(M\)</span> כן עוצרת, אז את <span class="math">\(w\)</span> אפשר לקבל בשתי צורות אפשריות - או שנקבל אותו כבר בהתחלה, אם נזהה שהוא ב-<span class="math">\(L_{1}\)</span>; או שנקבל אותו בהמשך, אם נזהה שהוא ב-<span class="math">\(L_{2}\)</span>. אלא ש-<span class="math">\(L_{1}\subseteq L_{2}\)</span>, כך שהאפשרות שנקבל אותו בהתחלה לא משנה כלום - מובטח לנו ש-<span class="math">\(L\left(U\right)=L_{2}\)</span> במקרה זה, שבו <span class="math">\(M\)</span> עוצרת. כפי שרצינו.</p>
<p>יפה, אז התנאי הראשון הכרחי. ומה עם השני? גם כאן מניחים שהתנאי לא מתקיים ומוכיחים שאם עדיין <span class="math">\(L_{S}\in\text{RE}\)</span> אז אפשר להכריע את <span class="math">\(\text{HP}\)</span>: נניח בשלילה שיש <span class="math">\(L_{1}\in S\)</span> שכל תת-שפה סופית שלה אינה ב-<span class="math">\(S\)</span>; אז בהינתן <span class="math">\(M\)</span> נבנה <span class="math">\(U\)</span> כך שאם <span class="math">\(M\)</span> אינה עוצרת, <span class="math">\(L\left(U\right)=L_{1}\)</span>, ואילו אם <span class="math">\(M\)</span> כן עוצרת, <span class="math">\(L\left(U\right)\)</span> היא שפה סופית כלשהי (ולכן לא ב-<span class="math">\(S\)</span>). התעלול פשוט: <span class="math">\(U\)</span> על קלט <span class="math">\(w\)</span> תריץ את <span class="math">\(M\)</span> במשך <span class="math">\(\left|w\right|\)</span> צעדים - כלומר, מספר צעדים ששווה לאורך של <span class="math">\(w\)</span>. אם <span class="math">\(M\)</span> עצרה במהלך הצעדים הללו, <span class="math">\(U\)</span> תעצור מייד ותגיד "לא"; אחרת, אחרי שהריצה את <span class="math">\(M\)</span> במשך <span class="math">\(\left|w\right|\)</span> צעדים, <span class="math">\(U\)</span> תתייאש ותריץ את התוכנית עבור <span class="math">\(L_{1}\)</span> על <span class="math">\(w\)</span> ותענה כמוה.</p>
<p>מה קרה כאן? אם <span class="math">\(M\)</span> עוצרת מתישהו, נניח אחרי 13 צעדים, אז <span class="math">\(U\)</span> תדחה כל מילה שאורכה גדול מ-13; ולכן השפה של <span class="math">\(U\)</span> סופית; ולכן היא אינה ב-<span class="math">\(S\)</span>. אם לעומת זאת <span class="math">\(M\)</span> אינה עוצרת אף פעם אז <span class="math">\(U\)</span> תמיד תגיע לשלב שבו היא בודקת אם <span class="math">\(w\)</span> שייכת ל-<span class="math">\(L_{1}\)</span>, ולכן שפתה תהיה בדיוק <span class="math">\(L_{1}\)</span>. מכאן הדרך להכרעת <span class="math">\(\text{HP}\)</span> סלולה.</p>
<p>נותרנו עם התנאי השלישי. על פניו הוא נראה הסבוך מכולם, אבל במקרה שלו ההוכחה קלה עוד יותר ואפילו לא נזדקק להוכחה בדרך השלילה. אם <span class="math">\(L_{S}\in\text{RE}\)</span> זה אומר שבהינתן מכונה <span class="math">\(M\)</span>, ניתן לבדוק אם <span class="math">\(L\left(M\right)\in S\)</span> ואם התשובה חיובית מובטח לנו שנעצור. אם כן, איך נבדוק, בהינתן שפה סופית <span class="math">\(L\)</span>, ש-<span class="math">\(L\in S\)</span>? פשוט מאוד: נבנה בעזרת הקידוד של <span class="math">\(L\)</span> מכונה <span class="math">\(M\)</span> כך ש-<span class="math">\(L\left(M\right)=L\)</span>. מכונה כזו, בהינתן קלט, פשוט משווה אותו לרשימת המילים הסופית של <span class="math">\(L\)</span> ומקבלת אם הוא שם. כעת כל שנותר לעשות כדי לבדוק אם <span class="math">\(L\in S\)</span> הוא לבדוק אם <span class="math">\(L\left(M\right)\in S\)</span>.</p>
<p>אם כן, הראנו כי אחד מהתנאים הללו בפני עצמו הוא הכרחי - אם הוא אינו מתקיים, <span class="math">\(L_{S}\notin\text{RE}\)</span>. החלק המעניין כאן הוא האופן שבו השילוב של שלושתם - שלושה תנאים שנראים בלתי קשורים בעליל ממבט ראשון - מוכיח כי <span class="math">\(L_{S}\in\text{RE}\)</span>. כמקודם, אני מאוד ממליץ לנסות ולחשוב על זה בעצמכם לפני שתקראו את ההוכחה.</p>
<p>בואו נבהיר לעצמנו מה צריך לעשות - אנחנו צריכים להראות איך, בהינתן תוכנית <span class="math">\(M\)</span>, אפשר לבדוק אם <span class="math">\(L\left(M\right)\in S\)</span>, כשהפריבילגיה שלנו היא שאם <span class="math">\(L\left(M\right)\notin S\)</span> אנחנו לא חייבים לעצור, אלא רק להימנע ממתן תשובה שגויה. אז השאלה שלנו היא - איך אנחנו יכולים להשתכנע ב-100 אחוזי ודאות ש-<span class="math">\(L\left(M\right)\in S\)</span>?</p>
<p>השפות הסופיות ב-<span class="math">\(S\)</span> הן המפתח לפתרון. אם נגלה שפה סופית ב-<span class="math">\(S\)</span> כך ש-<span class="math">\(M\)</span> מקבלת את <strong>כל</strong> המילים שבה, אנחנו יכולים בודאות לסיים. מדוע? על פי תנאי מס' 1: אם הראינו כי <span class="math">\(L\left(M\right)\)</span> מכילה שפה סופית ב-<span class="math">\(S\)</span>, תנאי 1 אומר שגם היא עצמה ב-<span class="math">\(S\)</span> ולכן ניתן בודאות לקבל.</p>
<p>אבל, תגידו, מי מבטיח לנו שבכלל <strong>קיימת</strong> שפה סופית ב-<span class="math">\(S\)</span> שאותה <span class="math">\(L\left(M\right)\)</span> מכילה? ובכן, תנאי 2, כמובן. שני התנאים מאפשרים לנו לנסח קריטריון אם-ורק-אם: <span class="math">\(L\left(M\right)\in S\)</span> אם ורק אם קיימת <span class="math">\(L_{1}\subseteq L\left(M\right)\)</span> סופית כך ש-<span class="math">\(L_{1}\in S\)</span>.</p>
<p>האתגר שנותר הוא להסביר איך בודקים בפועל אם קיימת <span class="math">\(L_{1}\in S\)</span> כזו שמקיימת <span class="math">\(L_{1}\subseteq L\left(M\right)\)</span>. את הבדיקה הזו עושים עם תעלול סטנדרטי נוסף בתורת החישוביות - הרצה מבוקרת.</p>
<p>הרצה מבוקרת היא דרך לרוץ על אינסוף קלטים "בבת אחת" או "במקביל", למרות ששתי המילים הללו אינן נכונות במיוחד. מה שאני רוצה לעשות הוא לבנות רשימה של כל המילים שעליהן <span class="math">\(M\)</span> עוצרת ומקבלת, אך סתם להריץ את <span class="math">\(M\)</span> על מילה כלשהי, לחכות עד שתסיים ואז לעבור למילה הבאה לא יעבוד, כי לא בטוח ש-<span class="math">\(M\)</span> תסיים בכלל. לכן התעלול הוא כזה: אני קובע סדר כלשהו על כל המילים הקיימות, <span class="math">\(w_{1},w_{2},w_{3},\dots\)</span> (שיטה אחת - להשוות קודם על פי האורך, ולאחר מכן על פי המספר שהמילה מייצגת). אני מריץ את <span class="math">\(M\)</span> זמן מה על <span class="math">\(w_{1}\)</span> ומפסיק. לאחר מכן אני מריץ אותה זמן מה על <span class="math">\(w_{2}\)</span>, ומפסיק. אז אני חוזר להריץ אותה על <span class="math">\(w_{1}\)</span> תוך שאני ממשיך מאותה נקודה שבה הפסקתי קודם; ואז אני רץ על <span class="math">\(w_{2}\)</span>. ואז על <span class="math">\(w_{3}\)</span>. ואז שוב <span class="math">\(w_{1}\)</span>, ושוב <span class="math">\(w_{2}\)</span>, ושוב <span class="math">\(w_{3}\)</span>, ואז <span class="math">\(w_{4}\)</span> - אתם מבינים את העיקרון. בכל "סיבוב" ריצה אני נותן הרצה לכל המילים שכבר התעסקתי איתן קודם, ומוסיף מילה חדשה למשחק. זה מבטיח שבסופו של דבר, כל מילה תזכה לכך שירוצו עליה זמן לא חסום, ולכן לכל מילה שאותה <span class="math">\(M\)</span> מקבל, בסוף אכן אגלה ש-<span class="math">\(M\)</span> מקבל אותה. זו נראית כמו שיטה בזבזנית למדי, אבל זה בדיוק האופן שבו דברים עובדים בתורת החישוביות - המקום שבו מתעניינים רק בשאלה אם משהו אפשרי ברמה הכי תיאורטית.</p>
<p>מה עכשיו? ובכן, בכל פעם שבה תתגלה מילה חדשה שאותה <span class="math">\(M\)</span> מקבלת, נבצע במקביל להרצה של <span class="math">\(M\)</span> על כל המילים האפשריות גם בדיקה נוספת - כל תת-קבוצה של המילים ש-<span class="math">\(M\)</span> קיבלה עד כה היא שפה סופית; פשוט נבדוק לכל שפה סופית כזו (שוב, על ידי הרצה מבוקרת) האם היא ב-<span class="math">\(S\)</span>. אנחנו יכולים לעשות זאת, על פי כלל 3. אם מתישהו שפה סופית שכזו תתקבל, סיימנו - פשוט נעצור ונקבל. ואם אף פעם לא תתקבל שפה סופית שכזו? ובכן, החיים קשים ולא נעצור לעולם, אבל כבר אמרתי שאם אף שפה סופית שכזו לא מתקבלת, הרי שממילא <span class="math">\(L\left(M\right)\notin S\)</span> ולכן כל מה שאני מחוייב לו הוא לא לקבל, ובפרט מותר לי לא לעצור.</p>
<p>אם כן, זה מסיים את ההוכחה הכללית ביותר של משפט רייס. אם זו הפעם הראשונה שאתם נתקלים בדברים כאלו אני מניח שזה נראה לכם מטורלל משהו; אם כן, מצויין! זה בדיוק האופי של תורת החישוביות שאני רוצה להעביר. אחרי שמתרגלים קצת לתורת החישוביות רואים שההוכחה הזו היא מאוד פשוטה וטבעית (לא סתם הפצרתי בכם לנסות ולגלות אותה בעצמכם) ולטעמי - גם יפה בצורה בלתי רגילה.</p>
        </article>
        
        <footer>
            <p>© כל הזכויות שמורות לגדי אלכסנדרוביץ'</p>
        </footer>
    </div>

    
    <script>
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm.trim()) {
                window.location.href = '/new_blog/post_list.html?search=' + encodeURIComponent(searchTerm);
            }
        }
        
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchPosts();
            }
        });
    </script>
    
    
    <!-- Auto-render KaTeX math -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

</body>
</html>