---
id: 210
title: "אז מה בין קודים לתיקון שגיאות והוכחת משפט ה-PCP?"
date: 2009-10-01 23:12:07
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - משפט ה-PCP
  - קוד הדמר
---
בשני הפוסטים האחרונים הצגתי שני מושגים שנראים על פניו חסרי קשר. <a href="http://www.gadial.net/2009/09/19/pcp_theorem_intro/">המושג הראשון</a> היה הוכחות PCP, שהן מעין תחליף להוכחות "רגילות" שבהן יש ודאות מוחלטות שההוכחה נכונה, כשהתמורה הבולטת לויתור הזה על הביטחון המוחלט (והחלפתו בביטחון "מוחלט לכל רמת דיוק שנרצה פרט למאה אחוז") היא שכבר אין צורך לקרוא את כל ההוכחה, אלא רק מספר קבוע של ביטים ממנה, בלי תלות בטענה הספציפית שרוצים להוכיח (מבחינה פורמלית זה טיפה יותר מסובך - תמיד יש "שפה" ברקע, והטענות שהמערכת מטפלת בהן הן מהצורה "המילה הזו שייכת לשפה").

<a href="http://www.gadial.net/2009/09/23/locally_checkable_codes/">המושג השני</a> היה קודים לתיקון וזיהוי שגיאות, ועיקר הפוסט הוקדש להצגת קוד מסויים - קוד הדמר - בעל התכונה שהוא ניתן לבדיקה מקומית - מספיק לדגום (באקראי) מספר קבוע של ביטים מתוך מילה נתונה כדי לבדוק בהסתברות טובה למדי האם זוהי מילת קוד חוקית או לא. זה התחיל להזכיר את משפט ה-PCP, שגם בו מבוצעת בדיקה אקראית "מקומית", אבל עדיין רב הנסתר על הנגלה - איך קודים מתקשרים להוכחות? בכך אטפל בפוסט הזה.

השלב הראשון הוא מעבר ממודל החישוב הרגיל שלנו - שנע בין דיבורים מעורפלים על "אלגוריתם" ו"מוודא" ועד למודל הפורמלי של <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%9B%D7%95%D7%A0%D7%AA_%D7%98%D7%99%D7%95%D7%A8%D7%99%D7%A0%D7%92">מכונת טיורינג</a> - למודל חישוב אחר, שבמובנים רבים הוא פשוט אף יותר, ויהיה מושלם למה שאנחנו מנסים לעשות - <a href="http://he.wikipedia.org/wiki/%D7%A1%D7%99%D7%91%D7%95%D7%9B%D7%99%D7%95%D7%AA_%D7%9E%D7%A2%D7%92%D7%9C%D7%99%D7%9D">מעגלים בוליאניים</a>.

על מעגלים בוליאניים אפשר לכתוב פוסטים מכאן ועד להודעה חדשה, אבל כמו במקרה של קודים לתיקון שגיאות גם כאן אתמקד כעת במה שרלוונטי עבורנו. בבסיסם, מעגלים הם מודל חישובי פשוט מאוד, שמורכב מ"שערים לוגיים" וחיבורים ביניהם. שער לוגי מקבל מספר ערכים, שכל אחד מהם הוא או 0 או 1, ומבצע עליהם חישוב פשוט. למשל, שער NOT מחזיר 1 אם קיבל 0, ו-0 אם קיבל 1; ושער AND מקבל שני ערכים, מחזיר 1 אם שניהם 1 ואחרת (אם לפחות אחד מהם הוא אפס) מחזיר 0. יש עוד שערים אבל די לנו בשני אלו כדי לייצג <strong>כל</strong> פונקציה בוליאנית (פונקציה שמקבלת מספר ערכים של 0 ו-1 ומחזירה כפלט 0 או 1) בעזרת מעגל שמכיל רק את השערים הללו.

המילה "מעגל" קצת מטעה; אין במעגל הזה מעגלים אמיתיים, כלומר לא ניתן למצוא שער שהפלט שלו יכול להתחבר איכשהו לקלט שלו. המעגל מתחיל בקלטים, שעליהם אפשר לחשוב כעל שערים פשוטים שפולטים ביט בודד, והקלטים נכנסים לשערים אחרים, והפלט שלהם נכנס לשערים נוספים, וכן הלאה וכן הלאה עד שלבסוף הכל מתנקז לשער אחד אחרון, שהיציאה שלו היא הפלט של המעגל כולו. כרגיל בעניינים כאלו, תמונה אחת שווה אלף מילים:

<img src="http://users.ece.gatech.edu/~sudha/academic/class/ece2030/Lectures/gate-design/examples-14.gif" height="255" width="469" />

מעגלים בוליאניים צצים דווקא בהקשרים מעשיים - זה (בפשטנות רבה להחריד, כמובן) מה שקורה בפועל במעגלים חשמליים. עם זאת, המקור ה"מעשי" של המעגלים לא מונע מהם להיות נושא מרתק וחשוב בעיסוקים תיאורטיים טהורים, כמו זה שכאן. האבחנה החשובה הראשונה היא שמעגלים בוליאניים יכולים לחשב כל פונקציה בוליאנית, ובפרט שלכל מכונת טיורינג (שהיא, כזכור, מודל מתמטי קונקרטי של "אלגוריתם") אפשר לתת משפחה של מעגלים בוליאניים שמתנהגים "כמוה". למה "משפחה"? כי בניגוד למכונת טיורינג, שמסוגלת לקבל קלטים מכל אורך שהוא, מעגל בוליאני מוגבל מראש - כל מעגל בנוי כך שהוא מקבל מספר קלטים ספציפי, ולכן אם רוצים לטפל בכל אורכי הקלטים האפשריים צריך לתת משפחה של מעגלים - מעגל לכל אורך קלט אפשרי. לעתים קרובות כל המעגלים הללו יהיו דומים זה לזה כך שאין כאן בעיה של ממש, אבל כשמנסים להגדיר פורמלית את מודל החישוב הזה, ה"משפחתיות" הזו יוצרת בעיות שלא ניכנס אליהן כעת (רק אעיר שאם לא מגבילים אותה, מקבלים מודל חישובי ש<strong>חזק</strong> יותר ממכונת טיורינג, אך אינו סביר בעליל).

נתמקד כעת במקרה שלנו - אנחנו מדברים על בעיות שנמצאות ב-NP, כלומר בעיות שאפשר לנסח במונחים של "וידוא שמילה {% equation %}w{% endequation %} שייכת לשפה {% equation %}L{% endequation %}", כך שקיים "מוודא" עבור השפה {% equation %}L{% endequation %} שמסוגל לקרוא "הוכחות" {% equation %}\pi{% endequation %} לכך ש-{% equation %}w\in L{% endequation %} ולומר "כן", ואם {% equation %}w\notin L{% endequation %} אז שום הוכחה לא תגרום למוודא לומר כן; והמוודא מבצע את הבדיקה שלו ביעילות - זמן שהוא פולינומי בגודל של {% equation %}w{% endequation %}. את המודל הזה אפשר להחליף במודל של מעגלים - לכל מספר טבעי {% equation %}n{% endequation %} אפשר לבנות מעגל כך שהוא מקבל קלט {% equation %}w{% endequation %} מאורך {% equation %}n{% endequation %}, ועוד קלט {% equation %}\pi{% endequation %} מאורך כלשהו שפולינומי ב-{% equation %}n{% endequation %} (וגם הוא קבוע), כך שאם {% equation %}w\in L{% endequation %} אז קיים {% equation %}\pi{% endequation %} שעבורו המעגל פולט 1, אם {% equation %}w\notin L{% endequation %} אז לכל {% equation %}\pi{% endequation %} המעגל פולט 0, וגודל המעגל כולו פולינומי ב-{% equation %}n{% endequation %} (כלומר, אין מספר גדול במיוחד של שערים). איך אפשר לבנות מעגל כזה? שאלה מצויינת. למי שמכיר את <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%A4%D7%98_%D7%A7%D7%95%D7%A7-%D7%9C%D7%95%D7%99%D7%9F">משפט קוק-לוין</a>, הרעיון זהה (משפט קוק-לוין מתוחכם עוד יותר - מסמלצים מכונת טיורינג באמצעות נוסחה בתחשיב הפסוקים - ועל נוסחה כזו אפשר לחשוב כגרסה פשוטה של מעגל בוליאני, שבו כל יציאה של שער נכנסת לכניסה של שער אחד בלבד, כלומר לא ניתן "למחזר" אותה). למי שלא מכיר - תאמינו לי לבינתיים, זו לא מטרת הפוסט.

עכשיו בואו נסתכל על התמונה הגדולה. נניח שאני מוודא PCP עבור השפה {% equation %}L{% endequation %}. בהינתן מילה {% equation %}w{% endequation %}, אני מצפה לקבל הוכחה כלשהי לכך ש-{% equation %}w{% endequation %} שייכת ל-{% equation %}L{% endequation %} - הוכחה שאצטרך לדגום ממנה רק מספר קבוע של ביטים. איך תיראה ההוכחה הזו? בתור התחלה, נוכל לחשוב על המעגל שתיארתי קודם, שמסמלץ את מוודא ה-NP עבור {% equation %}L{% endequation %}; אפשר "להקפיא" את הכניסות שמייצגות את {% equation %}w{% endequation %}, ולכן נישאר עם מעגל שאסמן ב-{% equation %}C{% endequation %}, שמקבל קלט בודד - {% equation %}\pi{% endequation %} - וקיים פלט כלשהו שעבורו הוא פולט 1 רק אם {% equation %}w{% endequation %} שייך לשפה. כלומר, כדי להשתכנע ש-{% equation %}w\in L{% endequation %} אני רוצה שיביאו לי הוכחה שניתן לספק את {% equation %}C{% endequation %}.

הוכחה פשוטה יחסית היא שפשוט יביאו לי את {% equation %}\pi{% endequation %} ויגידו לי "אתה יודע מהו {% equation %}C{% endequation %}, פשוט תריץ אותו על {% equation %}\pi{% endequation %} וגמרנו". זה לא טוב, כי כי להריץ את {% equation %}C{% endequation %} על {% equation %}\pi{% endequation %} אצטרך לקרוא כל הנראה את כל הביטים של {% equation %}\pi{% endequation %} (כי כל אחד מהם בא לידי ביטוי ב-{% equation %}C{% endequation %} בשלב זה או אחר).

הוכחה יותר מחוכמת, אם כן, תכלול לא רק את {% equation %}\pi{% endequation %}, אלא גם את הערך שכל שער של {% equation %}C{% endequation %} מקבל כאשר מזינים ל-{% equation %}C{% endequation %} את {% equation %}\pi{% endequation %}. בצורה זו לא אהיה חייב לקרוא את {% equation %}\pi{% endequation %} כדי לראות ש-{% equation %}C{% endequation %} מוציא עליו את הפלט 1; אוכל להסתפק בקריאת ערכי השערים של {% equation %}C{% endequation %}. לרוע המזל, {% equation %}C{% endequation %} ככל הנראה יהיה גודל <strong>יותר</strong> מ-{% equation %}\pi{% endequation %} ולכן אצטרך לקרוא עוד <strong>יותר</strong> ביטים, אז לא הרווחתי (בינתיים) כלום.

הצעד הבא הוא להסכים לקבל הוכחה מהסוג שתיארתי כרגע, של "רשימת כל הערכים שהשערים של {% equation %}C{% endequation %} מקבלים שמזינים ל-{% equation %}C{% endequation %} {% equation %}\pi{% endequation %} שמספק אותו", אבל לא לקרוא את כולה, אלא רק "לדגום" חלקים ממנה. מה בעצם אנחנו רוצים לבדוק? ששער היציאה של {% equation %}C{% endequation %} הוא 1 (אחרת {% equation %}\pi{% endequation %} בוודאי שאינו מספק את {% equation %}C{% endequation %}) ושכל שער מתנהג בצורה חוקית. אם נמספר את כל השערים ב-{% equation %}C{% endequation %} ונסמן ב-{% equation %}\alpha_{i}{% endequation %} את הערך של השער ה-{% equation %}i{% endequation %} (נניח לצורך העניין שגם הביטים של {% equation %}\pi{% endequation %} מיוצגים על ידי שערים), אפשר לסכם את הדרישות באופן הבא:
<ol>
	<li> {% equation %}\alpha_{t}=1{% endequation %}, כאשר {% equation %}t{% endequation %} הוא מספר שער היציאה של {% equation %}C{% endequation %}.</li>
	<li> אם {% equation %}i{% endequation %} הוא שער AND שהכניסות שלו הן מהשערים {% equation %}j,k{% endequation %}, אז {% equation %}\alpha_{i}=\alpha_{j}\alpha_{k}{% endequation %}.</li>
	<li> אם {% equation %}i{% endequation %} הוא שער NOT שהכניסה שלו היא מהשער {% equation %}j{% endequation %}, אז {% equation %}\alpha_{i}=\alpha_{j}+1{% endequation %} (כאן חיבור הוא מודולו 2, כלומר {% equation %}1+1=0{% endequation %}).</li>
</ol>
אם כן, צמצמנו את ה"הוכחה" שאנחנו רוצים לקבל לאוסף של ביטים {% equation %}\alpha_{i}{% endequation %} שמקיימים אוסף של "אילוצים". כשבודקים את {% equation %}C{% endequation %} אפשר לבחור באופן אקראי אחד מהאילוצים, נניח אילוץ AND שמערב את שערים {% equation %}5,3,1{% endequation %} ולבדוק אם {% equation %}\alpha_{5}=\alpha_{3}\alpha_{1}{% endequation %} - דבר שדורש קריאה של שלושה ביטים בלבד. אם כן - נניח שהכל בסדר ונגיד "כן", ואם לא, נדחה. הכוח שלנו נובע מכך שכל אחד מהאילוצים עלול להיות מוגרל, ולכן מי שמספק לנו את ההוכחה לא יכול לרמות באף אחד מהם.האמנם?

ובכן, לא. מי שמספק לנו את ההוכחה יכול לרמות בשער בודד - שער AND אחד שמקבל 0 ו-1 אבל מחזיר 1 יכול לגרום למעגל להסתפק, למרות שאם לא מרמים אין שום השמה שתספק אותו. כמובן, ייתכן שנגריל את השער הזה; אבל אם יש הרבה שערים, ההסתברות לכך היא נמוכה יחסית, ואילו אנחנו רוצים הסתברות לגילוי שקר שאינה תלויה בכלל בגודל המעגל הנבדק. לכן אנחנו שוב בבעיה. פתרון אחד הוא לדגום הרבה שערים - אבל זה יכריח אותנו שוב לקרוא הרבה ביטים מההוכחה ולא הרווחנו כלום. צריך לעשות כאן משהו חכם יותר.

היינו רוצים, אם זה אפשרי, לבדוק את כל השערים במעגל "בו זמנית", על ידי דגימה של מספר זעום של ביטים - יודעים מה? ביט בודד. זה לא אפשרי באופן ישיר, אבל כן אפשר לעשות זאת "בערך".

בואו נלך עוד צעד אחד קדימה בדרך לפישוט הבעיה שלנו. לכל אילוץ אפשרי נגדיר משתנה {% equation %}\phi_{i}{% endequation %}, שמקבל את הערך 0 אם האילוץ מסופק ואת הערך 1 אם הוא מופר. למשל, {% equation %}\phi_{t}=1+\alpha_{t}{% endequation %}; ואם {% equation %}i{% endequation %} הוא שער AND אז {% equation %}\phi_{i}=\alpha_{i}+\alpha_{j}\alpha_{k}{% endequation %}; ואם {% equation %}i{% endequation %} הוא שאר NOT אז {% equation %}\phi_{i}=\alpha_{i}+\alpha_{j}+1{% endequation %}. כעת, מהו הסכום {% equation %}\sum\phi_{i}{% endequation %} (מודולו 2)? אם כל האילוצים מסופקים, יש לנו סכום של אפסים, ולכן הסכום יהיה אפס; ואילו אם אילוץ אחד לפחות מופר, הסכום יהיה שונה מאפס... רגע, אופס, לא. בגלל שהסכום הוא מודולו 2, אז הסכום יהיה שונה מאפס אם מספר <strong>אי זוגי</strong> של אילוצים מופר, אבל יהיה עדיין אפס אם מספר <strong>זוגי</strong> של אילוצים מופר.

אז בואו נשכלל עוד יותר את הבדיקה. במקום לסכום את <strong>כל</strong> האילוצים, מה שנעשה יהיה להגריל תת קבוצה של אילוצים; עבור כל אילוץ נטיל מטבע, ובהסתברות של {% equation %}\frac{1}{2}{% endequation %} נוסיף אותו לסכום. כלומר, בסופו של דבר נחשב צירוף לינארי {% equation %}\sum a_{i}\phi_{i}{% endequation %}, כאשר {% equation %}a_{i}{% endequation %} שווה או לאפס (בהסתברות חצי) או לאחד (בהסתברות חצי). אם אף אילוץ לא מופר, הסכום של כל צירוף לינארי שכזה יהיה 0; אם לפחות אילוץ אחד מופר, כמה מהצירופים הללו יהיו שווים ל-1?

כאן נכנס לתמונה תעלול נפוץ בניתוח של סיטואציות מעין אלו. הבה ניקח אילוץ ספציפי אחד שמופר, {% equation %}\phi_{j}=1{% endequation %}, ו"נקפיא" אותו. כעת, אפשר לחלק את כל הצירופים הלינאריים האפשריים לשני סוגים - כאלו שבהן {% equation %}a_{j}=0{% endequation %}, וכאלו שבהם {% equation %}a_{j}=1{% endequation %}. הבה וניקח צירוף לינארי שכזה שבו {% equation %}a_{j}=0{% endequation %}, כלומר {% equation %}\phi_{j}{% endequation %} לא משתתף בו. אם סכומו של הצירוף הזה הוא 0, אז ערכו של הצירוף שזהה לו בכל פרט לכך ש-{% equation %}a_{j}=1{% endequation %} יהיה 1 (שכן הוספנו לצירוף הזה, שקודם ערכו היה 0, את הערך {% equation %}\phi_{j}{% endequation %} שהוא 1). בדומה, אם סכומו של הצירוף היה 1, אחרי שנשנה את {% equation %}a_{j}{% endequation %} ל-1 נקבל 0.

מה זה בעצם אומר? שאפשר לפרק את קבוצת כל הצירופים הלינאריים לאוסף של זוגות, כך שבכל זוג בדיוק אחד משני הצירופים נותן 1, והצירוף השני נותן 0. מסקנה: אם ולו אילוץ אחד מופר, הרי ש<strong>בדיוק חצי</strong> מהצירופים האפשריים נותן 1. לכן אם באמת נגריל את הצירופים באופן שתיארתי לעיל (כל אילוץ נבחר בהסתברות חצי) תהיה לנו הסתברות חצי לגלות שעבדו עלינו, בלי תלות בגודל המעגל. אאורקה!

כל זה טוב ויפה, אבל עדיין לא הסברתי <strong>איך</strong> אפשר, אחרי שכבר הגרלתי צירוף לינארי מסויים {% equation %}\sum a_{i}\phi_{i}{% endequation %}, לחשב את ערכו על ידי קריאה של ביט אחד בלבד. לשם כך צריך להיזכר מהם {% equation %}\phi_{i}{% endequation %} השונים. בואו נשכח לרגע מכך ש-{% equation %}\phi_{i}{% endequation %} יכול להכיל דברים שנראים כמו {% equation %}\alpha_{j}\alpha_{k}{% endequation %} (כלומר, מכפלה של שתי {% equation %}\alpha{% endequation %}-ות) ונדמיין, אם כן, שכל צירוף {% equation %}\sum a_{i}\phi_{i}{% endequation %} ניתן לתיאור באמצעות צירוף מהצורה {% equation %}\sum b_{i}\alpha_{i}+b{% endequation %} כש-{% equation %}b{% endequation %} הוא קבוע. כלומר, כדי לחשב את {% equation %}\sum a_{i}\phi_{i}{% endequation %} מספיק להיות מסוגלים לחשב את {% equation %}\sum b_{i}\alpha_{i}{% endequation %} - לחשב צירוף לינארי של ה-{% equation %}\alpha{% endequation %}-ות ששייכות להוכחה שקיבלנו. לרוע המזל, נראה שלא הרווחנו כלום - כדי לחשב צירוף כזה צריך לקרוא במפורש את כל ה-{% equation %}\alpha_{i}{% endequation %}-ות שעבורן {% equation %}b_{i}\ne0{% endequation %}, אז מה יצא לנו מזה?

כאן נכנס לתמונה קוד הדמר שתיארתי בפוסט הקודם. כזכור, קוד הדמר של מילה היה מורכב מכל הצירופים הלינאריים האפשריים של הביטים במילה. אם כן, אם מישהו נותן לנו בתור הוכחה לא את ה-{% equation %}\alpha_{i}{% endequation %} אלא את קידוד הדמר שלהן - ניצחנו, כי אז כדי לחשב את {% equation %}\sum b_{i}\alpha_{i}{% endequation %} די בדגימת הביט הבודד מתוך קוד הדמר שמכיל את הצירוף הלינארי הזה. אם כן, האם סיימנו?

התשובה היא שכמובן שלא. אם בא מישהו ואומר "שמעו, {% equation %}C{% endequation %} ספיק, והנה הוכחה: הערכים של השערים של {% equation %}C{% endequation %} כשמזינים לו השמה מספקת, כשהם מקודדים בקוד הדמר" אין לי שום סיבה להאמין לו. אולי הוא סתם נתן לי ג'יבריש. אולי הוא נתן לי משהו שהונדס כדי לעבוד עלי. לכן אני צריך לוודא בראש ובראשונה שמה שקיבלתי הוא <strong>מילה חוקית בקוד הדמר</strong>. אם הצלחתי לוודא זאת, אפשר להשתמש בכך שזה קוד הדמר (ולכן כל ביט הוא צירוף לינארי) כדי לוודא שזו לא סתם מילה חוקית, אלא מילה שמתארת את ערכי השערים של {% equation %}C{% endequation %} בהשמה מספקת (על ידי הבדיקה שתיארתי קודם).

ובכן, איך מוודאים שמה שקיבלתי הוא מילה חוקית בקוד הדמר? אפשר לקרוא את כל הביטים בקוד, אבל זה שוב יגרום לנו לקרוא יותר מדי ביטים. לחילופין, אפשר להשתמש במה שראינו את קיומו בפוסט הקודם - בודק מקומי עבור קוד הדמר. הבודק הזה צריך לקרוא מספר קבוע וקטן של ביטים כדי להכריע אם המילה שהוא קיבל לכל הפחות קרובה מאוד להיות מילה בקוד הדמר. אין לנו בטחון גמור שהמילה היא אכן מילה חוקית בקוד הדמר, כי אולי חלק קטן מהביטים במילה שגויים; אבל אם יש רק מספר מועט של ביטים שגויים, גם הסיכוי שנדגום אותם בזמן שנערוך את המבחן שתיארתי לעיל (חישוב {% equation %}\sum b_{i}\alpha_{i}{% endequation %}) הוא נמוך, ולכן רוב הסיכויים הם שהמבחן שלי יצליח.

נסכם: לקחנו את הבעיה של הוכחה ש-{% equation %}w\in L{% endequation %} וצמצמנו אותה לבעיה של הוכחה שמעגל {% equation %}C{% endequation %} כלשהו ספיק. ה"הוכחה" לכך היא תיאור של השמה מספקת ל-{% equation %}C{% endequation %} והערכים ששערי {% equation %}C{% endequation %} מקבלים כשמזינים אותה אליו, כשכל זה מקודד בקוד הדמר. בהינתן ההוכחה הזו, אנחנו:
<ol>
	<li> בודקים שההוכחה היא אכן מילה שמקודדת בקוד הדמר (או לכל הפחות, הרוב המוחץ של הביטים בה מתנהגים על פי החוקיות הזו). הבדיקה הזו דורשת קריאת מספר קטן וקבוע של ביטים, וההסתברות לטעות במקרה שעובדים עלינו היא קבועה.</li>
	<li> בודקים שההוכחה אכן מתארת התנהגות חוקית של {% equation %}C{% endequation %}, כלומר שכל האילוצים שלו מסתפקים. לבדיקה הזו נדרשת קריאת ביט בודד, וההסתברות לטעות במקרה שעובדים עלינו היא קבועה (חצי).</li>
	<li> אפשר לחזור על התהליך עוד כמה פעמים ולהקטין כרצוננו את ההסתברות לטעות - המחיר יהיה הגדלה של מספר הביטים הנקראים, אך הוא עדיין יהיה קבוע.</li>
</ol>
סוף דבר.או שלא. הסתרתי כאן עוד קושי טכני מרגיז - ה-{% equation %}\phi_{i}{% endequation %} יכול להכיל גם איברים מהצורה {% equation %}\alpha_{i}\alpha_{j}{% endequation %}, כלומר ב"צירוף הלינארי" שעלינו לחשב עשויים להופיע גם איברים מהצורה {% equation %}b\alpha_{i}\alpha_{j}{% endequation %}, מה שאומר שזה בכלל לא צירוף לינארי אלא צירוף "ריבועי". איך פותרים את זה? ובכן, זה טכני, ולא משנה שום דבר מהותי ברעיונות של ההוכחה, ולכן לא אתעמק בכך; הרעיון הוא להגדיר משתנים חדשים, {% equation %}\beta_{ij}=\alpha_{i}\alpha_{j}{% endequation %}, ואז לדבר על צירופים לינאריים של ה-{% equation %}\beta{% endequation %}-ות הללו. זה מגדיל עוד קצת את מספר הבדיקות שעלינו לעשות, אך הוא עדיין יהיה קבוע.

אם כן, זה סוף הסיפור, וזו ה"הוכחה" הבסיסית ביותר שאני מכיר למשפט ה-PCP. אני מקווה שכעת הוודו נראה קצת פחות מטורף. עם זאת, זו רחוקה מלהיות ההוכחה ה<strong>טובה</strong> ביותר של המשפט - יש הוכחות לגרסאות חזקות יותר מזו שהצגתי כאן (בפרט, עם הוכחה שאינה בגודל אסטרונומי כמו הוכחה שמקודדת בקידוד הדמר). אולי אציג אותן בעתיד.
