---
id: 3230
title: "אז מה הקשר בין דקדוקים חסרי הקשר ופונקציות יוצרות?"
date: 2015-03-15 16:05:17
layout: post
categories: 
  - קומבינטוריקה
  - תורת הסיבוכיות
tags: 
  - דקדוקים חסרי הקשר
  - פונקציות יוצרות
  - שפות חסרות הקשר
---
תכירו - מסלולי מוצקין. <strong>מסלול מוצקין</strong> מאורך {% equation %}n{% endequation %} הוא מסלול ב-{% equation %}\mathbb{Z}^{2}{% endequation %} שמתחיל ב-{% equation %}\left(0,0\right){% endequation %} ומסתיים ב-{% equation %}\left(n,0\right){% endequation %} ומורכב משלושה סוגים אפשריים של צעדים: ימינה, למעלה-ימינה ולמטה-ימינה. כלומר, אנחנו כרגע ב-{% equation %}\left(x,y\right){% endequation %} אז אנחנו יכולים לעבור אל {% equation %}\left(x+1,y+\delta\right){% endequation %} כאשר {% equation %}\delta\in\left\{ -1,0,1\right\} {% endequation %}. והנה העלילה מסתבכת: אסור למסלול לרדת מתחת לציר {% equation %}x{% endequation %}, דהיינו אם אנחנו ב-{% equation %}\left(x,0\right){% endequation %} אסור לנו לבצע צעד ימינה-למטה. אין עוד מגבלות, פרט למגבלה שאנחנו חייבים לסיים ב-{% equation %}\left(n,0\right){% endequation %}.

בואו ניתן שמות לצעדים האפשריים: לימינה-למעלה אקרא U, לימינה למטה אקרא D ולסתם ימינה אקרא S (מלשון Up, Down, Stay שמתארים מה קורה מבחינת הגובה של המסלול). אם כן, מסלול מוצקין הוא סדרה מאורך {% equation %}n{% endequation %} של התווים U,D,S שגם מקיימים עוד כמה כללים - כלומר, זו <strong>שפה פורמלית</strong> מעל הא"ב {% equation %}\Sigma=\left\{ \text{U, D, S}\right\} {% endequation %}. כך שאם לשניה פחדתם שאתם בפוסט הלא נכון - לא לדאוג, אנחנו עדיין מדברים על שפות פורמליות פה. ספציפית, על שפות חסרות הקשר, כי אני רוצה לטעון ששפת כל מסלולי מוצקין החוקיים היא שפה חסרת הקשר.

בואו נראה דוגמה למסלולים מאורך 3, חוקיים ולא חוקיים: מסלול חוקי פשוט הוא SSS שלא עולה למעלה ולא יורד למטה. עוד מסלול חוקי הוא USD שעולה, נשאר רגע למעלה ואז יורד. גם UDS (עולה, יורד, נשאר) הוא חוקי. לעומת זאת, USS לא חוקי כי הוא מסיים ב-{% equation %}\left(3,1\right){% endequation %}; ו-DUS לא חוקי כי אחרי הצעד הראשון הוא יורד אל {% equation %}\left(1,-1\right){% endequation %}; ו-UUD גם כן לא חוקי כי הוא מסיים שוב ב-{% equation %}\left(3,1\right){% endequation %}. כבר מתעוררת מאליה השאלה - האם שפת מסלולי המוצקין היא שפה <strong>רגולרית</strong>? קל לראות שלא, כי היא בעצם כוללת בתוכה את {% equation %}\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} {% endequation %} בתור מין מקרה פרטי. פורמלית, קחו את כל המילים מהצורה {% equation %}\text{U}^{n}{% endequation %}; עבור כל זוג מילים כאלו, {% equation %}\text{U}^{k},\text{U}^{t}{% endequation %} כך ש-{% equation %}k\ne t{% endequation %} קל לראות ש-{% equation %}\text{U}^{k}\text{D}^{k}{% endequation %} מגדירה מסלול מוצקין חוקי אבל {% equation %}\text{U}^{t}\text{D}^{k}{% endequation %} לא, כך ש-{% equation %}\text{D}^{k}{% endequation %} היא מה שקראתי לו <strong>מילה מפרידה</strong> בפוסט על משפט נרוד, שמוכיח שהשפה של מסלולי מוצקין אינה רגולרית.

כדי לראות שהשפה כן חסרת הקשר, אציג דקדוק שמייצר אותה. הדקדוק יהיה פשוט למדי - רק משתנה התחלתי בודד, {% equation %}A{% endequation %}, ועוד הטרמינלים שלנו U,S,D (בדרך כלל טרמינלים הם באותיות קטנות אבל כאן זה יהיה שונה, ולכן גם בחרתי לסמן את המשתנה ההתחלתי ב-{% equation %}A{% endequation %} ולא ב-{% equation %}S{% endequation %} כרגיל). כדי להבין מה יהיו כללי הגזירה, בואו ננסה להבין איך מסלול מוצקין בנוי. ראשית, נסכים שמסלול "ריק" הוא מסלול מוצקין חוקי, ולכן יהיה לנו את כלל הגזירה {% equation %}A\to\varepsilon{% endequation %} (אם לא מסכימים שמסלול ריק הוא חוקי השיקולים בהמשך יעבדו אבל יהיו מסורבלים יותר וזה לא יהיה כיף).

בואו ניקח מסלול מוצקין כלשהו מאורך {% equation %}n{% endequation %}. האות הראשונה לא יכולה להיות {% equation %}\text{D}{% endequation %} כי זה יוריד את המסלול אל {% equation %}\left(1,-1\right){% endequation %}. לכן יש שתי אפשרויות. באפשרות הראשונה, המסלול מתחיל ב-{% equation %}\text{S}{% endequation %}. אם מנתקים את ה-{% equation %}\text{S}{% endequation %} הזו מהמשך המסלול, המילה מאורך {% equation %}n-1{% endequation %} שנקבל תתאר מסלול מ-{% equation %}\left(1,0\right){% endequation %} אל {% equation %}\left(n,0\right){% endequation %} שמקיים את החוקיות של מסלולי מוצקין - דהיינו, היא תהווה מסלול מוצקין חוקי בעצמה. אז הנה כלל גזירה שמתאים לסיטואציה הזו: {% equation %}A\to\text{S}A{% endequation %}.

הסיטואציה האפשרית השניה היא זו שבה המסלול מתחיל ב-{% equation %}\text{U}{% endequation %}. כאן העסק קצת יותר טריקי. מכיוון שהמסלול הגיע אל {% equation %}\left(1,1\right){% endequation %} אחרי הצעד הראשון שלו, והוא מסיים ב-{% equation %}\left(n,0\right){% endequation %}, חייב להיות צעד כלשהו במסלול (אולי האחרון) שבו יורדים לראשונה לגובה 0. הצעד הזה הוא כמובן D כי שאר הצעדים לא מורידים אותנו. בואו נסמן את המקום שבו הגענו לגובה 0 בתור {% equation %}\left(k,0\right){% endequation %}. עכשיו, ראשית כל שימו לב לכך שהחל מ-{% equation %}\left(k,0\right){% endequation %} ועד ל-{% equation %}\left(n,0\right){% endequation %} יש לנו עוד מסלול מוצקין, מאורך {% equation %}n-k{% endequation %} (אולי מאורך 0). וכמו כן, מה קורה <strong>בין</strong> צעד ה-U בהתחלה וצעד ה-D שמוריד אותנו ל-{% equation %}\left(k,0\right){% endequation %}? יש לנו מסלול שמתחיל מ-{% equation %}\left(1,1\right){% endequation %} ומסתיים ב-{% equation %}\left(k-1,1\right){% endequation %} (המקום שאליו הגענו צעד לפני ה-D). יתר על כן - המסלול הזה לא יורד מתחת לגובה 1, מכיוון ש-{% equation %}\left(k,0\right){% endequation %} הוא המקום הראשון שבו חזרנו לגובה 0 אחרי ההתחלה. מסקנה: המסלול מ-{% equation %}\left(1,1\right){% endequation %} עד ל-{% equation %}\left(k-1,1\right){% endequation %} הוא גם כן מסלול מוצקין חוקי, מאורך {% equation %}k-2{% endequation %}. זה מוביל אותנו אל כלל הגזירה הבא: {% equation %}A\to\text{U}A\text{D}A{% endequation %}. האם ברור לכם למה הוא נכון?

כלומר, הדקדוק המלא שמייצר את כל מסלולי מוצקין האפשריים הוא {% equation %}A\to\text{U}A\text{D}A|\text{S}A|\varepsilon{% endequation %}. הנה למשל גזירה פשוטה עבור USD: {% equation %}A\Rightarrow\text{U}A\text{D}A\Rightarrow\text{U}\text{S}A\text{D}A\Rightarrow\text{USD}A\Rightarrow\text{USD}{% endequation %}.

מה שנחמד בדוגמה הזו הוא שסוף סוף אנחנו רואים שפה פורמלית שבאמת מייצגת משהו "אמיתי" - ועוד כזה שלאו דווקא חושבים עליו מלכתחילה בהקשר של שפות פורמליות. באופן דוגמה הרבה אובייקטים קומבינטוריים ניתן לייצג באמצעות מילים מעל א"ב סופי, ואז אובייקט כמו אוטומט או דקדוק עבור השפה עוזר לנו להבין את המבנה שלה. בפרט, אני לא מכיר תיאור יותר פשוט למסלולי מוצקין מאשר הדקדוק שנתתי.

עכשיו, מכיוון שמסלולי מוצקין הם אובייקט קומבינטורי, אפשר לשאול עליהם שאלות קומבינטוריות. השאלה הראשונה על אובייקטים מסוג זה היא "כמה מסלולים מאורך {% equation %}n{% endequation %} קיימים?". התקווה היא תמיד שתהיה לנו נוסחה סגורה פשוטה, אבל בעולם האמיתי דברים כאלו לא קורים - לרוב האובייקטים הקומבינטוריים הלא טריוויאליים אין נוסחה פשוטה שמתארת את מספרם. אז מסתפקים בשיטות ייצוג עקיפות יותר, כששיטת הייצוג המקובלת ביותר היא <strong>פונקציה יוצרת</strong>. פונקציה יוצרת היא אובייקט מאוד מוזר במבט ראשון: אם יש לנו {% equation %}a_{n}{% endequation %} אובייקטים מגודל {% equation %}n{% endequation %}, ולכן יש לנו סדרה אינסופית {% equation %}a_{0},a_{1},a_{2},\dots{% endequation %} של מספר האובייקטים מכל גודל, אז הפונקציה היוצרת שלהם היא הטור הפורמלי {% equation %}\sum a_{n}x^{n}{% endequation %}. לפעמים אפשר למצוא לטור הזה ייצוגים סימבוליים פשוטים יותר (למשל, {% equation %}f\left(x\right)=\frac{1}{1-x}{% endequation %} הוא ייצוג סימבולי פשוט של הטור {% equation %}\sum x^{n}{% endequation %} שמתאים לסדרה {% equation %}1,1,1,\dots{% endequation %}) ואפשר להיעזר בייצוגים הסימבוליים הללו כדי להפיק מידע על הסדרה - למשל, קצב הגידול שלה - וכדי למצוא פונקציות יוצרות לסדרות נוספות שמתכתבות איכשהו עם הסדרה המקורית.

על כל זה יש לי כבר <a href="http://www.gadial.net/2009/09/08/generating_functions/">פוסט</a>, ומסלולי מוצקין מופיעים שם בתור דוגמה - ולא במקרה, אני מאוד אוהב את מסלולי מוצקין. בפוסטים פיתחתי במפורש את הפונקציה היוצרת שלהם, ועכשיו אחזור על אותו פיתוח, אבל בניסוח טיפה שונה - ניסוח באמצעות הכלי של הדקדוקים שלא השתמשתי בו בפוסט ההוא. אין לכם ממש צורך לקרוא את הפוסט ההוא, אבל אם המושג של פונקציות יוצרות עדיין נשמע לכם מוזר או לא הגיוני או הזוי או מה זה פה תפסיק לרמות אותנו (ואם אין לכם היכרות סבירה עם פונקציות יוצרות אתם <strong>אמורים </strong>לחשוב ככה)<strong> </strong>- יש לי גם <a href="http://www.gadial.net/2011/08/07/generating_functions_hardcore_1/">פוסטים</a> שמציגים את התורה של פונקציות יוצרות יותר לעומק, ובתקווה ישכנעו אתכם.

הנה כמה עובדות שכן יהיו רלוונטיות לנו. אם {% equation %}f\left(x\right),g\left(x\right){% endequation %} הן פונקציות יוצרות שמתאימות לסדרות {% equation %}a_{n},b_{n}{% endequation %} אז הפונקציה {% equation %}f\left(x\right)+g\left(x\right){% endequation %} מתאימה לסדרה {% equation %}a_{n}+b_{n}{% endequation %}. כמו כן, {% equation %}xf\left(x\right){% endequation %} מתאימה לסדרה שמתקבלת מ-{% equation %}a_{n}{% endequation %} אחרי "הזזה" ימינה של כל האיברים ודחיפת 0 בהתחלה - פורמלית, {% equation %}c_{n}=a_{n-1}{% endequation %} כאשר {% equation %}c_{0}=0{% endequation %}. כמו כן, {% equation %}f\left(x\right)g\left(x\right){% endequation %} מתאימה לסדרה {% equation %}c_{n}=\sum_{k=0}^{n}a_{k}b_{n-k}{% endequation %}, שמתארת את מספר האפשרויות לבנות אובייקט מגודל {% equation %}n{% endequation %} מתוך זוג של אובייקט מגודל {% equation %}k{% endequation %} מתוך הסדרה הראשונה ואובייקט מגודל {% equation %}n-k{% endequation %} מתוך הסדרה השניה, עבור כל {% equation %}0\le k\le n{% endequation %}.

עכשיו, בואו ניקח את הדקדוק {% equation %}A\to\text{U}A\text{D}A|\text{S}A|\varepsilon{% endequation %}. מה שצריך להבין הוא שהדקדוק הזה בעצם מתאר לנו <strong>משוואה</strong>: אם נסמן ב-{% equation %}L_{A}{% endequation %} את השפה שנוצרת על ידי המשתנה {% equation %}A{% endequation %}, אז הדקדוק אומר שמתקיים השוויון

{% equation %}L_{A}=\left\{ \text{U}\right\} \cdot L_{A}\cdot\left\{ \text{D}\right\} \cdot L_{A}\cup\left\{ \text{S}\right\} \cdot L_{A}\cup\left\{ \varepsilon\right\} {% endequation %}

אני רוצה להפוך את המשוואה הזו למשוואה עבור פונקציות יוצרות. נסמן ב-{% equation %}f_{A}\left(x\right){% endequation %} את הפונקציה היוצרת של הסדרה {% equation %}a_{n}=\left|\left\{ w\in L_{A}\ |\ \left|w\right|=n\right\} \right|{% endequation %}. באופן דומה אפשר להגדיר פונקציה יוצרת לכל שפה שהיא. שימו לב גם לכך שהפונקציה היוצרת שמתאימה לשפה {% equation %}\left\{ \varepsilon\right\} {% endequation %} היא 1 (כי יש לנו אובייקט אחד מגודל 0 בשפה, ו-0 אובייקטים מכל גודל אחר) והפונקציה היוצרת שמתאימה ל-{% equation %}\left\{ \text{U}\right\} {% endequation %} היא {% equation %}x{% endequation %} (אובייקט אחד מגודל 1 ו-0 מכל גודל אחר) וכך גם עבור {% equation %}\left\{ \text{S}\right\} {% endequation %} ו-{% equation %}\left\{ \text{D}\right\} {% endequation %}.

עכשיו, נניח שיש לי שלוש שפות, {% equation %}L_{A}=L_{B}\cup L_{C}{% endequation %}, כך ש-{% equation %}L_{B}\cap L_{C}=\emptyset{% endequation %} עם פונקציות יוצרות מתאימות {% equation %}f_{A},f_{B},f_{C}{% endequation %}. אני טוען ש-{% equation %}f_{A}=f_{B}+f_{C}{% endequation %} מהסיבה שציינתי קודם (כי מספר האובייקטים מגודל {% equation %}n{% endequation %} ב-{% equation %}L_{A}{% endequation %} הוא בדיוק סכום מספרי האובייקטים מגודל זה ב-{% equation %}L_{B},L_{C}{% endequation %}). קצת יותר טריקי לראות שאם {% equation %}L_{A}=L_{B}\cdot L_{C}{% endequation %} אז {% equation %}f_{A}=f_{B}\cdot f_{C}{% endequation %}, אבל גם זה נובע ממה שאמרתי קודם (חשבו על זה קצת אם אתם לא משוכנעים). השתכנעתם בשני אלו? יופי, אז בואו נחזור למשוואה שלנו:

{% equation %}L_{A}=\left\{ \text{U}\right\} \cdot L_{A}\cdot\left\{ \text{D}\right\} \cdot L_{A}\cup\left\{ \text{S}\right\} \cdot L_{A}\cup\left\{ \varepsilon\right\} {% endequation %}

אם נתרגם אותה לפונקציות יוצרות ונשתמש בכללים שקיבלנו, הרי שנקבל

{% equation %}f_{A}=x\cdot f_{A}\cdot x\cdot f_{A}+x\cdot f_{A}+1=x^{2}f_{A}^{2}+xf_{A}+1{% endequation %}

אחרי העברת אגפים נקבל <strong>משוואה ממעלה שניה</strong>: {% equation %}x^{2}f_{A}^{2}+\left(x-1\right)f_{A}+1=0{% endequation %}. אפשר "לפתור" את המשוואה עם נוסחת השורשים הרגילה (כמובן, צריך להצדיק את זה, אבל אני לא אעשה את זה כאן) ולקבל את הפתרון

{% equation %}f_{A}=\frac{1-x-\sqrt{\left(x-1\right)^{2}-4x^{2}}}{2x^{2}}=\frac{1-x-\sqrt{1-2x-3x^{2}}}{2x^{2}}{% endequation %}

נוסחת השורשים מניבה שני פתרונות, וכאן לקחתי רק אחד - זה לא פוסט על קומבינטוריקה אז לא אסביר את השיקולים שבגללם יודעים שהפתרון שלקחתי הוא הנכון; זה מופיע בפוסט על פונקציות יוצרות ומסלולי מוצקין שקישרתי אליו. כאן מסלולי מוצקין מופיעים רק בתור דוגמה. הפואנטה היא שונה לחלוטין: התהליך שבו קיבלתי את הפונקציה היוצרת של {% equation %}L_{A}{% endequation %} היה כמעט <strong>מכני:</strong> בהינתן הדקדוק שמייצר את {% equation %}L_{A}{% endequation %}, קיבלתי ממנו באופן <strong>אוטומטי לגמרי</strong> משוואה עבור {% equation %}f_{A}{% endequation %}. כדי לחלץ ממנה את {% equation %}f_{A}{% endequation %} השתמשתי בידע כללי שיש לי על פתרון משוואות פונקציונליות שכאלו; לא תמיד אפשר לפתור את המשוואה בצורה נחמדה שכזו, אבל לפעמים כבר מערכת המשוואות עצמה היא מועילה.

בואו נראה עוד דוגמאות כדי להבין עד כמה חזק הכלי שכרגע קיבלנו. נתחיל מ-{% equation %}L=\left\{ a^{n}b^{n}\ |\ n\ge0\right\} {% endequation %} ידידתנו משכבר הימים. זו שפה שלכל {% equation %}n{% endequation %} זוגי יש בה בדיוק מילה אחת מאורך זה, ולכל {% equation %}n{% endequation %} אי זוגי יש בה 0 איברים מאורך זה. הפונקציה היוצרת באה מאליה: הדקדוק הוא {% equation %}S\to aSb|\varepsilon{% endequation %} ולכן המשוואה היא {% equation %}f=x^{2}f+1{% endequation %}, ואחרי חילוץ נקבל {% equation %}f=\frac{1}{1-x^{2}}=\sum x^{2n}{% endequation %} - בדיוק מה שהיינו אמורים לקבל. כמובן, זו בכל מקרה שפה פשוטה כי "קל לראות" מההגדרה שלה את העניין הזה של הזוגיים והאי זוגיים, אבל צריך להבין שאם השפה הזו נתונה למחשב, אז הייצוג שהמחשב הולך לקבל ככל הנראה יהיה הדקדוק, כי <strong>זה הייצוג הכי פשוט של השפה</strong>, ומהייצוג הזה הוא יכול להסיק את הפונקציה היוצרת (ובמקרה הזה, את מספר האיברים המפורש לכל {% equation %}n{% endequation %}) בקלות.

עוד דוגמה - <strong>מספרי קטלן</strong>. סדרת המספרים הזו היא פתרון לשלל בעיות ספירה מעניינות שלא נראות קשורות במבט ראשון. אציג כאן שתיים מהן - ראשית, מספר קטלן {% equation %}C_{n}{% endequation %} הוא מספר הסדרות מאורך {% equation %}2n{% endequation %} שמורכבות מסוגריים ימניים ושמאליים, כך שסדרת הסוגריים היא "חוקית" - מה שאומר שאם קוראים את המילה משמאל לימין אין רגע שבו מספר הסוגריים השמאליים גדול ממספר הסוגריים הימניים, ושבסוף המילה מספר הסוגריים משני הסוגים מתאזן. תחשבו על זה שניה ותבינו למה זה בדיוק אותו דבר כמו מספר המסלולים מ-{% equation %}\left(0,0\right){% endequation %} אל {% equation %}\left(2n,0\right){% endequation %} עם צעדי U ו-D אבל בלי צעדי S הפעם, כך שלא יורדים מתחת לציר {% equation %}x{% endequation %} (כלומר - זה דומה למסלולי מוצקין אבל זה לא באמת אותו דבר). דקדוק עבור השפה הזו נובע כמעט מאליו: {% equation %}A\to\text{U}A\text{D}A|\varepsilon{% endequation %}. ומכאן המשוואה {% equation %}f=x^{2}f^{2}+1{% endequation %} והפונקציה היוצרת {% equation %}f\left(x\right)=\frac{1-\sqrt{1-4x^{2}}}{2x^{2}}{% endequation %}. אבל רגע, זהירות, זו לא הפונקציה היוצרת של מספרי קטלן, כי {% equation %}C_{n}{% endequation %} מיוצג על ידי סדרה מאורך {% equation %}2n{% endequation %}. כדי לפתור את הבעיה הזו, אנחנו "מוציאים שורש". פורמלית, אם {% equation %}f\left(x\right)=\sum_{n=0}^{\infty}a_{2n}x^{2n}{% endequation %} (כלומר, מספר האיברים מגודל אי זוגי הוא תמיד אפס), אז אפשר להגדיר סדרה חדשה {% equation %}c_{n}=a_{2n}{% endequation %} עם פונקציה יוצרת {% equation %}g\left(x\right)=\sum c_{n}x^{n}{% endequation %} ונקבל ש-{% equation %}g\left(x^{2}\right)=f\left(x\right){% endequation %}. לכן אם {% equation %}g\left(x^{2}\right)=\frac{1-\sqrt{1-4x^{2}}}{2x^{2}}{% endequation %} קיבלנו שהפונקציה היוצרת של מספרי קטלן היא {% equation %}g\left(x\right)=\frac{1-\sqrt{1-4x}}{2x}{% endequation %} (לא הבנתם את התעלולים הללו? לא נורא, זו לא מטרת הפוסט).

עכשיו, אחרי שנהנינו קצת, הגיע הזמן לחשוף את האמת המכוערת - אני קצת משקר לכם. בואו ניקח דקדוק אחר עבור {% equation %}\left\{ a^{n}b^{n}\ |\ n\in\mathbb{N}\right\} {% endequation %} כדי לראות את זה: {% equation %}S\to aSb|aaSbb|\varepsilon{% endequation %}. מה עשינו כאן? כמעט שום דבר - פשוט אפשרנו ל-{% equation %}S{% endequation %} לקצר עניינים וליצור יותר תווים בגזירה אחת. זה הופך את הדקדוק שלנו ל<strong>רב משמעי</strong>, כי הנה למשל שתי גזירות שונות מהותית של {% equation %}aabb{% endequation %}: {% equation %}S\Rightarrow aaSbb\Rightarrow aabb{% endequation %} ו-{% equation %}S\Rightarrow aSb\Rightarrow aaSbb\Rightarrow aabb{% endequation %}.

אם ננסה להפעיל את השיטה שראינו על הדקדוק הזה, נקבל כמובן {% equation %}f=1+x^{2}f+x^{4}f{% endequation %} שמוביל אותנו אל {% equation %}f=\frac{1}{1-x^{2}-x^{4}}{% endequation %} - וזו פונקציה שונה מ-{% equation %}\frac{1}{1-x^{2}}{% endequation %}. מה קרה? ההנחה הסמויה שלי הייתה שהדקדוק שלי הוא חד משמעי. אחרת, משוואה כמו {% equation %}L=aLb\cup aaLbb\cup\left\{ \varepsilon\right\} {% endequation %} כבר לא ניתנת לתרגום ישיר לפונקציות יוצרות כי האיחוד הראשון בה איננו איחוד זר. אני לא אוכיח כאן שאם הדקדוק חד משמעי אז לא יכולה להיווצר בעיה עם השיטה, אבל זה נכון. כמובן, להוכיח שדקדוק הוא חד משמעי זה לאו דווקא טריוויאלי וזה מקטין את השימושיות של השיטה.

בואו נעבור עכשיו לדבר על שפות רגולריות. הסיבה שמלכתחילה תיארתי בבלוג פונקציות יוצרות הייתה כדי <a href="http://www.gadial.net/2009/09/10/automata_and_generating_functions/">להראות תוצאה</a> שאני מאוד מחבב - שאפשר למצוא את הפונקציה היוצרת עבור שפה רגולרית מתוך כל אוטומט עבור השפה. אני רוצה להראות עכשיו שהתוצאה הזו היא בעצם מקרה פרטי של מה שאנחנו עושים כאן.

בפוסט הקודם אמרתי שאם יש לנו אוטומט סופי דטרמיניסטי {% equation %}A{% endequation %}, אז אפשר לבנות דקדוק עבור השפה שלו. הרעיון היה להתאים משתנה דקדוקי לכל מצב של האוטומט, ואת הגזירה {% equation %}q\to\sigma p{% endequation %} אם באוטומט יש את המעבר {% equation %}\delta\left(q,\sigma\right)=p{% endequation %}. וכמו כן את הגזירה {% equation %}q\to\varepsilon{% endequation %} אם {% equation %}q\in F{% endequation %}. עכשיו, הדקדוק הזה הוא כן חד משמעי, וזה נובע מכך ש-{% equation %}A{% endequation %} דטרמיניסטי; אם אתם לא משוכנעים, נסו לחשוב איך ייראו שתי גזירות שונות לאותה מילה - קל לראות שברגע שבו הן מתחילות "להתנהג שונה" הן גם יהיו חייבות ליצור אותיות שונות, ולכן מילים שונות.

עכשיו, בדקדוק שלנו יש הרבה משתנים, ולכן אנחנו לא מקבלים משוואה אחת; אנחנו מקבלים <strong>מערכת משוואות</strong>. אבל משוואות פשוטות במיוחד - לינאריות: לכל מצב {% equation %}q{% endequation %} תהיה לנו משוואה מהצורה

{% equation %}f_{q}=\sum_{p}a_{p}^{q}xf_{p}+\delta_{q}{% endequation %}

כאשר {% equation %}a_{p}^{q}{% endequation %} הוא מספר המעברים מ-{% equation %}q{% endequation %} אל {% equation %}p{% endequation %} - פורמלית, {% equation %}a_{p}^{q}=\left|\left\{ \sigma\in\Sigma\ |\ \delta\left(q,\sigma\right)=p\right\} \right|{% endequation %}. כמו כן, {% equation %}\delta_{q}=\begin{cases}1 & q\in F\\0 & q\notin F\end{cases}{% endequation %}. למה המשוואה הזו נכונה? אין כאן שום דבר חדש, זו הפעלה של הכללים שכבר ראינו.

מה שיפה במשוואה הזו היא שמדובר על משוואה <strong>לינארית</strong> - אין ל-{% equation %}f{% endequation %}-ים חזקות גבוהות שם. זה מאפשר לנו להשתמש בעולם המושגים של האלגברה הלינארית: נגדיר מטריצה {% equation %}A{% endequation %} כך ש-{% equation %}A_{qp}=a_{p}^{q}{% endequation %} ונגדיר וקטורים {% equation %}\overline{f},\overline{\delta}{% endequation %} שמייצגים את ה-{% equation %}f_{q}{% endequation %} וה-{% equation %}\delta_{q}{% endequation %}-ים, וקיבלנו שאפשר לכתוב את מערכת המשוואות כולה במשוואה קומפקטית אחת:

{% equation %}\overline{f}=xA\cdot\overline{f}+\overline{\delta}{% endequation %}

ואחרי חילוץ של {% equation %}\overline{f}{% endequation %}:

{% equation %}\overline{f}=\left(I-xA\right)^{-1}\overline{\delta}{% endequation %}

זו נוסחה פרקטית שממנה אפשר (אם יש לכם כלי שיודע לבצע אלגברה של מטריצות שאבריהן הם פולינומים) לחלץ את הפונקציות היוצרות - כבר הראיתי אותה בפוסט המקורי שלי, אבל הנה אנחנו מקבלים אותה שוב בקלות, מתוך השיטה הכללית עבור דקדוקים.

אם כן, זו המחשה לאופן שבו דקדוקים הם דרך מעניינת ומועילה לתאר שפות; בפוסטים הבאים נמשיך לחקור את מחלקת השפות שאפשר לתאר באמצעותם.

