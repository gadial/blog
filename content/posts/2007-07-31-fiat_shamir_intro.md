---
id: 46
title: "שורש, ההוכחה (חלק א’)"
date: 2007-07-31 10:17:04
layout: post
categories: 
  - קריפטולוגיה
  - תורת המספרים
---
אם השעה היא 19:00 ושואלים אותנו מה תהיה השעה עוד שש שעות, אנו עונים שהיא תהיה 1:00. איך אנחנו יודעים? אנחנו מחברים 6 ל-19, מקבלים 25, ומחסרים 24 מהתוצאה, כי הרי בשעון, כל 24 שעות "מתחילים מהתחלה".

זו דוגמה ל<a href="http://he.wikipedia.org/wiki/%D7%97%D7%A9%D7%91%D7%95%D7%9F_%D7%9E%D7%95%D7%93%D7%95%D7%9C%D7%A8%D7%99">אריתמטיקה מודולרית</a> - במקרה הזה, אריתמטיקה מודולו 24. המשמעות היא פשוטה: האיברים שלנו הם מספרים שלמים בתחום מ-0 עד 23, ופעולות החשבון הבסיסיות (חיבור וכפל) מתבצעות כרגיל, פרט לכך שאחרי סיומן אנו מחלקים את התוצאה ב-24 ולוקחים רק את השארית. אלו מכם שיש להם נסיון בתכנות ודאי מכירים אופרטור שמצוי ברוב השפות הקיימות (ב-++C ושפות בעל תחביר דומה הוא "%") שמבצע פעולת חילוק-ולקיחת-שארית שכזו. כך למשל באריתמטיקת השעון שלנו מתקיים {% equation %}5\cdot 7=11{% endequation %} כי את התוצאה במספרים "רגילים", 35, אנו מחלקים ב-24 ולוקחים שארית. עוד מתקיים גם {% equation %}3\cdot 8=0{% endequation %}, כי כאן התוצאה היא 24, והשארית על כן היא 0.

כמובן, כל הניסוח ה"אלגוריתמי" הזה מרגיש לא פורמלי למדי, ויש הגדרות טובות יותר למבנה הזה, של מספרים מודולו n. הרעיון הבסיסי הוא לחשוב עליהם כעל מחלקות שקילות של המספרים השלמים, כשיחס השקילות הוא "ל-{% equation %}x{% endequation %} ול-{% equation %}y{% endequation %} אותה שארית בחלוקה ב-{% equation %}n{% endequation %}" - ובניסוח אפילו יותר מדוייק, {% equation %}n{% endequation %} מחלק את {% equation %}x-y{% endequation %}". לאחר מכן מוגדרות פעולות הכפל והחיבור על <strong>נציגים</strong> של מחלקות השקילות, ומתברר שהכל יוצא מוגדר היטב.

מה באשר לשאר פעולות החשבון הבסיסיות? חיסור לא מציב שום בעיה, כל עוד מוכנים לבצע מציאת שארית בצורה קצת שונה מזו שהמחשב עושה: כך למשל ה"שארית" של מינוס 2 באריתמטיקה מודולו 24 היא 22 דווקא (כי זה המספר היחיד בטווח מ-0 ועד 23 שהמרחק שלו ממינוס 2 הוא כפולה שלמה של 24). חילוק, לעומתו, זה סיפור שונה לגמרי.

ברור שחילוק "רגיל" לא עוזר לנו. כך למשל {% equation %}7/2=3.5{% endequation %} היא לא תוצאה קבילה, כי {% equation %}3.5{% endequation %} הוא לא מספר שלם בין 0 ל-23. לכן עלינו לשאול את עצמנו ראשית כל מה אנו רוצים.

חילוק, באופן כללי, הוא הפעולה ההפוכה לכפל. כלומר, {% equation %}a/b=x{% endequation %} פירושו שמתקיים {% equation %}b\cdot x=a{% endequation %}. תוצאת החלוקה של {% equation %}a{% endequation %} ב-{% equation %}b{% endequation %} היא המספר שכאשר כופלים אותו ב-{% equation %}b{% endequation %} מקבלים את {% equation %}a{% endequation %}. בפועל, קל להראות (נסו!) שמספר זה הוא בדיוק המספר אשר מתקבל כאשר כופלים את {% equation %}a{% endequation %} ב<strong>הופכי הכפלי</strong> של {% equation %}b{% endequation %} - כלומר, במספר {% equation %}t{% endequation %} כלשהו (אני נמנע בכוונה מהסימון המקובל) שעבורו מתקיים {% equation %}b\cdot t=1{% endequation %}.

כאן מתחילה הבעיה האמיתית. לא תמיד יש למספרים הופכי כפלי, והדוגמה הקלאסית היא 0: מכיוון ש-0 כפול כל מספר שבעולם שווה 0 (שוב, נסו להוכיח!), ברור שלא קיים מספר שכאשר כופלים אותו ב-0 מתקבל 1. לכן ל-0 אין הופכי כפלי - ובפרט, אין משמעות לחלוקה באפס בתור הפעולה ההפוכה לכפל (מסיבות של נוחיות, וכאשר עוסקים במבנים מתמטיים ספציפיים, לפעמים מגדירים את תוצאת החלוקה באפס, נניח להיות "אינסוף". בהגדרה הזו כבר מובלע הויתור על פירוש החלוקה הזו כפעולה הופכית לכפל - כדי לראות את הבעייתיות נסו לחשוב מה אמורה להיות תוצאת הכפלת אפס באינסוף).

כאשר עוסקים במספרים ממשיים, אפס הוא המספר הבעייתי היחידי. לעומת זאת, באריתמטיקה מודולו n, יכולים להיות מספרים בעייתיים נוספים. אפשר להראות (שוב, ללא קושי רב - נסו!) שכל זוג מספרים שונים מאפס המקיימים {% equation %}a\cdot b=0{% endequation %} (מספרים כאלו נקראים <strong>מחלקי אפס</strong>, וכבר הזכרתי אותם בעבר) אינם הפיכים. עם עוד קצת מאמץ אפשר לראות שמספר שהוא זר ל-{% equation %}n{% endequation %} (כלומר, אין מספר פרט ל-1 שמחלק גם אותו וגם את {% equation %}n{% endequation %}) הוא הפיך, ואילו מספר שאינו זר ל-{% equation %}n{% endequation %} הוא מחלק אפס, ולכן אינו הפיך. נסו להוכיח זאת. (רמז: אם מספר {% equation %}a{% endequation %} הוא זר ל-{% equation %}n{% endequation %} אז קיימים {% equation %}x,y{% endequation %} שלמים כך ש-{% equation %}xa+yn=1{% endequation %}; אם מספר לא זר ל-{% equation %}n{% endequation %} אז קיים מספר קטן ממש מ-{% equation %}n{% endequation %} שמחלק גם אותו וגם את {% equation %}n{% endequation %}).

אם {% equation %}n{% endequation %} הוא מספר ראשוני, הכל טוב ויפה: במקרה זה, <strong>כל</strong> מספר בין 1 ל-{% equation %}n-1{% endequation %} הוא זר ל-{% equation %}n{% endequation %}, ולכן כל המספרים הפיכים - ואכן, המבנה האלגברי שמתקבל הוא שדה (כמו הרציונליים והממשיים). למעשה, השדות הללו חשובים מאוד: במובן מסויים, <strong>כל</strong> השדות ממציין שאינו 0 בנויים "מעל" השדות הללו (הזכרתי את מושג המציין בפוסט קודם -  זה המספר הקטן ביותר של פעמים שיש לחבר את 1 לעצמו כדי לקבל 0, ומציין 0 פירושו שזה בלתי אפשרי).

כאשר {% equation %}n{% endequation %} אינו ראשוני, יהיו לנו בהכרח מחלקי אפס (למשל, כל מספר שונה מ-1 שמחלק את {% equation %}n{% endequation %}) ולכן לא נקבל שדה. מכיוון שלרוב רק פעולת הכפל מעניינת אותנו, ואנו רוצים שלכל איבר בקבוצה שלנו יהיה הופכי כי אז מתקבל מבנה שנוח מאוד לעבוד איתו - מבנה של <a href="http://he.wikipedia.org/wiki/%D7%97%D7%91%D7%95%D7%A8%D7%94_%28%D7%9E%D7%91%D7%A0%D7%94_%D7%90%D7%9C%D7%92%D7%91%D7%A8%D7%99%29"><strong>חבורה</strong></a> - מעדיפים לוותר לגמרי על תכונת החיבור (ובפרט על סגירות לחיבור) ופשוט "להוציא" מהקבוצה שלנו את כל האיברים שלא ניתן להפוך. הקבוצה שמתקבלת, שניתן לתאר בפשטות בתור "כל המספרים בתחום {% equation %}1\dots n-1{% endequation %} שזרים ל-{% equation %}n{% endequation %} עם פעולת כפל מודולו {% equation %}n{% endequation %}" היא חבורה, וחבורה חשובה מספיק כדי לזכות בשם מיוחד: <a href="http://he.wikipedia.org/wiki/%D7%97%D7%91%D7%95%D7%A8%D7%AA_%D7%90%D7%95%D7%99%D7%9C%D7%A8"><strong>חבורת אוילר</strong></a> מודולו {% equation %}n{% endequation %}. החבורה הזו היא גם הבסיס לפרוטוקול אפס-הידע שעליו אדבר עוד מעט.

סיימנו עם ארבע פעולות החשבון הבסיסיות. הפעולה הבאה בתור היא הוצאת שורש. שוב, שורש כאן אינו שורש במובן הרגיל, של "שורש 2 הוא {% equation %}1.41421356\dots{% endequation %}", אלא במובן של "איבר בחבורה שכשמכפילים אותו בעצמו מקבלים את 2". למשל, בחבורת אוילר מסדר 7, המספר 3 הוא (באופן מפתיע?) שורש של 2: 3 כפול עצמו זה 9, ומודולו 7 מקבלים 2. באופן דומה גם 4 הוא שורש.

כאן אנחנו נתקלים בבעיה ותיקה ומוכרת - לא לכל מספר יש שורש. זה בלתי נמנע, בהתחשב בכך שיש לנו מספר סופי של מספרים בחבורה, ושלמספר יכול להיות (כפי שכרגע ראינו) יותר משורש אחד. למרבה המזל, במקרה שלנו הקושי הזה לא מהווה בעיה אמיתית, ואפילו יכול להוות יתרון.

אבל ה"בעיה" האמיתית (שגם היא יתרון) היא שלהוציא שורש זה <strong>קשה</strong>. את כל שאר הפעולות מחשב יכול לבצע בקלות: חיבור וכפל כמובן, גם חיסור הוא פשוט בערך כמו חיבור, והפעולה היחידה שנראית מסובכת משהו היא חילוק - אבל ניתן, באמצעות <a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">האלגוריתם האוקלידי</a> (שהוא אלגוריתם יעיל למדי) למצוא הופכי, ולכן לבצע חילוק (אלו מכם שהוכיחו או ראו הוכחה לכך שמספר הוא הפיך אם ורק אם הוא זר ל-{% equation %}n{% endequation %} ודאי יבינו כיצד). הוצאת שורש, לעומת שאר הפעולות, היא קשה לביצוע ודורשת זמן רב. כאשר {% equation %}n{% endequation %} גדול מאוד, היא הופכת לבלתי ניתנת לביצוע פרקטי.

כדאי להרחיב קצת על כך. אם {% equation %}n{% endequation %} הוא מספר ראשוני, הבעיה דווקא איננה קשה וקיימים לה פתרונות יעילים. יתר על כן, אם ידוע לנו הפירוק של {% equation %}n{% endequation %} לגורמים ראשוניים, גם אז הבעיה היא קלה: מה שעושים הוא להוציא שורש בנפרד עבור כל אחד מהגורמים הראשוניים הללו, ואז "לשלב" את כל השורשים שהתקבלו יחד באמצעות <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%A4%D7%98_%D7%94%D7%A9%D7%90%D7%A8%D7%99%D7%95%D7%AA_%D7%94%D7%A1%D7%99%D7%A0%D7%99">משפט השאריות הסיני</a>. לכן, בהינתן שאנו יודעים את הפירוק של {% equation %}n{% endequation %} לגורמים, הבעיה אינה כה קשה. יתר על כן, אם אנו יודעים בדרך קסם כלשהי להוציא שורש מודולו {% equation %}n{% endequation %} מבלי שנדע את הפירוק שלו, אפשר להראות כי באמצעות יכולת הוצאת השורש הזו ניתן לפרק בקלות את {% equation %}n{% endequation %}. כלומר, בעית הוצאת השורש מודולו {% equation %}n{% endequation %} <strong>שקולה</strong> מבחינת הקושי החישובי שלה לבעיית הפירוק לגורמים של {% equation %}n{% endequation %}.

אלא שבעיית הפירוק לגורמים היא בעיה חישובית קשה ותיקה ומוכרת, וכיום לא ידוע לה שום פתרון יעיל באמצעות המחשבים הקיימים (עם זאת, <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%97%D7%A9%D7%91_%D7%A7%D7%95%D7%95%D7%A0%D7%98%D7%99">המחשבים הקוואנטיים</a> אמורים להיות מסוגלים לפתור אותה ביעילות, וזו אחת הסיבות לפרסום הרב שהם זוכים לו בשנים האחרונות למרות שטרם נבנו מחשבים קוואנטים רציניים בפועל). עוד דוגמה לשיטה קריפטוגרפית שתישבר אם בעיית הפירוק לגורמים תיפתר היא שיטת ההצפנה RSA.

עד שייבנה מחשב קוואנטי או יימצא אלגוריתם יעיל לפירוק לגורמים, הוצאת שורש מודולו {% equation %}n{% endequation %} נותרת בעיה קשה אפילו אם {% equation %}n{% endequation %} הוא בסך הכל מכפלה של שני ראשוניים. מערכת ההוכחה האינטראקטיבית של פיאט-שמיר, שאותה אציג בפוסט הבא, משתמשת בדיוק בבעיה זו: המוכיח יודע "באורח קסום" מה השורש מודולו {% equation %}n{% endequation %} של מספר כלשהו, והוא מנסה לשכנע בידע שלו את המוודא, מבלי שהמוודא יקבל ולו רמז לגבי מהו השורש.
