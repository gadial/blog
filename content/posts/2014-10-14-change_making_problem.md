---
id: 3182
title: "בעיית המטבעות"
date: 2014-10-14 11:08:53
layout: post
categories: 
  - אלגברה לינארית
  - משחקים וחידות מתמטיות
tags: 
  - בעיית המטבעות
social_media_share: true
---
אני רוצה להציג הפעם בעיה שמתאימה בול לבלוג: היא קלה לניסוח, מעניינת ו<a href="http://graal.ens-lyon.fr/~abenoit/algo09/coins2.pdf">בעלת פתרון</a> שלא דורש מתמטיקה עמוקה בכלל, כך שהוא ניתן להבנה על ידי קוראים חסרי רקע במתמטיקה (אבל שכן מוכנים להשקיע מאמץ בנסיון להבין); מצד שני, ההצגה והפתרון שלה נותנים לנו הזדמנות להרגיש בדיוק מה קורה במתמטיקה - ברמת הניסוחים הפורמליים שמקלים עלינו, ושיטות ההוכחה. בקיצור, אם מעולם לא נתקלתם במתמטיקה, נסו לקרוא את הפוסט הזה!

אנחנו רוצים לפתור בעיה שקשורה ל<strong>מערכת מטבעות</strong>. נתון לנו סכום כסף מסויים ויש מספר סוגי מטבעות שאנחנו יכולים להשתמש בהם - איך אנחנו מייצגים את הסכום בעזרת המטבעות?

נתחיל מדוגמאות קונקרטיות. בישראל כיום יש לנו מטבעות עבור 10 אגורות, 50 אגורות, 1 שקל, 2 שקלים, 5 שקלים, 10 שקלים, 20 שקלים, 50 שקלים, 100 שקלים ו-200 שקלים. המילה "מטבעות" קצת מטעה, כמובן, כי 20,50,100,200 הם סכומים שבאים בשטרות, לא במטבעות; אבל אני משתמש במילה "מטבעות" כדי לתאר כל סוג של כסף מזומן. כמו כן, אין לי כוח לאגורות אז בואו נשכח מקיומן ונדבר רק על סכומים שהם מספר שלם של שקלים. עכשיו, איך אפשר לייצג 12 ש"ח? הנה כמה דרכים: אפשר להשתמש ב-12 מטבעות של 1 ש"ח; אפשר להשתמש ב-6 מטבעות של 2 ש"ח; אפשר להשתמש ב-5 מטבעות של 2 ש"ח ובשני מטבעות של 1 ש"ח; אפשר להשתמש במטבע אחד של 10 ש"ח ומטבע אחד של 2 ש"ח, ועוד ועוד. אנחנו רואים שגם עבור סכום כסף קטן יחסית יש לו המון ייצוגים שונים. השאלה היא - מה הייצוג ה<strong>אופטימלי</strong>?

אופטימליות יכולה להימדד בכמה דרכים, אבל הדרך הכי מתבקשת היא פשוט כמה שפחות מטבעות (אני מתעלם כאן מעניינים של משקל וגודל המטבעות שאולי משפיעים על מה שאנחנו נתפוס כ"אופטימלי"). לכן ההצגה של 12 בתור 10 ועוד 2 היא האופטימלית, כי היא משתמשת בשני מטבעות בלבד.

עכשיו, נניח שאני רוצה לייצג את 31 בצורה אופטימלית. איך עושים את זה? עצרו רגע, וחשבו - ראשית כל, חשבו מה הצורה שבה אתם תחלקו את הסכום הזה למטבעות; ושנית, חשבו האם זו דרך החלוקה האופטימלית.

חשבתם? קרוב לודאי שהחלוקה שחשבתם עליה היא 20 ועוד 10 ועוד 1. זו חלוקה מאוד <strong>טבעית</strong>, שנובעת משיטת חלוקה שאוהבים לקרוא לה "חמדנית". בשיטה החמדנית, בכל רגע נתון בוחרים בדבר "הכי טוב" שנראה שאפשר לעשות כרגע. ספציפית אצלנו זה אומר שאנחנו בוחרים את המטבע בעל הערך הגבוה ביותר שעדיין לא עובר את הסכום שאנחנו רוצים לייצג כרגע, ואז מנסים לייצג את מה שנשאר. במקרה של 31 התחלנו מ-20 כי המטבע הבא (50) כבר גדול מדי. נותר לנו לייצג את 11, ולכן המטבע הבא היה 10, וזה שאחריו היה 1. בדומה, עבור 76 נקבל בשיטה החמדנית את 50 ואז 20 ואז 5 ואז 1.

האם החלוקות החמדניות הללו אופטימליות? התשובה היא חיובית, וזאת בשל תכונה נחמדה שיש למערכת המטבעות בישראל - <strong>החלוקה החמדנית היא תמיד אופטימלית</strong> במערכת הזו. זה מעלה מייד שאלה אחרת - האם קיימת מערכת מטבעות שבה החלוקה החמדנית היא לא תמיד אופטימלית?

למרבה המזל, בבריטניה הייתה נהוגה בעבר שיטת מטבעות הזויה לחלוטין, שבה התכונה הנחמדה הזו לא התקיימה. במערכת המטבעות הזו ערכי המטבעות היו 1,3,6,12,24,30,60,240 (יחידת המטבע הבסיסית היא פני). מה האלגוריתם החמדני יתן עבור 48 במערכת המטבעות הזו? קל לראות שאת החלוקה 30+12+6, שכוללת 3 מטבעות. לעומת זאת, החלוקה 24+24 כוללת רק 2 מטבעות ולכן עדיפה. מסקנה: קיימות מערכות של מטבעות שבהן החלוקה החמדנית אינה אופטימלית.

מכאן נובעות שתי שאלות הכרעה אלגוריתמיות:
<ol>
	<li>נתונה מערכת מטבעות ונתון סכום כלשהו. האם החלוקה החמדנית של הסכום הזה במערכת המטבעות הנתונה היא אופטימלית?</li>
	<li>נתונה מערכת מטבעות. האם החלוקה החמדנית במערכת המטבעות הנתונה <strong>תמיד</strong> נותנת את החלוקה האופטימלית?</li>
</ol>
הבעיה הראשונה נראית קלה יותר מן השניה - בראשונה אנחנו רק צריכים לבדוק סכום אחד, בעוד שבשאלה השניה אנחנו צריכים איכשהו לומר משהו על <strong>כל</strong> הסכומים האפשריים. לכן הטוויסט הבא כל כך נחמד: הבעיה הראשונה היא <strong>קשה</strong> אלגוריתמית, במובן מאוד קונקרטי שניתן להוכיח; ואילו הבעיה השניה היא משמעותית יותר <strong>קלה</strong> אלגוריתמית. פורמלית, למי שמכיר, הבעיה הראשונה היא NP-שלמה בעוד שהבעיה השניה היא ב-P.

איך זה הגיוני בכלל? פשוט מאוד: כדי לדעת אם מערכת מטבעות אינה מקיימת את תכונת ה"חמדני הוא אופטימלי" מספיק למצוא דוגמה נגדית <strong>אחת</strong>. באופן ממוזל, בזכות המבנה של הבעיה, מובטח לנו תמיד שאם קיימת דוגמה נגדית אז תהיה קיימת דוגמה נגדית <strong>פשוטה</strong> שיהיה קל למצוא ולבדוק. לעומת זאת, אם שואלים אותנו על סכום שרירותי כלשהו, בכלל לא מובטח לנו שיהיה קל לבדוק אותו.

מה שנכון הוא שאפשר לנסות לתקוף את בעיה 1 בעזרת בעיה 2: ראשית כל נבדוק אם מערכת המטבעות שלנו היא כזו שבה חלוקה חמדנית היא תמיד אופטימלית. אם זה אכן המצב, אז התשובה לשאלה ב-1 היא תמיד "כן" בלי קשר לשאלה מה הסכום שלנו; כלומר, במקרה כזה גם שאלה 1 היא קלה. אבל אם התשובה ל-2 הייתה "לא" אז אין לנו מושג איך לענות ל-1; ייתכן שהחלוקה החמדנית לא עובדת עבור הסכום שלנו וייתכן שהיא כן. כלומר, זה שאנחנו יודעים איך לפתור את 2 ביעילות לא עזר לנו לפתור את 1.

מה שאני רוצה לעשות בפוסט הזה הוא שלושה דברים: ראשית, להראות איך מפרמלים מתמטית את הבעיות הללו; שנית, להסביר מה האלגוריתם היעיל שפותר את 2; ולבסוף, לומר משהו על איך מראים ש-1 קשה. רק עבור ה"לבסוף" אצטרך לדרוש ידע מוקדם כלשהו, למרות שתוכלו פשוט להאמין לכמה הצהרות שאזרוק שם ולוותר על הידע המוקדם הזה.

בואו נעבור לניסוחים פורמליים. את מערכת המטבעות נסמן באות {% equation %}C{% endequation %}. מערכת כזו מאופיינת על ידי סדרה של מספרים טבעיים - ערכי המטבעות האפשריים. נסדר אותם מהגדול לקטן, כלומר {% equation %}C=\left(c_{1},c_{2},\dots,c_{n}\right){% endequation %} כאשר {% equation %}c_{1}&gt;c_{2}&gt;\dots&gt;c_{n}{% endequation %}. כמו כן נניח ש-{% equation %}c_{n}=1{% endequation %}, כי אחרת מערכת המטבעות שלנו לא שלמה ולא יכולה לייצג חלק מהסכומים (לפחות את 1). אז למשל, במערכת הישראלית יש לנו {% equation %}C=\left(200,100,50,20,10,5,2,1\right){% endequation %} (ו-{% equation %}n=8{% endequation %}). למי שלא מכיר - סדרה כזו של איברים נקראת לעתים קרובות <strong>וקטור</strong> והאיברים האינדיבידואלים בוקטור מכונים <strong>כניסות</strong>.

עכשיו, <strong>ייצוג</strong> של סכום כלשהו במערכת {% equation %}C{% endequation %} הוא בעצם סדרה של {% equation %}n{% endequation %} מספרים טבעיים, שאומרים "כמה מכל סוג מטבע אנחנו לוקחים". כך למשל {% equation %}V=\left(0,0,1,0,1,0,1,0\right){% endequation %} הוא ייצוג של 50+10+2, כלומר של 62. עכשיו נכניס לתמונה הוקוס-פוקוס של סימון מתמטי סטנדרטי: אם {% equation %}\left(a_{1},\dots,a_{n}\right){% endequation %} ו-{% equation %}\left(b_{1},\dots,b_{n}\right){% endequation %} הם שני וקטורים, אז <strong>המכפלה הסקלרית</strong> שלהם מתקבלת מכפל של איברים באותו מקום בשני הוקטורים וחיבור של כולם. נכון שבכלל לא הבנתם מה אמרתי כרגע? זה כי ניסוחים טקסטואליים הם מסורבלים ונוסחאות קלות יותר להבנה:

{% equation %}\left(a_{1},\dots,a_{n}\right)\cdot\left(b_{1},\dots,b_{n}\right)=\sum_{i=1}^{n}a_{i}b_{i}=a_{1}b_{1}+a_{2}b_{2}+\dots+a_{n}b_{n}{% endequation %}

סימן ה-{% equation %}\sum{% endequation %} הוא סימון מקוצר לסכימה שמקובל במתמטיקה; עבור מי שלא מכיר אותו כתבתי את הסכום יותר במפורש מימינו.

כעת, חמושים בסימן המכפלה הסקלרית, קל לנו להמשיך: אם {% equation %}C{% endequation %} היא מערכת המטבעות שלנו ו-{% equation %}V{% endequation %} הוא וקטור של טבעיים, אז המספר ש-{% equation %}V{% endequation %} מייצג במערכת {% equation %}C{% endequation %} הוא פשוט {% equation %}C\cdot V{% endequation %}. כמו כן, אם נסתכל על {% equation %}V\cdot\left(1,1,\dots,1\right){% endequation %} נקבל את מספר המטבעות שבהן {% equation %}V{% endequation %} משתמש (זה בעצם סכום כל הכניסות של {% equation %}V{% endequation %}). נשתמש בסימון המקוצר {% equation %}\left|V\right|=V\cdot\left(1,1,\dots,1\right){% endequation %} ונאמר ש-{% equation %}\left|V\right|{% endequation %} הוא <strong>המשקל</strong> של {% equation %}V{% endequation %}.

כעת אנחנו רוצים לתאר את הוקטור שהוא הייצוג הטוב ביותר של מספר {% equation %}x{% endequation %} כלשהו במערכת המטבעות {% equation %}C{% endequation %}. ברור שזה צריך להיות וקטור {% equation %}V{% endequation %} שמקיים {% equation %}C\cdot V=x{% endequation %}, אבל אי אפשר סתם לומר "בואו ניקח מבין כל ה-{% equation %}V{% endequation %} האפשריים את זה בעל המשקל המינימלי", כי אולי יש כמה וקטורים שונים בעלי משקל מינימלי שכזה. למשל, במערכת המוזרה של הבריטים אפשר לייצג את 36 בתור 30+6 או בתור 24+12 - שני ייצוגים מגודל 2, ואין ייצוג מגודל 1 כי אין מטבע של 36. אז צריך לבחור בצורה כלשהי מי מבין שני הייצוגים הללו הוא "טוב יותר", והבחירה שלנו היא להעיף כמה שיותר מטבעות גדולים. כמקודם, גם כאן הפורמליזם יאפשר לי להסביר את הכוונה שלי יותר טוב מאשר מילים.

למי שמכיר, מה שאנחנו עושים הוא קובעים סדר לקסיקוגרפי על הוקטורים {% equation %}V{% endequation %} האפשריים באופן הטבעי. למי שלא מכיר, הנה מה שזה אומר. ראשית, בואו ניזכר איך מילים מסודרות במילון (בהנחה שמישהו עדיין זוכר איך מילים מסודרות במילון...): ראשית כל מופיעות כל המילים שמתחילות באות א', אחריהן אלו שמתחילות באות ב' וכדומה. כלומר, משווים מילים על פי האות הראשונה שלהן. אם היא שונה, אז באה קודם מי שהאות הראשונה שלה באה קודם. ומה עם מילים שבהן האות הראשונה שווה? עוברים לאות השניה, וכדומה.

ניקח את אותו רעיון עבור וקטורים. נסמן {% equation %}U&lt;V{% endequation %} אם קיים {% equation %}1\le i\le n{% endequation %} כך ש-{% equation %}u_{j}=v_{j}{% endequation %} לכל {% equation %}j&lt;i{% endequation %} וכמו כן {% equation %}u_{i}&lt;v_{i}{% endequation %}. למשל, {% equation %}\left(1,100,500\right)&lt;\left(2,0,3\right){% endequation %}. כעת אפשר לומר על וקטור כלשהו {% equation %}V{% endequation %} שהוא <strong>מקסימלי</strong> בקבוצת וקטורים אם לכל וקטור {% equation %}U{% endequation %} שונה ממנו בקבוצה מתקיים {% equation %}U&lt;V{% endequation %}.

עכשיו אפשר לומר בדיוק מה אנחנו רוצים: בהינתן מערכת מטבעות {% equation %}C{% endequation %} וערך {% equation %}x{% endequation %} כלשהו, אני מסמן ב-{% equation %}M\left(x\right){% endequation %} ({% equation %}M{% endequation %} מלשון Minimal) וקטור {% equation %}V{% endequation %} שנבחר כך: ראשית אני מסתכל על כל הוקטורים {% equation %}U{% endequation %} המקיימים {% equation %}C\cdot U=x{% endequation %}. שנית, מביניהם אני מסתכל על כל אלו שעבורם {% equation %}\left|U\right|{% endequation %} הוא מינימלי; ולבסוף, מבין מי שנשארו אני לוקח את זה שהוא מקסימלי בסדר הלקסיקוגרפי להיות ה-{% equation %}V{% endequation %} שלי. אפשר לכתוב את זה פורמלית באופן הבא:

{% equation %}V=\max\left(\arg\min_{\left|U\right|}\left\{ U\ |\ C\cdot U=x\right\} \right){% endequation %}.

הכתיב הפורמלי כאן הוא לטעמי מסובך מדי ואין ממש הכרח להשתמש בו - ברור מה אני רוצה גם מהניסוח המילולי. עם זאת, יש כאן מוקש נפוץ למדי במתמטיקה שצריך להיזהר איתו. אני מגדיר כאן אובייקט כלשהו, אבל בכלל לא מובטח לי שהוא קיים. הסכנה במקרה הספציפי שלנו היא שאף אחד לא מבטיח לי אוטומטית שקבוצת "כל הוקטורים {% equation %}U{% endequation %} המקיימים {% equation %}C\cdot U=x{% endequation %}" אינה ריקה. במקרה שלנו, מכיוון שאמרנו שהמטבע 1 תמיד יהיה במערכת המטבעות שלנו, תמיד יש וקטור כזה - {% equation %}U=\left(0,0,\dots,0,x\right){% endequation %}, ולכן ההגדרה שלי טובה (שימו לב שהוקטור הזה הוא <strong>הקטן ביותר</strong> בסדר הלקסיקוגרפי, וש-{% equation %}\left|U\right|{% endequation %} יהיה <strong>הגדול ביותר</strong> מבין כל המשקלים של וקטורים שמייצגים את {% equation %}w{% endequation %}).

אם כן, {% equation %}M\left(x\right){% endequation %} הוא הייצוג האופטימלי של {% equation %}x{% endequation %}. עדיין נותר להגדיר את הייצוג החמדני, אבל זה קל - אנחנו פשוט מוותרים על דרישת המינימום של המשקל. דהיינו, אגדיר {% equation %}G\left(x\right)=\max\left\{ U\ |\ C\cdot U=x\right\} {% endequation %} (כאן {% equation %}G{% endequation %} הוא מלשון Greedy - חמדני). למה האיבר המקסימלי לקסיקוגרפית מבין אלו שמייצגים את {% equation %}x{% endequation %} מתאים לייצוג החמדני? כי מה זה אומר, שהוא ראשון לקסיקוגרפית? ראשית, שהכניסה הראשונה (שמייצגת את המטבע הכי גדול) היא הכי גדולה שרק אפשר כך שעדיין נייצג את {% equation %}x{% endequation %}; ואחר כך הכניסה השניה היא הגדולה ביותר שרק אפשר, בהינתן הערך של הכניסה הראשונה, וכן הלאה. זה זמן טוב לעצור ולוודא שאתם מבינים אותי (ואת כל הסימונים שהיו עד כה). אם איבדתם אותי, נסו לקרוא שוב, או לנסות ולהמציא את ההגדרות מחדש בעצמכם; אין טעם להמשיך לקרוא בלי להרגיש בנוח עם מה שהלך עד כה.

כעת אפשר לנסח מתמטית את מה שאנחנו רוצים. נאמר שמערכת המטבעות {% equation %}C{% endequation %} היא <strong>קנונית</strong> אם {% equation %}M\left(x\right)=G\left(x\right){% endequation %} לכל {% equation %}x{% endequation %} טבעי. שתי הבעיות שלנו, אם כן, הן הבעיות הבאות:
<ol>
	<li>בהינתן {% equation %}C,x{% endequation %}, האם {% equation %}M_{C}\left(x\right)=G_{C}\left(x\right){% endequation %}?</li>
	<li>בהינתן {% equation %}C{% endequation %}, האם {% equation %}M_{C}\left(x\right)=G_{C}\left(x\right){% endequation %} לכל {% equation %}x{% endequation %}?</li>
</ol>
הוספתי את {% equation %}C{% endequation %} ל-{% equation %}M,G{% endequation %} למטה כדי לציין שהפונקציות הללו תלויות במערכת המטבעות {% equation %}C{% endequation %} שלנו. בדרך כלל זה מובן מאליו ולכן אני לא טורח לכתוב את זה במפורש, אבל בניסוח הפורמלי של הבעיות שאנחנו רוצים לפתור זה נראה לי מתאים.

עכשיו בואו נעבור לפתרון הבעיה שאנחנו יודעים לפתור - בעיה 2. הרעיון הוא שבהינתן מערכת המטבעות {% equation %}C{% endequation %}, אם היא לא קנונית אז יש <strong>דוגמאות נגדיות</strong> לקנוניות שלה - כל מני {% equation %}x{% endequation %}-ים שמקיימים {% equation %}M\left(x\right)\ne G\left(x\right){% endequation %}. מביניהם, נסמן ב-{% equation %}w{% endequation %} את הדוגמה הנגדית הקטנה ביותר. הפתרון שלנו יתבסס על כך ש-{% equation %}w{% endequation %} יכול להיות רק אחד מבין לכל היותר מספר לא גדול של ערכים שונים שאפשר לחשב מתוך {% equation %}C{% endequation %} - מספר שלא אתן במדויק אבל הוא לא גדול מ-{% equation %}n^{2}{% endequation %} (כאשר {% equation %}n{% endequation %}, כזכור, הוא מספר המטבעות ב-{% equation %}C{% endequation %} - ה"אורך" של הוקטור {% equation %}C{% endequation %}). יותר מכך - עבור כל ה-{% equation %}w{% endequation %}-ים הפוטנציאליים הללו, אנחנו יודעים בדיוק מהו {% equation %},M\left(w\right){% endequation %} ולכן כל מה שנותר לנו לעשות הוא לחשב עבורם את {% equation %}G\left(w\right){% endequation %} (זה מהיר) ולבדוק אם {% equation %}G\left(w\right)\ne M\left(w\right){% endequation %}. אם כן - סיימנו; הוכחנו ש-{% equation %}C{% endequation %} אינה קנונית. אם לכל {% equation %}n^{2}{% endequation %} המועמדים שבדקנו התקיים {% equation %}G\left(w\right)=M\left(w\right){% endequation %} אנחנו יכולים לעצור ובלב שקט לומר ש-{% equation %}C{% endequation %} קנונית.

אבל איך נראים המועמדים? ובכן, אני אתן עכשיו את הניסוח המדויק של המשפט שנותן לנו אותם. בהתחלה ממש לא יהיה ברור למה שהמשפט הזה יהיה נכון - מן הסתם מה שאעשה בהמשך יהיה להוכיח אותו. המשפט הוא כזה: נניח ש-{% equation %}w{% endequation %} היא הדוגמה הנגדית המינימלית. נסמן ב-{% equation %}i{% endequation %} את האינדקס של הכניסה הראשונה ב-{% equation %}M\left(w\right){% endequation %} שאינה אפס וב-{% equation %}j{% endequation %} את האינדקס של הכניסה האחרונה ב-{% equation %}M\left(w\right){% endequation %} שאינה אפס (למשל, אם {% equation %}M\left(w\right)=\left(0,0,1,2,1,0\right){% endequation %} אז {% equation %}i=3{% endequation %} ו-{% equation %}j=5{% endequation %}). כעת הטענה היא ש-{% equation %}M\left(w\right){% endequation %} הוא בדיוק מהצורה הבאה: בכניסות {% equation %}1,2,\dots,j-1{% endequation %} הוא זהה לגמרי ל-{% equation %}G\left(c_{i-1}-1\right){% endequation %}; בכניסה ה-{% equation %}j{% endequation %}-ית הוא גדול מהכניסה ה-{% equation %}j{% endequation %}-ית של {% equation %}G\left(c_{i-1}-1\right){% endequation %} ב-1; ובשאר הכניסות הוא 0.

שימו לב שכשאנחנו באים להשתמש במשפט הזה, אנחנו לא יודעים מהו {% equation %}w{% endequation %} ולא מהו {% equation %}M\left(w\right){% endequation %} ולכן <strong>לא יודעים</strong> מהם {% equation %}i,j{% endequation %}; אבל אנחנו יכולים לעבור סדרתית על כולם. לכל {% equation %}i,j{% endequation %} נתונים אנחנו יכולים לשחק במשחק ה"נניח ש-{% equation %}i,j{% endequation %} הללו הם הערכים הנכונים, נחשב את {% equation %}M\left(w\right){% endequation %} ונראה אם הוא שווה ל-{% equation %}G\left(w\right){% endequation %}".

זה מבלבל, אז בואו נראה דוגמה. יש לנו את המערכת הבריטית, עם המטבעות {% equation %}1,3,6,12,24,30,60,240{% endequation %}, כלומר {% equation %}C=\left(240,60,30,24,12,6,3,1\right){% endequation %}. אנחנו יודעים ש-{% equation %}w=48{% endequation %} הוא דוגמה נגדית, ואגלה לכם שזו אכן הדוגמה הנגדית המינימלית. עכשיו, {% equation %}M\left(w\right)=\left(0,0,0,2,0,0,0,0\right){% endequation %} ולכן {% equation %}i=j=4{% endequation %}. כעת, מהו {% equation %}c_{i-1}-1{% endequation %}? המטבע {% equation %}c_{i-1}=c_{3}{% endequation %} הוא המטבע 30 (זכרו שאנחנו הולכים מהגדול לקטן), ולכן {% equation %}c_{i-1}-1=29{% endequation %}. מהו {% equation %}G\left(29\right){% endequation %}? הפעלה של האלגוריתם החמדני נותנת לנו {% equation %}G\left(29\right)=\left(0,0,0,1,0,0,1,2\right){% endequation %}. כעת, הכניסות {% equation %}1,\dots,j-1{% endequation %} של {% equation %}G\left(29\right){% endequation %} הן {% equation %}\left(0,0,0\right){% endequation %} והכניסה ה-{% equation %}j{% endequation %} כשמוסיפים לה 1 היא 2, ואם משם והלאה יש לנו אפסים קיבלנו על פי המשפט ש-{% equation %}M\left(w\right)=\left(0,0,0,2,0,0,0,0\right){% endequation %}, וזה אכן המצב בפועל. קסם!

למה הקסם נכון? או, בואו נתחיל לעשות מתמטיקה.

נתחיל עם עוד הגדרה מתבקשת: נאמר שוקטור {% equation %}U{% endequation %} הוא <strong>חמדני</strong> אם {% equation %}U=G\left(C\cdot U\right){% endequation %} (ובמילים - אם הפעלת האלגוריתם החמדני על המספר ש-{% equation %}U{% endequation %} מייצג מחזירה את {% equation %}U{% endequation %}) ונאמר ש-{% equation %}U{% endequation %} <strong>מינימלי</strong> אם {% equation %}U=M\left(C\cdot U\right){% endequation %} (במילים - אם הייצוג הטוב ביותר למספר ש-{% equation %}U{% endequation %} מייצג זה הוא עצמו). הטענה שלי היא שוקטורים חמדניים ומינימליים נשארים כאלו גם אם מחסרים להם משהו מהכניסות. בואו נכתוב את זה קצת יותר פורמלית: נשתמש בסימון {% equation %}U\subseteq V{% endequation %} במקרה שבו קיים וקטור {% equation %}D{% endequation %} כך ש-{% equation %}U+D=V{% endequation %} (במתמטיקה יש ל-{% equation %}\subseteq{% endequation %} לרוב שימוש שונה אבל לא נזדקק לשימוש השונה הזה כאן). למשל, אם {% equation %}U=\left(1,2,3\right){% endequation %} ו-{% equation %}D=\left(4,0,3\right){% endequation %} אז נקבל {% equation %}U+D=\left(5,2,6\right){% endequation %}.

שימו לב שהגדרנו על וקטורים פעולות "חיבור" ו"כפל" וגם יחס סדר {% equation %}\le{% endequation %} שהן שונות למדי מהפעולות והיחסים שאנחנו מכירים על מספרים; היופי בעניין הוא שה<strong>תכונות </strong>שאנחנו רגילים להן ממספרים משתמרות ברובן גם עבור הפעולות החדשות. למשל, {% equation %}\left(A+B\right)\cdot C=A\cdot C+B\cdot C{% endequation %}. ולמשל {% equation %}A\le B{% endequation %} אם ורק אם {% equation %}A+D\le B+D{% endequation %} (בדקו זאת!). זה מאפשר לנו לתת הוכחה אלגנטית לטענה שלנו. בואו נניח אם כן ש-{% equation %}U\le V{% endequation %} וש-{% equation %}V{% endequation %} חמדני, ונוכיח ש-{% equation %}G{% endequation %} חמדני. לשם כך ניקח {% equation %}U^{\prime}{% endequation %} כלשהו שמייצג את אותו מספר כמו {% equation %}U{% endequation %}, דהיינו {% equation %}C\cdot U=C\cdot U^{\prime}{% endequation %}, ונראה ש-{% equation %}U^{\prime}\le U{% endequation %} (כלומר, {% equation %}U{% endequation %} הוא הגדול ביותר מבין כל הייצוגים למספר שהוא מייצג, ולכן מה שהאלגוריתם החמדני יחזיר).

כל מה שנצטרך הוא מניפולציות אלגבריות. אם {% equation %}U^{\prime}\cdot C=U\cdot C{% endequation %} אז נקבל ש:

{% equation %}\left(V-U+U^{\prime}\right)\cdot C=V\cdot C-U\cdot C+U^{\prime}\cdot C=V\cdot C{% endequation %}

מה שאומר שהוקטור {% equation %}V{% endequation %} מייצג את אותו המספר כמו {% equation %}V-U+U^{\prime}{% endequation %}. מכיוון ש-{% equation %}V{% endequation %} חמדני הוא גדול מכל וקטור אחר שמייצג את אותו מספר, ומכיוון ש-{% equation %}V-U+U^{\prime}{% endequation %} הוא וקטור שכל הכניסות בו חיוביות הוא אכן מייצג מספר. והן כולן חיוביות כי {% equation %}U\subseteq V{% endequation %} - זה המקום שבו אנחנו משתמשים בנתון הזה. ולכן:

{% equation %}V-U+U^{\prime}\le V{% endequation %}

וכעת ניתן לבצע "העברת אגפים" ממש כמו באי-שוויונות במספרים רגילים, ולקבל {% equation %}U^{\prime}\le U{% endequation %}, כמבוקש.

הוכחה דומה עובדת גם עבור הטענה שאם {% equation %}V{% endequation %} מינימלי ו-{% equation %}U\subseteq V{% endequation %} אז {% equation %}U{% endequation %} מינימלי. רק צריך לשנות קצת את המשמעות של {% equation %}\le{% endequation %} כך שאם {% equation %}\left|A\right|\ge\left|B\right|{% endequation %} אז {% equation %}A\le B{% endequation %} (קצת מבלבל, אבל זכרו את הרעיון - וקטור מינימלי הוא וקטור <strong>בעל משקל מינימלי</strong> שהוא <strong>הגדול ביותר לקסיקוגרפית</strong>; כלומר, הסינון הראשוני הוא על פי המשקל, ומשקל קטן יותר הוא טוב יותר). צריך להוכיח שהמשמעות החדשה עדיין מקיימת את התכונות האלגבריות הנחמדות, אבל אין כאן משהו קשה.

בואו נבין איך אני הולך להשתמש במה שהוכחתי. בהמשך אני הולך לקחת כל מני וקטורים שמהוויים ייצוג מינימלי או חמדני לערך כלשהו, ואז לשנות אותם על ידי הקטנה של כניסות בהם - ואני אשתמש בכך שגם אחרי ההקטנה הזו עדיין קיבלתי וקטורים שהם ייצוג מינימלי או חמדני (עבור הערך שהם מייצגים, שהוא שונה מהערך שהוקטור לפני ההקטנה ייצג).

עוד תכונה שאשתמש בה בהמשך היא שהפונקציה {% equation %}G{% endequation %} שלוקחת מספר ומתאימה לו את הפתרון החמדני שלו היא <strong>משמרת סדר</strong> במובן הבא: אם {% equation %}x&lt;y{% endequation %} אז {% equation %}G\left(x\right)&lt;G\left(y\right){% endequation %}. כדי לראות את זה, שימו לב לכך ש-{% equation %}U=G\left(x\right)+\left(0,0,\dots,y-x\right){% endequation %} הוא ייצוג כלשהו עבור {% equation %}y{% endequation %} ולכן {% equation %}U\le G\left(y\right){% endequation %}. כמו כן בבירור {% equation %}G\left(x\right)&lt;U{% endequation %}, כי לקחנו את {% equation %}G\left(x\right){% endequation %} והוספנו לו עוד משהו. משני אלו קיבלנו ש-{% equation %}G\left(x\right)&lt;G\left(y\right){% endequation %} - המעבר האחרון הוא שימוש בתכונת ה<strong>טרנזיטיביות</strong> של יחס הסדר {% equation %}\le{% endequation %} ואם זה נראה לכם חשוד, נסו להוכיח שזה עובד.

עכשיו בואו נתחיל את ההוכחה המרכזית שלנו. נניח ש-{% equation %}C{% endequation %} היא מערכת מטבעות לא קנונית, ויהא {% equation %}w{% endequation %} הדוגמה הנגדית הקטנה ביותר לכך. כלומר, {% equation %}G\left(w\right)\ne M\left(w\right){% endequation %} אבל לכל {% equation %}x&lt;w{% endequation %} מתקיים {% equation %}G\left(x\right)=M\left(x\right){% endequation %} (הגישה הזו של "בואו ניקח את המינימלי" היא מאוד נפוצה במתמטיקה - היא אוטומטית נותנת לנו כלי נשק חדש ומועיל במהלך ההוכחה שסתם לקחת דוגמה נגדית כלשהי לא היה נותן לנו). בואו נתחיל להבין את התכונות של {% equation %}w{% endequation %} הזה. ראשית כל, אני טוען שאין ל-{% equation %}G\left(w\right),M\left(w\right){% endequation %} כניסות משותפות ששונות מאפס. בואו נזכר ב-{% equation %}w=48{% endequation %} של הבריטים: שם {% equation %}M\left(w\right)=\left(0,0,0,2,0,0,0,0\right){% endequation %} ואילו {% equation %}G\left(w\right)=\left(0,0,1,0,1,1,0,0\right){% endequation %}. ב-{% equation %}M\left(w\right){% endequation %} הכניסה היחידה שאינה 0 היא הרביעית, ואילו ב-{% equation %}G\left(w\right){% endequation %} הכניסות שאינן אפס הן 3,5,6. כלומר, אין כניסה ששונה מאפס אצל שניהם, ואני טוען שזה לא מקרי. למה? ובכן, נניח שהכניסה ה-{% equation %}k{% endequation %}-ית בשניהם לא הייתה 0. אז הייתי יכול לחסר ממנה 1 ולקבל מ-{% equation %}M\left(w\right){% endequation %} ומ-{% equation %}G\left(w\right){% endequation %} שני וקטורים חדשים<strong> שעדיין מייצגים את אותו מספר</strong> (המספר {% equation %}w-c_{k}{% endequation %} אם אנחנו רוצים להיות מדוייקים), ועל פי הטענה שהוכחתי לפני רגע על {% equation %}U\le V{% endequation %}, הוקטור שנקבל מ-{% equation %}M\left(w\right){% endequation %} על ידי החיסור יהיה הפתרון המינימלי עבור המספר הזה והוקטור שנקבל מ-{% equation %}G\left(w\right){% endequation %} יהיה הפתרון החמדני עבור המספר הזה. עכשיו, בגלל ש-{% equation %}w{% endequation %} הוא הדוגמה הנגדית המינימלית לסיטואציה שבה הוקטור החמדני והמינימלי שונים, ינבע ששני הוקטורים שקיבלתי הם <strong>זהים</strong>, אבל אם כך גם הוקטורים המקוריים שהתחלתי מהם היו צריכים להיות זהים כי כל מה ששיניתי היה לחסר משניהם 1 באותו מקום.

עכשיו בואו נסמן {% equation %}M\left(w\right)=\left(m_{1},m_{2},\dots,m_{n}\right){% endequation %} וכפי שהבטחתי, נסמן ב-{% equation %}i{% endequation %} את אינדקס הכניסה הראשונה שאינה 0 וב-{% equation %}j{% endequation %} את אינדקס הכניסה האחרונה שאינה 0. אבחנה ראשונה היא ש-{% equation %}M\left(w\right)&lt;G\left(w\right){% endequation %} על פי הגדרה (כי כל וקטור שמייצג את {% equation %}w{% endequation %} קטן לקסיקוגרפית מ-{% equation %}G\left(w\right){% endequation %}, ואנו מניחים ש-{% equation %}M\left(w\right)\ne G\left(w\right){% endequation %}). מכיוון ש-{% equation %}M\left(w\right),G\left(w\right){% endequation %} אינם חולקים כניסות שונות מ-0, הכניסה הראשונה של {% equation %}M\left(w\right){% endequation %} שאינה אפס חייבת להיות כזו שהיא כן אפס אצל {% equation %}G\left(w\right){% endequation %}; וכדי שעדיין יתקיים {% equation %}M\left(w\right)&lt;G\left(w\right){% endequation %} נובע שבהכרח יש ל-{% equation %}G\left(w\right){% endequation %} כניסה <strong>מוקדמת יותר</strong> ששונה מאפס (למה?) ולכן {% equation %}1&lt;i{% endequation %}. זו לא הסקה טריוויאלית - שוב, אני ממליץ לכם לוודא שאתם מבינים מה הלך פה.

המטרה שלי היא להראות ש-{% equation %}M\left(w\right){% endequation %} דומה למדי ל-{% equation %}G\left(c_{i-1}\right){% endequation %}, אז בואו ננסה להבין קצת את {% equation %}c_{i-1}{% endequation %} הזה.

מכיוון ש-{% equation %}i&gt;1{% endequation %} אפשר לדבר על {% equation %}c_{i-1}{% endequation %} (אם {% equation %}i=1{% endequation %} ואני כותב {% equation %}c_{i-1}{% endequation %} אז כתבתי משהו חסר משמעות כי ה-{% equation %}c{% endequation %}-ים מתחילים מ-1). עכשיו, {% equation %}G\left(w\right){% endequation %} כולל 1 בכניסה מוקדמת יותר מ-{% equation %}i{% endequation %}, כלומר {% equation %}w{% endequation %} מורכב לפחות ממטבע אחד שגדול או שווה ל-{% equation %}c_{i-1}{% endequation %} ומכאן ש-{% equation %}w\ge c_{i-1}{% endequation %}. מצאנו <strong>חסם מלעיל</strong> (מלמעלה) על {% equation %}c_{i-1}{% endequation %}. עכשיו בואו נמצא <strong>חסם מלרע</strong> (מלמטה) עליו: אנחנו יודעים שאם ניקח את {% equation %}M\left(w\right){% endequation %} אז הכניסה ה-{% equation %}j{% endequation %} תהיה גדולה מאפס. לכן ניתן לחסר ממנה 1, והוקטור שיתקבל יהיה ייצוג של {% equation %}w-c_{j}{% endequation %} (למה?). הוקטור הזה הוא ייצוג מינימלי של {% equation %}w-c_{j}{% endequation %} ומכיוון ש-{% equation %}w-c_{j}{% endequation %} קטן מ-{% equation %}w{% endequation %} ו-{% equation %}w{% endequation %} הוא הערך המינימלי שהייצוג המינימלי שלו אינו חמדני, קיבלנו שהוקטור שלנו (שהוא {% equation %}M\left(w\right){% endequation %} שבו הכניסה ה-{% equation %}j{% endequation %} הוקטנה ב-1) הוא הייצוג החמדני של {% equation %}w-c_{j}{% endequation %}. עכשיו, הייצוג הזה כולל רק את המטבעות שמשתתפים ב-{% equation %}M\left(w\right){% endequation %}, כלומר המטבע בעל הערך הגדול ביותר שמשתתף בו הוא {% equation %}c_{i}{% endequation %}. מסקנה: {% equation %}w-c_{j}&lt;c_{i-1}{% endequation %}. קחו שניה ותסבירו לעצמכם למה זה נכון, כי עשיתי פה קפיצה קטנה.

ההסבר: אם {% equation %}w-c_{j}\ge c_{i-1}{% endequation %} אז על פי הגדרתו, האלגוריתם החמדני ייקח לפחות את אחת המטבעות {% equation %}c_{1},\dots,c_{i-1}{% endequation %}. אנחנו יודעים שהוא לא עשה את זה (אמרתי את זה לפני רגע), ולכן.

אם כן, קיבלנו חסם מלרע עבור {% equation %}c_{i-1}{% endequation %}. אם נרכז את מה שכבר מצאנו:

{% equation %}w-c_{j}&lt;c_{i-1}\le w{% endequation %}

זה מראה לנו ש-{% equation %}c_{i-1}{% endequation %} <strong>קרוב מאוד</strong> ל-{% equation %}w{% endequation %}. כמה קרוב? הוא נמצא בטווח קטן יחסית שגודלו {% equation %}c_{j}{% endequation %} וקצהו האחד ב-{% equation %}w{% endequation %} עצמו. בואו נשתמש בזה עכשיו.

נסמן {% equation %}V=\left(v_{1},v_{2},\dots,v_{n}\right)=G\left(c_{i-1}-1\right){% endequation %}. מה שבעצם נותר לנו להוכיח הוא ש-{% equation %}v_{k}=m_{k}{% endequation %} לכל {% equation %}1\le k&lt;j{% endequation %} וש-{% equation %}v_{j}=m_{j}-1{% endequation %}. הדרך שבה נעשה את זה תהיה לחסום את {% equation %}V{% endequation %} בין שני וקטורים: נראה שהוא קטן מ-{% equation %}M\left(w\right){% endequation %} אבל שהוא גדול מוקטור אחר שנראה כמעט כמו {% equation %}M\left(w\right){% endequation %}, מה שלא יאפשר ל-{% equation %}V{% endequation %} להיות שונה במיוחד מ-{% equation %}M\left(w\right){% endequation %} בכל הכניסות עד ה-{% equation %}j{% endequation %}-ית.

נתחיל בלהראות ש-{% equation %}V&lt;M\left(w\right){% endequation %}. מן הסתם {% equation %}c_{i-1}-1{% endequation %} קטן מ-{% equation %}c_{i-1}{% endequation %} ולכן המטבע {% equation %}c_{i-1}{% endequation %} והגדולות ממנה לא יכולות להיות חלק מהפתרון החמדני עבור {% equation %}c_{i-1}{% endequation %}. אבל המטבע {% equation %}c_{i}{% endequation %} בוודאי יהיה, כי הוא המטבע הגדול ביותר שעדיין קטן או שווה ל-{% equation %}c_{i-1}-1{% endequation %}. מכאן ש-{% equation %}v_{i}\ne0{% endequation %}. לכן אפשר להשתמש בתעלול שכבר הפך לשגור אצלנו - להפחית 1 מהכניסה ה-{% equation %}i{% endequation %} הן ב-{% equation %}V{% endequation %} והן ב-{% equation %}M\left(w\right){% endequation %} ולקבל את {% equation %}G\left(c_{i-1}-1-c_{i}\right){% endequation %} ואת {% equation %}M\left(w-c_{i}\right)=G\left(w-c_{i}\right){% endequation %}, בהתאמה. כעת, אי השוויון שיש לנו על {% equation %}c_{i-1}{% endequation %} מראה ש-{% equation %}c_{i-1}-1-c_{i}&lt;w-c_{i}{% endequation %}, ולכן {% equation %}G\left(c_{i-1}-1-c_{i}\right)&lt;G\left(w-c_{i}\right){% endequation %}, כשהמעבר האחרון נובע מתכונת "שימור הסדר" של פתרונות חמדניים שראינו קודם.

קיבלנו שוקטור א' יותר קטן מוקטור ב'. אם נחבר לשניהם 1 בכניסה ה-{% equation %}i{% endequation %}-ית זה לא ישנה את הסדר היחסי בין הוקטורים שנקבל, שהם בדיוק {% equation %}V,M\left(w\right){% endequation %} בהתאמה, ולכן קיבלנו ש-{% equation %}V&lt;M\left(w\right){% endequation %}.

עכשיו בואו נחסום את {% equation %}V{% endequation %} מלרע. לשם כך, בואו ניקח את {% equation %}M\left(w\right){% endequation %} ונקטין את {% equation %}m_{j}{% endequation %} (הכניסה האחרונה שאינה 0) ב-1. נקבל את הוקטור {% equation %}G\left(w-c_{j}\right){% endequation %}, ומכיוון שכבר ראינו ש-{% equation %}w-c_{j}&lt;c_{i-1}{% endequation %}, כלומר ש-{% equation %}w-c_{j}\le c_{i-1}-1{% endequation %}, נקבל ש-{% equation %}G\left(w-c_{j}\right)\le G\left(c_{i-1}-1\right)=V{% endequation %}.

מכאן שהצלחנו לחסום את {% equation %}V{% endequation %} כך: {% equation %}G\left(w-c_{j}\right)\le V&lt;M\left(w\right){% endequation %}. זה מעניין, כי {% equation %}G\left(w-c_{j}\right){% endequation %} ו-{% equation %}M\left(w\right){% endequation %} הם כמעט אותו וקטור - הם נבדלים רק בכניסה {% equation %}m_{j}{% endequation %} שב-{% equation %}M\left(w\right){% endequation %} גדולה ב-1. מכאן שעד לכניסה הזו גם {% equation %}V{% endequation %} חייב להיות שווה אליהם (אחרת הוא היה גדול משניהם או קטן משניהם). כעת, מה קורה בכניסה {% equation %}m_{j}{% endequation %}? אנחנו יודעים שקורה אחד משניים: {% equation %}v_{j}=m_{j}{% endequation %} או {% equation %}v_{j}=m_{j}-1{% endequation %} (אחרת, שוב, {% equation %}V{% endequation %} היה גדול או קטן משני הוקטורים). האם יכול להיות ש-{% equation %}v_{j}=m_{j}{% endequation %}? ובכן, לא: זאת מכיוון שכל הכניסות של {% equation %}M\left(w\right){% endequation %} שאחרי ה-{% equation %}j{% endequation %}-ית הן אפסים. לכן, אם {% equation %}v_{j}=m_{j}{% endequation %} זה אומר ש-{% equation %}V{% endequation %} זהה ל-{% equation %}M\left(w\right){% endequation %} ב-{% equation %}j{% endequation %} הכניסות הראשונות וביתר הכניסות הוא שווה או גדול ממנו, ומכאן נובע ש-{% equation %}M\left(w\right)\le V{% endequation %} בסתירה לכך שכבר ראינו ש-{% equation %}V&lt;M\left(w\right){% endequation %}. מכאן ש-{% equation %}v_{j}=m_{j}-1{% endequation %}. ומה על יתר הכניסות של {% equation %}V{% endequation %}? ובכן, הן פשוט לא מעניינות אותנו; השגנו בדיוק את מה שרצינו להשיג. זה מסיים את המשפט ומסיים את כל הטיפול בבעיית "נתונה מערכת מטבעות - האם היא קנונית?"

ההוכחה עשויה להיראות כמו ערב-רב של פרטים כרגע, אבל נסו לקרוא אותה שוב - יש כמה רעיונות בסיסיים ויפים שחוזרים בה שוב ושוב והם בעצם העיקר.

נעבור עכשיו לדבר על הבעיה השניה - בהינתן {% equation %}C,x{% endequation %} לקבוע האם {% equation %}G_{C}\left(x\right)=M_{C}\left(x\right){% endequation %}. מכיוון שלחשב את {% equation %}G_{C}\left(x\right){% endequation %} זה קל, ברור שה"קושי" של הבעיה מסתמך על כך שבאופן כללי חישוב של {% equation %}M_{C}\left(x\right){% endequation %} הוא קשה. מה זה אומר, "קשה"? איך מודדים את זה? נתחיל מהשקר שקל יחסית לעכל ונעבור לאמת המסובכת והעגומה יותר. השקר הוא זה: אין לנו דרך "חכמה" לחשב את {% equation %}M_{C}\left(x\right){% endequation %} ולכן אנחנו פשוט עוברים על <strong>כל</strong> האפשרויות לייצג את {% equation %}x{% endequation %} בעזרת {% equation %}C{% endequation %} ובודקים מי מהן הכי חסכונית במטבעות. הבעיה היא שיש מספר גדול של אפשרויות: נניח שיש לנו {% equation %}n{% endequation %} סוגי מטבעות ואנחנו תוהים אם אפשר לייצג משהו שגודלו גדול מסכום כל המטבעות. אז יש לנו {% equation %}2^{n}{% endequation %} אפשרויות לחלוקה שכוללת כל מטבע רק פעם אחת או אפס פעמים, ובפועל יש הרבה יותר חלוקות מזה - מספר החלוקות הוא <strong>אקספוננציאלי</strong>. לעבור על כולן לוקח המון זמן. זה לא יעיל באופן שבו מודדים "יעילות" במדעי המחשב.

זה סוף השקר, וזה שקר יחסית משביע רצון שמעביר את האינטואיציה. אבל מהי האמת?

האמת היא שאנחנו לא יודעים אם זו בעיה קשה או לא. זה נכון שלחשב את {% equation %}M\left(x\right){% endequation %} על ידי האלגוריתם "עבור על כל האפשרויות ובדוק" זה לא יעיל, אבל מי אומר לנו שאין אלגוריתם יותר מתוחכם? אנחנו לא מכירים כזה בהכרח, אבל מי אומר שאין? למעשה, בפועל <strong>יש</strong> אלגוריתמים יותר מתוחכמים, שאני לא מכניס לפוסט הזה כי גם ככה הוא עמוס, אבל גם הם סובלים מאי-יעילות (דהיינו, הם טובים הרבה יותר מהאלגוריתם הנאיבי שהצגתי, אבל זמן הריצה שלהם עדיין איטי למדי). כדי להגיד שהבעיה קשה, אני צריך <strong>להוכיח</strong> איכשהו טענה כללית: ש<strong>כל</strong> האלגוריתמים שפותרים את הבעיה הם לא יעילים. איך אפשר להקיף את <strong>כל</strong> האלגוריתמים? זה בוודאי לא משהו טריוויאלי. ולמען האמת, זה אפילו לא נגמר כאן. הבעיה שאני הצגתי היא הבעיה הבאה: בהינתן {% equation %}C,x{% endequation %} האם {% equation %}G_{C}\left(x\right)=M_{C}\left(x\right){% endequation %}? זו בעיה שהתשובה לה היא "כן/לא". ייתכן, תיאורטית, שאפשר לענות עליה <strong>בלי</strong> שנצטרך בכלל לחשב את {% equation %}M_{C}\left(x\right){% endequation %}, כלומר זו עשויה להיות בעיה <strong>קלה</strong> יותר מאשר חישוב של {% equation %}M_{C}\left(x\right){% endequation %}, ולכן כל הטיעון האינטואיטיבי שנתתי למעלה היה רמאות מובהקת - הוא הסביר למה בעיה <strong>אחרת</strong> היא קשה. אמנם, אין לי מושג איך לפתור את הבעיה שלי מבלי לפתור את הבעיה האחרת, אבל זה שאני לא חושב על משהו לא אומר שאין.

ברוכים הבאים לעולם של מדעי המחשב התיאורטיים ולתחושה על קצה המזלג של "למה להוכיח חסמים תחתונים זה קשה". ועדיין, במובן מסויים שהוא פורמלי לגמרי במדעי המחשב התיאורטיים הבעיה נחשבת קשה. באיזה מובן? במובן זה שאם אנחנו מוצאים פתרון יעיל עבורה, הדבר יגרור פתרון יעיל עבור אלפי (עשרות אלפי?) בעיות אחרות במדעי המחשב ש<strong>לאף אחת מהן</strong> לא נמצא עד היום פתרון יעיל שכזה. הבעיות הללו נקראות הבעיות ה-NP-שלמות, ולא אסביר כרגע מהיכן מגיע השם. רק אעיר שמדובר על בעיות שמגיעות משלל תחומים שונים ומנוסחות לעתים בצורות שונות ביותר - ועדיין, באף תחום לא הצליחו לפתור ביעילות אף אחת מהבעיות הללו, מה שמוביל אותנו לאמץ את הנחת העבודה שכנראה אין פתרון יעיל עבורן. אבל הוכחה לכך? אין. הבעיה הזו - כיצד לפתור בעיה NP-שלמה ביעילות או להוכיח שאין פתרון יעיל לאף אחת מהן - נקראת בעיית P=NP והיא הבעיה התיאורטית הפתוחה המרכזית במדעי המחשב.

הערה קטנה למתקדמים, שמי שלא בקיא בתחום יכול לוותר עליה: שימו לב שבניסוח שנתתי, הבעיה אינה ב-NP אלא ב-coNP, מכיוון שלא קיים "עד" ברור לכך ש-{% equation %}G_{C}\left(x\right)=M_{C}\left(x\right){% endequation %} אבל כן קיים "עד" ברור לכך שהם שונים (בהינתן הפתרון האופטימלי קל לבדוק שהוא שונה מהחמדני). כשאני אומר "הבעיה" אני מתכוון בעצם למשלימה של הבעיה שלנו, וכך גם אפעל בהמשך; הדקות הזו לא קריטית למי שלא מצוי בנבכי ההגדרות הפורמליות.

איך מראים שבעיה היא NP-שלמה? הדרך המקובלת היא באמצעות מעין רקורסיה: לוקחים בעיה שכבר יודעים שהיא NP-שלמה, ומוכיחים שאם אנחנו יודעים לפתור ביעילות את הבעיה החדשה, אז אנחנו יודעים לפתור ביעילות את הבעיה ה-NP-שלמה הישנה (לדבר כזה קוראים <strong>רדוקציה</strong>). כמובן, רקורסיה צריכה להתחיל מהיכן שהוא, ונקודת ההתחלה הסטנדרטית - השפה ה-NP-שלמה ה"ראשונה", היא בדרך כלל שפה שנקראת SAT שלא אתאר במפורש כאן.

אז כדי להוכיח שבעיית המטבעות היא NP-שלמה אני צריך לקחת בעיה NP-שלמה קיימת ולעשות רדוקציה שלה אל בעיית המטבעות. מה שאומר שאני קצת מרמה: אני יכול לבחור איזו בעיה NP-שלמה שנוח לי לעבוד איתה בתור "נקודת התחלה", ומן הסתם בפוסט הזה לא אוכיח שגם היא NP-שלמה. בפועל יש כמה בעיות "סטנדרטיות" שכולם מכירים ונהוג להשתמש בהן או בוריאציות עליהן, ואני הולך להשתמש בוריאציה על בעיה שנקראת Subset Sum. הבעיה המקורית היא כזו: נתונה קבוצה {% equation %}S=\left\{ x_{1},x_{2},\dots,x_{n}\right\} {% endequation %} של מספרים ועוד מספר אחד {% equation %}c{% endequation %}. השאלה היא אם קיימת תת-קבוצה של {% equation %}S{% endequation %}, שאסמן {% equation %}S^{\prime}{% endequation %}, שסכום האיברים בה שווה בדיוק ל-{% equation %}c{% endequation %}, כלומר {% equation %}\sum_{x\in S^{\prime}}x=c{% endequation %}.

את הבעיה הזו אפשר לנסח בצורה שונה אבל שקולה לגמרי: נתון הוקטור {% equation %}X=\left(x_{1},\dots,x_{n}\right){% endequation %} של מספרים (אפשר לדרוש במפורש שמספר לא מופיע פעמיים בוקטור אבל זה לא חשוב). האם קיים וקטור <strong>בינארי </strong>{% equation %}A=\left(a_{1},\dots,a_{n}\right){% endequation %} כך ש-{% equation %}X\cdot A=c{% endequation %}? כאן "וקטור בינארי" אומר שכל כניסה בוקטור היא 0 או 1.

הוריאציה שאני אשתמש בה מרשה ל-{% equation %}A{% endequation %} להכיל מספרים טבעיים כלשהם, לא רק 0 ו-1 (אבל לא מספרים שליליים). לא אוכיח כאן שהיא NP-שלמה אבל זה תרגיל טוב. בניסוח הזה, הבעיה נראית כמעט לגמרי כמו בעיית המטבעות, בהבדל אחד - אנחנו לא מדברים על <strong>אופטימיזציה</strong> אלא על היתכנות. חשבו על {% equation %}X{% endequation %} בתור מערכת המטבעות שלנו, אבל ללא דרישה ש-1 יהיה שייך אליה, ואז השאלה היא אם אפשר בכלל לייצג ערך {% equation %}c{% endequation %} נתון במערכת הזו.

אם כן, אני מקבל {% equation %}X=\left(x_{1},\dots,x_{n}\right){% endequation %} ו-{% equation %}c{% endequation %} ורוצה לייצר שני דברים: מערכת מטבעות {% equation %}C{% endequation %}, וערך {% equation %}y{% endequation %} כלשהו, כך שמתקיים ש-{% equation %}G_{C}\left(y\right)\ne M_{C}\left(y\right){% endequation %} אם ורק אם קיים {% equation %}A{% endequation %} כך ש-{% equation %}X\cdot A=c{% endequation %}. זו המהות של רדוקציה - המרה של מקרה לבדיקה של בעיה אחת למקרה לבדיקה של בעיה אחרת.

לכאורה יש לי מגבלה די מהותית - ה"נשק" היחיד שיש לי הוא הפער שיכול להיות קיים בין הפתרון החמדני והאופטימלי. איכשהו אני צריך לנצל אותו כדי לדעת אם בכלל אפשר לייצג ערך כלשהו בעזרת {% equation %}X{% endequation %}. אבל אם חושבים קצת על האופן שבו אפשר ליצור מערכות של מטבעות שבהן הפתרון החמדני והאופטימלי לאו דווקא מזדהים, זה לא קשה. מה קרה במערכת הבריטית? היה לנו ערך - 48 - שמיוצג בקלות על ידי מספר קטן כלשהו - 24. אלא שיש מעל 24 מספר גדול יותר, 30, ש"מכריח" את הפתרון החמדני לפספס את 24 ולעבור להתעסק עם מספרים קטנים יותר. על זה אני אבנה את הפתרון שלי, וכדי שיהיה קל להבין אותו אני אסביר מה אני עושה במקרה פרטי.

המקרה הפרטי יהיה {% equation %}X=\left(10,20,30,40\right){% endequation %} ונראה מה אני עושה עבור {% equation %}c{% endequation %}-ים שונים. יש ב-{% equation %}X{% endequation %} ארבעה איברים, ולכן אני רוצה לבנות מערכת מטבעות {% equation %}C{% endequation %} וערך {% equation %}y{% endequation %} כך שאם {% equation %}c{% endequation %} ניתן לייצוג בידי {% equation %}X{% endequation %}, אפשר יהיה לייצג את {% equation %}y{% endequation %} ב-{% equation %}C{% endequation %} באותה הצורה, עם לכל היותר ארבעה איברים; אבל אם אי אפשר, אז כדי לייצג את {% equation %}y{% endequation %} אני אצטרך לפחות חמישה איברים. למעשה, די קל לעשות את זה - נגדיר את {% equation %}C{% endequation %} להיות {% equation %}X{% endequation %} ועוד שני איברים: {% equation %}1{% endequation %} (שחייב תמיד להיות ב-{% equation %}C{% endequation %}) ו-{% equation %}c-4{% endequation %}.

בואו נראה איך זה עובד. קודם כל, ניקח {% equation %}c=60{% endequation %} שאנחנו יודעים שאפשר לייצג ב-{% equation %}X{% endequation %}. אז {% equation %}C=\left(56,40,30,20,10,1\right){% endequation %} ו-{% equation %}y=60{% endequation %}. הפתרון המינימלי במקרה זה הוא {% equation %}60=40+20{% endequation %}. הפתרון החמדני, לעומת זאת, קודם כל ייקח את {% equation %}56{% endequation %}, יישאר עם 4, ואז יקח את 1 עוד 4 פעמים - כלומר, גודלו 5.

לעומת זאת, אם ניקח {% equation %}c=64{% endequation %}, שלא ניתן לייצוג על ידי {% equation %}X{% endequation %}, אז נקבל {% equation %}C=\left(60,40,30,20,10,1\right){% endequation %} ו-{% equation %}y=64{% endequation %}. במקרה זה, בבירור הפתרון האופטימלי הוא {% equation %}64=60+1+1+1+1{% endequation %} וזהו גם הפתרון החמדני.

ומה קורה אם {% equation %}c{% endequation %} קטן יותר מחלק מהאיברים ב-{% equation %}X{% endequation %}, למשל {% equation %}c=24{% endequation %}? ובכן, בדוגמה הזו אין שום שינוי מהותי - הפתרון החמדני עדיין ייקח את {% equation %}c-4{% endequation %} בתור האיבר הראשון. מתי כן עשויה להתעורר בעיה? כאשר {% equation %}c-4{% endequation %} אינו האיבר הגדול ביותר שעדיין קטן מ-{% equation %}y{% endequation %}. למשל, אם ניקח {% equation %}y=32{% endequation %} אז נקבל {% equation %}C=\left(40,30,28,20,10,1\right){% endequation %}, ואז הפתרון החמדני יהיה {% equation %}30+1+1{% endequation %}, שהוא גם הפתרון האופטימלי. עוד בעיה שיכולה להתעורר היא במקרה שבו {% equation %}c{% endequation %} ממש קטן - למשל, 2.

במקרה הזה אני אבחר את {% equation %}y{% endequation %} להיות גדול מאוד, עם שתי דרכים שונות להקטין אותו - אחת שתכריח אותנו להשתמש ב-1 מכאן ואילך, ואחת שתאפשר לנו להשתמש ב-{% equation %}X{% endequation %}. פורמלית, {% equation %}y=c+T{% endequation %} כאשר {% equation %}T{% endequation %} הוא מספר שגדול מהסכום של כל אברי {% equation %}X{% endequation %}, ונוסיף למערכת שלנו את {% equation %}y-5{% endequation %} ואת {% equation %}T{% endequation %} עצמו. במקרה שלנו {% equation %}40+30+20+10=100{% endequation %} אז בואו נבחר {% equation %}T=200{% endequation %} כי אפשר, ואז עבור {% equation %}c=32{% endequation %} נקבל {% equation %}y=232{% endequation %} ואת המערכת {% equation %}\left(227,200,40,30,20,10,1\right){% endequation %}. הפתרון החמדני הוא {% equation %}227+1+1+1+1{% endequation %} וקל לראות שהוא אופטימלי.

עוד מקרה קצה אחד שבו צריך לטפל הוא זה שבו {% equation %}c-4{% endequation %} גדול מאחד מאברי {% equation %}X{% endequation %}. פתרון פשוט? לכפול את כל אברי {% equation %}X{% endequation %} ב-10 ואת {% equation %}c{% endequation %} ב-10 ולהמשיך משם. אני אשאיר לכם לטפל בפרטים.

זו הייתה רדוקציה במקרה של {% equation %}X{% endequation %} ספציפית, אבל תחליפו את {% equation %}4{% endequation %} ב-{% equation %}n{% endequation %} ותקבלו את הרדוקציה עבור {% equation %}X{% endequation %} כללי - שוב, אני ממליץ לאלו מכם שמעוניינים לשבת ולכתוב אותה פורמלית ולהוכיח שהיא עובדת.

סיימנו! זה היה פוסט ארוך למדי בגלל שהסברתי כל צעד ושעל; אני מקווה שכמות האנשים שנשברו בגלל זה הייתה קטנה מכמות האנשים שהצליחו ללמוד משהו חדש בזכות זה. במילים אחרות, העדפתי את הפתרון האופטימלי על החמדני. או את החמדני על האופטימלי?

