---
id: 204
title: "אוטומטים סופיים ושפות רגולריות"
date: 2009-08-30 17:19:28
layout: post
categories: 
  - חישוביות
  - תורת הסיבוכיות
---
נתקלתי לא מזמן בתוצאה פשוטה אך מקסימה בקומבינטוריקה, שעוסקת באופן שבו ניתן למצוא <a href="http://he.wikipedia.org/wiki/%D7%A4%D7%95%D7%A0%D7%A7%D7%A6%D7%99%D7%94_%D7%99%D7%95%D7%A6%D7%A8%D7%AA">פונקציות יוצרות</a> ל<a href="http://he.wikipedia.org/wiki/%D7%A9%D7%A4%D7%94_%D7%A8%D7%92%D7%95%D7%9C%D7%A8%D7%99%D7%AA">שפות רגולריות</a>. לרוע המזל, כדי להסביר את הקשר צריך להסביר ראשית כל מהן פונקציות יוצרות ומהן שפות רגולריות, ולכן אקדיש לכך את הפוסטים הבאים - בשני המקרים מדובר בנושאים מתמטיים בסיסיים בתחומם ומעניינים מאוד גם בלי הקשר שבינם. אתחיל מהנושא שמוכר לי קצת יותר (לא שאני יכול להתיימר לבקיאות רבה באף אחד מהם) - השפות הרגולריות; זה נושא שניתן לגשת אליו במספר דרכים, ואבחר דרך "חישובית" משהו.

<a href="http://www.gadial.net/2007/09/23/turing_machine/">דיברתי כאן בעבר</a> על המודל המתמטי של חישוב - <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%9B%D7%95%D7%A0%D7%AA_%D7%98%D7%99%D7%95%D7%A8%D7%99%D7%A0%D7%92">מכונת טיורינג</a>. אין צורך להיכנס שום לפרטי המודל, אלא רק לכך שהוא היה מעין מחשב פרימיטיבי מאוד, ועם זאת חזק מספיק כדי להריץ כל תוכנית מחשב קיימת (אולי לא הכי ביעילות). ה"כוח" של מכונת טיורינג נמדד בדרך כלל בכמות המשאבים שמותר לה להשתמש בה, ושני המשאבים העיקריים הם זמן וזיכרון. קשה להפריד את שני המשאבים הללו זה מזה, בגלל שניתן להשיג שיפור בזמן הריצה אם מגדילים את כמות הזכרון (ומה קורה כשמביאים את הגישה הזו לאבסורד <a href="http://www.gadial.net/2009/07/22/bad_math_rsa/">הדגמתי לא מזמן</a>), וגם ניתן לשפר את הזכרון לעתים במחיר זמן ריצה גדול יותר (על כך לא פירטתי ולא אכנס לנושא כעת). לכן דיון בהגבלות סיבוכיות, כדאי שיביא בחשבון את שניהם. אתמקד דווקא במדד הפחות "פופולרי" של סיבוכיות זכרון - הסיבה לכך תתברר בהמשך.

השאלה היא אילו בעיות עדיין ניתן לפתור ככל שאנחנו מצמצמים את צריכת הזכרון של המכונה שלנו. הזכרון שמותר להשתמש בו תמיד נמדד כפונקציה של אורך הקלט, {% equation %}n{% endequation %}; ותמיד מתכוונים ל"זכרון העבודה" בלבד - כלומר, לא כוללים את הזכרון שהקלט עצמו דורש. אם מרשים למכונה להשתמש בכמות פולינומית של זכרון (ולא מגבילים את זמן הריצה), התוצאה היא מחלקת הבעיות PSPACE, שהיא ענקית וכוללת את המחלקה P (שנחשבת ל"מחלקת כל הבעיות שניתנות לפתרון בזמן יעיל"), את NP (שעליה <a href="http://www.gadial.net/2007/12/16/np_haystack/">פירטתי בעבר</a>) ועוד ועוד. אז כמות פולינומית של זכרון זה יותר מדי; השלב הבא הוא לבצע צמצום דרסטי ולהרשות רק כמות לוגריתמית של זכרון, כלומר רק {% equation %}O\left(\log n\right){% endequation %} זכרון. בניסוח מילולי לא פורמלי - מותר להשתמש במעט מאוד זכרון ביחס לגודל הקלט. גם במחלקה המצומצמת הזו, שנקראת L, עדיין יש בעיות מעניינות - המפורסמת שבהן היא בעית הישיגות בגרף לא מכוון (האם ניתן להגיע מצומת א' לצומת ב' בגרף לא מכוון); ההוכחה לכך שבעיה זו פתירה בזכרון לוגריתמי ניתנה בשנת 2004 על ידי מדען המחשב הישראלי עומר ריינגולד (ממכון וייצמן). עם זאת, אני רוצה לחלוף ביעף גם על פני המחלקה המעניינת הזו ולהמשיך לצמצם - כמה עוד אפשר?

מסתבר שלא הרבה. אפשר לדבר גם על המחלקה של הבעיות שפתירות בזכרון {% equation %}O\left(\log\log n\right){% endequation %}, אבל כל מגבלה חריפה עוד יותר מכך תפיל אותנו אל התחתית - זכרון {% equation %}O\left(1\right){% endequation %}. דהיינו - אם אנחנו מרשים רק כמות זכרון קטנה מאוד מאוד מאוד ביחס לקלט, למשל {% equation %}\log\log\log n{% endequation %}, כבר אפשר היה לוותר על זה לחלוטין ולהסתפק בכמות זכרון <strong>קבועה</strong> מבלי לשנות את קבוצת הבעיות שאנו יכולים לפתור. לא אכנס כרגע להוכחה של הטענה הזו, אבל בהחלט ייתכן שאדבר עליה ב<a href="http://www.gadial.net/2009/10/04/sub_loglog_space_is_constant/">פוסט בהמשך</a>, שכן לטעמי היא מעניינת למדי (אם כי לא מסובכת).

אז מעתה ואילך נמקד את הדיון הכי נמוך שרק אפשר - זכרון קבוע. "זכרון קבוע" משמעותו שכמות הזכרון שבה האלגוריתם משתמש אינה תלויה בגודל הקלט בכלל. רק כדי להבין מה זה אומר, למתכנתים שבכם, חשבו על תוכנית שאסור לה לבצע רקורסיות ואסור לה להקצות דינמית זכרון בתוך לולאות, ואסור לה להשתמש במשתנים שגודלם דינמי (כלומר, ספריות של "מספרים שלמים גדולים כרצונך" לא מותרות).

השאלה המעניינת הראשונה היא מה קורה מבחינת סיבוכיות זמן. האם ייתכן שנוכל עדיין לפתור בעיות מסובכות, אם ירשו לנו לרוץ זמן רב מאוד? התשובה (המפתיעה?) שלילית - מסתבר שדי בזמן ריצה <strong>לינארי</strong> באורך הקלט, {% equation %}O\left(n\right){% endequation %}, כדי לפתור את כל מה שבכלל פתיר בזכרון קבוע. יותר מכך - מספיק שהאלגוריתם יקרא כל ביט בקלט בדיוק פעם אחת, יבצע חישוב כלשהו (בזכרון קבוע ובזמן קבוע גם כן) ואז יעבור לביט הבא - ואחרי קריאת כל הביטים, יעצור ויחזיר את הפלט (במקרה שלנו מדברים על פלט של "כן/לא", למרות שאפשר לדבר גם על פלטים אחרים). גם זו תוצאה מפתיעה למדי (לדעתי) ואציג אותה שוב מנקודת מבט שונה עוד מעט.

אם כן, אנחנו רוצים לעבור מדיבורים על מכונות טיורינג לדיבורים על מודל חישובי עוד יותר פרימיטיבי - יש לו רק כמות קבועה של זכרון עבודה (שתלויה באלגוריתם שהוא מריץ אבל לא בקלט הספציפי), הוא רץ על הקלט בדיוק פעם אחת באופן סדרתי, ובסוף מחזיר תשובה. למודל המוגבל הזה קוראים <strong><a href="http://he.wikipedia.org/wiki/%D7%90%D7%95%D7%98%D7%95%D7%9E%D7%98_%D7%A1%D7%95%D7%A4%D7%99">אוטומט סופי</a></strong>. ברשותכם, אתאר את האוטומט הזה בצורה יחסית פורמלית, כולל סימונים מתמטיים - הדבר חשוב לתוצאה שאני רוצה לתאר בסופו של דבר. מי שלא אוהב אותיות יווניות יכול שלא להסתכל על המתמטיקה, בינתיים.

השלב הראשון בהגדרה הפורמלית של המודל הוא לפשט עוד יותר את כל עניין זכרון העבודה. במקום לדבר על סרט זכרון עם ראש קורא וכותב, כמו שיש במכונת טיורינג, מסתפקים בלהגיד שיש לאוטומט "מצבים". אפשר לחשוב על כל מצב כמייצג יחידת מידע בסיסית כלשהי. למשל, אם האוטומט שלנו מנסה לפתור את הבעיה "האם המספר שקיבלת כקלט מתחלק ב-3 ללא שארית?" המצבים שלו יהיו "מה שקראתי עד כה מהקלט הוא מספר שמתחלק ב-3 ללא שארית", "מה שקראתי עד כה מהקלט הוא מספר שמתחלק ב-3 עם שארית 1", ו-"מה שקראתי עד כה מהקלט הוא מספר שמתחלק ב-3 עם שארית 2". מסתבר שדי בשלושת המצבים הללו כדי לפתור את הבעיה. מבחינה פורמלית נוהגים לסמן את קבוצת המצבים של האוטומט באות {% equation %}Q{% endequation %}, ואת המצבים עצמם לסמן בסימונים קומפקטיים, למשל {% equation %}q_{0},q_{1},q_{2}{% endequation %} הם המצבים במקרה של האוטומט שלעיל.

כעת ניתן לתאר את הריצה של אוטומט על קלט כלשהו באופן הבא: האוטומט קורא ביט מהקלט (נניח לצורך העניין שהקלט מיוצג בבסיס בינארי). על בסיס הביט הזה, ועל בסיס המצב הנוכחי שלו, הוא "בוחר" מצב חדש לעבור אליו. כך אחרי כל קריאת ביט האוטומט עובר מצב, ואפשר לתאר את החישוב שלו כולו בתור מעבר בין מצבים, עד שלבסוף מסתיים הקלט והאוטומט צריך להחזיר תשובה. כדי לפשט את החיים עוד יותר, מגדירים מראש קבוצה של "מצבים מקבלים" - אם החישוב מסתיים במצב מקבל, האוטומט מחזיר "כן", אחרת הוא מחזיר "לא". בדוגמה שלנו, {% equation %}q_{0}{% endequation %} הוא מצב מקבל והשאר לא. את קבוצת המצבים המקבלים מסמנים בדרך כלל באות {% equation %}F{% endequation %}.

את האופן שבו האוטומט "בוחר" איך לעבור בין מצבים אפשר לתאר באמצעות פונקציה: {% equation %}\delta\left(q,\sigma\right)=p{% endequation %} אם האוטומט עובר מהמצב {% equation %}q{% endequation %} למצב {% equation %}p{% endequation %} אחרי קריאת התו {% equation %}\sigma{% endequation %}. מי שלא אוהב פונקציות יכול לחשוב על זה בתור "טבלת מעברים" שהשורות בה הן המצבים של האוטומט, והעמודות הן התווים האפשריים לקריאה, כך שבתא שבשורה שמסומנת על ידי {% equation %}q{% endequation %} והעמודה שמסומנת על ידי {% equation %}\sigma{% endequation %} כתוב {% equation %}p{% endequation %} אם האוטומט עובר מהמצב {% equation %}q{% endequation %} למצב {% equation %}p{% endequation %} אחרי קריאת התו {% equation %}\sigma{% endequation %}.

ייתכן שלחלק מכם פתאום מצלצלת בראש המילה "גרף". אכן, אפשר לתאר כל אוטומט באופן ציורי בתור גרף. הנה הגרף של האוטומט שתיארתי כאן:

<img src="{{site.baseurl}}{{site.post_images}}/2009/08/automata.png" alt=""/>
כמו שאפשר לראות, קל מאוד לתאר באמצעות ציור את פונקצית המעברים של האוטומט. חץ שנכנס משום מקום למצב מרמז שזהו המצב ההתחלתי, ומצב שמסומן בעיגול כפול הוא מצב מקבל. עכשיו תוכלו "לשחק" עם האוטומט ולראות שהוא עובד - כתבו מספר כלשהו בבסיס בינארי, "הריצו" את האוטומט על המספר משמאל לימין, כשאתם מתחילים במצב {% equation %}q_{0}{% endequation %}, ותראו לאן תגיעו.

אם כן, זהו המודל הבסיסי. המילה "סופי" בשם האוטומט מרמזת שמספר המצבים שלו הוא סופי (מספר מצבים אינסופי יגרום למודל להיות חזק יותר ממכונת טיורינג, ולמעשה - כל יכול מבחינה חישובית). אפשר קצת להקל על ההנחה המובלעת שלי שהאוטומט יודע לעבוד רק על מספרים בייצוג בינארי, ולהרשות לו לעבוד על סדרות של תווים כלשהם מתוך קבוצה סופית מסויימת - לקבוצה שכזו קוראים "אלפבית" ונהוג לסמן אותה באות {% equation %}\Sigma{% endequation %}. קלט לאוטומט יהיה סדרה סופית של אותיות מתוך {% equation %}\Sigma{% endequation %} - לסדרה כזו נהוג לקרוא "מילה", ולאוסף של מילים - "שפה". המילה "שפה" אולי קצת מטעה כאן - באמצעות סדרות סופיות כאלו של תווים אפשר לתאר דברים רבים ושונים - מספרים שלמים, גרפים, רצפים של DNA, קבצי וידאו, מודל של מערכת השמש וכו'.

לסיום נחזור להערה שהערתי בהתחלה. המודל שתיארתי כאן קורא את הקלט סדרתית, ביט אחרי ביט, ולא חוזר אחורה אף פעם. ניתן להוכיח (וההוכחה אינה פשוטה) שמודל זה שקול למודל שכן מותר לו לחזור אחורה - למעשה, שיכול ללכת קדימה ואחורה כאוות נפשו. במילים אחרות, אין <strong>צורך</strong> בקריאת כל תו קלט יותר מפעם אחת. זה מוביל מייד למסקנה שאם הגבלנו את כמות הזכרון שלנו ל-{% equation %}O\left(1\right){% endequation %}, אז <strong>אין צורך</strong> בזמן ריצה גדול יותר מ-{% equation %}O\left(n\right){% endequation %} (אבל זמן ריצה כזה הוא הכרחי; לפעמים כל תו במילה יכול לשנות התשובה שיש להחזיר עליה, והאוטומט שנתתי לעיל הוא דוגמה לכך, ועל כן חייבים לקרוא את כל הקלט).

אם יש לנו אוטומט, אז אוסף המילים שעליהן הוא אומר "כן" הוא "השפה שמקבל האוטומט". לשפה כזו, שיש אוטומט סופי שמזהה אותה, קוראים <strong>שפה רגולרית</strong>. השאלה הראשונה שקופצת לראש היא מהן, אם כן, כל השפות הרגולריות - האם יש להן אפיון פשוט? למרבה השמחה, מתברר שכן. כל שפה סופית היא רגולרית (כי כל מה שצריך לעשות הוא להשוות את מילת הקלט לרשימה סופית ונתונה מראש של מילים - אין צורך בזכרון עבודה שתלוי בגודל הקלט כדי לעשות זאת). אם יש שתי שפות רגולריות, גם איחודן - השפה שהמילים בה הן מילים ששייכות לפחות לאחת משתי השפות המקוריות - הוא רגולרי. בנוסף לכך, יש עוד שתי פעולות הרכבה מתוחכמת יותר שניתן לבצע על שפות כדי לקבל שפה רגולרית.

ראשית, אם יש לנו שתי מילים כלשהן, {% equation %}u,v{% endequation %}, אז אפשר לדבר על ה<strong>שרשור</strong> שלהן, שמסומן ב-{% equation %}u\cdot v{% endequation %} - זו פשוט מילה שמתחילה ב-{% equation %}u{% endequation %}, ואחרי ש-{% equation %}u{% endequation %} נגמרת, מתחילה {% equation %}v{% endequation %}. למשל, אם {% equation %}u=101{% endequation %} ואילו {% equation %}v=110{% endequation %}, אז השרשור שלהן הוא {% equation %}u\cdot v=101110{% endequation %}. כעת אפשר לדבר גם על שרשור של שפות - שרשור שתי שפות {% equation %}L_{1},L_{2}{% endequation %} הוא אוסף כל המילים שהן שרשור של מילה מ-{% equation %}L_{1}{% endequation %} עם מילה מ-{% equation %}L_{2}{% endequation %}. בצורה פורמלית, {% equation %}L_{1}\cdot L_{2}=\left\{ u\cdot v|u\in L_{1},v\in L_{2}\right\} {% endequation %}.

בעזרת פעולת השרשור אפשר להגדיר גם פעולת "חזקה" - {% equation %}L^{i}{% endequation %} הוא פשוט שרשור של {% equation %}L{% endequation %} עם עצמה בדיוק {% equation %}i{% endequation %} פעמים. ניתן להראות ששרשור של שתי שפות רגולריות הוא שפה רגולרית בעצמו, ולכן גם חזקה כלשהי של שפה תהיה רגולרית. אלא שכל הפעולות הללו הן סופיות במהותן - אם נפעיל אותן על שפות סופיות, נקבל שוב שפות סופיות, אבל הרי יש גם שפות לא סופיות שהן רגולריות, כמו זו בדוגמת ההתחלקות ב-3 שנתתי. אז מה עוד חסר?

הפעולה הנוספת אינה כה מסובכת. כבר הסכמנו שלכל {% equation %}i{% endequation %}, החזקה ה-{% equation %}i{% endequation %}-ית של {% equation %}L{% endequation %} רגולרית היא בעצמה רגולרית. אם כן, למה לא לבנות שפה שמורכבת מאיחוד <strong>כל</strong> החזקות הללו? מכאן מגיעה ההגדרה הפורמלית של "סגור קלייני" (Kleene) {% equation %}L^{*}=\bigcup_{i=0}^{\infty}L^{i}{% endequation %} ({% equation %}L^{0}{% endequation %} מוגדרת בתור שפה שמכילה רק את המילה הריקה - מושג טכני שלא אכנס אליו כאן). ניתן להוכיח כי גם {% equation %}L^{*}{% endequation %} רגולרית אם {% equation %}L{% endequation %} רגולרית (ולעתים אף יותר מכך - תוצאה יפה ומעניינת היא שאם האלפבית של המילים בשפה {% equation %}L{% endequation %} כלשהי מכיל תו בודד, אז {% equation %}L^{*}{% endequation %} תהיה תמיד רגולרית). מה שעוד ניתן להוכיח והוא הפאנץ' של כל זה הוא ש<strong>כל</strong> שפה רגולרית יכולה להתקבל מהשפות הסופיות על ידי הפעלות נשנות של שלוש הפעולות שהצגתי - איחוד, שרשור וסגור קלייני. האפיון הזה הוא הבסיס לעיסוק בביטויים הרגולריים - עוד נושא שראוי לפוסט נפרד.

אם כן, "שדה המשחק" של השפות הרגולריות הוא יחסית ברור. בדרך כלל הדיון ממשיך מכאן לכיוון מציאת תכונות סגור נוספות ואפיונים נוספים של שפות רגולריות, אך כאמור - אני רוצה לעבור כעת לקומבינטוריקה ולדבר על פונקציות יוצרות. על כך - בפוסט הבא.

