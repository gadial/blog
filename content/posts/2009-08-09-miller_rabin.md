---
id: 202
title: "אז איך באמת בודקים ראשוניות (בעזרת אלגוריתם מילר-רבין)?"
date: 2009-08-09 15:02:06
layout: post
categories: 
  - מבני נתונים ואלגוריתמים
  - קריפטולוגיה
  - תורת המספרים
tags: 
  - אלגוריתמים הסתברותיים
  - המשפט הקטן של פרמה
  - מספרים ראשוניים
social_media_share: true
---
<a href="http://www.gadial.net/2009/07/22/bad_math_rsa/">בפוסט הקודם</a> הזכרתי את אלגוריתם מילר-רבין ההסתברותי לבדיקת <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A1%D7%A4%D7%A8_%D7%A8%D7%90%D7%A9%D7%95%D7%A0%D7%99">ראשוניות</a>, ובפוסט הזה אני רוצה להרחיב קצת על הנושא - למה בכלל צריך לבדוק ראשוניות, ואיך אפשר לבדוק דבר כזה באופן הסתברותי, ומה זה בכלל אומר. כמובן שאציג גם את האלגוריתם עצמו, אבל לא אכנס לפרטי ההוכחה שהוא אכן עובד אלא אסתפק ברעיונות המרכזיים. למעשה, דרך ההצגה שלי תהיה קצת שקרית ואסביר זאת בהמשך.

נתחיל מהצורך הכללי במבחנים שכאלו. מבחן לבדיקת ראשוניות נדרש לרוב כשאנחנו רוצים למצוא מספר ראשוני "אקראי". מכיוון שלא מוכרות דרכים טובות במיוחד (עדיין...) לייצר מספר ראשוני אקראית, פשוט מגרילים מספר כלשהו בתחום שממנו רוצים לדגום את הראשוני, ואז בודקים שהוא ראשוני (כפי שהסברתי בפוסט הקודם, משפט המספרים הראשוניים מבטיח שלא נצטרך יותר מדי הגרלות). להגריל מספר זה קל גם כשמדובר במספרים גדולים יחסית; זו בדיקת הראשוניות שלו שעושה לנו צרות (השאלה "אבל למה בכלל צריך ראשוניים גדולים?" היא שאלה אחרת שרוב התשובות המוכרות לי אליה קשורות לקריפטוגרפיה).

הדרך הפשוטה לבדוק ראשוניות של מספר {% equation %}n{% endequation %} היא לעבור אחד אחד על כל המספרים הקטנים מ-{% equation %}n{% endequation %} אבל גדולים מ-1 ולבדוק אם הם מחלקים אותו ללא שארית. אם נמצא כזה, המספר אינו ראשוני (זו ההגדרה של ראשוני - מספר המתחלק רק בעצמו וב-1). לתעלול הזה יש אופטימיזציה פשוטה - אם {% equation %}a{% endequation %} מחלק את {% equation %}n{% endequation %}, כך גם {% equation %}n/a{% endequation %} (כי מה זה אומר ש-{% equation %}a{% endequation %} מחלק את {% equation %}n{% endequation %}? שקיים {% equation %}b{% endequation %} כך ש-{% equation %}n=ab{% endequation %}, כלומר גם {% equation %}b=n/a{% endequation %} מחלק את {% equation %}n{% endequation %} ללא שארית), ואם {% equation %}a{% endequation %} גדול מהשורש של {% equation %}n{% endequation %}, אז {% equation %}b{% endequation %} יהיה קטן ממנו (כי אם {% equation %}a,b>\sqrt{n}{% endequation %} אז {% equation %}n=a\cdot b>\sqrt{n}\cdot\sqrt{n}=n{% endequation %} - סתירה). לכן מספיק לבדוק את המספרים הקטנים מ-{% equation %}n{% endequation %} "עד השורש" של {% equation %}n{% endequation %}. זמן הריצה של האלגוריתם הזה יהיה {% equation %}O\left(\sqrt{n}\right){% endequation %}, זמן ריצה שנחשב טוב מאוד כשמתעסקים באלגוריתמים (להשוואה, זמן הריצה של אלגוריתמי המיון הכלליים הוא {% equation %}O\left(n\log n\right){% endequation %}). אם כן, מה הבעיה?

הבעיה היא שבכל הנוגע למספרים, מה שחשוב הוא לא גודל המספר עצמו אלא גודל הייצוג שלו - מספר הביטים שדרושים כדי לאחסן אותו בזכרון. כדי לאחסן את {% equation %}n{% endequation %}, צריך {% equation %}\lg n{% endequation %} ביטים ({% equation %}\lg{% endequation %} הוא <a href="http://he.wikipedia.org/wiki/%D7%9C%D7%95%D7%92%D7%A8%D7%99%D7%AA%D7%9D">לוגריתם</a> על בסיס 2 - אם {% equation %}\lg n=k{% endequation %} זה אומר ש-{% equation %}n=2^{k}{% endequation %}; כמובן ש-{% equation %}k{% endequation %} עשוי שלא להיות מספר שלם, אז נעגל למעלה כשנצטרך להתייחס אליו כשלם). הסיבה שגודל הייצוג הוא מה שחשוב היא שהזמן שלוקח לבצע פעולות חשבון בסיסיות על מספרים - חיבור, חיסור, כפל, חילוק, השוואה בין שני מספרים - נמדד ביחס ל-{% equation %}\lg n{% endequation %}, לא ל-{% equation %}n{% endequation %}. למשל, השוואה של שני מספרים דורשת {% equation %}\lg n{% endequation %} פעולות (חשבו על הצורה שבה אתם משווים שני מספרים שנתונים בבסיס עשרוני - אתם פשוט משווים ספרה ספרה), חיבור שלהם דורש {% equation %}\lg n{% endequation %} פעולות (מחברים "ספרה ספרה" ולכל היותר זוכרים בע"פ שצריך להוסיף 1 לתוצאת החיבור הבאה), כפל דורש (במימוש נאיבי, כמו זה שתלמידים בבית הספר לומדים לבצע) {% equation %}\lg^{3}n{% endequation %} פעולות, וכדומה. זה אומר שקל לנו לבצע פעולות על מספרים ענקיים, בני 500 ספרות ויותר (וגם מספרים בני מיליון ספרות הם עדיין משהו שאפשר להתמודד איתו), בזמן שלעבור על כל המספרים בני 500 ספרות, אפילו "עד השורש", זה לחלוטין לא פרקטי. זו הייתה גם הנקודה המרכזית בפוסט הקודם שלי.

אם כן, אלגוריתם טוב לבדיקת ראשוניות צריך להיות בעל זמן ריצה שהוא לכל היותר חזקה כלשהי ב-{% equation %}\lg n{% endequation %}. כזה הוא מילר רבין, שזמן ריצתו חסום על ידי {% equation %}O\left(\lg^{3}n\right){% endequation %} (זמן ריצה מעולה עבור אלגוריתם שמבצע בדיקה של דבר מה "מסובך" כראשוניות). <a href="http://en.wikipedia.org/wiki/AKS_primality_test">אלגוריתם AKS </a>המפורסם לבדיקת ראשוניות - היחיד שידוע כיום שעובד באופן דטרמיניסטי ובזמן "סביר" לכל הראשוניים - דורש זמן ריצה של מעט יותר מ-{% equation %}O\left(\lg^{6}n\right){% endequation %}, כלומר הוא פחות יעיל בכמה סדרי ממילר-רבין, ולכן עדיין מעדיפים את מילר-רבין בשימושים פרקטיים (דוגמת זה של הספריה OpenSSL שקישרתי אליה בפוסט הקודם). זה לא אומר שאין יישומים של AKS או שאי אפשר להשתמש בו אם רוצים לוודא ב-100 אחוזים סופר-דופר שמספר הוא ראשוני; אבל כמו שאסביר בהמשך (בפוסט נפרד), האקראיות של מילר-רבין נותנת 99 אחוזים (למעשה, אפילו יותר - אבל על כך בפוסט הבא) שלרוב הוא די והותר בשבילנו (ופרט ל-AKS יש עוד מבחנים שמוכיחים בודאות שמספר הוא ראשוני, אך לא מובטח שהם תמיד יעבדו בזמן פולינומי למרות שלעתים קרובות הם מהירים למדי, וגם על זה אפרט בעתיד).

איך ניגשים בכלל לבניית אלגוריתמים לבדיקת ראשוניות? האינסטינקט הראשון שלי אומר שצריך למצוא דרך מתוחכמת יותר לעבור על מספרים שהם "בעלי פוטנציאל" לחלק את {% equation %}n{% endequation %} ולבדוק אותם. למשל, אם בדקתי את 2 והוא לא חילק את {% equation %}n{% endequation %}, ברור שגם 4 וגם 8 (וגם כל מספר אחר שמתחלק ב-2) לא יחלקו אותו אז לא צריך לבדוק אותם. אולי אפשר להסתפק בתת-קבוצה קטנה כלשהי?

אלא שהגישה הזו היא ללכת עם הראש בקיר, בראש ובראשונה כי היא לא מנסה לפתור את בעיית בדיקת הראשוניות אלא בעיה אחרת, קשה ממנה - בעית הפירוק לגורמים: בהינתן {% equation %}n{% endequation %}, למצוא מחלק לא טריוויאלי של {% equation %}n{% endequation %} (ה"טריוויאליים" הם 1 ו-{% equation %}n{% endequation %} עצמו). בעיית הפירוק לגורמים היא בעלת היסטוריה מרתקת משל עצמה ואלגוריתמים מחוכמים משל עצמה שפותרים אותה; אבל אף אחד מהם עדיין לא נחשב "יעיל" במובן זה שהוא פולינומי ב-{% equation %}\lg n{% endequation %}, וגם הם פועלים בצורה שונה מסתם בדיקה של מספרים שהם בעלי פוטנציאל לחלק את {% equation %}n{% endequation %} (בתור התחלה, הם מסתמכים על כך שדי למצוא מספר {% equation %}m{% endequation %} שאינו זר ל-{% equation %}n{% endequation %} ואינו מתחלק על ידו, כלומר שיש להם מחלק משותף לא טריוויאלי שהוא גם מחלק לא טריוויאלי של {% equation %}n{% endequation %}; אם נמצא {% equation %}m{% endequation %} כזה, קל למצוא את המחלק המשותף המדובר באמצעות <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%97%D7%9C%D7%A7_%D7%9E%D7%A9%D7%95%D7%AA%D7%A3_%D7%9E%D7%A7%D7%A1%D7%99%D7%9E%D7%9C%D7%99">האלגוריתם האוקלידי</a>. על כל זה אפשר וכדאי להרחיב בפעם אחרת).

בקיצור, את בעיית הראשוניות כדאי לתקוף מכיוון שונה לגמרי, מה שמבחינה "פילוסופית" נראה מסקרן - איך אפשר לבדוק האם מספר הוא ראשוני מבלי לבדוק כלל מספרים שאולי מחלקים אותו ואולי לא? וכאן נכנס לתמונה אספקט יפה של המתמטיקה, שאכנה אותו כאן (בצורה שהיא כנראה לא מדוייקת במיוחד) "לוקלי מול גלובלי". בדיקה נאיבית מהסוג שהצעתי היא "לוקלית" - היא מסתמכת על התכונה "המספר שאני בודק כרגע מחלק את {% equation %}n{% endequation %}", כשהבעייתיות נעוצה בעובדה שיכולים להיות מעט מאוד מספרים שמקיימים את התכונה הלוקלית הזו וקשה למצוא אותם. במקום בדיקות לוקליות שכאלו אפשר לבצע בדיקה "גלובלית" שבודקת תכונה של אובייקט מתמטי כללי יותר שמוגדר באמצעות {% equation %}n{% endequation %} - החבורה הכפלית מודולו {% equation %}n{% endequation %}, תכף אסביר בפירוט - ומקיים את התכונה אם {% equation %}n{% endequation %} ראשוני, ואחרת לא מקיים אותה. בדיקת התכונה הזו תתבסס גם היא על דגימה אקראית של איברים מתוך האובייקט; אבל מכיוון שהתכונה היא "גלובלית" (שוב, קחו את המילים הללו בצורה הכי לא פורמלית שאפשר), כמות האיברים שמעידים על כך שהתכונה "נכשלת" תהיה גדולה - נניח, יותר מחצי מהאיברים במרחב המדגם שלנו.

האתגר הוא כמובן למצוא תכונות "גלובליות" שכאלו, ומה שמילר-רבין עושה למעשה הוא להשתמש בשתי תכונות גלובליות שונות; כשהאחת נכשלת (במובן זה של "לא מספקת עדות טובה לכך שהמספר לא ראשוני"), מובטח שהשניה תעבוד לעתים קרובות; ומה שנחמד הוא שאפשר לבדוק את שתיהן גם יחד. נתחיל מהתכונה הראשונה - היא מתבססת על מה שמכונה "<a href="http://he.wikipedia.org/wiki/%D7%94%D7%9E%D7%A9%D7%A4%D7%98_%D7%94%D7%A7%D7%98%D7%9F_%D7%A9%D7%9C_%D7%A4%D7%A8%D7%9E%D7%94">המשפט הקטן של פרמה</a>" שהוא האבחנה שעבור כל מספר ראשוני {% equation %}p{% endequation %} וכל מספר אחר {% equation %}a{% endequation %} שאינו מתחלק בידי {% equation %}p{% endequation %}, מתקיים ש-{% equation %}a^{p-1}-1{% endequation %} מתחלק על ידי {% equation %}p{% endequation %}. למשל, אם ניקח {% equation %}p=5{% endequation %}, נקבל שכל מספר {% equation %}a{% endequation %} שאינו מתחלק ב-5 מקיים ש-5 מחלק את {% equation %}a^{4}-1{% endequation %} (קחו {% equation %}a=2{% endequation %}; {% equation %}2^{4}-1=16-1=15{% endequation %} שמתחלק ב-5, וכו' וכו'). בניסוח מודרני מסמנים זאת כ-{% equation %}a^{p-1}\equiv_{p}1{% endequation %} (קראו את השוויון שבאמצע כ"שקול מודולו {% equation %}p{% endequation %}" - המשמעות הפורמלית היא בדיוק שהפרש שני האגפים מתחלק ב-{% equation %}p{% endequation %}, או אם תרצו, שחלוקת כל אחד מהאגפים ב-{% equation %}p{% endequation %} נותן את אותה שארית).

פרמה גילה את המשפט מתוך משחקים במספרים והעלאת השערות; אוילר הוכיח לאחר מכן גרסה כללית יותר שלו, התקפה לכל מספר {% equation %}n{% endequation %} ולא רק לראשוניים; בגרסה זו, החזקה שבה מעלים את {% equation %}a{% endequation %} היא שונה (היא {% equation %}\phi\left(n\right){% endequation %} - פונקצית אוילר של {% equation %}n{% endequation %}, למי שמכיר) והיא תהיה {% equation %}n-1{% endequation %} אך ורק אם {% equation %}n{% endequation %} ראשוני. אם כן, יש לנו קריטריון כלשהו לראשוניות: {% equation %}n{% endequation %} אינו ראשוני אם {% equation %}a^{n-1}-1{% endequation %} לא מתחלק על ידי {% equation %}n{% endequation %}. לכן אלגוריתם לבדיקת ראשוניות {% equation %}n{% endequation %} (אלגוריתם אמיתי, שנקרא על שם פרמה) יעבוד כך: בהינתן {% equation %}n{% endequation %}, הגרל {% equation %}a{% endequation %} שאינו מתחלק על ידי {% equation %}n{% endequation %}, חשב את {% equation %}a^{n-1}-1{% endequation %} ובדוק אם הוא מתחלק ב-{% equation %}n{% endequation %}. אם לא, מובטח ש-{% equation %}n{% endequation %} לא ראשוני. אם כן, בסבירות לא רעה {% equation %}n{% endequation %} ראשוני (על עניין הסבירויות ארחיב בהמשך). מצאנו את האלגוריתם שרצינו.

האמנם?

צריך להיות זהירים פה. אמנם, המשפט של אוילר לא עובד עבור החזקה {% equation %}n-1{% endequation %} אם {% equation %}n{% endequation %} אינו ראשוני, אבל זה רק אומר ש<strong>לא מובטח</strong> לנו שמתקיים {% equation %}a^{n-1}\equiv_{n}1{% endequation %}; זה בכל זאת עשוי לקרות לפעמים (למשל, אם {% equation %}a=1{% endequation %} זה יקרה תמיד). מה שהיינו רוצים שיקרה הוא שתתקיים תוצאה כמו "אם {% equation %}n{% endequation %} אינו ראשוני, אז יש המון ערכים של {% equation %}a{% endequation %} שעבורם {% equation %}a^{n-1}-1{% endequation %} אינו מתחלק ב-{% equation %}n{% endequation %}" כי כל מספר {% equation %}a{% endequation %} כזה "מוכיח" לנו ש-{% equation %}n{% endequation %} אינו ראשוני. זה נכון לעתים קרובות; אלא שלרוע המזל, זה לא נכון תמיד. למעשה, יש מספרים פריקים שעבורם <strong>לכל</strong> {% equation %}a{% endequation %} (שאין לו ול-n מחלקים משותפים, אבל הסיכוי להגריל {% equation %}a{% endequation %} כזה הוא כמו הסיכוי לפרק לגורמים את {% equation %}n{% endequation %} "במזל") מתקיים {% equation %}a^{n-1}\equiv_{n}1{% endequation %}, כלומר מספרים פריקים ש"בכל זאת" מקיימים את המשפט הקטן של פרמה ככתבו וכלשונו. למספרים הללו קוראים <strong><a href="http://en.wikipedia.org/wiki/Carmichael_number">מספרי קרמייקל</a></strong>; הקטן ביותר שבהם הוא 561. התכונות שלהם ידועות לא רע - למשל, ניתן להוכיח די בקלות שכל מספר קרמייקל חייב להיות מכפלה של ראשוניים אי זוגיים שונים זה מזה (כלומר, מספר כמו {% equation %}3\cdot3{% endequation %} או {% equation %}2\cdot3{% endequation %} הוא מחוץ למשחק מראש); לא ניכנס לזה עכשיו. הנקודה היא שיש קבוצה ספציפית של מספרים "מרגיזים", עם אפיונים ספציפיים משל עצמה, שעבורם השיטה של משפט פרמה <strong>נכשלת לחלוטין</strong>.

אז מה עושים? מחפשים עוד קריטריון ש"מתקלקל" כש-{% equation %}n{% endequation %} אינו ראשוני. לכאורה חזרנו לנקודת ההתחלה, אבל למעשה מצבנו טוב יותר מאשר קודם, כי המבחן של הקריטריון הנוכחי נותן לנו מוטיבציה לקריטריון הבא. לשם כך עלינו להסביר קודם כל איך בדיוק אפשר לבדוק את הקריטריון של פרמה. אמרתי קודם שהבדיקה פשוטה - מגרילים {% equation %}a{% endequation %} ומחשבים את {% equation %}a^{n-1}-1{% endequation %}, אבל איך עושים את זה אם {% equation %}n{% endequation %} עצום? יש כאן שתי בעיות מהותיות - ראשית, אם {% equation %}n{% endequation %} עצום, גם {% equation %}a^{n-1}-1{% endequation %} יהיה עצום - אבל עצום ברמה גדולה פי כמה, כך שלא יהיה שום סיכוי לשמור אותו במחשב; ושנית, זמן החישוב של {% equation %}a^{n-1}-1{% endequation %} יהיה גם הוא עצום אם ננקוט בשיטה הנאיבית - לכפול את {% equation %}a{% endequation %} בעצמו {% equation %}n-1{% endequation %} פעמים. כבר עדיף לעבור על כל המספרים שקטנים מ-{% equation %}n{% endequation %} וחסל. אם כן, מה עושים?

הפתרון לבעיה הראשונה פשוט. לא חייבים לחשב את {% equation %}a^{n-1}{% endequation %} עצמו; אפשר להסתפק בחישוב השארית של {% equation %}a^{n-1}{% endequation %} כשהוא מחולק ב-{% equation %}n{% endequation %}. הצורה שבה עושים זאת פשוטה - במהלך החישובים שלנו, בכל פעם שבה מתקבל מספר גדול מ-{% equation %}n{% endequation %}, פשוט מחלקים אותו ב-{% equation %}n{% endequation %} ומשאירים רק את השארית. לא קשה לראות שזה עובד. בפועל מה שאנחנו עושים כאן הוא להפסיק לעבוד עם שלמים ולהתחיל לעבוד עם מה שנקרא "חוג השלמים מודולו {% equation %}n{% endequation %}". לצורך העניין מספיק לחשוב עליהם בתור אוסף כל המספרים הטבעיים הקטנים מ-{% equation %}n{% endequation %} עם פעולות החיבור והכפל הרגילות, פרט לכך שאחרי שהן מבוצעות מחלקים ב-{% equation %}n{% endequation %} ולוקחים את השארית. מעכשיו בכל פעם שבה אכתוב משהו כמו {% equation %}a^{n-1}{% endequation %} הכוונה יהיה לאיבר שמקבלים באותה חבורה אחרי ש-{% equation %}a{% endequation %} מועלה בחזקת {% equation %}n-1{% endequation %}; ואם אכתוב {% equation %}-1{% endequation %}, הכוונה יהיה לאיבר המקביל לו בחבורה הזו, שהוא {% equation %}n-1{% endequation %} (הם מייצגים את אותו האיבר שכן ההפרש שלהם מתחלק ב-{% equation %}n{% endequation %}). מכיוון שכל המספרים שעובדים איתם הם קטנים מ-{% equation %}n{% endequation %} (שהוא מספר "סביר" מבחינת זה שפעולות החשבון הרגילות קלות לביצוע עבורו), נפטרנו מהבעיה הראשונה.

כעת לבעיה השניה. האבחנה המרכזית כאן היא שלא חייבים לכפול את {% equation %}a{% endequation %} בעצמו {% equation %}n-1{% endequation %} פעמים כדי לחשב את {% equation %}a^{n-1}{% endequation %}. הנה דוגמה פשוטה לדרך שבה אפשר לבצע קיצורים: נניח שאני רוצה לחשב את {% equation %}a^{16}{% endequation %} במעט פעולות כפל. מה שאעשה יהיה ראשית לכפול את {% equation %}a{% endequation %} בעצמו ולקבל {% equation %}a^{2}{% endequation %}. כעת, במקום לכפול את התוצאה שוב ב-{% equation %}a{% endequation %}, אכפול את התוצאה בעצמה, כלומר אבצע את החישוב {% equation %}a^{2}\cdot a^{2}=a^{4}{% endequation %}. את התוצאה שוב אכפול בעצמה ואקבל {% equation %}a^{8}{% endequation %}, ואת זה שוב אכפול בעצמו ואקבל {% equation %}a^{16}{% endequation %}. סיימנו, וביצענו רק ארבע פעולות כפל במקום שש עשרה.

בואו ננסה משהו יותר מתוחכם. נניח שאנחנו רוצים לחשב את {% equation %}a^{13}{% endequation %} עכשיו. מה עושים? פתרון פשוט הוא זה: כבר חישבנו לפני רגע את {% equation %}a^{4}{% endequation %} ואת {% equation %}a^{8}{% endequation %}, אז פשוט נכפול אותם זה בזה וב-{% equation %}a{% endequation %} ונקבל {% equation %}a\cdot a^{4}\cdot a^{8}=a^{13}{% endequation %}. כאן הסתמכנו על כך שניתן לכתוב את 13 כסכום של חזקות של 2: {% equation %}13=1+4+8{% endequation %}. מכיוון שאפשר לכתוב כל מספר באמצעות סכום של חזקות של 2 (זוהי פשוט ההצגה של המספר בבסיס בינארי), התעלול הזה עובד תמיד. הפאנץ' הוא שאם אנחנו רוצים להעלות בחזקת {% equation %}n{% endequation %} מספר כלשהו, אנחנו צריכים לחשב רק {% equation %}\lg n{% endequation %} איברים של {% equation %}a{% endequation %} בחזקת חזקות של 2 (למה? כי אנחנו צריכים את כל החזקות מהצורה {% equation %}2^{i}{% endequation %} עבורן {% equation %}2^{i}\le n{% endequation %}, כלומר {% equation %}i\le\lg n{% endequation %}) ולכפול את החזקות הרלוונטיות.

מה שאלגוריתם מילר-רבין עושה הוא לחשב את {% equation %}a^{n-1}{% endequation %} בצורה דומה מאוד אבל לא זהה לגמרי - יש עוד טוויסט אחד, שהוא זה שעושה את כל ההבדל. הנה עוד דוגמה - נניח שאנחנו רוצים לחשב את {% equation %}a^{24}{% endequation %}. אפשר לעשות זאת בשתי דרכים: או לחשב את {% equation %}a^{8}{% endequation %} ו-{% equation %}a^{16}{% endequation %} ולכפול אותם, כפי שכבר ראינו; אבל אפשר גם לחשב את {% equation %}a^{3}{% endequation %} ואז להעלות אותו שוב ושוב בריבוע, עד שמגיעים ל-{% equation %}a^{24}{% endequation %}. כדי להבין למה זה עובד, נשים לב לכך ש-{% equation %}24=3\cdot2^{3}{% endequation %}. כלומר, אפשר לכתוב את המספר הזה בתור מכפלה של מספר אי זוגי וחזקה כלשהי של 2, ואז {% equation %}a^{24}=\left(a^{3}\right)^{2^{3}}{% endequation %}, כלומר ניתן לכתוב את {% equation %}a^{24}{% endequation %} בתור העלאה בריבוע שלוש פעמים ברצף של {% equation %}a^{3}{% endequation %}. זה עובד גם באופן כללי, כמובן: כדי לחשב את {% equation %}a^{n-1}{% endequation %} אפשר לכתוב {% equation %}n-1=m\cdot2^{k}{% endequation %} כאשר {% equation %}m{% endequation %} אי זוגי, ואז לחשב את {% equation %}a^{m}{% endequation %}, ואותו להעלות בריבוע {% equation %}k{% endequation %} פעמים. כשמסיימים, בודקים אם קיבלנו 1 או לא.

אבל למעשה, אפשר לקצר את התהליך. נניח שחישבנו את {% equation %}a^{m}{% endequation %} וקיבלנו 1; אז גם כשנעלה אותו בריבוע, ולא משנה כמה פעמים, נקבל 1. לכן אפשר לעצור כבר כאן ולהגיד שהמבחן הצליח (כלומר, נתן לנו תחושה טובה בבטן ש-{% equation %}n{% endequation %} הוא ראשוני). באופן דומה, אם חישבנו את {% equation %}a^{m}{% endequation %} וקיבלנו {% equation %}-1{% endequation %} אפשר לעצור - אחרי העלאה אחת בריבוע נקבל 1, ומכאן ואילך נמשיך לקבל 1. באותו אופן, אם {% equation %}a^{m}{% endequation %} לא היה לא {% equation %}1{% endequation %} ולא {% equation %}-1{% endequation %}, היינו מצפים שמתישהו במהלך ההעלאות בריבוע שלו נקבל 1, וכאן נמצא לב לבו של מילר-רבין, והקריטריון הנכסף שלנו - איך מספר {% equation %}x{% endequation %} שקודם לכן לא היה 1 הופך ל-1 אחרי שמעלים אותו בריבוע (מודולו {% equation %}n{% endequation %})? מה {% equation %}x{% endequation %} יכול להיות?

תשובת המחץ היא זו: אם {% equation %}n{% endequation %} הוא ראשוני, {% equation %}x{% endequation %} יכול להיות רק {% equation %}1{% endequation %} (אבל אמרנו שהוא לא) או {% equation %}-1{% endequation %} (שכזכור, מסמן את {% equation %}n-1{% endequation %}). לעומת זאת, אם {% equation %}n{% endequation %} אינו ראשוני, יכולים להיות ערכים נוספים שמקיימים זאת - "שורשים לא טריוויאליים של 1". לדוגמה, אם {% equation %}n=8{% endequation %} אז מתקיים די בבירור {% equation %}7^{2}=49\equiv_{8}1{% endequation %} (ו-{% equation %}7{% endequation %} הוא בעצם מה שאנחנו מסמנים כ-{% equation %}-1{% endequation %}) אבל מתקיים גם {% equation %}5^{2}=25\equiv_{8}1{% endequation %}, ולכן {% equation %}5{% endequation %} הוא שורש לא טריוויאלי של 1. מכאן שבמהלך החישוב של מילר-רבין, עבור ערך "מוצלח" של {% equation %}a{% endequation %}, ה-1 המובטח בסוף הדרך יתקבל דרך שורש לא טריוויאלי של 1, ואז נדע <strong>בודאות</strong> ש-{% equation %}n{% endequation %} אינו ראשוני.

נסכם: האלגוריתם של מילר-רבין בוחר באקראי {% equation %}a{% endequation %} קטן מ-{% equation %}n{% endequation %} וזר לו (אם הוא אינו זר לו, קל לגלות זאת בעזרת האלגוריתם האוקלידי, וזה גם יוכיח ש-{% equation %}n{% endequation %} אינו ראשוני). הוא מחשב את {% equation %}a^{n-1}{% endequation %} על ידי כך שהוא מפרק את {% equation %}n-1{% endequation %} למכפלה {% equation %}n-1=m\cdot2^{k}{% endequation %} (איך עושים זאת? מחלקים את {% equation %}n-1{% endequation %} שוב ושוב ב-2 עד שמתקבל מספר אי זוגי), מחשב את {% equation %}a^{m}{% endequation %} בצורה מהירה בשיטת קיבוץ החזקות של 2 שהראיתי (או בשיטות אחרות - יש כאלו), ואז מעלה אותו בריבוע {% equation %}k{% endequation %} פעמים תוך שהוא בודק אם במהלך החישוב צץ לו שורש לא טריוויאלי של 1 (מספר שהיה שונה מ-1 ומ-{% equation %}-1{% endequation %} אבל הפך ל-1 אחרי העלאתו בריבוע). אם צץ כזה שורש, או אם בסוף החישוב, כשהתקבל {% equation %}a^{n-1}{% endequation %}, התוצאה עדיין שונה מ-1, האלגוריתם דוחה; אחרת הוא אומר "סביר להניח ש-{% equation %}a{% endequation %} ראשוני, אם כי אני לא בטוח".

וכאן נכנסת לתמונה השאלה האחרונה - כמה בטוחים אנחנו יכולים להיות? מה שרבין הוכיח (בהוכחה לא מסובכת אבל מעט טכנית שאני מעדיף לא להיכנס אליה) הוא שלכל {% equation %}n{% endequation %} פריק שרק נרצה - בין אם הוא קרמייקל ובין אם לאו - לכל היותר רבע מה-{% equation %}a{% endequation %}-ים שאנחנו עשויים לבחור יכולים להטעות אותנו; כל היתר אכן יגרמו לדחייה באחת מהדרכים המתוארות (או שבמהלך ריצת האלגוריתם עליהם יצוץ שורש לא טריוויאלי של 1, או ש-{% equation %}a^{n-1}{% endequation %} לא יהיה 1). מבחינה היסטורית מילר קדם לרבין עם האלגוריתם (ואף לפניו הרעיון הכללי היה מוכר); ההבדל הוא בניתוחים שלהם - מילר הציג את האלגוריתם שלו כאלגוריתם דטרמיניסטי, שבודק {% equation %}a{% endequation %}-ים בצורה סדרתית, והסתמך על <a href="http://he.wikipedia.org/wiki/%D7%94%D7%A9%D7%A2%D7%A8%D7%AA_%D7%A8%D7%99%D7%9E%D7%9F">השערת רימן המוכללת</a> כדי לטעון שמספיק לבדוק תחום קטן יחסית של {% equation %}a{% endequation %}-ים כדי שיובטח לנו שאחד מ-{% equation %}a{% endequation %}-ים שנבדקו הוא כזה שהיה מפריך את היות {% equation %}n{% endequation %} ראשוני במקרה שהוא פריק; לרוע המזל, השערת רימן המוכללת טרם הוכחה. מה שרבין עשה היה הפיכה של האלגוריתם להסתברותי, תוך הסתמכות על טענת ה"רבע" שהוא הוכיח.

אם כן, זהו מילר-רבין: אלגוריתם קל מאוד לתכנות ובעל זמן ריצה מהיר מאוד. אני אישית משתמש בו, כמו גם ספריות מתמטיות רבות אחרות; עם זאת, קרוב לודאי שחלקכם עדיין סקפטיים ביחס לכך שהוא עשוי לטעות, ובאופן כללי לא מבינים מה הרעיון באלגוריתמים הסתברותיים; אפרט על כך בפוסט הבא.

