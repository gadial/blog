---
title: "נוסחת קיילי לספירת עצים"
layout: post
categories:
  - תורת הגרפים
  - קומבינטוריקה
tags:
  - עצים
  - נוסחת קיילי
---

הפוסט הזה בא לסגור חור שגילתי להפתעתי שקיים בבלוג: אין לי אף פוסט על אחת מהתוצאות החביבות עלי בקומבינטוריקה בסיסית - נוסחת קיילי לספירת עצים. הנוסחה אומרת שמספר העצים על קבוצה של {% equation %}n{% endequation %} צמתים מסומנים היא {% equation %}n^{n-2}{% endequation %}, כך שקל לתאר אותה - אבל מה זה "עץ על קבוצה של צמתים מסומנים"? את זה יהיה קל להסביר. יותר מעניין להראות <strong>הוכחה</strong> לטענה הזו, והוכחה כזו כבר <a href="https://gadial.net/2011/08/13/generating_functions_hardcore_2/">מתחבאת בשוליים של אחד הפוסטים שלי</a>, אבל אני רוצה להראות הוכחה שונה מהותית שאני מאוד אוהב וממחישה טובה "מה הולך פה".

אז בואו נדבר על מה הולך פה.

ראשית, גרפים. <strong>גרף</strong> {% equation %}G{% endequation %} במובן שעליו אנחנו מדברים כאן מורכב מקבוצה {% equation %}V{% endequation %} שלאיברים שלה קוראים <strong>צמתים</strong> וקבוצה {% equation %}E{% endequation %} של זוגות של צמתים שנקראת <strong>קשתות</strong>. יש הרבה סוגים של גרפים, ובפוסט הזה אני אתעסק עם סוג פשוט למדי - לקשתות אין כיוון, ואין קשת מצומת לעצמו, ואין יותר מקשת אחת בין זוג צמתים. אפשר לחשוב על הקשתות בתור דרך לתאר קשר שיש או בין כל שני איברים שונים של הגרף.

גרפים הם משהו מאוד שימושי. שתי דוגמאות פשוטות: אנחנו יכולים למדל מפה באמצעות גרף - כל צומת הוא מיקום מעניין, וקשת אומרת שיש דרך ישירה לעבור בין שני מיקומים. או שאפשר לתאר רשת חברתית באמצעות גרף - כל משתתף ברשת הוא צומת, ויש קשת בין שני משתמשים שהם חברים (יש רשתות שבהן אפשר לעקוב אחרי מישהו שלא עוקב אחרייך; זה מתאים למושג של <strong>גרף מכוון</strong> שאני לא מדבר עליו כאן). עכשיו, אם יש לנו גרף אפשר "לטייל" עליו - להתחיל בצומת אחד וללכת לאורך קשתות כדי להגיע לצמתים אחרים. אם אני יכול להגיע מכל צומת לכל צומת בגרף, אומרים שהוא <strong>קשיר</strong>. זה מוביל אותי למושג של <strong>עץ</strong>, שאני אגדיר פה בצורה שנוחה לי - עץ הוא גרף קשיר שהוא <strong>מינימלי</strong> במובן זה שכל קשת שנסיר ממנו, תהפוך אותו לבלתי-קשיר. אפשר לחשוב על זה גם כך - אין בגרף "מעגלים", אבל אני לא אגדיר פורמלית מה זה מעגל. הנה דוגמא לאיך זה נראה:

<img src="{{site.baseurl}}{{site.post_images}}/2025/CayleyFormula.png" alt=""/>

עכשיו, כשאני אומר שהצמתים הם <strong>מסומנים</strong> אני אומר שאני יכול להבדיל בין שני צמתים שונים. זה נשמע כמעט טריוויאלי, אז בואו נראה דוגמא:

<img src="{{site.baseurl}}{{site.post_images}}/2025/CayleyFormula2.png" alt=""/>

יש לנו כאן איור של עץ פשוט במיוחד (למעשה, הוא "שרוך") אבל כשיש לנו סימונים לצמתים, אנחנו רואים שבעצם יש כאן שלושה עצים שונים, כתלות בשאלה מי הצומת שנמצא באמצע. זו סיטואציה שיותר קל לספור מאשר הסיטואציה שבה אין לנו סימנים על הצמתים ולא אדבר עליה בכלל בפוסט.

שלושת העצים שראינו פה הם המקרה של נוסחת קיילי עבור {% equation %}n=3{% endequation %}. עבור {% equation %}n=4{% endequation %} הנוסחה אומרת לנו שכבר צפויים {% equation %}4^{2}=16{% endequation %} עצים, אבל זו כבר תהיה מהומה לצייר את כולם, ומבט חטוף בהם לא מראה סדר כל כך ברור שאפשר לנצל. אז איך בדיוק להוכיח את הנוסחה? יש כמה גישות שונות להוכחה אבל זו שאני אוהב משתמשת במה שנקרא סדרות Prüfer. הרעיון פה הוא שאפשר לקודד כל עץ על קבוצת הצמתים {% equation %}V{% endequation %} כך ש-{% equation %}\left|V\right|=n{% endequation %} באמצעות סדרה מאורך {% equation %}n-2{% endequation %} של איברים מ-{% equation %}V{% endequation %}, או כמו שאוהבים לסמן לפעמים כשחושבים על האיברים של {% equation %}V{% endequation %} בתור "אותיות" ועל הסדרה בתור "מילה", באמצעות סדרה ב-{% equation %}V^{n-2}{% endequation %}. הרעיון הוא זה: ככל שאיבר מופיע יותר פעמים בסדרה, כך יש לו יותר שכנים, וכל פעם שבה הוא מופיע בסדרה אומרת "אוקיי, אחד מהשכנים של הצומת הזה כבר לא יהיה רלוונטי להמשך אז אפשר לשכוח ממנו". זה קצת אמורפי אז הנה מה שעושים באופן כללי כדי לבנות מילה ב-{% equation %}V^{n-2}{% endequation %} מתוך העץ {% equation %}G=\left(V,E\right){% endequation %}.

ראשית, בואו נקבע <strong>סדר</strong> כלשהו על הצמתים של {% equation %}V{% endequation %}, נאמר {% equation %}V=\left\{ v_{1},v_{2},\ldots,v_{n}\right\} {% endequation %}. לסדר יש חשיבות; אם נסדר את אברי הקבוצה בצורה שונה, אז אותו עץ יניב מילים שונות. אז נתייחס לסדר בתור משהו נתון.

עכשיו, אם {% equation %}\left|V\right|=2{% endequation %} אין לנו בכלל מה לעשות - יש עץ יחיד על שני צמתים, שמורכב משניהם מחוברים בקשת (הם חייבים להיות מחוברים או שהגרף לא יהיה קשיר ולכן לא עץ). אז במקרה הזה, המילה שלנו (שאמורה להיות מאורך {% equation %}n-2=0{% endequation %}) היא מה שמכונה "המילה הריקה", מילה בלי אותיות בכלל שמסומנת ב-{% equation %}\varepsilon{% endequation %}.

כשיש יותר משני צמתים, נרצה למצוא צומת שהסרה שלו מהעץ עדיין תשאיר עץ, ולהסיר אותו. בשביל שהסרה של צומת לא תקלקל את העציות של העץ, הצומת הזה צריך להיות מבוי סתום, נקודת קצה של העץ - כלומר, להיות מחובר רק לצומת יחיד. אנחנו אומרים <strong>שהדרגה</strong> של צומת היא מספר הקשתות שמחוברות אליו, אז מה שאנחנו מחפשים הוא צומת מדרגה 1. לצמתים כאלו יש שם מיוחד: <strong>עלה</strong> (כי עלה הוא "נקודת קצה" של עץ). יכולים להיות כמה עלים בגרף - אז נבחר מתוכם את הקטן ביותר, על פי הסדר שיש על הצמתים. השאלה האמיתית, כמובן, היא למה תמיד קיים עלה; אני אראה את זה בהמשך.

עכשיו, אחרי שבחרנו את העלה הקטן ביותר אנחנו מסירים אותו מהעץ ומוסיפים למילה שאנחנו בונים - לא את הסימון של העלה שהסרנו, אלא דווקא את הסימון של <strong>השכן היחיד</strong> שלו. למה? כי כשנשחזר את העץ מתוך המילה נוכל לדעת בודאות מי העלה שהוסר בשלב הזה בזכות הקטע הזה של "הקטן ביותר" - המידע החסר דווקא יהיה מי השכן שלו, וזה מה שהמילה תגיד לנו.

וזהו, זה כל מה שעושים; חוזרים על זה {% equation %}\left|V\right|-2{% endequation %} פעמים עד שנשארים עם שני צמתים ובסיטואציה הזו כפי שכבר ראינו לא צריך לטפל. אז האלגוריתם, על קלט {% equation %}G=\left(V,E\right){% endequation %}, הוא:

<ol> <li>אתחלו {% equation %}w=\varepsilon{% endequation %}.</li>


<li>אם {% equation %}\left|V\right|=2{% endequation %} סיימו והוציאו את {% equation %}w{% endequation %} כפלט.</li>


<li>מצאו מבין כל העלים של {% equation %}G{% endequation %} את הצומת המינימלי. סמנו אותו ב-{% equation %}v{% endequation %} ואת הקשת היחידה שמחוברת אליו ב-{% equation %}\left(v,u\right){% endequation %}.</li>


<li>הוסיפו את {% equation %}u{% endequation %} ל-{% equation %}w{% endequation %}: {% equation %}w\leftarrow w\cdot u{% endequation %}.</li>


<li>הסירו מ-{% equation %}G{% endequation %} את {% equation %}v{% endequation %} ואת הקשת {% equation %}\left(v,u\right){% endequation %}.</li>


<li>חזרו לשלב 2.</li>

</ol>

בואו נראה איך זה יעבוד על העץ שהראיתי קודם, זה:

<img src="{{site.baseurl}}{{site.post_images}}/2025/CayleyFormula.png" alt=""/>

בתחילת הריצה, העלים הם {% equation %}\left\{ 3,4,5\right\} {% endequation %} ומביניהם המינימלי הוא 3, לכן נתחיל בלהסיר אותו מהעץ ולכתוב {% equation %}1{% endequation %} במילה. עכשיו, גם אחרי שהסרנו את 3 מהעץ, 1 עדיין לא הפך לעלה בעצמו, לכן קבוצת העלים שלנו עכשיו היא {% equation %}\left\{ 4,5\right\} {% endequation %} ולכן אנחנו מסירים את 4 מהעץ וכותבים {% equation %}6{% endequation %} במילה שלנו, שכרגע נראית ככה: {% equation %}16{% endequation %}. עכשיו, הסרת 4 הפכה את {% equation %}6{% endequation %} לעלה בעצמו אז הקבוצה שלנו היא {% equation %}\left\{ 5,6\right\} {% endequation %} אבל על פי הכללים שלנו, אנחנו מסירים קודם כל את {% equation %}5{% endequation %} מהעץ ולכן מוסיפים למילה את {% equation %}2{% endequation %} ומקבלים {% equation %}162{% endequation %}. זה הופך את {% equation %}2{% endequation %} לעלה, כלומר קבוצת העלים שלנו כרגע היא {% equation %}\left\{ 6,2\right\} {% endequation %} ומכיוון ש-{% equation %}2{% endequation %} הוא הקטן יותר אנחנו מסירים אותו, כותבים {% equation %}1{% endequation %} במילה ומסיימים - נשארנו רק עם הצמתים {% equation %}1,6{% endequation %} וקיבלנו את המילה {% equation %}1621{% endequation %}.

זה היה מאוד נחמד - אנחנו מבינים איך האלגוריתם עובד, אבל עדיין צריך להראות שהוא <strong>עובד</strong>, כלומר שהוא נותן לנו התאמה חח"ע ועל בין עצים עם {% equation %}n{% endequation %} צמתים ובין מילים מאורך {% equation %}n-2{% endequation %} מעל אלפבית מגודל {% equation %}n{% endequation %}. בשביל זה אני צריך להוכיח את הטענה הבאה: שלכל מילה {% equation %}w{% endequation %} קיים עץ <strong>יחיד</strong> שהאלגוריתם מייצר את {% equation %}w{% endequation %} ממנו. אבל לפני שאני אנסח את זה פורמלית ואוכיח את זה, בואו ננסה לקבל תחושה של מה קורה כאן על ידי זה שנסתכל על ה-1621 שקיבלנו ונשאל את עצמנו איך אפשר "לשחזר" את העץ המקורי ממנו. כלומר, נחשוב באופן לא פורמלי איך יעבוד אלגוריתם בכיוון <strong>ההפוך</strong> לזה שכבר ראינו.

מה שהאלגוריתם מקבל כקלט הוא את המילה {% equation %}w=1621{% endequation %} אבל גם את הקבוצה {% equation %}V=\left\{ 1,2,3,4,5,6\right\} {% endequation %} של הצמתים של הגרף, יחד עם הסדר עליהם - הרי מהמילה בלבד הוא לא יכול להיות בטוח לגבי הסדר, ולא כל הצמתים בעץ בהכרח יופיעו במילה, אז צריך לספר לו את המידע הזה במפורש.

האלגוריתם מתחיל בלהסתכל על ה-1 השמאלי של {% equation %}1621{% endequation %} ואומר לעצמו "הממ... אני יודע שהצומת הראשון שהסירו מהגרף היה שכן של 1, אבל מי הוא עצמו היה? הוא היה העלה בעל המספר המינימלי בשלב הזה, אבל מי היו העלים בהתחלה?"

זו שאלה טריקית, עד ששמים לב לעובדה הקריטית הבאה: במילה {% equation %}1621{% endequation %} <strong>לא מופיעים עלים</strong>. שלושת הצמתים שמופיעים פה: {% equation %}1,2,6{% endequation %}, כולם היו מדרגה גבוהה מ-1. {% equation %}2,6{% endequation %} היו מדרגה 2 ו-{% equation %}1{% endequation %} היה מדרגה 3 ו... שימו לב שבמילה {% equation %}1{% endequation %} מופיע פעמיים ואילו {% equation %}2,6{% endequation %} מופיעים פעם אחת. אם נסתכל על עוד דוגמאות דומות, מהר מאוד נוכל להעלות השערה כללית: שמספר הפעמים שבהן צומת {% equation %}v{% endequation %} מופיע במילה שווה לדרגה שלו פחות 1, {% equation %}d\left(v\right)-1{% endequation %}. בפרט עלים לא מופיעים בכלל.

למה זה קורה? זה די פשוט, האמת. בכל פעם שבה צומת מופיע במילה, זה אומר שזה עתה הורדנו מהגרף את אחד מהשכנים שלו, כלומר הקטנו את הדרגה שלו ב-1. הפעם היחידה שבה אנחנו מקטינים את הדרגה של צומת ב-1 אבל לא מוסיפים אותו למילה היא כשהוא עצמו הצומת שמוסר מהגרף. מצד שני, בסיום ריצת האלגוריתם <strong>כל</strong> צומת הוסר מהגרף (ואז הוא נכתב {% equation %}d\left(v\right)-1{% endequation %} פעמים), או (במקרה של שני הצמתים האחרונים שנשארו) הפך להיות מדרגה 1, כלומר הדרגה שלו הוקטנה {% equation %}d\left(v\right)-1{% endequation %} פעמים ולכן הוא נכתב במילה {% equation %}d\left(v\right)-1{% endequation %} פעמים.

מה המסקנה? ראשית, שעל ידי הסתכלות ב-{% equation %}1621{% endequation %} אני יודע שהעלים של הגרף הם {% equation %}3,4,5{% endequation %}, ושהם היו עלים במשך כל ריצת האלגוריתם. הקטן מביניהם הוא 3, כך שאני יכול להסיק שבצעד הראשון 3 הוסר מהגרף והשכן שלו היה הצומת הראשון שמופיע ב-{% equation %}1621{% endequation %}. לכן הדבר הראשון שאעשה יהיה להוסיף לגרף את הקשת {% equation %}\left(1,3\right){% endequation %} ואסמן לעצמי שכבר טיפלתי בצומת {% equation %}3{% endequation %}.

מכיוון שקראתי את האות הראשונה ב-{% equation %}1621{% endequation %} אפשר להסיר אותה, להישאר עם המילה {% equation %}621{% endequation %} ולחזור על מה שעשינו גם איתה. אותו הגיון יעבוד עכשיו גם עם 4, ולכן אני אסמן לעצמי שיש בגרף את {% equation %}\left(4,6\right){% endequation %} ואוריד את 4 מרשימת הצמתים שצריך לטפל בהם. אבל עכשיו קורה משהו מעניין - אני נשאר עם המילה {% equation %}21{% endequation %} שבה {% equation %}6{% endequation %} לא מופיע יותר. זה מספר לי <strong>שבשלב הזה של האלגוריתם</strong> המקורי, 6 היה עלה. לכן אני מוסיף אותו לקבוצת העלים הפוטנציאליים שלי, שכוללת עכשיו את {% equation %}5,6{% endequation %}. מכיוון ש-5 הוא עם האינדקס הקטן יותר, אני אחבר אותו ל-2 שבתחילת המילה. אחר כך אני נשאר עם המילה {% equation %}1{% endequation %} שבה גם {% equation %}2{% endequation %} לא מופיע, אז אוסיף <strong>גם אותו</strong> לרשימת הצמתים שצריך לבדוק, ומכיוון שהוא קטן מ-2 הוא יהיה הצומת שאני מחבר ל-1.

בשלב הזה נגמרה לי המילה, ונשארו רק שני צמתים שלא טיפלתי בהם: {% equation %}1,6{% endequation %}. אז אני מוסיף קשת גם להם ומסיים את הסיפור. 

יופי, זה היה תיאור לא פורמלי של איך עובד האלגוריתם שמשחזר את העץ מתוך {% equation %}w{% endequation %}. עוד מעט אני אכתוב אותו בצורה פורמלית, אבל לפני כן בואו ננסה להבין איך מוכיחים את הטענה שרציתי להראות על כך שבהינתן {% equation %}w{% endequation %} קיים עץ יחיד שנותן את {% equation %}w{% endequation %}. הניסוח הפורמלי של הטענה צריך להיות קצת יותר זהיר - כפי שראינו, אני חייב להתחיל מקבוצה {% equation %}V{% endequation %} קונקרטית. נסמן {% equation %}\left|V\right|=n{% endequation %} ועכשיו ניקח מילה {% equation %}w\in V^{n-2}{% endequation %} והטענה היא שקיים ויחיד עץ עם קבוצת הצמתים {% equation %}V{% endequation %} שנותן את {% equation %}w{% endequation %}.

אני אוכיח את הטענה <strong>באינדוקציה</strong> על {% equation %}n{% endequation %}, כשהבסיס הוא {% equation %}n=2{% endequation %}. במקרה הזה, {% equation %}w\in V^{0}{% endequation %} חייבת להיות המילה הריקה {% equation %}\varepsilon{% endequation %}, ואילו {% equation %}V{% endequation %} היא קבוצה בת שני צמתים. יש בדיוק שני גרפים על שני צמתים: הגרף שבו הם לא מחוברים בקשת <strong>שאינו עץ</strong> ולכן אינו רלוונטי לדיון; והגרף שבו הם כן מחוברים והוא כן עץ והוא אכן מחזיר {% equation %}\varepsilon{% endequation %} על פי האלגוריתם שראינו קודם. אז את הבסיס יש לנו.

בשביל הצעד, ניקח את {% equation %}w{% endequation %} ונפרק אותה לאות הראשונה וכל היתר: {% equation %}w=\sigma w^{\prime}{% endequation %} כך ש-{% equation %}w^{\prime}\in V^{n-3}{% endequation %}. ה-{% equation %}\sigma{% endequation %} הזה הוא הצומת <strong>הפנימי</strong> של הגרף שאליו מחובר העלה שאנחנו רוצים "לשחזר" בשלב הזה, אבל מי זה העלה הזה? זו הנקודה שדיברתי עליה, שבה אפשר לגלות את העלה גם בלי שהוא יהיה כתוב לנו במפורש: נשים לב שב-{% equation %}V{% endequation %} יש יותר צמתים מאשר יש אותיות ב-{% equation %}w{% endequation %} אז בהכרח קיימים צמתים ב-{% equation %}V{% endequation %} שלא מופיעים ב-{% equation %}w{% endequation %} בכלל, ולכן הם עלים <strong>בכל עץ</strong> שנותן את {% equation %}w{% endequation %}, כפי שראינו, ונסמן את המינימלי מביניהם ב-{% equation %}u{% endequation %}. מה שקרה פה הוא <strong>שבכל עץ</strong> שנותן את {% equation %}w{% endequation %}, בהכרח {% equation %}u{% endequation %} מחובר אל {% equation %}\sigma{% endequation %}, כי בשלב הראשון של האלגוריתם {% equation %}u{% endequation %} בהכרח היה מוסר (הוא המינימלי מבין העלים של <strong>כל עץ</strong> שנותן את {% equation %}w{% endequation %}) והוא בהכרח מחובר אל {% equation %}\sigma{% endequation %} בכל עץ שמחזיר את {% equation %}w{% endequation %} כי האות הראשונה ב-{% equation %}w{% endequation %} היא {% equation %}\sigma{% endequation %}.

עכשיו אפשר להשתמש בהנחת האינדוקציה. נגדיר {% equation %}V^{\prime}=V\backslash\left\{ u\right\} {% endequation %}, כלומר הסרנו את {% equation %}u{% endequation %} מתוך {% equation %}V{% endequation %}, וקיבלנו קבוצה מגודל {% equation %}n-1{% endequation %} ומילה {% equation %}w^{\prime}\in V^{\prime\left(n-1\right)-2}{% endequation %} (אנחנו יודעים ש-{% equation %}w^{\prime}{% endequation %} אכן מורכבת רק מאיברים של {% equation %}V^{\prime}{% endequation %} כי {% equation %}w{% endequation %} הורכבה מאיברים של {% equation %}V{% endequation %}, והסרנו מ-{% equation %}V{% endequation %} רק איבר <strong>שלא הופיע</strong> ב-{% equation %}w{% endequation %}). על פי הנחת האינדוקציה קיים עץ יחיד שנותן את {% equation %}w^{\prime}{% endequation %} הזו, ואחרי שנצרף אליו את הקשת {% equation %}\left(u,\sigma\right){% endequation %} שחייבת להיות <strong>בכל</strong> עץ שנותן את {% equation %}w{% endequation %} נקבל עץ יחיד שנותן את {% equation %}w{% endequation %}.

בואו נכתוב את מה שעשינו בתור אלגוריתם מסודר. על קלט של קבוצה {% equation %}V{% endequation %} ומילה {% equation %}w\in V^{\left|V\right|-2}{% endequation %}, האלגוריתם פועל כך:

<ol> <li>מאתחל קבוצת קשתות {% equation %}E\leftarrow\emptyset{% endequation %} וקבוצת "צמתים לטיפול" {% equation %}S\leftarrow V{% endequation %} ומפרק את המילה לאותיות {% equation %}w=\sigma_{1}\ldots\sigma_{n-2}{% endequation %}.</li>


<li>לכל {% equation %}i=1,2,\ldots,n-2{% endequation %}: </li>
<ol>


<li>מוצא את האיבר הקטן ביותר של {% equation %}S{% endequation %} שלא מופיע ב-{% equation %}\sigma_{i}\ldots\sigma_{n-2}{% endequation %} ומסמן אותו ב-{% equation %}u{% endequation %}.</li>


<li>{% equation %}E\leftarrow E\cup\left\{ \left(u,\sigma_{i}\right)\right\} {% endequation %}</li>


<li>{% equation %}S\leftarrow S\backslash\left\{ u\right\} {% endequation %}</li>

</ol>


<li>בשלב הזה {% equation %}S=\left\{ u,v\right\} {% endequation %}. מבצע: {% equation %}E\leftarrow E\cup\left\{ \left(u,v\right)\right\} {% endequation %}</li>


<li>מחזיר את {% equation %}E{% endequation %}.</li>
</ol>

 זה הכל! מה שחמוד פה הוא שההתאמה למילות פרופר היא שימושית קצת יותר מאשר רק הוכחת המשפט הזה. למשל, אם אני רוצה לבנות עץ עם מבנה ספציפי, שבו יש צומת אחד מדרגה 7 וארבעה מדרגה 3 והיתר עלים, אני יודע בדיוק מה לעשות - מילה עם אות אחת שחוזרת על עצמה 6 פעמים ועוד ארבע אותיות שכל אחת חוזרת על עצמה פעמיים. אני יכול להגריל מילים תחת האילוצים הללו (זה קל, זו בסך הכל פרמוטציה אקראית של סימובלים) ולקבל עץ אקראי שעונה לדרישה המקורית שלי. זה ממש נחמד! הרבה יותר שווה מסתם לדעת את {% equation %}n^{n-2}{% endequation %}. 