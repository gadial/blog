---
title: "פירוק SVD והפירוק הפולארי של מטריצות"
layout: post
categories:
  - אלגברה לינארית
tags:
  - פירוק SVD
  - פירוק פולארי
  - מטריצות
---


<h2>מבוא</h2>

בפוסט הזה אני רוצה לדבר על פירוק SVD, שהוא תוצאה מרהיבה באלגברה לינארית שבמובן מאוד מסויים מכלילה תוצאה מרהיבה אחרת של האלגברה הלינארית שעליה כתבתי <a href="https://gadial.net/2025/09/06/unitary_diagonalization/">ממש לא מזמן</a>: לכסון אוניטרי. אמרנו שמטריצה {% equation %}A{% endequation %} ניתנת ללכסון אוניטרי אם אפשר לכתוב {% equation %}A=UDU^{*}{% endequation %} כאשר {% equation %}U{% endequation %} היא <strong>מטריצה אוניטרית</strong> ואילו {% equation %}D{% endequation %} היא <strong>מטריצה אלכסונית</strong>. המשפט שהוכחנו אמר ש:

<ul> 
<li>מעל {% equation %}\mathbb{R}{% endequation %}, {% equation %}A{% endequation %} היא לכסינה אוניטרית אם ורק אם {% equation %}A=A^{*}{% endequation %} ("A צמודה לעצמה").</li>


<li>מעל {% equation %}\mathbb{C}{% endequation %}, {% equation %}A{% endequation %} היא לכסינה אוניטרית אם ורק אם {% equation %}A^{*}A=AA^{*}{% endequation %} ("A נורמלית").</li>

</ul>

אפשר לחשוב על לכסון אוניטרי גם בצורה שונה: מטריצה אוניטרית {% equation %}U{% endequation %} מסדר {% equation %}n\times n{% endequation %} מעל {% equation %}\mathbb{F}{% endequation %} היא בעצם אוסף {% equation %}\left\{ u_{1},\ldots,u_{n}\right\} {% endequation %} של <strong>וקטורים</strong> ב-{% equation %}\mathbb{F}^{n}{% endequation %}: כל <strong>עמודה</strong> שלה היא וקטור שכזה. דרישת האוניטריות שקולה לכך שהוקטורים הללו יהיו <strong>בסיס אורתונורמלי</strong>, כלומר וקטורים בלתי תלויים המקיימים {% equation %}\left\langle u_{i},u_{j}\right\rangle =\delta_{ij}{% endequation %} כאשר המכפלה הפנימית היא המכפלה הסטנדרטית מעל {% equation %}\mathbb{F}{% endequation %}. כדי לראות שזה עובד פשוט נסתכל על השוויון {% equation %}U^{*}U=I{% endequation %} שמגדיר אוניטריות: באופן כללי, כאשר כופלים שתי מטריצות {% equation %}A,B{% endequation %} אז הכניסה ה-{% equation %}ij{% endequation %} במכפלה שווה ל<strong>שורה</strong> ה-{% equation %}i{% endequation %} של {% equation %}A{% endequation %} שמוכפלת סקלרית ב<strong>עמודה</strong> ה-{% equation %}j{% endequation %} של {% equation %}B{% endequation %}; במכפלה {% equation %}U^{*}U{% endequation %}, השורה ה-{% equation %}i{% endequation %} של {% equation %}U^{*}{% endequation %} היא בעצם העמודה ה-{% equation %}i{% endequation %} של {% equation %}U{% endequation %}, אחרי שביצענו לאבריה הצמדה. המכפלה הפנימית הסטנדרטית מעל {% equation %}\mathbb{F}{% endequation %} היא בדיוק "בצעו הצמדה לאחד הוקטורים ואז כפלו אותם סקלרית", מה שנותן לנו את המעבר החלק מלשון מטריצות ללשון וקטורים. בנוסף, העמודות של {% equation %}U{% endequation %} הן בלתי תלויות לינארית כי {% equation %}U{% endequation %} היא מטריצה הפיכה - כל זה חומר סטנדרטי של אלגברה לינארית שאני לא אוכיח שוב.

את השוויון {% equation %}A=UDU^{*}{% endequation %} אפשר להבין גם כן בלשון וקטורית. בואו נסמן

{% equation %}D=\left(\begin{array}{cccc} \lambda_{1}\\  & \lambda_{2}\\  &  & \ddots\\  &  &  & \lambda_{n} \end{array}\right){% endequation %}

כלומר {% equation %}D{% endequation %} היא מטריצה אלכסונית עם הערכים {% equation %}\lambda_{1},\ldots,\lambda_{n}{% endequation %}. עכשיו, ניקח את {% equation %}A=UDU^{*}{% endequation %}, נכפול מימין ב-{% equation %}U{% endequation %} ונקבל

{% equation %}AU=UD{% endequation %}

מה קורה פה? אמרתי שהכניסה ה-{% equation %}ij{% endequation %} של {% equation %}AU{% endequation %} היא מכפלת השורה ה-{% equation %}i{% endequation %} של {% equation %}A{% endequation %} בעמודה ה-{% equation %}j{% endequation %} של {% equation %}U{% endequation %}; אם נסתכל על כל <strong>העמודה</strong> ה-{% equation %}j{% endequation %} של {% equation %}AU{% endequation %} (כלומר, על הכניסות {% equation %}1j,2j,\ldots,nj{% endequation %}) אז יוצא שהעמודה הזו שווה למכפלה של {% equation %}A{% endequation %} בוקטור העמודה ה-{% equation %}j{% endequation %}-י של {% equation %}U{% endequation %}. סימנו את הוקטור הזה כזכור ב-{% equation %}u_{j}{% endequation %} אז אפשר לסכם שהעמודה ה-{% equation %}j{% endequation %} של {% equation %}AU{% endequation %} היא פשוט {% equation %}Au_{j}{% endequation %}.

עכשיו, מה זו {% equation %}UD{% endequation %}? הכניסה ה-{% equation %}ij{% endequation %} של {% equation %}UD{% endequation %} שווה למכפלת השורה ה-{% equation %}i{% endequation %} של {% equation %}U{% endequation %} בעמודה ה-{% equation %}j{% endequation %} של {% equation %}D{% endequation %}. בעמודה ה-{% equation %}j{% endequation %} של {% equation %}D{% endequation %} יש רק איבר אחד שאולי שונה מאפס: {% equation %}\lambda_{j}{% endequation %}, שנמצא בשורה ה-{% equation %}j{% endequation %} של העמודה. אז מכל השורה ה-{% equation %}i{% endequation %}-ית של {% equation %}U{% endequation %}, הולך להישאר רק האיבר במקום {% equation %}ij{% endequation %}, והוא יוכפל ב-{% equation %}\lambda_{j}{% endequation %}. במילים אחרות: העמודות של {% equation %}UD{% endequation %} הן בדיוק העמודות של {% equation %}U{% endequation %}, רק שבנוסף העמודה ה-{% equation %}j{% endequation %} של {% equation %}U{% endequation %} מוכפלת ב-{% equation %}\lambda_{j}{% endequation %}, כלומר היא שווה ל-{% equation %}\lambda_{j}u_{j}{% endequation %}.

השוויון {% equation %}AU=UD{% endequation %} אומר לנו, אם כן, ש-{% equation %}Au_{j}=\lambda_{j}u_{j}{% endequation %}, כלומר ש-{% equation %}u_{j}{% endequation %} הוא <strong>וקטור עצמי</strong> של {% equation %}A{% endequation %} עם ערך עצמי {% equation %}\lambda_{j}{% endequation %}. זה מוביל לניסוח שקול של מה זה לכסון אוניטרי: שיהיה לנו בסיס <strong>אורתונורמלי</strong> למרחב שמורכב כולו מוקטורים עצמיים של {% equation %}A{% endequation %}. לבסוף, אם לוקחים טרנספורמציה לינארית כללית {% equation %}T:V\to V{% endequation %} עבור מרחב סוף-ממדי {% equation %}V{% endequation %} מעל {% equation %}\mathbb{R}{% endequation %} או {% equation %}\mathbb{C}{% endequation %} אז אפשר לקחת בסיס אורתונורמלי למרחב הזה (תהליך גרם-שמידט מבטיח שקיים כזה), ולהשתמש בבסיס הזה כדי לעבור לדבר על {% equation %}\mathbb{F}^{n}{% endequation %} ולקבל את כל המושגים שדיברנו עליהם כאן גם בהקשר של טרנספורמציות כלליות. מכיוון שאני מניח שהטריק הזה מוכר, בפוסט הזה אני לא ממש אדבר עליו - לכאורה נדבר רק על המקרה הקונקרטי של {% equation %}\mathbb{F}^{n}{% endequation %} ושל מטריצות, אבל ברקע הדברים צריך לזכור שזה פשוט התכל'ס הטכני של תוצאה שתקפה לכל מרחב מכפלה פנימית סוף-ממדי.

עכשיו אפשר לעבור לדבר סוף סוף על מה פירוק SVD אומר. עד כה נראה שסתם ניסחתי מחדש בצורה מסורבלת דברים שכל מי שקורא פוסט כזה כבר אמור להכיר, אבל לא ניסחתי את זה ככה סתם: נצטרך את הכל כדי להבין את האופן הספציפי שבו SVD מכליל את מה שראינו.

<h2>מה זה פירוק SVD?</h2>

לכסון אוניטרי זה משהו שקיים לחלק מהמטריצות הריבועיות. לעומתו, פירוק SVD (ראשי תיבות של Singular Value Decomposition, "פירוק ערכים סינגולריים" ואוטוטו נראה מהם הערכים הללו) זה משהו שקיים <strong>לכל</strong> מטריצה {% equation %}A\in M_{n,m}\left(\mathbb{F}\right){% endequation %} מעל {% equation %}\mathbb{F}{% endequation %} שהוא הממשיים או המרוכבים (בדרך כלל לא אטרח לכתוב אותו), גם אם {% equation %}A{% endequation %} היא בכלל לא ריבועית. זה הפירוק הבא:

{% equation %}A=U\Sigma V^{*}{% endequation %}

כאשר {% equation %}U\in M_{n,n}{% endequation %} ו-{% equation %}V\in M_{m,m}{% endequation %} הן מטריצות אוניטריות ואילו {% equation %}\Sigma\in M_{n,m}{% endequation %} (כלומר, מטריצה לא בהכרח ריבועית, מאותו סדר כמו {% equation %}A{% endequation %}) היא "אלכסונית" במובן זה שהערכים היחידים שלה שעשויים להיות שונים מאפס הם הערכים מהצורה {% equation %}\Sigma_{ii}{% endequation %} (עבור {% equation %}1\le i\le\min\left\{ n,m\right\} {% endequation %}). יותר מזה: אם נסמן את הערכים על האלכסון הזה ב-{% equation %}\sigma_{1},\sigma_{2},\ldots,\sigma_{k}{% endequation %} אז <strong>כולם</strong> מספרים ממשיים, ומתקיים {% equation %}\sigma_{1}\ge\sigma_{2}\ge\ldots\ge\sigma_{k}\ge0{% endequation %}. כלומר, בניגוד ללכסון אוניטרי שבו היה "חופש בחירה" עבור {% equation %}D{% endequation %} איך הערכים העצמיים יהיו מסודרים בה, כאן יש הצגה קנונית יחידה של המטריצה {% equation %}\Sigma{% endequation %} (אבל לא של {% equation %}U,V{% endequation %}). ויותר מכך: ערכי ה-{% equation %}\alpha{% endequation %} ששונים מאפס הם בדיוק הערכים {% equation %}\sigma_{1},\ldots,\sigma_{r}{% endequation %}, כאשר {% equation %}r{% endequation %} היא <strong>הדרגה</strong> של המטריצה {% equation %}A{% endequation %}.

הערכים {% equation %}\sigma_{1},\sigma_{2},\ldots,\sigma_{k}{% endequation %} הללו נקראים <strong>הערכים הסינגולריים</strong> של {% equation %}A{% endequation %}. קל להגיד מה הם: אם נסתכל על {% equation %}AA^{*}{% endequation %} נקבל את מה שקראתי לו <a href="https://gadial.net/2025/09/21/positive_semidefinite_matrices/">בפוסט הקודם</a> <strong>מטריצה חיובית</strong> (Positive Definite) והערכים העצמיים של המטריצות הללו הם ממשיים אי-שליליים ולכן אפשר להוציא להם שורש ריבועי ולקבל ממשיים אי-שליליים; הערכים הסינגולריים הם בדיוק השורשים הללו.

בואו ננסה להבין את SVD ברמת הוקטורים. אני אסמן את העמודות של {% equation %}U{% endequation %} ב-{% equation %}\left\{ u_{1},\ldots,u_{n}\right\} {% endequation %}ושל {% equation %}V{% endequation %} ב-{% equation %}\left\{ v_{1},\ldots,v_{m}\right\} {% endequation %}, אז מכיוון שאלו מטריצות אוניטריות, שני אלו הם בסיסים אורתונורמליים (למרחבים שהם אולי שונים; הראשון ל-{% equation %}\mathbb{F}^{n}{% endequation %} והשני ל-{% equation %}\mathbb{F}^{m}{% endequation %}). עכשיו, נכפול את {% equation %}A=U\Sigma V^{*}{% endequation %} ב-{% equation %}V{% endequation %} מימין ונקבל

{% equation %}AV=U\Sigma{% endequation %}

וכמו שהסברתי במבוא, זה אומר שמתקיים

{% equation %}Av_{j}=\sigma_{j}u_{j}{% endequation %}

זה מאוד מזכיר וקטורים עצמיים, חוץ מהקטע של ה"עצמי". מכפלה ב-{% equation %}A{% endequation %} מעבירה את {% equation %}v_{j}{% endequation %} אל מכפלה של {% equation %}u_{j}{% endequation %} ב-{% equation %}\sigma_{j}{% endequation %}, כלומר אנחנו עוברים מהקבוצה {% equation %}\left\{ v_{1},\ldots,v_{m}\right\} {% endequation %} אל {% equation %}\left\{ u_{1},\ldots,u_{n}\right\} {% endequation %}. זה ה"מחיר" שאנחנו משלמים: מצד אחד הפירוק קיים לכל מטריצה, מצד שני אין לנו בסיס אחד לאותו מרחב ש-{% equation %}A{% endequation %} מעבירה אותו לעצמו; יש לנו שני בסיסים למרחבים שונים ש-{% equation %}A{% endequation %} מעבירה אותנו מאחד מהם לשני, אבל עדיין בצורה פשוטה יחסית: היא לא מעבירה איבר בסיס ל<strong>צירוף לינארי</strong> של שני וקטורים או יותר, אלא רק למכפלה בסקלר של וקטור אחד.

<h2>מקבלים פירוק שהוא כמעט, אבל לא בדיוק, שונה לגמרי מ-SVD</h2>

ההוכחה שפירוק SVD תמיד קיים היא לא מסובכת במיוחד, אבל אני הולך בכוונה לסבך אותה טיפה כי אם מתחילים ממשפט יותר כללי, אפשר לקבל ממנו גם את פירוק SVD אבל גם את הפירוק הפולארי של מטריצות שהזכרתי בפוסט הקודם: שכל מטריצה {% equation %}A{% endequation %} ניתן לכתוב בתור {% equation %}A=PU{% endequation %} כך ש-{% equation %}P{% endequation %} היא מטריצה חיובית ו-{% equation %}U{% endequation %} היא מטריצה אוניטרית. למעשה, גם כאן זה עובד אפילו למטריצות לא ריבועיות: אם {% equation %}A\in M_{n,m}{% endequation %} כך ש-{% equation %}n\le m{% endequation %} (מספר השורות לא גדול ממספר העמודות) אז קיימת {% equation %}P\in M_{n,n}{% endequation %} חיובית מאותה דרגה כמו {% equation %}A{% endequation %}, ו-{% equation %}U\in M_{n,m}{% endequation %} כך ש-{% equation %}A=PU{% endequation %}, ו-{% equation %}U{% endequation %} היא "אוניטרית" במובן הבא: {% equation %}UU^{*}=I_{n\times n}{% endequation %}. כלומר, <strong>השורות</strong> של {% equation %}U{% endequation %} הן אורתונורמליות.

נראה קשור אל SVD? לא? לי זה בכלל לא נראה קשור ממבט ראשון אבל תוך שניה הכל יתבהר, ולמעשה כבר הזכרתי את טיעון המפתח המרכזי: זה לא משנה איזו מטריצה היא {% equation %}A{% endequation %} - הפיכה, לא הפיכה, ריבועית, לא ריבועית - אני <strong>תמיד</strong> מקבל ש-{% equation %}AA^{*}{% endequation %} היא מטריצה חיובית, ולכן אפשר לקחת את הערכים העצמיים שלה ולהוציא להם שורש ולקבל את הערכים הסינגולריים. זה האופן שבו מטריצות חיוביות נדחפות לתוך ההוכחה, ואם יש לנו מטריצות חיוביות ומטריצות כמו-אוניטריות, כבר יש לנו את הפירוק הפולארי.

אוקיי, אז מה עושים? עכשיו נעבוד מסודר ומדוקדק. התחלנו עם {% equation %}A\in M_{n,m}{% endequation %} שמקיימת {% equation %}n\le m{% endequation %}. ביצענו את הכפל {% equation %}AA^{*}{% endequation %} וקיבלנו מטריצה {% equation %}n\times n{% endequation %} שהיא חיובית, ולכן עם ערכים עצמיים {% equation %}\lambda_{1}\ge\lambda_{2}\ge\ldots\ge\lambda_{n}\ge0{% endequation %}. הערכים העצמיים לאו דווקא שונים זה מזה, אבל שימו לב שכל {% equation %}n{% endequation %} הערכים העצמיים <strong>קיימים</strong>, וזה כי {% equation %}AA^{*}{% endequation %} היא בפרט מטריצה צמודה לעצמה ולכן לכסינה. מכיוון שכל ערך עצמי הוא ממשי אי שלילי אני יכול להגדיר {% equation %}\sigma_{i}=\sqrt{\lambda_{i}}{% endequation %} ולקבל סדרה חדשה של מספרים ממשיים אי שליליים {% equation %}\sigma_{1}\ge\sigma_{2}\ge\ldots\ge\sigma_{n}\ge0{% endequation %}. המספרים הללו הם מה שנקרא <strong>הערכים הסינגולריים</strong> של {% equation %}A{% endequation %}. לפעמים קוראים "ערכים סינגולריים" רק לאותם {% equation %}\sigma_{i}{% endequation %}-ים שגדולים ממש מאפס; אני לא אעשה את ההפרדה הזו כרגע, אבל אני כן אכניס סימון חדש לתמונה: {% equation %}r{% endequation %} יהיה המספר של הערכים הסינגולריים שגדולים מאפס, כלומר {% equation %}\sigma_{1}\ge\ldots\ge\sigma_{r}>0{% endequation %} ו-{% equation %}\sigma_{r+1}=\ldots=\sigma_{n}=0{% endequation %}. בהמשך נראה ש-{% equation %}r=\text{rank}A{% endequation %}, אבל ההוכחה לא מיידית אז נחכה עם זה קצת.

עכשיו אנחנו יכולים לבנות מטריצה אלכסונית {% equation %}n\times n{% endequation %} עם הערכים הסינגולריים על האלכסון:

{% equation %}\Lambda=\left(\begin{array}{cccc} \sigma_{1}\\  & \sigma_{2}\\  &  & \ddots\\  &  &  & \sigma_{n} \end{array}\right){% endequation %}

עכשיו, {% equation %}AA^{*}{% endequation %} לא סתם לכסינה אלא לכסינה <strong>אוניטרית</strong>, כלומר יש לנו בסיס של וקטורים עצמיים אורתונורמליים {% equation %}x_{1},\ldots,x_{n}{% endequation %} שאפשר לסדר יפה בתור עמודות ולקבל מטריצה אוניטרית {% equation %}X\in M_{n,n}{% endequation %}. אני רוצה למצוא פירוק של {% equation %}A{% endequation %} שהוא מהצורה {% equation %}A=X\Lambda Y{% endequation %}, אבל מהי {% equation %}Y{% endequation %} הזו? ראשית, {% equation %}X\Lambda\in M_{n,n}{% endequation %} ולכן צריך שיתקיים {% equation %}Y\in M_{n,m}{% endequation %} כדי שכפל המטריצות יהיה מוגדר ונקבל ממנו מטריצה מאותם ממדים כמו {% equation %}A{% endequation %}. אבל חוץ מזה, מה אנחנו יודעים עליה? אם {% equation %}\Lambda{% endequation %} היא <strong>הפיכה</strong> אז הסיטואציה פשוטה: {% equation %}Y=\Lambda^{-1}X^{*}A{% endequation %}, אבל זה עובד רק אם {% equation %}\Lambda{% endequation %} הפיכה, כלומר אם כל הערכים העצמיים גדולים מאפס (כלומר אם {% equation %}r=n{% endequation %}). אחרת? המצב קצת מסובך יותר אבל עדיין אפשר לבנות {% equation %}Y{% endequation %} מתאימה. בשביל לעשות את זה, אני קודם אניח ש-{% equation %}\Lambda{% endequation %} כן הפיכה ואראה מה אני יכול להגיד על המבנה של {% equation %}Y{% endequation %}:

יהיה לי קצת יותר נוח לבנות את {% equation %}Y^{*}{% endequation %} ולקבל ממנו את {% equation %}Y{% endequation %}, אז נתחיל עם לחשב

{% equation %}Y^{*}=\left(\Lambda^{-1}X^{*}A\right)^{*}=A^{*}X\Lambda^{-1}{% endequation %}

כשאני משתמש כאן בכך ש-{% equation %}\Lambda^{-1}{% endequation %} היא מטריצה ממשית אלכסונית ולכן {% equation %}\left(\Lambda^{-1}\right)^{*}=\Lambda^{-1}{% endequation %}.

עכשיו, באופן כללי כשיש לנו מכפלת מטריצות {% equation %}AB{% endequation %} אפשר לחשוב על העמודה ה-{% equation %}i{% endequation %} של המכפלה בתור {% equation %}Ab_{i}{% endequation %}, כלומר המכפלה של כל {% equation %}A{% endequation %} בעמודה ה-{% equation %}i{% endequation %} של {% equation %}B{% endequation %}. זה אומר שהעמודה ה-{% equation %}i{% endequation %} של {% equation %}A^{*}X{% endequation %} היא פשוט {% equation %}A^{*}x_{i}{% endequation %}. עכשיו, עוד דרך לחשוב על העמודות של המכפלה {% equation %}AB{% endequation %} היא שהעמודה ה-{% equation %}i{% endequation %} במכפלה היא <strong>צירוף לינארי</strong> של העמודות של {% equation %}A{% endequation %} עם המקדמים שנמצאים בעמודה ה-{% equation %}i{% endequation %} של {% equation %}B{% endequation %}. כך שאם {% equation %}B{% endequation %} היא אלכסונית עם הערך {% equation %}b_{ii}{% endequation %} על האלכסון, אז העמודה ה-{% equation %}i{% endequation %} של {% equation %}AB{% endequation %} תכיל את העמודה ה-{% equation %}i{% endequation %}של {% equation %}A{% endequation %} כשהיא מוכפלת ב-{% equation %}\lambda_{ii}{% endequation %} ותו לא. במקרה שלנו זה אומר שהעמודה ה-{% equation %}i{% endequation %} של {% equation %}A^{*}X\Lambda^{-1}{% endequation %} תהיה {% equation %}\sigma_{i}^{-1}A^{*}x_{i}{% endequation %}. לכן, במטריצה {% equation %}Y{% endequation %} שאנחנו בונים, <strong>השורה</strong> ה-{% equation %}i{% endequation %} תהיה הוקטור {% equation %}y_{i}=\left(\sigma_{i}^{-1}A^{*}x_{i}\right)^{*}=\sigma_{i}^{-1}x_{i}^{*}A{% endequation %}. כל זה נכון במקרה שבו {% equation %}\Lambda{% endequation %} הפיכה, אבל גם אם לא - אנחנו יכולים להשתמש בו כדי <strong>להגדיר</strong> את השורות של {% equation %}Y{% endequation %}, כל עוד {% equation %}\sigma_{i}\ne0{% endequation %}, כלומר עבור הערכים הסינגולריים שסימנתי ב-{% equation %}\sigma_{1},\ldots,\sigma_{r}{% endequation %}.קיבלנו את השורות {% equation %}y_{1},\ldots,y_{r}{% endequation %}, כלומר {% equation %}r{% endequation %} השורות הראשונות במטריצה {% equation %}Y{% endequation %} שאמורה לכלול סך הכל {% equation %}n{% endequation %} שורות שכל אחד מהן היא באורך {% equation %}m{% endequation %} (כי היא מסדר {% equation %}n\times m{% endequation %}).

ה-{% equation %}y_{i}{% endequation %}-ים הללו מקיימים תכונה מהותית אחת - גם הם אורתונורמליים. כדי לראות את זה, בואו נכפול אותם פנימית. אם {% equation %}x,y{% endequation %} הם שני וקטורים ב-{% equation %}\mathbb{F}^{n}{% endequation %}, המכפלה הפנימית הסטנדרטית שלהם היא {% equation %}\left\langle x,y\right\rangle =y^{*}x{% endequation %}, אבל זה נכון לוקטורי <strong>עמודה. </strong>אם יש לנו וקטורי שורה, להסתכל על {% equation %}xy^{*}{% endequation %} ישיג את אותו אפקט (מצמיד את אברי {% equation %}y{% endequation %} ומסדר את הממדים כך שכפל שני הוקטורים יניב סקלר). לכן

{% equation %}\left\langle y_{i},y_{j}\right\rangle =\left(\sigma_{i}^{-1}x_{i}^{*}A\right)\left(\sigma_{j}^{-1}x_{j}^{*}A\right)^{*}=\left(\sigma_{i}\sigma_{j}\right)^{-1}x_{i}^{*}AA^{*}x_{j}{% endequation %}

עכשיו, כזכור {% equation %}x_{j}{% endequation %} הוא וקטור עצמי של {% equation %}AA^{*}{% endequation %} עם ערך עצמי {% equation %}\lambda_{j}=\sigma_{j}^{2}{% endequation %} כך שקיבלנו

{% equation %}\left(\sigma_{i}\sigma_{j}\right)^{-1}x_{i}^{*}AA^{*}x_{j}=\left(\sigma_{i}\sigma_{j}\right)^{-1}\sigma_{j}^{2}x_{i}^{*}x_{j}=\frac{\sigma_{j}}{\sigma_{i}}\left\langle x_{j},x_{i}\right\rangle =\frac{\sigma_{j}}{\sigma_{i}}\delta_{ij}=\delta_{ij}{% endequation %}

המעבר האחרון נובע מכך שאם {% equation %}i\ne j{% endequation %} אז {% equation %}\frac{\sigma_{j}}{\sigma_{i}}\delta_{ij}=0{% endequation %} ואילו אם {% equation %}\delta_{ij}=1{% endequation %} אז ברכיב {% equation %}\frac{\sigma_{j}}{\sigma_{i}}{% endequation %} יש לנו את אותו איבר ולכן הוא מתבטל.

עכשיו, אם יש לנו קבוצה {% equation %}\left\{ y_{1},\ldots,y_{r}\right\} {% endequation %} של וקטורים אורתונורמליים בלתי תלויים במרחב {% equation %}\mathbb{F}_{m}{% endequation %}, כאשר {% equation %}r\le n\le m{% endequation %}, אז אפשר <strong>להרחיב</strong> אותה לקבוצה {% equation %}\left\{ y_{1},\ldots,y_{r},y_{r+1},\ldots,y_{n}\right\} {% endequation %} של וקטורים אורתונורמליים בלתי תלויים בשיטות הסטנדרטיות של השלמה לבסיס וביצוע גרם-שמידט (רק שכאן אנחנו לא צריכים להגיע ל-{% equation %}m{% endequation %} וקטורים אלא יכולים להסתפק ב-{% equation %}n{% endequation %} כאלו). שימו לב שההרחבה הזו לא נקבעת בצורה יחידה, אז זו כבר הנקודה השניה שבה משהו לא נקבע באופן יחיד: גם {% equation %}X{% endequation %} לא נקבעה באופן יחיד, ועכשיו אנחנו רואים שאם לא כל הערכים הסינגולריים שונים מאפס אז גם {% equation %}Y{% endequation %} לא נקבעת באופן יחיד בהינתן {% equation %}X{% endequation %}.

קיבלנו מטריצה {% equation %}Y{% endequation %}, אבל צריך להראות ש-{% equation %}A=X\Lambda Y{% endequation %}, או באופן שקול ש-{% equation %}X^{*}A=\Lambda Y{% endequation %}. אפשר להראות ששתי המטריצות הללו שוות, שורה-שורה. עבור {% equation %}r{% endequation %} השורות הראשונות, השורות של {% equation %}Y{% endequation %} הן מהצורה

{% equation %}y_{i}=\sigma_{i}^{-1}x_{i}^{*}A{% endequation %}

ולכן השורות של {% equation %}\Lambda Y{% endequation %} הן מהצורה {% equation %}x_{i}^{*}A{% endequation %}, וזו בדיוק הצורה של שורה של {% equation %}X^{*}A{% endequation %} (שני אלו מאותם שיקולים על איך נראות העמודות של מכפלה שהזכרתי קודם, רק כשמפעילים אותם על שורות בתיקונים המתאימים).

עבור שורה {% equation %}y_{k}{% endequation %} שהיא מעבר ל-{% equation %}r{% endequation %} הראשונות, הסקלר המתאים ב-{% equation %}\Lambda{% endequation %} שבו כופלים את השורה ה-{% equation %}k{% endequation %} הוא {% equation %}\sigma_{k}=0{% endequation %}, ולכן מקבלים ב{% equation %}\Lambda Y{% endequation %}- את שורת האפס. מצד שני, השורה המתאימה בצד שמאל היא {% equation %}x_{k}^{*}A{% endequation %}. אל מה היא שווה? ובכן, מכיוון שהערך הסינגולרי {% equation %}\sigma_{k}=0{% endequation %} אז גם {% equation %}\lambda_{k}=0{% endequation %}, כלומר {% equation %}\left(AA^{*}\right)x_{k}=\lambda_{k}x_{k}=0{% endequation %}.

עכשיו אפשר להשתמש בטריק. נכפול את {% equation %}\left(AA^{*}\right)x_{k}{% endequation %} משמאל ב-{% equation %}x_{k}^{*}{% endequation %}. מכיוון ש-{% equation %}\left(AA^{*}\right)x_{k}{% endequation %} הוא וקטור האפס, אחרי הכפל ב-{% equation %}x_{k}^{*}{% endequation %} נקבל את סקלר האפס. מצד שני, אפשר להשתמש בפלא של האסוציאטיביות של כפל מטריצות כדי להפוך את המכפלה הזו למכפלה פנימית:

{% equation %}0=x_{k}^{*}\left(AA^{*}\right)x_{k}=\left(x_{k}^{*}A\right)\left(A^{*}x_{k}\right)=\left(A^{*}x_{k}\right)^{*}\left(A^{*}x_{k}\right)=\left\langle A^{*}x_{k},A^{*}x_{k}\right\rangle {% endequation %}

ולהשתמש בכך שמכפלה פנימית היא חיובית, כך שמכפלה פנימית של איבר בעצמו יצאה 0, האיבר הוא 0, כלומר {% equation %}A^{*}x_{k}=0{% endequation %}, ולכן גם {% equation %}0=\left(A^{*}x_{k}\right)^{*}=x_{k}^{*}A{% endequation %}, כמו שרצינו להראות. זה מסיים את ההוכחה.

בואו נציין שוב במפורש את מה שמצאנו: <strong>לכל</strong> מטריצה {% equation %}A{% endequation %}, תהא אשר תהא (חוץ מההנחה שמספר השורות בה לא גדול ממספר העמודות) קיים פירוק {% equation %}A=X\Lambda Y{% endequation %} כך ש-{% equation %}\Lambda{% endequation %} היא המטריצה האלכסונית של הערכים הסינגולריים של {% equation %}A{% endequation %}, {% equation %}X{% endequation %} היא מטריצה אוניטרית, ואילו {% equation %}Y{% endequation %} היא מטריצה בעלת שורות אורתונורמליות. 

נקודה אחת שעוד לא ראינו היא ש-{% equation %}\Lambda{% endequation %} נקבעת בצורה <strong>יחידה</strong>, במובן הבא: אם {% equation %}\Lambda{% endequation %} היא מטריצה אלכסונית <strong>כלשהי</strong> מסדר {% equation %}n\times n{% endequation %} שהכניסות על האלכסון שלה הן {% equation %}\tau_{1}\ge\tau_{2}\ge\ldots\ge\tau_{n}{% endequation %} ויש פירוק {% equation %}A=X\Lambda Y{% endequation %} עם תכונות האורתונורמליות של {% equation %}X,Y{% endequation %} שציינתי קודם, אז {% equation %}\tau_{i}=\sigma_{i}{% endequation %}, כלומר {% equation %}\Lambda{% endequation %} היא המטריצה של הערכים הסינגולריים. אין פירוק אחר שבו באמצע יש מטריצה עם ערכים <strong>ממשיים</strong> שמסודרים בסדר יורד. כדי לראות את זה, נניח ש-{% equation %}A=X\Lambda Y{% endequation %} ונחשב את {% equation %}AA^{*}{% endequation %}:

{% equation %}AA^{*}=\left(X\Lambda Y\right)\left(X\Lambda Y\right)^{*}=X\Lambda YY^{*}\Lambda X^{*}=X\Lambda^{2}X^{*}{% endequation %}

כאן השתמשנו בכך ש-{% equation %}YY^{*}=I{% endequation %} בזכות האורתונורמליות של שורות {% equation %}Y{% endequation %}.

עכשיו, מכיוון ש-{% equation %}X{% endequation %} היא מטריצה אוניטרית, המשוואה {% equation %}AA^{*}=X\Lambda^{2}X^{*}{% endequation %} אומרת ש-{% equation %}\Lambda^{2}{% endequation %} היא מה שמתקבל מלכסון אוניטרי של {% equation %}AA^{*}{% endequation %}, כלומר הכניסות של {% equation %}\Lambda^{2}{% endequation %} הן הערכים העצמיים של {% equation %}AA^{*}{% endequation %}: {% equation %}\tau_{i}^{2}=\lambda_{i}=\sigma_{i}^{2}{% endequation %}, ומכיוון שגם {% equation %}\sigma_{i}{% endequation %} וגם {% equation %}\tau_{i}{% endequation %} הם ממשיים אי שליליים, אפשר להוציא שורש ולקבל {% equation %}\tau_{i}=\sigma_{i}{% endequation %}.

<h2>מקבלים את הפירוק הפולארי ואת פירוק SVD</h2>

המטרה של הפוסט היא להראות איך מקבלים את פירוק SVD אבל עם מה שכבר ראינו כל כך קל לקבל את הפירוק הפולארי שיהיה מגוחך להתעלם מזה. אנחנו לוקחים מטריצה {% equation %}A{% endequation %} כלשהי מסדר {% equation %}n\times m{% endequation %} כך ש-{% equation %}n\le m{% endequation %} ועל פי מה שכבר ראינו, מקבלים עבורה פירוק

{% equation %}A=X\Lambda Y{% endequation %}

עכשיו נשתמש בטריק הכי עתיק בספר - נתקע באמצע הביטוי את {% equation %}X^{*}X{% endequation %} ששווה למטריצת היחידה, ונשתמש באסוציאטיביות. נקבל:

{% equation %}A=\left(X\Lambda X^{*}\right)\left(XY\right){% endequation %}

נסמן {% equation %}P=X\Lambda X^{*}{% endequation %} ו-{% equation %}U=XY{% endequation %} וקיבלנו פירוק {% equation %}A=PU{% endequation %}. עכשיו, מה אמרתי על הפירוק הזה קודם? שקיימת {% equation %}P\in M_{n,n}{% endequation %} חיובית מאותה דרגה כמו {% equation %}A{% endequation %}, ו-{% equation %}U\in M_{n,m}{% endequation %} כך ש-{% equation %}A=PU{% endequation %}, ו-{% equation %}U{% endequation %} היא "אוניטרית" במובן הבא: {% equation %}UU^{*}=I_{m\times m}{% endequation %}. כלומר, <strong>השורות</strong> של {% equation %}U{% endequation %} הן אורתונורמליות. האם שני אלו נכונים?

ראשית, הממדים מתאימים: {% equation %}X\Lambda X^{*}{% endequation %} היא באמת מסדר {% equation %}n\times n{% endequation %}, ואילו {% equation %}XY{% endequation %} היא מסדר {% equation %}n\times m{% endequation %}. שנית, 

{% equation %}UU^{*}=XYY^{*}X^{*}=XIX^{*}=XX^{*}=I{% endequation %}

מה שמשאיר רק להבין למה {% equation %}P{% endequation %} היא חיובית - אבל אנחנו יודעים שמטריצה היא חיובית אם ורק אם הערכים העצמיים שלה הם ממשיים אי שליליים, ו-{% equation %}X\Lambda X^{*}{% endequation %} הוא לכסון אוניטרי, הערכים העצמיים כבר כתובים במפורש ב-{% equation %}\Lambda{% endequation %} והם כולם ממשיים אי שליליים. זה מסיים את ההוכחה - אמרתי שזה יהיה פשוט!

עוד דבר שקל יחסית לראות הוא מתי הפירוק הפולארי הוא <strong>יחיד</strong>. ראשית, מה זו {% equation %}P{% endequation %}? אנחנו יודעים ש-{% equation %}P^{2}=\left(X\Lambda X^{*}\right)\left(X\Lambda X^{*}\right)=X\Lambda^{2}X^{*}{% endequation %}. אבל מי אלו {% equation %}X,\Lambda{% endequation %}? הן לא מטריצות שבאו משום מקום, הן הגיעו מכך שמצאנו לכסון אוניטרי של {% equation %}AA^{*}{% endequation %}, ובלכסון האוניטרי הזה {% equation %}AA^{*}{% endequation %} הייתה דומה למטריצה {% equation %}\Lambda^{2}{% endequation %} והמטריצה המלכסנת הייתה {% equation %}X{% endequation %}. במילים אחרות, {% equation %}P^{2}=AA^{*}{% endequation %} ולכן {% equation %}P{% endequation %} נקבעת בצורה <strong>יחידה</strong>, כי בפוסט הקודם ראינו שהשורש החיובי של מטריצה חיובית הוא יחיד.

האם זה קובע באופן יחיד את {% equation %}U{% endequation %}? לא בהכרח, אבל אם {% equation %}P{% endequation %} <strong>הפיכה</strong> אז כן, כי אז פשוט נקבל {% equation %}U=AP^{-1}{% endequation %} (בפוסט הקודם אמרתי שזה מאוד אנלוגי למה שקורה עם ההצגה הפולארית של מספרים מרוכבים - שם המספר היחיד שאין לו הצגה יחידה הוא 0, שאינו הפיך).

עכשיו בואו נעבור אל SVD. מה שקורה כאן הוא ש-{% equation %}A=X\Lambda Y{% endequation %} הוא לא פירוק מתאים, כי בפירוק {% equation %}A=U\Sigma V^{*}{% endequation %} שאנחנו מחפשים גם {% equation %}U{% endequation %} וגם {% equation %}V{% endequation %} הן ריבועיות ואוניטריות ואילו {% equation %}\Sigma{% endequation %} עלולה להיות לא ריבועית, בזמן שבפירוק {% equation %}A=X\Lambda Y{% endequation %} אמנם {% equation %}X{% endequation %} הוא ריבועית ואוניטרית, אבל {% equation %}Y{% endequation %} לא ריבועית (למרות שהיא כן סוג של אוניטרית במובן הזה ש-{% equation %}YY^{*}=I{% endequation %}) ודווקא {% equation %}\Lambda{% endequation %} היא ריבועית. אז איך עוברים מפירוק אחד לשני? באופן די ישיר, למען האמת.

ראשית, {% equation %}X\in M_{n,n}{% endequation %} היא כבר ריבועית ואוניטרית, אז מה יש לשנות כאן? נגדיר {% equation %}U=X{% endequation %}.

שנית, {% equation %}\Lambda\in M_{n,n}{% endequation %} כבר מכילה את הערכים הסינגולריים על האלכסון. הדבר היחיד שמבדיל בינה ובין {% equation %}\Sigma{% endequation %} שתיארנו קודם, הוא ש-{% equation %}\Sigma{% endequation %} יכולה להיות ארוכה יותר - כלומר, עם יותר עמודות. ליתר דיוק, {% equation %}\Sigma\in M_{n,m}{% endequation %} ובכל החלל הריק הנוסף הזה יש רק אפסים. אז ככה נגדיר אותה; פורמלית, מסמנים {% equation %}\Sigma=\left[\Lambda|0\right]{% endequation %} או משהו בסגנון כדי לתאר את המטריצה שמתקבלת מ-{% equation %}\Lambda{% endequation %} על ידי "הדבקה מימין" של מטריצת אפסים מסדר {% equation %}n\times\left(m-n\right){% endequation %}.

האתגר הגדול יותר הוא {% equation %}V{% endequation %}. אי אפשר להשתמש סתם ב-{% equation %}Y{% endequation %} כי {% equation %}Y{% endequation %} היא מסדר {% equation %}n\times m{% endequation %}. זכרו ש-{% equation %}n\le m{% endequation %} ולכן ייתכן ש"חסרות לה שורות" כדי להיות ריבועית. אבל כמו שעשינו קודם, אפשר <strong>להרחיב</strong>. אם נסתכל על איך קיבלנו את {% equation %}Y{% endequation %} מלכתחילה, הגדרנו שורות מסוימות שלה במפורש באמצעות ביטוי שעירב את {% equation %}A{% endequation %}, את העמודות של {% equation %}X{% endequation %} ואת הערכים הסינגולריים, ואז הוספנו עוד שורות שהיו בלתי תלויות ואורתונורמליות לשורות הקודמות, רק שאז עצרנו באופן שרירותי אחרי שהיו לנו {% equation %}n{% endequation %} שורות, למרות שיכלנו להמשיך (בטכניקות הרגילות של השלמה לבסיס וגרם-שמידט) ולקבל {% equation %}m{% endequation %} שורות כאלו. אז נשלים את ההרחבה; נסמן את המטריצה של השורות הנוספות שהוספנו ב-{% equation %}S{% endequation %} ועכשיו נשים לב שמה שאני רוצה שיהיה איפה ש-{% equation %}Y{% endequation %} נמצאת כרגע הוא לא {% equation %}V{% endequation %} אלא {% equation %}V^{*}{% endequation %}, אז נגדיר את {% equation %}V{% endequation %} בתור הפעלת הצמדה על הכל: {% equation %}V=\left[Y^{*}|S^{*}\right]{% endequation %}. זו מטריצה מסדר {% equation %}m\times m{% endequation %}, אבל האם באמת מתקיים {% equation %}A=U\Sigma V^{*}{% endequation %}? בואו נראה שמתקיים {% equation %}U\Sigma V^{*}=X\Lambda Y=A{% endequation %} ובכך נסיים את זה.

ראשית, {% equation %}X=U{% endequation %} אז המשוואה שצריך להראות היא מהצורה {% equation %}U\Sigma V^{*}=U\Lambda Y{% endequation %} ועל ידי כפל ב-{% equation %}U^{*}{% endequation %} של שני האגפים נקבל שצריך להראות {% equation %}\Sigma V^{*}=\Lambda Y{% endequation %}.

נסמן את השורות של {% equation %}Y{% endequation %} ב-{% equation %}y_{1},\ldots,y_{r}{% endequation %} כמו קודם, ואת השורות החדשות, שנמצאות ב-{% equation %}S{% endequation %}, ב-{% equation %}y_{r+1},\ldots,y_{m}{% endequation %}. אפשר לתאר באופן סכמטי את שני כפלי המטריצות בתור

{% equation %}\Sigma V^{*}=\left(\begin{array}{ccccccc} \sigma_{1} &  &  &  & 0 & \cdots & 0\\  & \sigma_{2}\\  &  & \ldots\\  &  &  & \sigma_{n} & 0 & \cdots & 0 \end{array}\right)\left(\begin{array}{c} y_{1}\\ y_{2}\\ \vdots\\ y_{m} \end{array}\right)=\left(\begin{array}{c} \sigma_{1}y_{1}\\ \sigma_{2}y_{2}\\ \vdots\\ \sigma_{n}y_{n} \end{array}\right){% endequation %}

{% equation %}\Lambda Y=\left(\begin{array}{cccc} \sigma_{1}\\  & \sigma_{2}\\  &  & \ldots\\  &  &  & \sigma_{n} \end{array}\right)\left(\begin{array}{c} y_{1}\\ y_{2}\\ \vdots\\ y_{n} \end{array}\right)=\left(\begin{array}{c} \sigma_{1}y_{1}\\ \sigma_{2}y_{2}\\ \vdots\\ \sigma_{n}y_{n} \end{array}\right){% endequation %}

כאן ה"וקטור" של ה-{% equation %}y{% endequation %}-ים הוא לא וקטור, הוא מטריצה - מה שמקבלים כשכותבים במקום כל {% equation %}y{% endequation %} כזה את כל השורה שהוא מייצג (ולכן {% equation %}\sigma_{i}y_{i}{% endequation %} הוא כפל של כל אברי השורה {% equation %}y_{i}{% endequation %} בסקלר {% equation %}\sigma_{i}{% endequation %}). לי אישית הכי קשה לעכל כאן את זה ש-{% equation %}\Sigma V^{*}{% endequation %} כולל כפל ב"וקטור" של {% equation %}y_{1},\ldots,y_{m}{% endequation %} אבל התוצאה מגיעה רק עד {% equation %}y_{n}{% endequation %}; אבל זה ברור אם חושבים על זה רגע כי יש לנו שורה בתוצאה רק לכל שורה של {% equation %}\Sigma{% endequation %}, לא מעבר לכך. ה-{% equation %}y{% endequation %}-ים שמעבר ל-{% equation %}y_{n}{% endequation %} שב-{% equation %}V^{*}{% endequation %} לא מקבלים הזדמנות לבוא לידי ביטוי כי הם מוכפלים תמיד בחלק של ה-{% equation %}0\cdots0{% endequation %} של {% equation %}\Sigma{% endequation %}. הסיבה שבגללה הם קיימים היא כדי ש-{% equation %}V{% endequation %} תהיה מטריצה אוניטרית בעצמה, לא יותר מכך.

<h2>בואו נכניס את הדרגה לתמונה</h2>

יש עוד היבט מעניין של SVD שעוזר להבין מה בעצם הוא אומר: אפשר לחשוב עליו בתור פירוק של {% equation %}A{% endequation %} לצירוף לינארי של מטריצות מדרגה 1, כשמקדמי הצירוף הם בדיוק הערכים הסינגולריים - ולכן בעצם יש לנו פירוק של {% equation %}A{% endequation %} לרכיבים בסיסיים על פי "סדר חשיבות" (ככל שהערך הסינגולרי גדול יותר, הרכיב "יבוא יותר לידי ביטוי").

קודם כל אולי כדאי שאזכיר מה זו דרגה של מטריצה, שאני מסמן ב-{% equation %}\text{rank}A{% endequation %}. ההגדרה שלי היא שזה המימד של <strong>מרחב העמודות</strong> של {% equation %}A{% endequation %} - כלומר, אם {% equation %}A\in M_{n,m}{% endequation %} אז אני לוקח את {% equation %}m{% endequation %} העמודות של {% equation %}A{% endequation %} ולוקח כל צירוף לינארי אפשרי שלהן ובודק מה הגודל של בסיס למרחב הזה. זה הולך להיות מספר בין 0 ל-{% equation %}m{% endequation %}, כש-0 פירושו שהמטריצה {% equation %}A{% endequation %} כולה אפסים ואילו {% equation %}m{% endequation %} פירושו שכל העמודות של {% equation %}A{% endequation %} הן בלתי תלויות, וזה שקול לכך ש-{% equation %}A{% endequation %} <strong>הפיכה</strong>. אם כן, אפשר לחשוב על דרגה של מטריצה בתור כמות "דרגות החופש" שיש בה - כמה אינפורמציה היא מכילה.

יש עוד אפיונים שקולים לדרגה. ראשית, הדרגה שווה גם למימד של <strong>מרחב השורות</strong> של המטריצה. זו תוצאה לא טריוויאלית, אבל לא אוכיח אותה כאן; זה גם אומר שהדרגה של מטריצה לא יכולה להיות גדולה מ-{% equation %}\min\left\{ n,m\right\} {% endequation %}. עכשיו, כשכופלים את {% equation %}A{% endequation %} בוקטור {% equation %}v{% endequation %} כלשהו, אז {% equation %}Av{% endequation %} הוא וקטור שהוא צירוף לינארי של <strong>עמודות</strong> {% equation %}A{% endequation %} - ולכן אם אנחנו כופלים את {% equation %}A{% endequation %} בכל הוקטורים האפשריים, נקבל בדיוק את מרחב העמודות של המטריצה; ומצד שני נקבל בדיוק את מה שנקרא <strong>התמונה</strong> של {% equation %}A{% endequation %} ומסומן {% equation %}\text{Im}A\triangleq\left\{ Av\ |\ v\in\mathbb{F}^{m}\right\} {% endequation %}, כך שיוצא ש-{% equation %}\text{rank}A=\dim\text{Im}A{% endequation %}. 

עכשיו, נסתכל על פירוק ה-SVD של {% equation %}A{% endequation %}, {% equation %}A=U\Sigma V^{*}{% endequation %}. מה אנחנו יודעים על הדרגות של המטריצות המעורבות? מכיוון ש-{% equation %}U,V{% endequation %} הן הפיכות הן מדרגה מקסימלית ביחס לגודל שלהן, ומה שחשוב כאן הוא שכפל במטריצה כזו <strong>לא משנה את הדרגה</strong> של התוצאה. כלומר, זה שאני כופל את {% equation %}\Sigma{% endequation %} משמאל ב-{% equation %}U{% endequation %} ומימין ב-{% equation %}V{% endequation %} לא ישפיע על הדרגה, והדרגה של {% equation %}U\Sigma V^{*}{% endequation %} (כלומר של {% equation %}A{% endequation %}) תהיה זהה לדרגה של {% equation %}\Sigma{% endequation %}. ומה זו הדרגה הזו? {% equation %}\Sigma\in M_{n,m}{% endequation %} ואנחנו יודעים ש-{% equation %}n\le m{% endequation %} אז הדרגה של {% equation %}\Sigma{% endequation %} היא לכל היותר {% equation %}n{% endequation %}, אבל היא יכולה להיות קטנה יותר. יש ב-{% equation %}\Sigma{% endequation %} עמודות שכל אחת מהן כוללת ערך סינגולרי יחיד {% equation %}\sigma_{i}{% endequation %}, ולכן מספר העמודות השונות מאפס ב-{% equation %}\Sigma{% endequation %} <strong>זהה</strong> למספר הערכים הסינגולריים ששונים מאפס. כלומר, {% equation %}\text{rank}A=r{% endequation %} אם ורק אם הערכים הסינגולריים הגדולים מאפס של {% equation %}A{% endequation %} הם {% equation %}\sigma_{1},\ldots,\sigma_{r}{% endequation %}.

עכשיו בואו נחזור לתחביב שלי "להציג מטריצות כאילו הן וקטורים". אני אסמן {% equation %}U=\left(u_{1}\ u_{2}\ \ldots\ u_{n}\right){% endequation %} כאשר כל {% equation %}u_{i}{% endequation %} הוא וקטור עמודה; ואסמן {% equation %}V=\left(v_{1}\ v_{2}\ \ldots\ v_{m}\right){% endequation %} עם אותו רעיון בדיוק. עכשיו אפשר להציג את {% equation %}U\Sigma V^{*}{% endequation %} כמו כפל של מטריצה בוקטורים מימין ומשמאל, כמו בתבנית בילינארית:

{% equation %}U\Sigma V^{*}=\left(u_{1}\ u_{2}\ \ldots\ u_{n}\right)\left(\begin{array}{ccccccc} \sigma_{1} &  &  &  & 0 & \cdots & 0\\  & \sigma_{2}\\  &  & \ldots\\  &  &  & \sigma_{n} & 0 & \cdots & 0 \end{array}\right)\left(\begin{array}{c} v_{1}^{*}\\ v_{2}^{*}\\ \vdots\\ v_{m}^{*} \end{array}\right)=\left(u_{1}\ u_{2}\ \ldots\ u_{n}\right)\left(\begin{array}{c} \sigma_{1}v_{1}^{*}\\ \sigma_{2}v_{2}^{*}\\ \vdots\\ \sigma_{n}v_{n}^{*} \end{array}\right)=\sum_{i=1}^{n}\sigma_{i}u_{i}v_{i}^{*}{% endequation %}

כזכור, {% equation %}u_{i}{% endequation %} הוא וקטור <strong>עמודה</strong> מסדר {% equation %}n\times1{% endequation %} ואילו {% equation %}v_{i}^{*}{% endequation %} הוא וקטור <strong>שורה</strong> מסדר {% equation %}1\times m{% endequation %}. לכן המכפלה {% equation %}u_{i}v_{i}^{*}{% endequation %} היא מטריצה מסדר {% equation %}n\times m{% endequation %}, בדיוק כמו {% equation %}A{% endequation %} המקורית, אבל מכיוון שהיא מכפלה של שתי מטריצות מדרגה 1 גם היא מדרגה 1 לכל היותר (באופן כללי מכפלה של מטריצות יכולה רק להוריד את הדרגה או להותיר אותה ללא שינוי - אי אפשר ליצור אינפורמציה יש מאין). לכן {% equation %}\sum_{i=1}^{n}\sigma_{i}u_{i}v_{i}^{*}{% endequation %} הוא בדיוק מה שרצינו - הצגה של {% equation %}A{% endequation %} בתור צירוף לינארי של מטריצות מדרגה 1. אפשר גם לכתוב {% equation %}\sum_{i=1}^{r}\sigma_{i}u_{i}v_{i}^{*}{% endequation %} כדי להדגיש שמעניינות אותנו רק המטריצות שמתאימות לערכים הסינגולריים החיוביים.

<h2>בשביל מה זה טוב...?</h2>

אוקיי, תפסתם אותי, אני לא באמת יודע בשביל מה זה טוב - יש לכל זה הרבה שימושים בתחומים שאני לא כל כך מכיר אז אני לא אוכל להיכנס לזה בפוסט הזה. אבל אני כן אדבר על שימוש אחד שנתקלתי בו והוא חביב ודי קל להצגה (ההקשר היה חישוב קוונטי, ספציפית בנייה של מעגלים קוונטיים יעילים כדי לייצור אופרטורים אוניטריים כלליים; אבל זה לא באמת חשוב להמשך): בהינתן מטריצה ריבועית {% equation %}A\in M_{n,n}{% endequation %} ייתכן שהיא לא אוניטרית, אבל אפשר לשאול מי המטריצה האוניטרית "הכי קרובה" אליה. בהקשר שבו נתקלתי בזה, זה היה שימושי בסיטואציות שבהן ביצענו חישוב שהיא <strong>אמור</strong> להניב מטריצה אוניטרית, אבל בגלל בעיות נומריות נכשל; במקרה כזה סביר להניח שהמטריצה שהייתה אמורה לצאת היא האוניטרית הקרובה ביותר למה שקיבלנו בפועל, אז אם נוכל למצוא אותה נחליף את המטריצה הנוכחית בה.

הטריק הוא מאוד פשוט: אם נמצא את הפירוק הפולארי {% equation %}A=PU{% endequation %}, אז {% equation %}U{% endequation %} היא הקירוב האוניטרי הזה. באופן שקול, אם {% equation %}A=U\Sigma V^{*}{% endequation %} הוא פירוק SVD של {% equation %}A{% endequation %} אז המטריצה האוניטרית הקרובה ביותר היא {% equation %}UV^{*}{% endequation %} (כזכור, התחלנו מ-{% equation %}A=X\Lambda Y{% endequation %}; במקרה של הפירוק הפולארי הגדרנו {% equation %}U=XY{% endequation %} ואילו במקרה של SVD הגדרנו {% equation %}U=X{% endequation %} וכאשר {% equation %}A{% endequation %} היא ריבועית, ההגדרה של {% equation %}V{% endequation %} יוצאת פשוט {% equation %}V=Y^{*}{% endequation %} ולכן {% equation %}UV^{*}=XY{% endequation %}).

בואו נוכיח את זה, אבל קודם כל צריך להסביר מה זה בכלל אומר "הכי קרובה". כדי לדבר על קרבה של מטריצות צריך להכניס לתמונה <strong>מטריקה</strong>, פונקציה כלשהי שמודדת מרחק; למרבה המזל עבור מטריצות יש אחת פשוטה למדי.

עבור וקטור {% equation %}a=\left(a_{1},\ldots,a_{n}\right){% endequation %}, מכפלה פנימית שלנו בעצמו מחזירה לנו את <strong>הנורמה</strong> {% equation %}\|a\|^{2}=\sum_{i=1}^{n}\left|a_{i}\right|^{2}{% endequation %}. יש עוד דרכים להגדיר נורמות על וקטורים, אז נהוג לפעמים לסמן את הנורמה הזו עם "2" כדי לציין את זה שאנחנו מעלים בחזקת 2 את אברי המטריצה (אחרי שלקחנו את הערך המוחלט שלהם) ובסוף מוציאים שורש ריבועי כדי לקבל את הנורמה: {% equation %}\|a\|_{2}=\sqrt{\sum_{i=1}^{n}\left|a_{i}\right|^{2}}{% endequation %}. עבור מטריצות אפשר להגדיר את אותו הדבר בדיוק: ניקח את הכניסות של המטריצה, לכל אחת נחשב את הריבוע של הערך המוחלט, נחבר את הכל ונוציא שורש ריבועי. לדבר הזה קוראים לפעמים <strong>נורמת פרובניוס</strong> ולפעמים סתם נורמה-2 ואני סתם אשתמש בסימן הנורמה:

{% equation %}\|A\|=\sqrt{\sum_{i,j}\left|A_{ij}\right|^{2}}{% endequation %}

יש דרך קצת יותר נקייה לתאר את הנורמה הזו. כזכור, {% equation %}AA^{*}{% endequation %} שכבר ראינו כמה פעמים היא מטריצה שבה הכניסה ה-{% equation %}ij{% endequation %} היא מכפלה של השורה ה-{% equation %}i{% endequation %} בהצמדה של השורה ה-{% equation %}j{% endequation %} של {% equation %}A{% endequation %}. בפרט, אם נסתכל על <strong>האלכסון</strong> של {% equation %}AA^{*}{% endequation %}, מה שיש שם הוא את המכפלה של השורה ה-{% equation %}i{% endequation %} בהצמדה של <strong>עצמה</strong>, מה שנותן בדיוק את נורמת-2 בריבוע של וקטור השורה הזו. אז אם <strong>נחבר</strong> את כל אברי האלכסון, נקבל בדיוק את סכום כל הכניסות במטריצה, בערך מוחלט, בריבוע. וכשמדברים על מטריצות, יש שם וסימון פשוטים לסכום אברי האלכסון של המטריצה: "עקבה", trace. במילים אחרות,

{% equation %}\|A\|^{2}=\text{tr}\left(AA^{*}\right){% endequation %}

זה מקרה פרטי של המכפלה הפנימית הכללית: {% equation %}\left\langle A,B\right\rangle =\text{tr}\left(AB^{*}\right){% endequation %}.

למעבר לשימוש ב-{% equation %}\text{tr}{% endequation %} יש יתרונות לא זניחים, כי זו פונקציה שאנחנו מכירים יפה אותה ואת המוזרויות שלה. מוזרות שימושית במיוחד נקראת <strong>התכונה הציקלית</strong> של העקבה. היא אומרת שאם יש לנו מטריצות {% equation %}A,B,C,D{% endequation %} אז 

{% equation %}\text{tr}\left(ABCD\right)=\text{tr}\left(DABC\right){% endequation %}

כלומר, הזזנו את {% equation %}D{% endequation %} "ימינה" באופן ציקלי - כלומר, היא יצאה מימין ונכנסה חזרה משמאל. כמובן, זה יכול לעבוד רק כשהממדים של המטריצות מאפשרים את המכפלות הללו, אבל כשזה עובד זה די מרהיב.

אוקיי, בואו נחזור לעניין שלנו. אפשר להשתמש בנורמת פרובניוס כדי להגדיר <strong>מרחק</strong> בין שתי מטריצות על ידי {% equation %}\|A-B\|{% endequation %}. בהקשר שלנו, השאלה היא זו: נתונה לנו {% equation %}A\in M_{n,n}{% endequation %} ריבועית ואנחנו רוצים למצוא מטריצה {% equation %}U\in M_{n,n}{% endequation %} אוניטרית כך ש-{% equation %}\|A-U\|{% endequation %} יהיה מינימלי (כשהמינימום נלקח על פני כל הערכים האפשריים של {% equation %}U\in M_{n,n}{% endequation %} האוניטריות).

בשביל למצוא {% equation %}U{% endequation %} כזו, בואו נתייחס אל {% equation %}\|A-U\|{% endequation %} בתור מכפלה פנימית ונשתמש בחוקי החשבון הרגילים של מכפלות פנימיות:

{% equation %}\|A-U\|=\left\langle A-U,A-U\right\rangle =\left\langle A,A\right\rangle -\left\langle A,U\right\rangle -\left\langle U,A\right\rangle +\left\langle U,U\right\rangle {% endequation %}

{% equation %}=\|A\|^{2}-\left\langle A,U\right\rangle -\overline{\left\langle A,U\right\rangle }+\|U\|^{2}=\|A\|^{2}-2\text{Re}\left\langle A,U\right\rangle +\|U\|^{2}{% endequation %}

עכשיו, {% equation %}\|A\|^{2}{% endequation %} הוא מספר קבוע (כי {% equation %}A{% endequation %} קבועה) ואילו {% equation %}\|U\|^{2}=n{% endequation %}, כי {% equation %}U{% endequation %} אוניטרית ולכן 

{% equation %}\|U\|^{2}=\left\langle U,U\right\rangle =\text{tr}\left(UU^{*}\right)=\text{tr}\left(I\right){% endequation %}

אז הדבר היחיד שיכול להשתנות בערך של {% equation %}\|A-U\|{% endequation %} כשאנחנו עוברים על ה-{% equation %}U{% endequation %} האוניטריות הוא החלק {% equation %}-2\text{Re}\left\langle A,U\right\rangle {% endequation %}. אם אנחנו רוצים להקטין את {% equation %}\|A-U\|{% endequation %} ככל הניתן, אנחנו רוצים למקסם את {% equation %}\text{Re}\left\langle A,U\right\rangle {% endequation %} ככל הניתן. עכשיו,

{% equation %}\text{Re}\left\langle A,U\right\rangle =\text{Re}\text{tr}\left(AU^{*}\right){% endequation %}

עכשיו אפשר להכניס לתמונה את התותח הכבד שלנו: ניקח פירוק SVD של {% equation %}A{% endequation %}, {% equation %}A=V\Sigma W^{*}{% endequation %} (אני לא משתמש ב-{% equation %}U{% endequation %} כמו בדרך כלל כי הוא כבר תפוס). אז קיבלנו

{% equation %}\text{Re}\text{tr}\left(AU^{*}\right)=\text{Re}\text{tr}\left(V\Sigma W^{*}U^{*}\right)=\text{Re}\text{tr}\left(\Sigma W^{*}U^{*}V\right){% endequation %}

כשהמעבר האחרון הוא התכונה הציקלית הידועה לשמצה. זה טוב לנו, כי עכשיו {% equation %}\Sigma{% endequation %} היא בהתחלה, והיא מטריצה אלכסונית עם אלכסון של הערכים הסינגולריים {% equation %}\left(\sigma_{1},\ldots,\sigma_{n}\right){% endequation %}. כזכור, לכפול משמאל במטריצה אלכסונית מכפיל את <strong>השורות</strong> של מה שמימין בסקלרים של המטריצה האלכסונית. אז אם נסמן {% equation %}T=W^{*}U^{*}V{% endequation %} אז נקבל

{% equation %}\text{tr}\left(\Sigma T\right)=\sum_{i=1}^{n}\sigma_{i}t_{ii}{% endequation %}

ומכיוון שהערכים הסינגולריים הם ממשיים, אפשר להכניס את ה-{% equation %}\text{Re}{% endequation %} פנימה:

{% equation %}\text{Re}\text{tr}\left(\Sigma T\right)=\sum_{i=1}^{n}\sigma_{i}\text{Re}\left(t_{ii}\right){% endequation %}

עכשיו, {% equation %}T{% endequation %} היא מכפלה של <strong>שלוש</strong> מטריצות אוניטריות, ולכן גם היא עצמה אוניטרית. זה בפרט אומר שהעמודות של {% equation %}T{% endequation %} הן אורתונורמליות, כלומר מנורמה 1. לכן {% equation %}\sum_{i=1}^{n}\left|t_{ij}\right|^{2}=1{% endequation %} ובפרט {% equation %}\text{Re}\left(t_{ii}\right)\le\left|t_{ii}\right|^{2}\le1{% endequation %}. לכן הסכום {% equation %}\sum_{i=1}^{n}\sigma_{i}\text{Re}\left(t_{ii}\right){% endequation %} יקבל את ערכו המקסימלי אם {% equation %}\text{Re}\left(t_{ii}\right)=1{% endequation %} לכל {% equation %}1\le i\le n{% endequation %}, מה שקורה אם {% equation %}T=I{% endequation %}, כלומר אם {% equation %}W^{*}U^{*}V=I{% endequation %} כלומר אם {% equation %}U^{*}=WV^{*}{% endequation %}, כלומר אם {% equation %}U=VW^{*}{% endequation %}, וזו בדיוק התוצאה שהבטחתי.

מה שאני אוהב כאן הוא שבעזרת SVD אנחנו מקבלים הוכחה פשוטה מאוד לטענה הזו, ובעזרת הפירוק הפולארי אנחנו גם יכולים לקבל אינטואיציה: במספרים מרוכבים, אם היינו רוצים את המספר המרוכב מנורמה {% equation %}1{% endequation %} הקרוב ביותר אל {% equation %}z{% endequation %} היינו מותחים קו ישר מ-{% equation %}z{% endequation %} אל ראשית הצירים ובודקים איפה הוא חותך את מעגל היחידה- כלומר, היינו מייצגים את {% equation %}z{% endequation %} בתור {% equation %}z=re^{i\theta}{% endequation %} ואז פשוט היינו מציבים {% equation %}r=1{% endequation %} ונשארים עם {% equation %}e^{i\theta}{% endequation %}. זה בעצם גם מה שאנחנו עושים כאן, כשאנחנו מוצאים את {% equation %}A=PU{% endequation %} ואז מחליפים את {% equation %}P{% endequation %} ב-{% equation %}I{% endequation %}. אלגברה לינארית זה כיף. 