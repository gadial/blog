---
title: "תורת הקבוצות - פונקציות"
layout: post
categories:
  - תורת הקבוצות
tags:
  - תורת הקבוצות
  - פונקציות
image: /assets/img/og_image/functions.png
---

סדרת הפוסטים שלי על תורת הקבוצות הגיעה עכשיו לשלב שבו אני רוצה להגדיר פורמלית <strong>פונקציות</strong>. וזה נחמד, כי פונקציה היא אחד מהמושגים המרכזיים במתמטיקה, אם לא המושג המרכזי ביותר, ולכן זו הזדמנות טובה לעצור ולשאול - מה זה בדיוק, הדבר הזה שמופיע בכל מקום?

האינטואיציה שלי היא לחשוב על פונקציה בתור <strong>תהליך</strong> או בתור <strong>כלל</strong> שלוקח משהו אחד שאני קורא לו "הקלט" וממיר אותו למשהו אחר שאני קורא לו "הפלט". למשל {% equation %}f\left(x\right)=x^{2}{% endequation %} זו פונקציה שלוקחת מספר ומעלה אותו בריבוע (כופלת אותו בעצמו) או {% equation %}f\left(a\right)=\left\{ a\right\} {% endequation %} זו פונקציה שלוקחת איבר ומחזירה את הסינגלטון שכולל רק אותו (סינגלטון הוא קבוצה בעלת איבר יחיד). זו אינטואיציה לא רעה. היא גם <strong>לא מספיק טובה</strong> בשביל ההגדרה שאני רוצה לתת כאן. למה? כי אני רוצה להיות כללי ככל הניתן, ולכן להיות מסוגל לדבר גם על פונקציות שבהן אני לא יכול לזהות "תהליך" ברור או "כלל" מובהק שמגדיר אותן.

בואו נחדד את הנקודה הזו. הפונקציה {% equation %}f\left(x\right)=\frac{x^{3}+7}{2x-4}{% endequation %} היא פונקציה שנתונה לי על ידי <strong>נוסחה</strong>. מה זו נוסחה? במקרה הזה, הנוסחה מגדירה לי תרגיל חשבוני שלם שצריך לבצע. היא אומרת לי "קח את איקס, תכפול אותו בעצמו פעמיים ותוסיף שבע לתוצאה, שים את התוצאה בצד לרגע, קח את איקס, כפול אותו ב-2 וחסר 4 מהתוצאה, ועכשיו קח את התוצאה המקורית וחלק במה שקיבלת לפני רגע". שזו דרך ארוכה ומסורבלת להגיד בעברית את מה שהנוסחה אומרת במקוצר (ולכן אנחנו משתמשים בנוסחאות ולא בעברית!) אבל מה שחשוב פה הוא שהנוסחה אומרת <strong>במפורש</strong> מה לעשות בכל שלב (וכמובן, מתעלמת באלגנטיות מהסכנה של חלוקה באפס שיש כאן - אני אתייחס לנקודה הזו בהמשך).

אבל הנה פונקציה מסוג שונה לגמרי: פונקציה שלוקחת פולינום {% equation %}p\left(x_{1},\dots,x_{n}\right){% endequation %} במספר כלשהו של משתנים - לאו דווקא משתנה יחיד - עם מקדמים <strong>שלמים</strong> ומחזירה את המספר 1 אם קיימים מספרים שלמים שאפשר להציב אותם בפולינום כך שיתקבל 0; והיא מחזירה 0 אם לא קיימים מספרים כאלו. פורמלית, {% equation %}f\left(p\right)=\begin{cases} 1 & \exists a\in\mathbb{Z}^{n}:P\left(a\right)=0\\ 0 & \text{else} \end{cases}{% endequation %}. הפונקציה הזו עדיין מתארת, לכאורה, תהליך כלשהו: לוקחים את {% equation %}p{% endequation %}, בודקים איכשהו אם אפשר לאפס אותו ככה או לא, ואז מחזירים 1 או 0 בהתאם. העניין הוא ש<strong>אין תהליך שעושה את זה</strong> במובן הסטנדרטי שאנחנו רגילים לחשוב עליו: אין <strong>אלגוריתם</strong> שפותר את הבעיה הזו, שנקראת <strong>הבעיה העשירית של הילברט</strong> והקדשתי לה בשעתו <a href="https://gadial.net/2012/08/27/hilbert_tenth_intro/">סדרת פוסטים בבלוג</a> בדיוק כדי שנראה שהיא לא פתירה.

אפשר, כמובן, לטעון שפונקציות שאין לנו תיאור מפורש של תהליך שמחשב אותן הן לא מעניינות, אבל אותי הן כן מעניינות! בפרט, איך בדיוק אפשר לדעת מראש אם פונקציה כלשהי היא ניתנת לחישוב או לא? בשביל להיווכח בכך שהבעיה העשירית של הילברט בלתי פתירה נדרשו שבעים שנים בערך והמצאה של כל תורת החישוביות. אז לא, בואו נעזוב את האינטואיציה שפונקציה אמורה לתאר במפורש איך היא מחשבת את מה שהיא מחשבת.

בסדר גמור, אתם אומרים. אז "תהליך" לא צריך, אבל "כלל" עדיין יש - עבור הבעיה העשירית של הילברט אתה נתת במפורש כלל שהיה פשוט למדי לניסוח וכולנו מבינים מה הוא אומר. מעולה! אז הנה לכם בעיה חדשה. ניקח את המספרים הממשיים, {% equation %}\mathbb{R}{% endequation %}, ונסתכל על אוסף כל תת-הקבוצות שלהם, {% equation %}\mathcal{P}\left(\mathbb{R}\right){% endequation %}. מהאוסף הזה נוריד את הקבוצה הריקה, ועכשיו נדבר על פונקציה שהקלט שלה הוא קבוצה {% equation %}A{% endequation %} מתוך האוסף - כלומר, קבוצה לא ריקה של ממשיים - והפלט שלה על הקלט הזה הוא איבר כלשהו מתוך הקבוצה.

אוקיי, אבל <strong>איזו</strong> פונקציה? נאמר, מה הפונקציה מחזירה עבור הקבוצה {% equation %}\left\{ 1,2\right\} {% endequation %}? היא יכולה להחזיר כל אחד משניהם, אנחנו חייבים להחליט מה מהם היא מחזירה אם אנחנו רוצים לדבר על פונקציה קונקרטית ולא על אוסף גדול של פונקציות אפשריות. אז נניח שהחלטנו שהיא מחזירה 1. אבל עכשיו נשאלת השאלה מה היא מחזירה עבור הקבוצה {% equation %}\left\{ \pi,17,523\right\} {% endequation %} וכן הלאה. אם היה מדובר, נאמר, על קבוצות של מספרים טבעיים היה קל לתת כלל שיגיד מה לעשות בכל מקרה אפשרי - פשוט להחזיר את האיבר המינימלי בכל קבוצה. אבל בקבוצות של ממשיים לאו דווקא יש איבר מינימלי, וגם טריקים מתוחכמים יותר שיעבדו עבור הרציונליים לא יעבדו פה. אז מה עושים?

התשובה היא שלא עושים. להוכיח שלא עושים זה מסובך מאוד ולא ניכנס לזה כאן, אבל פשוט <strong>אי אפשר</strong> לתת תיאור מפורש של פונקציה כזו. תחת זאת, אנחנו מניחים שקיימת כזו, כאקסיומה. ואם אנחנו מדברים על האינטואיציות, אז האינטואיציה פה היא שזה מאוד, מאוד מוזר. כלומר - כל מה שהפונקציה צריכה לעשות הוא להחזיר איברים מתוך קבוצות לא ריקות, לא? אז הנה, היא קיבלה קבוצה לא ריקה. <strong>יש שם איברים שאפשר להחזיר</strong>. אז למה שהיא לא פשוט... תחזיר? אחד מהם? לא חשוב איזה? אבל זה בדיוק מקרה שבו אין "כלל". מקרה שבו אנחנו רוצים לדבר על פונקציה גם בלי שום דרך טובה להסביר מה בעצם היא עושה מעבר לכך שאנחנו יכולים לדבר על קשר כלשהו בין הקלט והפלט שלה.

אז כשאני בא להגדיר את המושג של פונקציה, אני לוקח את האינטואיציה של "תהליך או כלל שהופך קלט לפלט" ופשוט מעיף ממנה את ה"תהליך". אני משאיר את הקלט ואת הפלט. כלומר - פורמלית פונקציה מ-{% equation %}A{% endequation %} אל {% equation %}B{% endequation %} הולכת להיות אוסף של זוגות מהצורה {% equation %}\left(a,b\right){% endequation %} כך ש-{% equation %}a\in A{% endequation %} ו-{% equation %}b\in B{% endequation %}. לדבר הזה יש שם: זה <strong>יחס</strong> מ-{% equation %}A{% endequation %} אל {% equation %}B{% endequation %}; תת-קבוצה של {% equation %}A\times B{% endequation %}. אבל לא כל יחס יכול להיחשב פונקציה - בואו נחשוב לרגע מה אנחנו כן רוצים שיתקיים מבחינת יחסי קלט/פלט.

ובכן, כשאני מדמיין אינטואיטיבית פונקציה אני חושב על משהו שלוקח קלט, עושה לו קרחחצבופינצינקי ואז מוציא פלט. לא מעניין אותי ה-"קרחחצבופינצינקי" אבל אני במובלע מניח שהוא מקבל בברכה <strong>כל</strong> קלט ותמיד מוציא לו פלט מתאים, ושזה <strong>תמיד אותו פלט</strong>. במילים אחרות, אני לא מדמיין את אדון קרחחצבופינצינקי אומר פתאום "עזבו אותי מהשיעמום הזה אני הולך הביתה" ומסרב לתת לי פלט מתאים עבור קלט כלשהו; ואני גם לא מדמיין את אדון קרחחצבופינצינקי אומר "מה לבחור מה לבחור מה לבחור פשוט אטיל קוביה ונראה מה היא תגיד".

בשלב הזה אתם עשויים להזדעק - למה אני מייחס לאדון קרחחצבופינצינקי כאלו דברים? מה, אנחנו לא מכירים תוכניות מחשב שיש קלטים שהן פשוט נתקעות עליהם ולא מוציאות פלט? מה, אנחנו לא מכירים תוכניות מחשב שהפלט שלהן הוא אקראי? מה, הטבע אינו אקראי? אם אני מודד מצב קוונטי אני לא אקבל תוצאות שונות בהסתברויות שונות? מה זו הגישה הצרה והמוגבלת הזו לתיאור המציאות? שוב המתמטיקאים עם השטויות שלהם?

ובכן, זוכרים איך כבר <a href="https://gadial.net/2019/10/19/what_is_set_theory/">בפוסט הראשון</a> על תורת הקבוצות דיברנו על חיסרון מהותי דומה של קבוצות - זה שאין בהן סדר? ודקה אחר כך ראינו שדווקא אפשר ליצור סדר מתוך החוסר-סדר הזה של קבוצות? אותו הדבר עם פונקציות - גם אם נדרוש שלכל קלט יהיה פלט יחיד, עדיין נוכל להגדיר בהמשך סוגים מתוחכמים יותר של פונקציות בעזרת הפורמליזם הבסיסי הזה. נגיע לכך עוד מעט, ובינתיים הנה ההגדרה הפורמלית הסופית לפונקציה.

פונקציה {% equation %}f:A\to B{% endequation %} מורכבת משלושה דברים: קבוצה {% equation %}A{% endequation %} שנקראת <strong>התחום</strong> של הפונקציה, קבוצה {% equation %}B{% endequation %} שנקראת <strong>הטווח</strong> של הפונקציה, ויחס {% equation %}f\subseteq A\times B{% endequation %} שאותו לרוב אני פשוט מכנה "הפונקציה" וזהו. היחס הזה צריך לקיים שתי תכונות:

<ol> <li>"קיום": לכל {% equation %}a\in A{% endequation %} <strong>קיים</strong> {% equation %}b\in B{% endequation %} כך ש-{% equation %}\left(a,b\right)\in f{% endequation %}.</li>


<li>"יחידות": אם {% equation %}\left(a,b_{1}\right)\in f{% endequation %} וגם {% equation %}\left(a,b_{2}\right)\in f{% endequation %} עבור {% equation %}a\in A{% endequation %} ו-{% equation %}b_{1},b_{2}\in B{% endequation %} אז {% equation %}b_{1}=b_{2}{% endequation %}.</li>

</ol>

שתי התכונות הללו מאפשרות לי להשתמש בקיצור הנפוץ ביותר במתמטיקה. במקום לכתוב {% equation %}\left(a,b\right)\in f{% endequation %} אני יכול לכתוב {% equation %}b=f\left(a\right){% endequation %} או פשוט לשכוח מ-{% equation %}b{% endequation %} ופשוט לסמן {% equation %}f\left(a\right){% endequation %} כדי להגיד "האיבר היחיד ב-{% equation %}B{% endequation %} שנמצא ביחס {% equation %}f{% endequation %} עם {% equation %}a{% endequation %}" (קיים כזה כי 1 והוא יחיד כי 2).

הנקודה הראשונה והנודניקית שאני רוצה להדגיש הוא ש<strong>התחום והטווח חשובים</strong>. שתי פונקציות שמוגדרות על ידי אותו "כלל" אבל הן עם תחומים שונים או טווחים שונים נחשבות שונות. למשל לכתוב {% equation %}f\left(x\right)=x^{2}{% endequation %} לא נותן לנו את כל האינפורמציה על הפונקציה. אם {% equation %}f:\mathbb{N}\to\mathbb{N}{% endequation %}, כלומר התחום והטווח הם הטבעיים, אז ברור שזו פונקציה שונה מ-{% equation %}g:\mathbb{R}\to\mathbb{R}{% endequation %} המוגדרת על ידי {% equation %}g\left(x\right)=x^{2}{% endequation %} גם כן; הרי הזוג {% equation %}\left(\frac{1}{2},\frac{1}{4}\right){% endequation %} שייך ל-{% equation %}g{% endequation %} ולא שייך ל-{% equation %}f{% endequation %}. אלא שיש גם סיטואציות הרבה יותר עדינות. בואו נסתכל על {% equation %}f:\mathbb{R}\to\mathbb{R}{% endequation %} המוגדרת על ידי {% equation %}f\left(x\right)=x^{2}{% endequation %} אל מול {% equation %}g:\mathbb{R}\to[0,\infty({% endequation %} המוגדרת על ידי {% equation %}g\left(x\right)=x^{2}{% endequation %}. כאן {% equation %}[0,\infty({% endequation %} הוא קבוצת כל הממשיים <strong>האי-שליליים</strong>. מה קורה פה? אם מעלים מספר ממשי בריבוע, התוצאה היא תמיד מספר אי שלילי. כלומר הטווח של {% equation %}f{% endequation %} שהוא כל {% equation %}\mathbb{R}{% endequation %} הוא בעצם "לא מנוצל כולו" כי אנחנו אף פעם לא מחזירים מספר שלילי. יותר מכך - היחסים {% equation %}f{% endequation %} ו-{% equation %}g{% endequation %} הם <strong>שווים</strong> כי הם מכילים בדיוק את אותם איברים. ועדיין, {% equation %}f{% endequation %} היא לא אותה פונקציה כמו {% equation %}g{% endequation %} כי הן נבדלות בטווח שלהן <strong>ולא משנה שלא משתמשים בחלק הנוסף של הטווח</strong>.

אם לא תמיד משתמשים בכל הטווח, נראה שיש ערך גם לדבר על אותו חלק של הטווח שבו כן משתמשים - הוא נקרא <strong>התמונה</strong> של {% equation %}f{% endequation %} והוא מסומן לעתים קרובות ב-{% equation %}f\left(A\right)=\left\{ f\left(a\right)\ |\ a\in A\right\} {% endequation %} (או בסימון הפחות מעניין {% equation %}\text{Im}f{% endequation %}). הסימון הזה יכול להיות קצת מבלבל כי נראה כאילו מזינים ל-{% equation %}f{% endequation %} את הקבוצה {% equation %}A{% endequation %} בתור קלט, כשבעצם מתכוונים ל"הקבוצה שמתקבלת כשמזינים ל-{% equation %}f{% endequation %} בתור קלט את כל האיברים ב-{% equation %}A{% endequation %}" אבל לפני שמתרעמים על חילול הקודש כדאי לזכור שגם הסימון {% equation %}f\left(a\right){% endequation %} בעצמו הוא רק סימון מקוצר למשהו, כך שאין בעיה עקרונית עם לכתוב {% equation %}f\left(A\right){% endequation %} ואפילו מרחיבים אותו לכל תת-קבוצה של {% equation %}A{% endequation %} (כלומר, אם {% equation %}X\subseteq A{% endequation %} אז כותבים {% equation %}f\left(X\right){% endequation %} כדי לתאר את {% equation %}\left\{ f\left(x\right)\ |\ x\in X\right\} {% endequation %}). כן קיים מקרה אחד שבו הסימון הזה עשוי להיות מסוכן - אם איברים של {% equation %}A{% endequation %} הם גם תת-קבוצות של {% equation %}A{% endequation %}, וזה בהחלט מקרה שנראה בהמשך - ובמקרה הזה באמת לא נשתמש בשיטת הסימון הזו.

עכשיו בואו נעבור לדבר על המגבלות לכאורה של ההגדרה הזו ולמה הן לא באמת מגבלות. נתחיל דווקא עם זו שאולי נראית פחות קריטית: על פניו, לפונקציה שלי יש משתנה <strong>בודד</strong>, וזהו. זה כמובן לא המצב באופן כללי. בחדו"א למשל אחרי שגומרים להבין את הבסיס של החדו"א של פונקציות במשתנה יחיד עוברים לדבר על פונקציות בשני משתנים שכותבים בתור {% equation %}f\left(x,y\right){% endequation %}. איך זה מסתדר עם ההגדרה שלנו? ובכן, בקלות: אם אני מגדיר {% equation %}f:\mathbb{R}^{2}\to\mathbb{R}{% endequation %} ({% equation %}\mathbb{R}^{2}{% endequation %} הוא סימון מקוצר למכפלה הקרטזית {% equation %}\mathbb{R}\times\mathbb{R}{% endequation %}), הגדרתי פונקציה שהקלט שלה הוא <strong>זוג</strong> איברים: כלומר, אני צריך לכתוב {% equation %}f\left(\left(x,y\right)\right){% endequation %} כדי לתאר את הקלט. מכיוון ש-{% equation %}f{% endequation %} הוא מלכתחילה סימון מטעמי נוחות, אני פשוט כותב {% equation %}f\left(x,y\right){% endequation %} במקום לכתוב {% equation %}f\left(\left(x,y\right)\right){% endequation %} וחסל. באופן דומה בחדו"א עוברים לדבר אחר כך על פונקציה שמקבלת {% equation %}n{% endequation %} קלטים ומחזירה סדרה של {% equation %}m{% endequation %} ערכים - זו פשוט פונקציה {% equation %}f:\mathbb{R}^{n}\to\mathbb{R}^{m}{% endequation %}, אז אין בעיה עם זה. למעשה, באלגברה לינארית כבר משלב מוקדם מאוד עובדים עם פונקציות מרובות משתנים שכאלו, רק שבאלגברה לינארית על פי רוב כן ממשיכים להתייחס לאיבר {% equation %}\left(x_{1},\ldots,x_{n}\right){% endequation %} בתור איבר בודד שהוא סדרה של {% equation %}n{% endequation %} ערכים ולא בתור {% equation %}n{% endequation %} איברים.

המגבלה הבאה היא שפונקציה לא יכולה להיות לא מוגדרת עבור ערך כלשהו מתוך התחום שלה. את זה קל לתקן מאוד בקלות על ידי הרחבה של הטווח. נוסיף לטווח איבר חדש שנסמן נניח ב-{% equation %}\perp{% endequation %}, ואז נגדיר את {% equation %}f{% endequation %} להחזיר את {% equation %}\perp{% endequation %} על כל איבר של התחום שהיא לא מוגדרת עבורו. זו קונבנציה סטנדרטית שאפשר לראות, למשל, בספרים של תורת החישוביות, שעוסקים בדיוק בחישובים שעשויים לא להסתיים ולכן לא להחזיר פלט. לפונקציה שלא מוגדרת על כל התחום קוראים שם "פונקציה לא מלאה" וכפי שראינו עכשיו אין בעיה להגדיר אותה פורמלית בעזרת המושג הרגיל של פונקציה.

תכונת היחידות מעלה בעיה אחרת. האם לפעמים אנחנו רוצים שהפונקציה תחזיר יותר מפלט אחד? ובכן, כמובן: נאמר שאנחנו רוצים פונקציה שלוקחת מספר טבעי ומחזירה את הפירוק שלו לגורמים ראשוניים, אז למשל {% equation %}f\left(6\right)=\left(2,3\right){% endequation %}. אבל לא באמת החזרנו כאן שני פלטים; החזרנו פלט שהוא סדרה של שני איברים, ובזה הפורמליזם הקיים שלנו של קבוצות כבר מטפל יפה.

בואו נחדד את הסיטואציה הבעייתית עם דוגמא אחרת - פונקציית השורש, {% equation %}f:[0,\infty)\to\mathbb{R}{% endequation %}, {% equation %}f\left(x\right)=\sqrt{x}{% endequation %}. מהו "שורש" של מספר? קונספטואלית, השורש של {% equation %}a{% endequation %} הוא מספר {% equation %}x{% endequation %} כך ש-{% equation %}x^{2}=a{% endequation %}. העניין הוא שבמספרים הממשיים למספר יכולים להיות שני שורשים: למשל, עבור 4, מתקיים גם {% equation %}2^{2}=4{% endequation %} וגם {% equation %}\left(-2\right)^{2}=4{% endequation %}. יש גם את הבעיה שאין שורש ממשי למספרים שליליים אבל כאן פשוט בחרתי את התחום לא לכלול אותם.

אם כן, לפונקציית השורש יש על פי רוב שני פלטים שונים שהיא יכולה להחזיר. הם לא אותו אובייקט; הם שתי אפשרויות אלטרנטיביות לתשובה שכל אחת מהן טובה באותה מידה. ואנחנו צריכים להחזיר אחת מהן. אז מה עושים? פשוט בוחרים באופן שרירותי משהו את מה לעשות - המוסכמה היא שהפונקציה {% equation %}f\left(x\right)=\sqrt{x}{% endequation %} תמיד תחזיר את השורש <strong>החיובי</strong> ולא את השלילי (תמיד יש אחד כזה ואחד כזה אם יש שניים). אם היינו בוחרים תמיד להחזיר את השלילי היינו מקבלים פונקציה חוקית באותה מידה, וגם אם היינו בוחרים מדי פעם להחזיר את החיובי ומדי פעם את השלילי, כל עוד הכלל של מתי בוחרים מה להחזיר היה מוגדר היטב.

העניין הוא שאם מבצעים תהליך כזה של "לבחור איזה מהערכים האפשריים של הפונקציה לקחת" אנחנו רוצים גם להיות מסוגלים לדבר על הפונקציה שממנה מתחילים את התהליך הזה. מקום שבו זה נפוץ במיוחד הוא בתורת הפונקציות המרוכבות, שם התופעה של פונקציה שמחזירה הרבה ערכים היא נפוצה מאוד. אז קוראים לפונקציה כזו "פונקציה רב-ערכית". ואיך פורמלית מטפלים בזה? אם הפונקציה {% equation %}f:A\to B{% endequation %} היא רב-ערכית, אפשר לחשוב עליה פורמלית בתור פונקציה {% equation %}f:A\to\mathcal{P}\left(B\right){% endequation %}. כלומר, במקום שהיא תחזיר איבר בודד של {% equation %}B{% endequation %} היא מחזירה תת-קבוצה של {% equation %}B{% endequation %}. פתרון די פשוט. עכשיו אפשר לקחת את הפונקציה הזו ולצמצם אותה כך שתחזיר רק פלט אחד בפעם - לפעולה הזו קוראים <strong>לקיחת ענף</strong> של הפונקציה. בתורת הפונקציות המרוכבות מתחיל עכשיו סיפור די מרתק של מה קורה אם מנסים לקחת ענף תוך שמירה על תכונות נחמדות של הפונקציה, אבל אנחנו לא מדברים על התחום הזה כרגע אז אני אימלט ממנו לפני שתשימו לב שאני לא באמת מבין על מה אני מדבר.

והנה דוגמא מתחום שונה לגמרי - תורת האוטומטים. בשביל להבין את הדוגמא לא צריך להבין אוטומטים מעבר לכך שהם מורכבים מקבוצה של מצבים {% equation %}Q{% endequation %} שאפשר להיות בהם, קבוצה של אותיות קלט {% equation %}\Sigma{% endequation %} שאפשר לראות, ופונקציה {% equation %}\delta:Q\times\Sigma\to Q{% endequation %} שבהינתן מצב ואות קלט קובעת לאיזה מצב חדש האוטומט צריך לעבור (הנה דוגמא לפונקציה בשני משתנים!)

המושג הזה של אוטומט נקרא <strong>אוטומט דטרמיניסטי</strong> כי בהינתן הזוג של מצב + אות קלט, המצב שאליו עוברים נקבע באופן יחיד. אבל בפועל נוח להרחיב את סוג האוטומט הזה ל<strong>אוטומט לא דטרמיניסטי</strong> שמותר לו לבצע כמה מעברים שונים בתגובה לאותו זוג של מצב ואות קלט (הפרה של תכונת ה"יחידות"), או לא לבצע מעבר בכלל (הפרה של תכונת ה"קיום"). פורמלית קל לטפל בזה: פונקצית המעברים הופכת להיות {% equation %}\delta:Q\times\Sigma\to\mathcal{P}\left(Q\right){% endequation %} שלכל זוג קלטים מחזיר את קבוצת כל הפלטים האפשרית עבורם (כאן "אף מעבר" מתואר על ידי פלט שהוא הקבוצה הריקה). בגלל כל מני קשיים טכניים שההגדרה הזו מעוררת לפעמים פשוט בוחרים בשלב הזה לדבר על <strong>יחס מעברים</strong> במקום על פונקציית מעברים - כלומר, לחזור למקורות שבהם פונקציה היא סוג של יחס עם תכונות מסויימות ופשוט לוותר על התכונות הללו - אבל לא נתעסק בזה כאן.

נקודה אחת אחרונה שאני רוצה לדבר עליה היא מה עשוי להשתבש כשמגדירים פונקציה בלי שנשים לב אפילו. כמו שהפרדוקס של ראסל לימד אותנו, זה שאנחנו כותבים אוסף אקראי של מילים בעברית לא אומר שיצרנו קבוצה, וכך גם בפונקציות - זה שכתבתי כלל כלשהו לא אומר שבאמת הגדרתי פונקציה. צריך לוודא את זה, ולו בינינו לבין עצמנו. 

הבעיה הפשוטה ביותר שצריך לחשוש ממנה היא פשוט שהכלל לא יעבוד לכל הקלטים, ולכן יהיה קלט נטול פלט ותכונת ה"קיום" שלנו תתקלקל. למשל, {% equation %}f:\mathbb{R}\to\mathbb{R}{% endequation %} המוגדרת על ידי {% equation %}f\left(x\right)=\frac{1}{x}{% endequation %} איננה פונקציה כי עבור {% equation %}x=0{% endequation %} אין משמעות לביטוי {% equation %}\frac{1}{x}{% endequation %} שכתבנו כך בקלילות. כמובן, קל לתקן את זה על ידי שינוי של התחום (כלומר, להוציא את 0 מהתחום: {% equation %}f:\mathbb{R}\backslash\left\{ 0\right\} \to\mathbb{R}{% endequation %}) או על ידי שינוי של הטווח (כמו שאמרתי קודם, להגדיר {% equation %}f:\mathbb{R}\to\mathbb{R}\cup\left\{ \perp\right\} {% endequation %} ו-{% equation %}f\left(0\right)=\perp{% endequation %}) אבל בלי אחד מהשינויים הללו, אין לנו פה פונקציה גם אם אנחנו חושבים בטעות שיש.

עוד בעיות קלאסיות עם הגדרות חסרות משמעות של פונקציות הן כשמציבים אפס או מספר שלילי בפונקציית הלוגריתם ({% equation %}\ln0{% endequation %}), כשמנסים לתת לפונקציה טריגונומטרית הפוכה ערך שאינו בין {% equation %}-1{% endequation %} ל-1 ({% equation %}\sin^{-1}\left(\pi\right){% endequation %}), כשמנסים להוציא שורש למספר שלילי מעל הממשיים ({% equation %}\sqrt{-1}{% endequation %}; כאן אפשר להרחיב את הטווח באופן סביר והגיוני לקבוצת המרוכבים, {% equation %}\mathbb{C}{% endequation %}, במקום סתם לומר שאנחנו לא מוגדרים, אבל לפעמים אנחנו לא <strong>רוצים</strong> לערב את המרוכבים בסיפור) וכדומה. על פי רוב אין <strong>יותר מדי</strong> סכנות מהסוג הזה - צריך לדעת על כמה דברים בסיסיים שיש להיזהר מהם, וזה מספיק.

סכנה גדולה בהרבה אורבת לנו דווקא עם תכונת ה"יחידות". הסיבה לכך היא שבמתמטיקה לעתים קרובות יש לאובייקט מתמטי <strong>יותר מייצוג אחד</strong> וכשמגדירים פונקציה על האובייקט צריך להיזהר שהפונקציה לא תוגדר באופן שהוא תלוי ייצוג - כלומר, שעבור <strong>ייצוגים שונים לאותו קלט</strong> לא יתקבלו פלטים שונים.

הנה דוגמא פשוטה לאיך שזה יכול לצוץ כשמשתמשים ביחסי שקילות. <a href="https://gadial.net/2020/01/06/equivalence_relations/">בפוסט על יחסי שקילות</a> הצגתי יחס שקילות שסימנתי אותו ב-{% equation %}\equiv_{3}{% endequation %}: אמרתי ש-{% equation %}a\equiv_{3}b{% endequation %} אם השארית ש-{% equation %}a,b{% endequation %} משאירים בחלוקה ב-3 היא זהה. למשל, {% equation %}1\equiv_{3}4{% endequation %}. לכן אפשר לכתוב {% equation %}\left[1\right]=\left[4\right]{% endequation %} - מחלקת השקילות של 1 ומחלקת השקילות של 4 הן אותה מחלקת שקילות.

עכשיו בואו נגדיר פונקציה מקבוצת המנה {% equation %}\mathbb{N}/\equiv_{3}{% endequation %} אל {% equation %}\mathbb{N}{% endequation %} באופן הבא: {% equation %}f\left(\left[a\right]\right)=a{% endequation %}. כלומר: בהינתן מחלקת שקילות שמיוצגת על ידי המספר הטבעי {% equation %}a{% endequation %}, הפונקציה מחזירה את {% equation %}a{% endequation %}. למשל, {% equation %}f\left(\left[0\right]\right)=0{% endequation %} ו-{% equation %}f\left(\left[1\right]\right)=1{% endequation %} ו-{% equation %}f\left(\left[2\right]\right)=2{% endequation %} ו-{% equation %}f\left(\left[4\right]\right)=4{% endequation %} ו... אה-הא! הנה הבעיה. הרי {% equation %}\left[1\right]=\left[4\right]{% endequation %} אבל כרגע ראינו שני פלטים שונים על אותו קלט: {% equation %}f\left(\left[1\right]\right)=1\ne4=f\left(\left[4\right]\right){% endequation %}. זו סתירה לתכונת ה"יחידות" של פונקציה, וזה קרה לנו בלי לשים לב, בזמן שניסינו להגדיר את הפונקציה באמצעות נוסחה "רגילה" שלא נראית רב-ערכית.

אז מה הפתרון? אין פתרון קסם, צריך להיות זהירים. גם בהוכחות מתקדמות במתמטיקה לא כזה נדיר, כשמוגדרת פונקציה, לראות שלב בהוכחה שבו מראים שהפונקציה היא "מוגדרת היטב". כלומר, אם יש ספק כלשהו לגבי תכונת ה"קיום" או ה"יחידות", מסבירים במפורש למה אין בעיה.

אז זהו זה לגבי מה שרציתי להגיד על מה זו פונקציה בכלל, ועכשיו הגיע הזמן להתחיל לעשות איתן דברים מעניינים. 