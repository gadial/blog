---
id: 995
title: "תוכניות מתפצלות ומשפט ברינגטון"
date: 2011-01-23 21:43:07
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - משפט ברינגטון
  - פרוייקט "תוצאות מפתיעות בסיבוכיות"
  - תוכניות מתפצלות
  - תורת הסיבוכיות
social_media_share: true
---
<a href="http://www.gadial.net/2011/01/18/what_are_boolean_circuits/">בפוסט הקודם</a> בסדרת הפוסטים של פרוייקט "תוצאות מפתיעות בסיבוכיות" הצגתי מודל חישובי מרכזי בתורת הסיבוכיות - מעגלים בוליאניים. עכשיו אני רוצה להציג מודל קצת יותר אזוטרי אבל עדיין חשוב ומעניין בזכות עצמו - תוכניות מתפצלות. משפט ברינגטון, שאת הניסוח שלו אציג בסוף הפוסט, הוא הסיבה שבגללה אני מתאר כאן תוכניות מתפצלות. הוא אומר, בפשטות, שתוכניות מתפצלות הן חזקות הרבה יותר ממה שנדמה במבט ראשון, כשההשוואה של הכוח שלהן הוא לכוח שיש למעגלים בוליאניים.

כמו שמעגל בוליאני הוגדר כגרף, כך גם תוכנית מתפצלת מוגדרת כגרף מכוון וחסר מעגלים. אלא שבמעגל בוליאני חשבנו על הצמתים בתור יחידות עיבוד למידע: מידע (בדמות ביטים - אפסים ואחדים) נכנס לכל צומת, עבר עיבוד כלשהו (למשל, פונקציית "וגם"), ונפלט מהיציאה של הצומת. בתוכנית מתפצלת אנחנו חושבים על הצמתים כמעין "שורות קוד" בתוכנית מחשב. כל שורה בתוכנית מכילה פקודות לקפיצה לאחת מכמה שורות אפשריות אחרות, כשההחלטה לאן לקפוץ תלויה בקלט. יותר במדויק, כל צומת מסומן על ידי משתנה {% equation %}x_{i}{% endequation %}, והקשתות שיוצאות מהצומת מסומנות ב-0 וב-1. יש לתוכנית שני צמתים מיוחדים: צומת התחלה {% equation %}s{% endequation %} (שגם הוא מסומן במשתנה) וצומת סיום {% equation %}t{% endequation %}. עבור השמה כלשהי למשתנים, אנחנו מוחקים קשתות בהתאם להשמה - אם למשל המשתנה {% equation %}x_{3}{% endequation %} קיבל 0, אז מכל צומת שמסומן ב-{% equation %}x_{3}{% endequation %} (יכולים להיות הרבה כאלו) אנו מוחקים את כל הקשתות היוצאות שמסומנות ב-1. פלט התוכנית על קלט הוא 1 אם לאחר מחיקת הקשתות הזו עדיין קיים מסלול מ-{% equation %}s{% endequation %} ל-{% equation %}t{% endequation %} בגרף, ואחרת הפלט שלה הוא 0.

כרגיל, תמונה אחת שווה אלף מילים. הנה תוכנית מתפצלת עבור הפונקציה {% equation %}\mbox{MAJORITY}\left(x_{1},x_{2},x_{3}\right){% endequation %} שמחזירה את הערך הבוליאני שמצוי אצל רוב הקלטים. נסו "לסמלץ" את הריצה של התוכנית על כמה קלטים ובדקו מה קורה.

<a href="{{site.baseurl}}{{site.post_images}}/2011/01/bp_maj.png"><img class="alignnone size-full wp-image-996" title="bp_maj" src="{{site.baseurl}}{{site.post_images}}/2011/01/bp_maj.png" alt="" width="392" height="166" /></a>

אולי אתם תוהים למה הגדרתי הגדרה מסובכת שכזו לתוכנית מתפצלת - כל העסק עם מחיקת הקשתות ועם "אם <strong>קיים</strong> מסלול...". למה לא אמרתי פשוט "בהינתן קלט נצא לטיול בגרף - כאשר אנחנו בצומת {% equation %}x_{i}{% endequation %} נתבונן בערך המשתנה {% equation %}x_{i}{% endequation %} והצעד הבא שלנו ייקבע על פי ערך זה, ואם אין לנו קשת יוצאת מתאימה ניתקע"? ובכן, זה אכן מספיק עבור מה שנתעסק בו, אבל באופן כללי ייתכן שמאותו צומת תצא יותר מקשת אחת שמסומנת ב-1 (או יותר מקשת אחת שמסומנת ב-0) וכל מה שיעניין אותו הוא ש<strong>קיימת</strong> דרך כלשהי להגיע מ-{% equation %}s{% endequation %} אל {% equation %}t{% endequation %}. מי שזה מבלבל אותו - לא נורא, אתם בהחלט יכולים לחשוב על ההגדרה שהצגתי כרגע כאילו היא הגדרה שקולה.

תוכנית מתפצלת היא מודל מאוד נאיבי ופשוט של חישוב: אין לה סרט שעליו היא יכולה לכתוב מידע ביניים - ה"מידע" שיש לה צריך להיות מיוצג איכשהו על ידי הצמתים של הגרף ותו לא. זה שונה מהותית ממה שקורה במעגל בוליאני שבו כמות גדולה של מידע "זורמת" בתוך הגרף. בנוסף, תוכנית מתפצלת מבצעת את החישוב שלה בצורה שנראית מגבילה מאוד - בכל צעד פועלת על פי ביט בודד של הקלט ותו לא. בקיצור, זה נראה כמו מודל חלש מאוד. בשל כך, הוא מועמד טבעי להיות קורבן להוכחות של חסמים תחתונים - וזה, כזכור, הדבר שאנשי תורת הסיבוכיות הכי אוהבים להוכיח.

כדי להוכיח חסמים תחתונים על מודל חישובי, צריך קודם כל להגדיר מדדי סיבוכיות כלשהם עבורו. אם אנחנו רוצים להגיד "קשה לחשב את {% equation %}f{% endequation %} בעזרת תוכניות מתפצלות" צריך קודם כל להבהיר מה זה בכלל אומר, "קשה", בהקשר של תוכניות מתפצלות. המדד האלמנטרי הוא הגודל של התוכנית - מספר הצמתים שבה. מחשב אמיתי שרוצה להריץ תוכנית מתפצלת צריך לזכור את כל הצמתים שלה - ולכן מספר אקספוננציאלי של צמתים (כתלות במספר הביטים של הקלט לפונקציה שאותה רוצים לחשב) הוא לא ריאלי - חשבו על תוכנית שכדי לחשב את הפלט של פונקציה על 50 ביטים דורשת {% equation %}1,125,899,906,842,624{% endequation %} שורות קוד! ({% equation %}2^{50}{% endequation %}). לכן הדרישה האלמנטרית מתוכנית מתפצלת הוא שגודלה יהיה פולינומי. כמו שקרה עם מעגלים בוליאניים, כך גם כאן, תוכנית מתפצלת תמיד מוגדרת עבור מספר נתון של ביטי קלט. לכן מדברים לרוב על <strong>משפחות</strong> של פונקציות, שמחושבות על ידי <strong>משפחות</strong> של תוכניות מתפצלות, והשאלה ששואלים היא כמה מהר צומח הגודל של התוכנית המתפצלת עבור קלט מאורך {% equation %}n{% endequation %} כאשר מגדילים את {% equation %}n{% endequation %}. לא אחזור שוב על הדיון הזה בשלמותו.

יפה. אם כן, רצו להם מדעני המחשב בשמחה ובששון לאכול בלי מלח תוכניות מתפצלות בעלות גודל פולינומי ולהוכיח שכך וכך וכך אי אפשר לעשות בהן. כפי שבדרך כלל קורה בעניינים הללו, הנסיונות הללו נסתיימו בלא כלום. להוכיח חסמים תחתונים זה <strong>קשה</strong>.

אז מה עושים עכשיו? מגבילים עוד קצת את המודל. אפשר לדבר, בלי להגביל את עצמנו במיוחד, על תוכניות מתפצלות שהגרף שלהן הוא גרף <strong>שכבות</strong>: כל צומת שייך לשכבה כלשהי, ויש קשת רק בין צומת בשכבה אחת לצומת בשכבה העוקבת. על יצור כזה אפשר להגדיר שני מדדי סיבוכיות חדשים - אורך (מספר השכבות הכולל) ורוחב (מספר הצמתים המקסימלי בשכבה כלשהי). ככל שתוכנית היא קצרה יותר כך "זמן הריצה" שלה קצר יותר; וככל שהרוחב של תוכנית קטן יותר, כך הזכרון שנדרש כדי לסמלץ אותה קטן יותר. הפרמטר המקורי שלנו - גודל - עדיין חבוי בין שני הפרמטרים הללו - הוא חסום על ידי מכפלת האורך ברוחב (למה?)

להגביל את האורך יותר מדי - אי אפשר. עבור רוב הפונקציות סביר להניח שנרצה להתיר לתוכנית המתפצלת לקרוא את כל הביטים של הקלט לפחות פעם אחת, וכל ביט קלט נקרא במעבר משכבה אחת לשכבה הבאה אחריה. אז מספר פולינומי של שכבות הוא המינימום שצריך (שימו לב להבדל בין זה ובין מעגלים בוליאניים, שבהם האורכים שעניינו אותנו היו <strong>לוגריתמיים</strong>: זה התאפשר מכיוון שהמעגל ביצע חישוב מקבילי וכל שכבה טיפה בהרבה ביטי קלט בבת אחת). אם כן, הפרמטר שמעניין להגביל אותו - ולהגביל בצורה קיצונית ביותר - הוא הרוחב. שאלו את עצמם מדעני המחשב - מה יכולה לעשות תוכנית מתפצלת עם אורך פולינומי ורוחב <strong>קבוע</strong>?

רוחב קבוע נראה כמו דבר מגביל. מאוד. זה בעצם אומר שהזכרון של התוכנית הוא חסום בגודלו ולא תלוי בכלל בקלט. ייתכן שהקלט יהיה בן מיליארדי ביטים, ועדיין לתוכנית יהיה מותר להיות בכל שכבה רק באחד מבין, נאמר, חמישה מצבים שונים. תחשבו על זה רגע. <strong>מיליארדי</strong> ביטי קלט שונים! זה אומר שכאשר הגעתי לשכבה ה-{% equation %}k{% endequation %}-ית, מה שקרה "בעבר" של התוכנית יכל להיות בן זילארדי זיליארדים (זה מספר בכלל?) אפשרויות שונות. ועכשיו מבקשים ממני לקחת את כל האפשרויות הללו ואיכשהו לתמצת אותן לאחד מבין חמישה מקרים - חמשת המצבים האפשריים של השכבה ה-{% equation %}k{% endequation %}. בעצם, זה אומר שמרבית ההיסטוריה שלנו חייבת "להימחק". מה כבר אפשר לחשב באופן הזה?

כדי להבהיר את הקושי כדאי לשכוח שנייה מתוכניות מתפצלות ולדבר על מה שקורה למודל החישובי הסטנדרטי, מכונת טיורינג, אם דורשים מהזכרון שלה להיות חסום באופן שאינו תלוי בקלט. מה שמקבלים הוא שקילות למודל פשוט בהרבה, שמכונה <strong>אוטומט סופי דטרמיניסטי</strong>. לא אציג את המודל הזה כרגע, אבל רק אבהיר עד כמה הוא חלש: אם נותנים לו מספר, הוא לא מסוגל לבדוק האם המספר ראשוני. אם נותנים לו מחרוזת מהצורה {% equation %}0^{*}1^{*}{% endequation %} (סדרת אפסים ואז סדרת אחדות - הכוכבית מציינת "0 או 1 או 2 או...") הוא לא מסוגל לבדוק האם מספר האפסים שווה למספר האחדות. אם נותנים לו שלשה {% equation %}\left(a,b,c\right){% endequation %} הוא לא מסוגל לבדוק האם {% equation %}c=a-b{% endequation %} (זה בעצם נובע מיידית ממה שאמרתי קודם...). זה מודל מאוד, מאוד חלש. ותוכניות מתפצלות מרוחב קבוע הן בדיוק האנלוג המתאים לאוטומטים סופיים דטרמיניסטיים בתוך עולם התוכניות המתפצלות.

כדי להראות חסם תחתון על תוכניות מתפצלות, כדאי לתקוף קודם כל פונקציה קונקרטית אחת ולהראות שהיא קשה. עבור מעגלים בוליאניים הצליחו להשתמש ב-{% equation %}\bigoplus{% endequation %} (שמבצעת XOR של כל הביטים שלה) בתור פונקציה שכזו - הוכיחו כי היא אינה ב-{% equation %}\mbox{AC}^{0}{% endequation %} (מעגלים בוליאניים מעומק <strong>קבוע</strong> - שוב ה"קבוע" הזה - עם דרגת כניסה לא מוגבלת של הצמתים). אחרי שיש דוגמה קונקרטית אחת ביד, אפשר לרוב להראות עבור פונקציות רבות אחרות שהן לא שייכות למחלקה על ידי טיעון בסגנון "אם הן כן היו שייכות, אפשר היה להשתמש בהן כדי לחשב גם את {% equation %}\bigoplus{% endequation %}". לרוע המזל, את {% equation %}\bigoplus{% endequation %} קל מאוד לחשב עם תוכנית מתפצלת מרוחב 2: קוראים ביט ביט, וכל המידע שצריך לזכור הוא "האם סכום הביטים עד כה היה 0 או 1 מודולו 2". הנה התוכנית המתפצלת המתאימה עבור {% equation %}\bigoplus\left(x_{1},x_{2},x_{3},x_{4},x_{5}\right){% endequation %}:

<strong><a href="{{site.baseurl}}{{site.post_images}}/2011/01/xor_bp.png"><img class="alignnone size-full wp-image-999" title="xor_bp" src="{{site.baseurl}}{{site.post_images}}/2011/01/xor_bp.png" alt="" width="605" height="229" /></a>
</strong>

ובכן, מי כן מועמד טוב להיות פונקציה שתוכניות מתפצלות לא יכולות לחשב? רצוי שזו תהיה פונקציה פשוטה, כזו שאפשר לחשב ביעילות במודלים פשוטים אחרים - זכרו שבסופו של דבר אנחנו רוצים להצביע על קושי של בעיות שנראות פשוטות יחסית (זהו למשל העניין בשאלת {% equation %}\mbox{P=NP}{% endequation %}; המחלקה {% equation %}\mbox{NP}{% endequation %} מורכבת מבעיות שבמובן מסויים הן קלות, ולכן חשוב לנו להוכיח שלמרות זאת הן קשות; את זה שקיימות בכלל בעיות שאינן ב-{% equation %}\mbox{P}{% endequation %} קל להוכיח). לצורך העניין, מחלקה פשוטה מספיק שעדיין נראית כמו כר מתאים לחיפוש אחר פונקציות קשות לחישוב היא {% equation %}\mbox{NC}^{1}{% endequation %} - מה שבא בתור אחרי {% equation %}\mbox{AC}^{0}{% endequation %}. ב-{% equation %}\mbox{NC}^{1}{% endequation %}, כזכור, נמצאות כל הפונקציות שניתנות לחישוב על ידי מעגל מעומק <strong>לוגריתמי</strong> וגודל פולינומי, שבו דרגת הכניסה של כל שער היא לכל היותר 2. הרבה פונקציות פשוטות (למשל, הפונקציות האריתמטיות) נמצאות שם; וגם הפונקציה {% equation %}\mbox{MAJORITY}{% endequation %} שהזכרתי בהתחלה. אותה {% equation %}\mbox{MAJORITY}{% endequation %} נראתה כבעלת פוטנציאל רב לתקיפת תוכניות מתפצלות; כמו שאפשר לראות בתוכנית המתפצלת שציירתי בהתחלה, נראה שהרוחב תלוי בצורה חזקה בכמות המשתנים. ובאמת, צריך "לזכור" כמה משתנים היו 0 וכמה משתנים היו 1 עד כה, או לפחות מה היה ההפרש ביניהם, והוא יכול להיות גדול באופן שרירותי, לא? זה לא נראה כמו משהו שאפשר לתפוס עם תוכניות מתפצלות מרוחב קבוע. זה הוביל להשערה בראשית שנות השמונים לפיה כל תוכנית מתפצלת מרוחב חסום עבור {% equation %}\mbox{MAJORITY}{% endequation %} לא תהיה פולינומית באורכה. די מהר הוכיחו גם חסם תחתון נאיבי יחסית - שתוכנית מתפצלת מרוחב חסום עבור פונקציה זו לא יכולה להיות <strong>לינארית</strong> באורכה (כלומר, {% equation %}O\left(n\right){% endequation %}). על פניו כיוון המחקר הזה נראה מבטיח.

ואז, בשנת 1989 בא ברינגטון ופוצץ את הכל כשהוכיח שלא רק את {% equation %}\mbox{MAJORITY}{% endequation %} אפשר לחשב באמצעות תוכניות מתפצלות מרוחב חסום, אלא כל פונקציה ב-{% equation %}\mbox{NC}^{1}{% endequation %}. ולא רק שאפשר, אלא שמספיק שהרוחב החסום יהיה 5 (<strong>לכל</strong> פונקציה ב-{% equation %}\mbox{NC}^{1}{% endequation %}). אני מקווה שביצעתי מספיק עבודת הכנה כדי שתתקבל תחושה כלשהי עד כמה זו תוצאה מפתיעה. גם אני, למרות שאני מכיר את ההוכחה, עדיין מתקשה להבין איך בכלל אפשר לתפוס משהו כמו {% equation %}\mbox{MAJORITY}{% endequation %} עם רוחב חסום. וכמובן, יש את עניין מספר הקסם 5 - מאיפה הוא צץ? למה דווקא 5 ולא 4 או 6? גם לשאלה הזו יש תשובה מצויינת. כל התשובות - בפוסט הבא, שבו אציג במפורט את ההוכחה.
