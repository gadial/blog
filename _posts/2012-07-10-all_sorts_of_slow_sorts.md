---
id: 2075
title: "מיון מהיר של מיונים איטיים"
date: 2012-07-10 16:39:09
layout: post
categories: 
  - מבני נתונים ואלגוריתמים
  - תכנות
tags: 
  - אלגוריתם
  - מיון בועות
  - מיון בחירה
  - מיון הכנסה
  - מיון מיזוג
  - מיונים
  - סיבוכיות זמן
  - רקורסיה
---
היום נדבר על אלגוריתמים למיון, אבל לפני שנתחיל להציג אלגוריתמים קונקרטיים, בואו נענה על השאלה האקוטית שחלקכם בוודאי תוהים לגביה - מה זה בכלל <strong>אלגוריתם</strong>?

המילה אלגוריתם מגיעה משיבוש שמו של המתמטיקאי הפרסי מוחמד אבן מוסא אל-ח'ואריזמי, אחד מגדולי המתמטיקאים של ימי הביניים (בימי הביניים, בזמן שאירופה הייתה בחור שחור מאין כמותו, המתמטיקה פרחה במקומות אחרים ובעולם המוסלמי בעיקר). אל-ח'ואריזמי כתב את אחד מהספרים החשובים במתמטיקה - "חיסאב אל-ג'אבר ואל-מוקאבלה", שעסק בפתרון משוואות ממעלה שניה (המילה "אלגברה" מגיעה מה"אל-ג'אבר" שבשם הספר). ספר אחר שלו עסק בחישובים בעזרת ספרות הודיות - ליתר דיוק, בעזרת שיטת כתיבת המספרים ההודית, השונה מאוד מזו הרומאית. בשיטה זו אנו משתמשים עד היום. אחד מהיתרונות בשיטה הזו היא הקלות הרבה שבה ניתן לבצע פעולות חשבון; זה כל כך קל עד שילדים לומדים את זה כבר בבית הספר היסודי. למשל, איך מחברים שני מספרים? כותבים האחד מעל השני, ספרה-ספרה, כאשר הספרות הימניות ביותר של המספרים נמצאות זו מעל זו, ואז עוברים ספרה-ספרה מימין לשמאל, מחברים את הספרות, כותבים את הספרה הראשונה של התוצאה וזוכרים את היתר (מה שמקבלים אחרי ש"חותכים" את הספרה הימנית ביותר ממנו), ומחברים אותו לשתי הספרות הבאות, וכן הלאה. זו דוגמה לאלגוריתם.

אלגוריתם באופן כללי הוא תיאור <strong>פשוט</strong> של <strong>תהליך</strong> שמטרתו לפתור בעיה. הפשטות היא קריטית - האלגוריתם תמיד צריך לכלול סדרה של צעדים פשוטים שכל אחד מהם הוא קל מספיק כדי שלקורא יהיה ברור איך אפשר לבצע אותו. כמו כן צריך שהאלגוריתם תמיד יסיים את עבודתו תוך פרק זמן <strong>סופי</strong> ושתוצאות האלגוריתם תהיה <strong>נכונה</strong>. כל תוכנית מחשב היא דוגמה לאלגוריתם, אם כי לרוב מעדיפים לכתוב אלגוריתמים בשפה שהיא חופשית קצת יותר מאשר תוכנית מחשב. אני אנקוט בדרך ביניים שמשלבת את הרע מבין שני העולמות - אתאר אלגוריתמים באופן לא פורמלי, שבו אני לא מסביר כל צעד עד הסוף; ואציג קוד מחשב "אמיתי" שפותר את הבעיה, בשפה שאף אחד לא מכיר (Ruby).

עכשיו משסיימנו עם המבוא, בואו נעבור לאקשן.

בעיית ה<strong>מיון</strong> היא הבעיה המושלמת להתחיל איתה דיון על אלגוריתמים. זו בעיה פשוטה מאוד לתיאור, אך לא טריוויאלית לפתרון; זו בעיה מאוד, מאוד, מאוד חשובה; יש לה פתרונות שונים ומגוונים מבחינת אופיים ואיכותם, ואין פתרון אחד "נכון"; והפתרונות הם פשוטים דיו כדי שאפשר יהיה להציג ניתוחים מפורטים שלהם, ועם זאת הם מסובכים מספיק כדי שיהיה עניין בניתוחים הללו. בפוסט הזה אסתפק לבינתיים בהצגת הבעיה והצגת פתרונות נאיביים עבורה.

"מיון", בעברית, משמש באופן אומלל למדי לתיאור שני דברים שונים. האחד הוא Classification - בהינתן קבוצת אובייקטים, לחלק אותם לתת-קבוצות על פי תכונה שלהם ("יונקים", "זוחלים", "חרקים"). זו לא הבעיה שאני מדבר עליה, אלא Sorting - בהינתן רשימה של אובייקטים שמוגדר עליהם סדר כלשהו, לסדר אותה.

לרשימה אני אקרא {% equation %}A{% endequation %}, ואת האיבר במקום ה-{% equation %}i{% endequation %} ברשימה אסמן בתור {% equation %}A\left[i\right]{% endequation %}. ההנחה היא שיש <strong>סדר</strong> על הרשימה, כלומר שלכל {% equation %}i\ne j{% endequation %} מתקיים {% equation %}A\left[i\right]<A\left[j\right]{% endequation %} או {% equation %}A\left[j\right] < A\left[i\right]{% endequation %}. המטרה היא לסדר מחדש את הרשימה כך שיתקיים {% equation %}A\left[0\right] < A\left[1\right] < A\left[2\right]<\dots<A\left[n\right]{% endequation %} (שימו לב שאני מתחיל את האינדקס מאפס, כפי שנהוג במדעי המחשב; יש לשיטה הזו יתרונות וחסרונות ואני בוחר בה כדי להתאים לקוד שאני אכתוב כאן).

מהם אברי הרשימה {% equation %}A{% endequation %}? אניח שהם מספרים שלמים, רק לצורך פשטות. באופן כללי הם יכולים להיות אובייקטים מורכבים מאוד, וההשוואה בין שניהם יכולה להיעשות בצורה מחוכמת מאוד. רוב האלגוריתמים שאציג פה לא יתעניינו בכך - כל מה שהם יצטרכו לדעת לצורך תהליך המיון זה המידע הבא: בהינתן שני איברים {% equation %}a,b{% endequation %} האם {% equation %}a<b{% endequation %} או {% equation %}b < a{% endequation %} (או שהם שווים). יש גם אלגוריתמים שיכולים להיעזר בכך שהם יודעים משהו על סוג האיברים שממיינים, אבל דיה לצרה בשעתה.

אז הנה דוגמה פשוטה. נניח ש-{% equation %}A=\left[1,4,2,3\right]{% endequation %}. אחרי מיון נרצה לקבל {% equation %}A=\left[1,2,3,4\right]{% endequation %}. איך אפשר לעשות זאת? השיטה הראשונה שאני מעלה על דעתי היא זו: נעבור על {% equation %}A{% endequation %} ונמצא את האינדקס שבו נמצא האיבר הגדול ביותר. מצאנו? נחליף את האיבר הזה עם האיבר שנמצא כרגע בסוף הרשימה. עכשיו אנחנו יודעים שהאיבר בסוף הרשימה נמצא במקומו הנכון ולכן אפשר לחשוב על הסיטואציה כאילו הרשימה קטנה ב-1. נעבור מחדש על הרשימה הקטנה יותר ונמצא את האיבר המקסימלי <strong>בה</strong>, נחליף אותו עם האיבר שנמצא כרגע בסוף הרשימה (הרשימה הקטנה ב-1), וכן הלאה וכן הלאה. הנה קוד שעושה את זה:

<div class="code-block">
{% highlight ruby %}
def selection_sort(list)
  list.length.downto(1) do |k|
    max_index = 0
    for i in 1...k do
      max_index = i if list[max_index] < list[i]
    end
    list.swap(max_index,k-1)
  end
  return list
end
{% endhighlight %}
</div>

קצת על רובי, כדי שהקוד יהיה קריא בכל זאת גם למי שלא מכיר שפות תכנות בכלל:

ברובי, def מתאר הכרזה על שם של פונקציה, כלומר קטע קוד שמקבל קלט (במקרה שלנו הקלט הוא ה-list שמופיע בסוגיים, שהוא על תפקיד ה-{% equation %}A{% endequation %} שלנו), ובסופו של דבר מחזיר פלט (אבל יותר מעניין אותנו כאן דווקא המניפולציות שעושים על הקלט - ממיינים את list ישירות, אם כי בסוף גם מחזירים אותה). הפונקציה מסתיימת ב-end שלמטה.

בתוך הפונקציה יש <strong>לולאות</strong>. לולאה היא קטע קוד שחוזר על עצמו שוב ושוב; לפעמים יש משתנה מיוחד כלשהו (ה<strong>מונה</strong>) שהערך שלו משתנה בין כל הרצה של הלולאה (הרצה כזו נקראת <strong>איטרציה</strong>). כך גם אצלנו:
<div class="code-block">
{% highlight ruby %}
list.length.dowto(1) do |k|
{% endhighlight %}
</div>

 זו דרך לרשום "עכשיו תעשה לולאה שהמונה שלה, שנקרא לו k מתחיל מהערך list.length (אורך הרשימה) ובכל איטרציה המונה קטן ב-1 עד שהוא מגיע ל-1 (וכשהוא מגיע ל-1 תריץ את הלולאה פעם אחת אחרונה וצא ממנה)".

אחרי השורה הזו מגיע הגוף של הלולאה - מה שמתבצע בכל איטרציה - ומסתיים ב-end שלפני ה-return list (זו, באופן מפתיע, השורה שבה מחזירים את המערך הממויין).

המשמעות של k היא "האורך של הרשימה שכרגע אנחנו ממיינים" - זכרו שבכל איטרציה, האורך הזה באמת אמור לקטון ב-1.

קטע הקוד הבא מוקדש למציאת האיבר המקסימלי ברשימה הנוכחית. אז קודם כל יוצאים מתוך ברירת מחדל שהאיבר המקסימלי נמצא במקום 0, וזה פשוט max_index = 0, וכעת מבצעים לולאה נוספתת שמחפשת ברשימה את האינדקס של האיבר המקסימלי.

הלולאה נפתחת ב-for i in 1...k do, שגם אותו צריך להסביר. כאן משתנה הלולאה הוא ה-i שבא מייד אחרי ה-for; ואילו 1...k מייצג את "כל המספרים השלמים מ-1 ועד k, לא כולל k''. אצלנו i יתחיל מ-1 ויגדל ב-1 כל פעם עד שיגיע ל-k, ואז נצא מהלולאה (בלי להריץ אותה עבור i=k). הסיבה שאנחנו לא מגיעים עד k היא פשוטה: ברובי, כמו ברוב שפות התכנות, האיבר הראשון ברשימה הוא איבר מספר 0, ולכן אם אורך הרשימה הוא {% equation %}n{% endequation %} אז האיבר האחרון בה הוא איבר מספר {% equation %}n-1{% endequation %}. זה משהו מבלבל ואיום ונורא למי שכרגע נתקל בו לראשונה, אבל מתרגלים אליו ורואים שהוא חשוב מאוד לפעמים. במילים אחרות - הרבה אלגוריתמים הם פשוטים יותר בגלל זה, אבל גם הרבה אלגוריתמים הם מסובכים יותר בגלל זה. אני אישית דבק בקונבנציה הזו כי זה מה שקורה בשפות תכנות. בפועל. בעולם האמיתי. כשתרצו ללכת ולכתוב קוד, זה מה שתצטרכו לעשות. מקומות אחרים (למשל <a href="http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844">הספר של CLRS</a> שהוא התנ"ך של מבוא לאלגוריתמים) מתחילים דווקא מ-1. אין תשובה טובה לשאלה "מה נכון" פרט ל"זה הבלוג שלי. אל תריבו!"

השורה הבאה מציבה ב-max_index את האינדקס של המספר הנוכחי שבודקים, i, אם האיבר במקום i גדול מהאיבר במקום max_index. שימו לב לסגנון הכתיבה - קודם כל ההשמה, ורק אחר כך הבדיקה. לטעמי זה משפר את הקריאות של הקוד, שמרגיש כמו שפה טבעית ויותר ברור מה הולך בו; אנשים אחרים <strong>מתעבים לחלוטין</strong> את סגנון הכתיבה הזה. לגיטימי.

בסיום הלולאה הפנימית (ה-end שאחרי השורה של הבדיקה-והשמה) אנחנו מחליפים בין האיבר האחרון במערך כרגע (זה האיבר במקום {% equation %}k-1{% endequation %}) ובין האיבר במקום המקסימלי, וזאת על ידי הפקודה (list.swap(max_index, k-1. לא הסברתי איך אני מבצע החלפה בין שני איברים במערך. ברובי אפשר לעשות את זה בשורה אחת:
<div class="code-block">
{% highlight ruby %}
list[i], list[j] = list[j], list[i]
{% endhighlight %}
</div>
קטע הקוד הזה מחליף את האיברים במקומות {% equation %}i,j{% endequation %} ברשימה. אני משתמש ב-list.swap במקום זה רק כדי לשפר את הקריאות. בפועל, בשפה ברמה יותר בסיסית מאשר רובי, צריך להשתמש במשתנה עזר כלשהו כדי לזכור את הערך שהיה באחד המקומות ברשימה לצורך ההחלפה (תרגיל נחמד: כאשר הרשימה כוללת מספרים, אפשר להחליף שני תאים בלי שום משתני עזר - איך?)

האם האלגוריתם שלמעלה (שאני קורא לו "מיון-בחירה", כי בוחרים בכל פעם את האיבר שצריך להיכנס לסוף הרשימה) הוא טוב או רע? ובכן, הוא פשוט מאוד להבנה, וזה טוב. אבל הוא עושה הרבה עבודה: מספר האיטרציות שלו הוא כגודל המערך, ובכל איטרציה יש לולאה פנימית, שעושה הרבה השוואות. באיטרציה הראשונה יש {% equation %}n-1{% endequation %} השוואות (כש-{% equation %}n{% endequation %} הוא אורך הרשימה); בשניה יש {% equation %}n-2{% endequation %} השוואות; בשלישית יש {% equation %}n-3{% endequation %} וכן הלאה. סך הכל {% equation %}\left(n-1\right)+\left(n-2\right)+\cdots+1=\frac{\left(n-1\right)\left(n-2\right)}{2}=\Theta\left(n^{2}\right){% endequation %} השוואות. בנוסף יש גם {% equation %}\Theta\left(n\right){% endequation %} החלפות, אבל זה פחות נורא. בסך הכל האלגוריתם הוא לא אסון אבל יש טובים ממנו שעוד נראה.

המשמעות של סיבוכיות ריבועית שכזו היא שעבור רשימה של 1,000 פריטים צריך סדר גודל של מיליון השוואות; עבור רשימה של מיליון פרטים (וזו סיטואציה אפשרית בהחלט) צריך סדר גודל של {% equation %}10^{12}{% endequation %} השוואות - זה לא משהו בכלל. כבר על רשימות קטנות יחסית האלגוריתם דורש זמן ריצה מורגש, גם במחשבים מודרניים (אערוך השוואות כלשהן בהמשך, אחרי שאציג את כל אלגוריתמי המיון).

בואו ננסה לחשוב על שיטת מיון אחרת, שהיא טבעית מאוד עבור בני אדם (ונוחה מאוד למימוש אצל בני אדם, כל עוד הקלט קטן מספיק - למשל, קלפי משחק) - מיון הכנסה. במיון הכנסה, חושבים על הרשימה הקיימת {% equation %}A{% endequation %} בתור משהו מבולגן לחלוטין, ובונים לאט לאט רשימה ממוינת באופן הבא: שולפים איבר כלשהו מ-{% equation %}A{% endequation %}, בודקים איפה ברשימה החדשה הוא צריך להיות, ומכניסים אותו שם, אולי בין שני איברים קיימים.

השיטה הזו <strong>דואלית</strong> למיון בחירה במובן מסויים. במיון בחירה ידענו מראש בתחילת כל איטרציה <strong>לאן</strong> אנחנו רוצים להכניס את האיבר שאנחנו הולכים לבחור (המקסימלי) והעבודה שלנו הייתה למצוא אותו; במיון הכנסה אנחנו יודעים מראש מי האיברי שאנחנו רוצים להכניס, ונותר רק למצוא את המקום שבו נרצה להכניס אותו.

בפועל המימוש של מיון הכנסה קצת יותר מסובך, בגלל שכדי להכניס איבר <strong>לתוך</strong> רשימה צריך "להזיז הצידה" את האיברים שבאים אחריו ברשימה. הנה הקוד:
<div class="code-block">
{% highlight ruby %}
def insertion_sort(list)
  for k in 1...list.length
    new_element = list[k]
    i = k-1
    while i >= 0 and list[i] > new_element
      list[i+1] = list[i]
      i = i - 1
    end
    list[i+1] = new_element
  end
  return list
end
{% endhighlight %}
</div>

בתחילת ריצת האלגוריתם מתייחסים לתא 0 לבדו בתור "רשימה ממוינת" (לא חוכמה, זו רשימה של איבר אחד) ואילו כל היתר הוא מערב פרוע. לאט לאט מגדילים את האיזור הממויין על ידי כך שלוקחים את האיבר הראשון שהוא מחוץ לאיזור הממויין (האיבר במקום ה-k) ועוברים על האיזור הממויין מהסוף להתחלה תוך שאנו דוחפים קדימה את האיברים שאנו חולפים על פניהם, עד שאנו מוצאים את המקום הנכון להכניס אליו את האיבר החדש (בדיוק המקום שבו כל האיברים שחלפנו על פניהם היו גדולים מ-k והאיבר הראשון שטרם חלפנו על פניו קטן מ-k).

ניתוח הסיבוכיות כאן יותר מסובך. ללולאה החיצונית יש n-1 איטרציות, אבל הלולאה הפנימית היא לולאה מסוג חדש - לולאת while, שממשיכה לרוץ כל עוד תנאי מסויים לא התקיים. התנאי הוא שטרם מצאנו את המקום שאליו צריך להכניס את האיבר החדש. לכל היותר זה ייקח לנו k צעדים, אבל ייתכן שזה יקח לנו גם הרבה פחות. אז מה עושים?

לרוב הניתוח מתבסס על <strong>המקרה הגרוע ביותר</strong>. מה יהיה המקרה הגרוע ביותר כאן? אם תמיד האיבר החדש יהיה קטן מכל האיברים שכרגע נמצאים ברשימה הממויינת. זה יכול לקרות אם list כבר ממוין, אבל בדיוק בסדר הפוך (מהגדול ביותר לקטן ביותר). במקרה הזה בכל איטרציה יהיו לנו {% equation %}O\left(k\right){% endequation %} השוואות ו-{% equation %}O\left(k\right){% endequation %} החלפות, ולכן בסך הכל נקבל שהאלגוריתם מבצע {% equation %}\Theta\left(n^{2}\right){% endequation %} החלפות ו-{% equation %}\Theta\left(n^{2}\right){% endequation %} השוואות. זה עוד פחות טוב ממיון-בחירה. מצד שני, שימו לב שהאלגוריתם לא בדיוק מבצע "החלפה" - הוא מבצע חצי החלפה בלבד בכל פעם (לא השתמשתי ב-swap), אז הנזק פחות גדול משנראה במבט ראשון.

מצד שני, הביצועים במקרה הגרוע ביותר הם ממש לא המדד היחיד שצריך לחשוב עליו. למיון-בחירה יש חסרון לפיו הוא <strong>תמיד</strong> ידרוש ביצוע של {% equation %}\Theta\left(n^{2}\right){% endequation %} השוואות; לעומת זאת מיון הכנסה עשוי לדרוש הרבה, הרבה פחות פעולות אם הקלט יהיה "נחמד" (למשל, אם הרשימה ממויינת ברובה כבר כך - סיטואציה מציאותית יחסית).

בואו נעבור למיון פשוט נוסף - מיון בועות. השם של המיון הזה מגיע מכך שבשיטה שלו, בכל איטרציה האיבר הגדול ביותר שטרם טופל "מפעפע למעלה" למקומו במערך. השיטה פשוטה: מתחילים מהשוואה בין {% equation %}A\left[0\right]{% endequation %} ו-{% equation %}A\left[1\right]{% endequation %}. אם {% equation %}A\left[0\right]<A\left[1\right]{% endequation %} הכל בסדר, אבל אם {% equation %}A\left[1\right]<A\left[0\right]{% endequation %} אז מחליפים ביניהם. כעת אנו יודעים שב-{% equation %}A\left[1\right]{% endequation %} יש את האיבר הגדול מבין שני הראשונים; משווים אותו עם {% equation %}A\left[2\right]{% endequation %}. אם {% equation %}A\left[2\right]<A\left[1\right]{% endequation %}, מחליפים, וכעת ב-{% equation %}A\left[2\right]{% endequation %} יש את האיבר הגדול מבין שלושת הראשונים. ממשיכים... ובסוף התהליך ב-{% equation %}A\left[n\right]{% endequation %} יהיה את האיבר הגדול ביותר ברשימה. עכשיו אפשר להתחיל את כל הסיפור מחדש אבל לעצור ב-{% equation %}A\left[n-1\right]{% endequation %}, וכן הלאה.

<div class="code-block">
{% highlight ruby %}
def bubble_sort(list)
  list.length.downto(1) do |n|
    for i in 0...(n-1) do
      list.swap(i,i+1) if list[i] > list[i+1]
    end
  end
  return list
end
{% endhighlight %}
</div>
האלגוריתם הזה הוא <strong>איום ונורא</strong>. הוא גם לא טריוויאלי לחלוטין להבנה מבחינה רעיונית (למרות שאחרי שמבינים, הקוד עצמו הוא פשוט מאוד), והוא גם משיג בפועל תוצאות שהן משמעותית גרועות יותר מאשר אלו של מיון הכנסה ומיון-בחירה. הסיבה לכך היא שהוא מבצע גם המון השוואות ({% equation %}\Theta\left(n^{2}\right){% endequation %} תמיד - למה?) וגם המון החלפות, במקרים גרועים. במקרה טוב, למשל אם המערך כבר ממוין, הוא ישיג ביצועים טובים יותר מאשר מיון-בחירה, אבל בדרך כלל הביצועים שלו יהיו גרועים משמעותית יותר מאלו של מיון-בחירה ומיון הכנסה. אל תשתמשו בו. פשוט אל.

עד כה כל האלגוריתמים פעלו בזמן שהוא {% equation %}\Theta\left(n^{2}\right){% endequation %} במקרה הגרוע. הגיע הזמן לראות אלגוריתם מיון טוב, כזה שפועל בזמן {% equation %}\Theta\left(n\log n\right){% endequation %} ולכן משיג ביצועים טובים יותר משמעותית מכל האלגוריתמים שהצגתי. נתחיל ממיון שהוא פשוט יחסית להצגה, אבל הוא חזק מאוד (יש ספריות שמשתמשות בו בתור אלגוריתם המיון שלהן) - מיון מיזוג, שהומצא על ידי המתמטיקאי ג'ון פון-נוימן בשנת 1945 (ראשית ימי מדעי המחשב).

הרעיון של האלגוריתם פשוט, ומתמצה בביטוי <strong>הפרד ומשול</strong>. אלגוריתמי הפרד ומשול הם אלגוריתמים שלוקחים את הקלט, מחלקים אותו לכמה חלקים (הפרד), פותרים כל חלק בנפרד ואז איכשהו משלבים את הפתרונות של כל חלק בנפרד לפתרון כללי. הרעיון שבלב השיטה הזו הוא שלפעמים השלם הוא יותר מסך כל חלקיו; כלומר, שהעבודה שנדרשת כדי למיין רשימה שלמה בצורה פשוטה היא גדולה משמעותית יותר מאשר העבודה שנדרשת כדי למיין שתי רשימות קטנות יותר, כל אחת בנפרד.

האבחנה הזו די ברורה אם מסתכלים על האלגוריתמים שכבר התעסקנו בהם. מיון נאיבי של רשימה לוקח {% equation %}n^{2}{% endequation %} צעדים, נאמר? אז מיון נאיבי של רשימה שגודלה {% equation %}\frac{n}{2}{% endequation %} יקח {% equation %}\left(\frac{n}{2}\right)^{2}=\frac{n^{2}}{4}{% endequation %} צעדים, ולכן מיון של <strong>שתי</strong> רשימות שגודלן {% equation %}\frac{n}{2}{% endequation %} יקח רק {% equation %}\frac{n^{2}}{2}{% endequation %} צעדים - חצי מספר הצעדים מאשר מיון של הרשימה הגדולה. כמובן, זה בפני עצמו עדיין לא מהווה שיפור גדול במיוחד, אבל אחרי שמפצלים את הרשימה הגדולה לשתי רשימות קטנות, אפשר כדי למיין אותן לפצל אותן <strong>שוב</strong> לשתי רשימות כל אחת, ושוב ושוב ושוב. זו דוגמה לאלגוריתם <strong>רקורסיבי</strong>; אלגוריתם שמפעיל את עצמו על מקרים קטנים ופשוטים יותר של הבעיה. המקרה הכי פשוט הוא רשימה מגודל 0 או 1; רשימה כזו היא ממויינת בהכרח מעצמה, בלי שנעשה שום דבר נוסף איתה.

בינתיים לא אמרנו כלום, בעצם. אוקיי, אז מפצלים את הרשימה לשניים, באמצע, ממיינים כל תת-רשימה באופן רקורסיבי, ואז מה? נשארנו עם רשימה שהחצי הראשון שלה ממויין והחצי השני שלה ממויין אבל היא עצמה לא ממויינת. אז מה עושים עכשיו? <strong>ממזגים</strong> את שני החצאים לרשימה אחת גדולה.

איך עושים את זה? פשוט. מכינים בצד מקום לרשימה חדשה, בגודלה של הרשימה המקורית; ומתחילים לעבור בו זמנית על שתי תתי-הרשימות הממוינות. בכל צעד משווים את שני האיברים בתתי-הרשימות הממויינות שאנחנו רואים כרגע. את הקטן מבין השניים נכניס לרשימה שאנחנו בונים ונקדם את האינדקס של האיבר שאנחנו מסתכלים עליו ברשימה הזו ב-1. אם מתישהו סיימנו לעבור על אחת מהרשימות, נעתיק את כל יתר האיברים הרשימה השניה אל הרשימה שאנחנו בונים כמות שהם. הנכונות של המיזוג הזה נובעת מכך ששתי תתי-הרשימות כבר ממויינות.

הנה הקוד של המיון:
<div class="code-block">
{% highlight ruby %}
def merge_sort(list)
  return list if list.length <= 1
  k = list.length / 2
  list_a = merge_sort(list[0...k])
  list_b = merge_sort(list[k...list.length])
  return merge(list_a, list_b)
end
{% endhighlight %}
</div>

כמו שאנחנו רואים, הוא פשוט מאוד - אפילו טריוויאלי. פשוט מחלקים את הרשימות לשני חלקים באמצע (אלא אם הרשימה שלנו מכילה לכל היותר איבר אחד ואז לא עושים כלום), ממיינים כל אחת משתי הרשימות בנפרד ובסוף ממזגים. כדי להשלים את התמונה צריך להציג את האלגוריתם שממזג. כאן, למרבה הצער, הקוד יוצא טיפה מסורבל, אם כי לא נורא:
<div class="code-block">
{% highlight ruby %}
def merge(list_a, list_b)
  i, j = 0, 0
  result = []
  while i < list_a.length and j < list_b.length
    if (list_a[i] < list_b[j])
      result.push(list_a[i])
      i = i + 1
    else
      result.push(list_b[j])
      j = j + 1
    end
  end

  while i < list_a.length
        result.push(list_a[i])
        i = i + 1
  end

  while j < list_b.length
        result.push(list_b[j])
        j = j + 1
  end
  return result
end
{% endhighlight %}
</div>
נשאר רק להבין מה סיבוכיות זמן הריצה של האלגוריתם הזה. ראשית כל, שימו לב שאם merge מופעל על שתי רשימות שהארוכה מביניהן היא באורך {% equation %}n{% endequation %}, אז זמן הריצה שלו הוא {% equation %}\Theta\left(n\right){% endequation %} (עוברים על לכל היותר {% equation %}2n{% endequation %} איברים). במילים - מיזוג ניתן לבצע <strong>בזמן לינארי</strong>.

כדי להבין כמה זמן נדרש מ-merge_sort לרוץ צריך להתאמץ טיפה יותר. הקושי כאן הוא שמדובר על אלגוריתם רקורסיבי - כזה שקורא לעצמו - ולכן צריך להתחכם קצת בניתוח. בואו נסמן את זמן הריצה של האלגוריתם ב-{% equation %}T\left(n\right){% endequation %}. אז ברור ש-{% equation %}T\left(1\right)=O\left(1\right){% endequation %} (כי על רשימה מגודל 1 האלגוריתם רק מבזבז זמן על בדיקה האם הרשימה מגודל 1 או פחות וזהו).

אם לעומת זאת {% equation %}n{% endequation %} גדול יותר, אנחנו מקבלים את המשוואה הבאה שמתארת את זמן הריצה של האלגוריתם:

{% equation %}T\left(n\right)=2T\left(\frac{n}{2}\right)+\Theta\left(n\right){% endequation %}

מה המשוואה בעצם אומרת? שהזמן שלוקח להריץ את המיון על רשימה בגודל {% equation %}n{% endequation %} שווה לזמן שלוקח להריץ את המיון על שתי רשימות בגודל {% equation %}\frac{n}{2}{% endequation %} ({% equation %}2T\left(\frac{n}{2}\right){% endequation %} - זה שלב ה"הפרד") ועוד הזמן שלוקח למזג אותן אחר כך ({% equation %}\Theta\left(n\right){% endequation %} - זה ה"ומשול"). יופי, איך מתקדמים מכאן? - פשוט משתמשים באותה נוסחה <strong>שוב</strong>, ומקבלים:

{% equation %}2T\left(\frac{n}{2}\right)+\Theta\left(n\right)=2\left(2T\left(\frac{n}{4}\right)+\Theta\left(\frac{n}{2}\right)\right)+\Theta\left(n\right)=4T\left(\frac{n}{4}\right)+\Theta\left(n\right){% endequation %}

מפתה לעבור עכשיו לטענה כללית: שלכל {% equation %}k{% endequation %} טבעי, מתקיים:

{% equation %}T\left(n\right)=2^{k}T\left(\frac{n}{2^{k}}\right)+\Theta\left(n\right){% endequation %}

ואז לומר "בואו נבחר {% equation %}k{% endequation %} כך ש-{% equation %}2^{k}=n{% endequation %} ואז נקבל {% equation %}T\left(n\right)=n+\Theta\left(n\right)=\Theta\left(n\right){% endequation %} וקיבלנו זמן ריצה לינארי של האלגוריתם". רק שזה <strong>לא נכון</strong>. זו נקודה עדינה ומבלבלת שחשוב להתייחס אליה, אז בואו נעשה את זה.

מה {% equation %}T\left(n\right)=\Theta\left(n\right){% endequation %} אומר? שקיים קבוע {% equation %}c{% endequation %} וקיים {% equation %}N{% endequation %} כך ש-{% equation %}T\left(n\right)<c\cdot n{% endequation %} לכל {% equation %}n>N{% endequation %} (יש גם חסם מלמטה אבל הוא לא חשוב כרגע).

מה {% equation %}T\left(n\right)=2^{k}T\left(\frac{n}{2^{k}}\right)+\Theta\left(n\right){% endequation %} אומר? שלכל {% equation %}k{% endequation %}, קיים קבוע {% equation %}c_{k}{% endequation %} וקבוע {% equation %}N_{k}{% endequation %} כך ש-{% equation %}T\left(n\right)<2^{k}T\left(\frac{n}{2^{k}}\right)+c_{k}n{% endequation %} לכל {% equation %}n>N_{k}{% endequation %}.

האם אפשר לעבור מהטענה השניה לראשונה על ידי הצבת {% equation %}k=n{% endequation %}? לא! כי {% equation %}n{% endequation %} אינו קבוע. זכרו - אנחנו מנסים לחסום פה פונקציה של {% equation %}n{% endequation %}. בקיצור, האינטואיציה פכמהה מסוכנת ובעייתית. משחקי {% equation %}\Theta{% endequation %} עלולים להוביל לבעיות מסוג זה.

הדרך להתגבר על הבעיה היא ניתוח קצת יותר זהיר. אנחנו יודעים ש-{% equation %}T\left(n\right)=2T\left(\frac{n}{2}\right)+\Theta\left(n\right){% endequation %}. זה אומר ש{% equation %}T\left(n\right)<2T\left(\frac{n}{2}\right)+c\cdot n{% endequation %} לכל {% equation %}n>N{% endequation %} עבור {% equation %}N,c{% endequation %} מסויימים. יפה. עכשיו ניטרלנו (לעת עתה) את הסימונים האסימפטוטיים מהמשוואה. כדי לסיים עם זה, נשים לב לכך שעבור {% equation %}n<N{% endequation %} מתקיים {% equation %}T\left(n\right)<d{% endequation %} עבור קבוע {% equation %}d{% endequation %} כלשהו. אם נבחר את {% equation %}c{% endequation %} להיות גדול מספיק, ובפרט גדול יותר מ-{% equation %}d{% endequation %}, נקבל ש-{% equation %}T\left(n\right) < 2T\left(\frac{n}{2}\right)+c\cdot n{% endequation %} היא משוואה שתקפה תמיד, לכל {% equation %}n{% endequation %}.

עכשיו אפשר לעשות את התעלול הבא:

{% equation %}T\left(n\right)<2T\left(\frac{n}{2}\right)+c\cdot n<2\left(2T\left(\frac{n}{4}\right)+c\cdot\frac{n}{2}\right)+c\cdot n=4T\left(\frac{n}{4}\right)+2cn{% endequation %}

שימו לב: ה-{% equation %}2cn{% endequation %} שבאגף ימין נבנה מה-{% equation %}cn{% endequation %} שהיה בהתחלה, ועוד פעמיים {% equation %}c\frac{n}{2}{% endequation %} (המחיר של הפעלת מיזוג על שני תתי-הרשימות).

נחזור על הקסם שוב:

{% equation %}4T\left(\frac{n}{4}\right)+2cn<4\left(2T\left(\frac{n}{8}\right)+c\frac{n}{4}\right)+2cn=8T\left(\frac{n}{8}\right)+3cn{% endequation %}

הבנתם את הרעיון. הנה המשוואה הכללית, שנכונה לכל {% equation %}k{% endequation %} טבעי:

{% equation %}T\left(n\right)<2^{k}T\left(\frac{n}{2^{k}}\right)+k\cdot cn{% endequation %}

ולכן עבור {% equation %}k{% endequation %} שמקיים {% equation %}2^{k}\ge n{% endequation %} יתקיים ש- {% equation %}T\left(\frac{n}{2^{k}}\right)<d{% endequation %} עבור איזה שהוא קבוע {% equation %}d{% endequation %}. נשאלת רק השאלה איזה {% equation %}k{% endequation %} לבחור.

אם {% equation %}2^{k}=n{% endequation %}, יש סימון מיוחד ל-{% equation %}k{% endequation %} שמקיים את השוויון: {% equation %}k=\lg n{% endequation %} (זה מה שנקרא לוגריתם על בסיס 2). לא תמיד {% equation %}n{% endequation %} הוא בדיוק חזקה של 2, ולכן לא תמיד {% equation %}\lg n{% endequation %} יוצא מספר שלם. תמיד אפשר לעגל למעלה: {% equation %}k=\left\lceil \lg n\right\rceil {% endequation %}, והמספר שנקבל יקיים {% equation %}n\le2^{k}\le2n{% endequation %}. לכן אנחנו מקבלים בסופו של דבר את אי השוויון הבא:

{% equation %}T\left(n\right)<2n\cdot d+\left\lceil \lg n\right\rceil \cdot cn=O\left(n\log n\right){% endequation %}

(הסיבה שעברתי מ-{% equation %}\lg{% endequation %} ל-{% equation %}\log{% endequation %} היא שכדי לעבור בין שני בסיסים שונים של לוגריתם כופלים בקבוע: {% equation %}\log_{a}n=\left(\log_{a}b\right)^{-1}\cdot\log_{b}n{% endequation %}, ולכן {% equation %}\log_{a}n=\Theta\left(\log_{b}n\right){% endequation %}).

קיבלנו חסם עליון על הזמן שבו רץ האלגוריתם, ולא קשה במיוחד להראות חסם תחתון דומה. המסקנה: מיון מיזוג רץ בזמן {% equation %}\Theta\left(n\log n\right){% endequation %}, שהוא טוב משמעותית יותר מאשר {% equation %}\Theta\left(n^{2}\right){% endequation %}, שכן {% equation %}\log n{% endequation %} הוא קטן משמעותית ביחס ל-{% equation %}n{% endequation %}. ההבדל שבין {% equation %}n{% endequation %} ו-{% equation %}\log n{% endequation %} הוא ההבדל שבין <strong>גודל</strong> של מספר ובין <strong>מספר הספרות</strong> של אותו מספר (בבסיס עשרוני, או בינארי, לא באמת חשוב). כך למשל הגודל של 10 הוא עשר, ואילו מספר הספרות שלו הוא 2; ואילו מספר הספרות של {% equation %}10^{100}{% endequation %} הוא בסך הכל 101, בעוד הגודל של המספר הזה (<strong>גוגול</strong>) הוא גדול ממספר האטומים ביקום. התוצאה היא הבדל משמעותי ביותר בביצועים.

מיון מיזוג הוא האלגוריתם ה"טוב" הראשון למיון שהראיתי. בהמשך אראה עוד שני אלגוריתמים מפורסמים טובים למיון, כל אחד עם יתרונות וחסרונות משל עצמו: מיון ערימה, ומיון מהיר. בנוסף לכך שהם יפים ומועילים לכשעצמם, הניתוח של זמן הריצה שלהם הוא מורכב ומחוכם יותר מתמטית ממה שראינו עד כה ויתן תחושה כלשהי של אופי הטיפול באלגוריתמים מחוכמים. יהיה כיף.
