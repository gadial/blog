---
id: 47
title: "שורש, ההוכחה (חלק ב’)"
date: 2007-08-07 09:43:49
layout: post
categories: 
  - קריפטולוגיה
tags:
  - הוכחות לא קונסטרוקטיביות
---
פרוטוקול הוכחת אפס-הידע שאני עומד להציג נקרא "פרוטוקול פיאט-שמיר", על שם שני ממציאיו הישראליים - עמוס פיאט ועדי שמיר (את עדי שמיר הזכרתי כבר במובלע לפחות פעמיים בפוסטים קודמים - הוא זה שהוכיח שהוכחות אינטראקטיביות שקולות למחלקה PSPACE, והוא ה-S שבשמו של אלגוריתם ההצפנה RSA). המערכת שאני מציג הנה פרימיטיבית למדי, במונחים של ביצוע מעשי; לא אתעכב על הבעייתיות הטכנית שבה אלא רק אציין שהיא שופרה בידי אוריאל פייגה, שתיקן את הבעיה הטכנית ועשה עוד משהו נוסף, שגם אליו אתייחס בהמשך.

הבסיס של הוכחת אפס הידע הוא במספר גדול {% equation %}n{% endequation %} שהוא מכפלה של שני מספרים ראשוניים גדולים. המושג "גדול" אינו מוגדר היטב, ותלוי בכוח החישוב הנוכחי של מחשבים, אבל בימינו פירוש הדבר מספר בן כמה מאות ספרות (400? 600?). הרעיון העקרוני שעומד מאחורי זה הוא שקל <strong>לייצג</strong> מספרים גדולים ולעבוד איתם (בניסוח נאיבי, צריך רק "400 בייטים" כדי לייצג מספר בן 400 ספרות, והרי בזכרונות המחשב של ימינו זוהי כמות זניחה ביותר. בפועל, צריך הרבה פחות מ-400 בייטים), אבל לא קשה לנסח בעיות שהקושי שלהן תלוי ב<strong>גודל</strong> המספר (ערכו המספרי), ולא ב<strong>גודל הייצוג</strong> שלו (מספר הבייטים שנדרשים לצורך כתיבתו). כדי להבין את ההבדל אעיר שמספר האטומים ביקום מוערך כמספר שאינו גדול מגוגול ({% equation %}10^{100}{% endequation %}, ובמילים אחרות - 1 עם מאה אפסים אחריו) וגוגול הוא יצור פיצי ומסכן לעומת מספר בן 400 ספרות.

הנה המחשה לבעייתיות שבדבר: בדיקת ראשוניות. הדרך שבה יוצרים את {% equation %}n{% endequation %} היא על ידי הגרלה של שני ראשוניים גדולים (אם אנחנו רוצים ש-{% equation %}n{% endequation %} יהיה בגודל 600 ספרות, נגריל ראשוניים בני 300 ספרות) והכפלתם (פעולה שכאמור - קל לבצע גם עבור מספרים גדולים שכאלו, בגלל שגודל הייצוג שלהם סביר). הבעיה היא רק כיצד להגריל שני ראשוניים דווקא, הרי ראשוניים הם לא מספרים נפוצים עד כדי כך.

דרך נאיבית היא פשוט להגריל מספרים גדולים שוב ושוב עד שיצאו ראשוניים ולקוות שזה יקרה מהר. אפשר לחשוב על כל מני אופטימיזציות טריוויאליות - למשל, להימנע מהגרלת מספריים זוגיים, אבל צוואר הבקבוק של האלגוריתם יהיה נעוץ בשאלה איך ניתן לדעת, בהינתן מספר שהגרלנו, האם הוא ראשוני או לא?

הדרך הסטנדרטית לבדיקת ראשוניות היא לעבור על כל המספרים הקטנים מהמספר שאנו בודקים ולבדוק האם הם מחלקים אותו (והמהדרין יגידו - כל המספרים הקטנים או שווים לשורש המספר שאנו בודקים). השיטה הזו, שהיא קלה מאוד לתכנות ונוחה לשימוש עבור מספרים קטנים, היא חסרת ערך עבור מספרים גדולים. גם אם המספר שלנו מיוצג עם 300 ספרות בלבד, הרי שלעבור על כל המספרים עד לשורש שלו ידרוש מאיתנו פרק זמן הגדול בהרבה מזה שחלף מאז המפץ הגדול. על כן נדרשות שיטות אחרות - וכאלו אכן יש, וייתכן שאציג אותן בעתיד.

אם כן, ייצרנו שני מספרים ראשוניים גדולים {% equation %}p,q{% endequation %} כפלנו אותם וקיבלנו {% equation %}n=pq{% endequation %}. כעת זורקים את הראשוניים לכל הרוחות (אם מישהו ידע מה הם, הוא ידע את הפירוק של {% equation %}n{% endequation %} ולכן יוכל להוציא שורש מודולו {% equation %}n{% endequation %} והמערכת חסרת ערך) ומפרסמים את {% equation %}n{% endequation %} לכל דורש. כעת המערכת מסוגלת להתחיל לתפקד.

אני, בתור המוכיח, רוצה להראות למערכת שאני מכיר שורש של מספר כלשהו. אם כן, אני בוחר באקראי מספר מודולו {% equation %}n{% endequation %} שנכנה {% equation %}x{% endequation %} (צריך לוודא גם שהוא זר ל-{% equation %}n{% endequation %} כדי שיהיה איבר בחבורה הכפלית - אבל הסיכוי שניפול על איבר שאינו זר שווה לסיכוי שנצליח לפרק את {% equation %}n{% endequation %} לגורמים "בטעות" - למה?), מעלה אותו בריבוע מודולו {% equation %}n{% endequation %} ומקבל מספר חדש, {% equation %}y=x^2(mod n){% endequation %}. מן הסתם אני צריך לבחור את {% equation %}y{% endequation %} כך שהריבוע שלו יהיה גדול מ-{% equation %}n{% endequation %}, אחרת יהיה קל להוציא ל-{% equation %}x{% endequation %} שורש (למה?)

אני מפרסם את {% equation %}y{% endequation %} לכל דורש, ובפרט למערכת שרוצה לזהות אותי. יש כאן בעיה לוגיסטית כלשהי - צריך שהיא <strong>תשתכנע</strong> ש-{% equation %}y{% endequation %} באמת מייצג אותי ולא איזה מתחזה, וזו יכולה להיות בעיה רצינית - אולם הפתרונות לבעיה הם לרוב לא קריפטוגרפיים, והבעיה עצמה אינה חמורה כל כך מכיוון שהיא "חד פעמית" - אחרי שפעם אחת אני "אירשם" במערכת כבעליו של המספר {% equation %}y{% endequation %}, לא יידרשו עוד שכנועים עתידיים. כל מה שיידרש ממני להוכיח בפני המערכת כדי להזדהות הוא שאני יודע את השורש של {% equation %}y{% endequation %} - סוד שרק אני אמור לדעת, מכיוון שהוצאת שורש היא קשה.

ההוכחה הטריוויאלית של "שלח את {% equation %}x{% endequation %}, תן למוודא להעלות אותו בריבוע ולוודא שהוא קיבל {% equation %}y{% endequation %}" לא טוב לנו מכיוון שכך {% equation %}x{% endequation %} נחשף לכל מי שרוצה לצותת. ה"תיקון" שיש לבצע להוכחה הנאיבית אינו גדול, במפתיע; מה שנעשה יהיה לכפול את {% equation %}x{% endequation %} במספר אקראי כלשהו, ואז לשלוח את המכפלה. מכיוון שכפלנו את {% equation %}x{% endequation %} במספר אקראי ואנחנו עובדים בחבורה הכפלית מודולו {% equation %}n{% endequation %} (ולכן <strong>כל</strong> מספר מודולו {% equation %}n{% endequation %} ששייך לחבורה הזו הוא תוצאה אפשרית של המכפלה, תלוי מה המספר האקראי) הרי שאין במכפלה הזו שום מידע על זהותו של {% equation %}x{% endequation %}.

אם כן, נסכם: אנו מגרילים {% equation %}r{% endequation %} אקראי מודלו {% equation %}n{% endequation %}, ושולחים למוודא את {% equation %}xr{% endequation %}. כיצד המוודא יכול לוודא שאנחנו יודעים את שורש {% equation %}y{% endequation %}? אם הוא יעלה את המספר ששלחנו לו בריבוע הוא יקבל את {% equation %}(xr)^2=x^2r^2=yr^2{% endequation %}, ולכן הוא צריך מידע נוסף - מהו {% equation %}r^2{% endequation %}. אם כן, נשלח לו גם את המספר הזה (בלי חשש שאפשר יהיה לגלות ממנו את {% equation %}r{% endequation %}, שהרי הוצאת שורש היא קשה), וכעת המוודא אכן יכול לוודא שהכל בסדר: ש-{% equation %}y{% endequation %} כפול המספר השני ששלחנו לו שווה למספר הראשון בריבוע. עשינו זאת מבלי לחשוף שום מידע על {% equation %}x{% endequation %} (שלחנו רק מספרים שנראים אקראיים) ולכן תם ונשלם הפרוטוקול.

האמנם?

שלמות יש ואפס ידע יש בפרוטוקול שלהלן, אבל נאותות אין בכלל. הנה הדגמה כיצד ניתן להונות את המוודא: נניח שאנחנו אמנם מכירים את {% equation %}y{% endequation %} אבל אין לנו מושג מה השורש שלו. איך נבצע הונאה?

אנחנו יודעים שהמוודא מצפה לקבל שני מספרים {% equation %}a,b{% endequation %} (בכוונה עברתי לאותיות אחרות) כך שמתקיים {% equation %}yb=a^2{% endequation %}. במילים אחרות, הוא מצפה שיתקיים {% equation %}b=\frac{a^2}{y}{% endequation %}. קשה לנו להוציא שורש, אולם לחלק קל, ולכן מה שנעשה יהיה להגריל את {% equation %}a{% endequation %} (שכזכור, אם היינו מוכיחים "הגונים" היה המספר {% equation %}xr{% endequation %}, שאינו "סתם" אקראי אלא מהווה פונקציה של {% equation %}x{% endequation %}), להעלות אותו בריבוע, לחלק ב-{% equation %}y{% endequation %} ולחשב ממנו את {% equation %}b{% endequation %} (שכזכור, אם היינו הגונים היה בכלל {% equation %}r^2{% endequation %}). הצלחנו לענות בכך על כל הדרישות של המוודא, ועם זאת אין לנו שמץ של מושג מה השורש של {% equation %}y{% endequation %}. בעיה.

הפתרון הוא הוספת שאלה נוספת למוודא: אם שלחנו לו {% equation %}a,b{% endequation %}, הוא יכול לתפוס את הרמאות הזו על ידי דרישת השורש של {% equation %}b{% endequation %}. אם היינו הגונים, אז {% equation %}b=r^2{% endequation %} ולכן כל מה שצריך הוא לשלוח את {% equation %}r{% endequation %}; אם רימינו ולא יצרנו את {% equation %}b{% endequation %} על ידי העלאה בריבוע של מספר אקראי אלא על ידי חישוב מהסוג שהוצג לעיל - אז אין סיכוי שנדע את השורש של {% equation %}b{% endequation %} (אם היינו יודעים, היינו יכולים לדעת גם את {% equation %}x{% endequation %} - למה?).

מה הבעיה עכשיו? איבדנו את אפס הידע. מדוע? מכיוון שאם אנחנו הוגנים, ושלחנו למוודא את {% equation %}r^2, xr{% endequation %} ועכשיו הוא דרש מאיתנו גם את {% equation %}r{% endequation %}, הרי שהוא מסוגל לחלק את {% equation %}xr{% endequation %} ב-{% equation %}r{% endequation %} ולקבל את {% equation %}x{% endequation %} ישירות - וכך גם כל מי שמצותת לרשת.

הפתרון הוא לבצע פשרה. האבחנה היא שאת {% equation %}r^2{% endequation %} תמיד אפשר לשלוח, אבל שתי פיסות המידע האחרות, {% equation %}r{% endequation %} ו-{% equation %}xr{% endequation %} לא מתיישבות זו עם זו, ושתיהן גם ממלאות פונקציות שונות: {% equation %}xr{% endequation %} מראה למוודא שאנחנו אכן יודעים את {% equation %}x{% endequation %}, ואילו {% equation %}r{% endequation %} מראה למוודא שאנחנו הגונים ובאמת יצרנו את ה-{% equation %}b{% endequation %} באופן אקראי. לכן, מספיק לבחון כל אחת משתי פיסות המידע הללו <strong>לסירוגין</strong>.

הנה הפרוטוקול השלם והאמיתי: הפרוטוקול שלנו יחולק לסיבובים. בכל סיבוב, המוכיח יגריל {% equation %}r{% endequation %} אקראי וישלח למוודא את {% equation %}r^2{% endequation %}. בשלב הזה המוודא יבצע "הטלת מטבע" ועל פיה יודיע למוכיח אם הוא רוצה לקבל את {% equation %}xr{% endequation %} או את {% equation %}r{% endequation %}. אם הוא ביקש את {% equation %}xr{% endequation %}, הוא מעלה בריבוע את מה שקיבל, מחלק במספר הראשון שקיבל ובודק אם יצא {% equation %}y{% endequation %}. אם הוא ביקש את {% equation %}r{% endequation %}, הוא מעלה בריבוע את מה שקיבל ובודק האם זה שווה למספר הראשון שקיבל. אם הבדיקה נכשלה, הוא יודע שהמוכיח שקרן ומעיף אותו. אחרת, ממשיכים לסיבוב הבא.

אם המוכיח דובר אמת הוא תמיד יצליח - כלומר, יש לנו שלמות. אם המוכיח שקרן, לעומת זאת, הוא אף פעם לא יידע בו זמנית את התשובה לשתי השאלות שהמוודא עשוי לשאול - זה תלוי בצורה שבה הוא יצר את המספר הראשון ששלח למוודא. לכן הוא צריך "לנחש" מה המוודא ישאל, וההסתברות לכך היא 50:50. לכן, ההסתברות שלו לעבור את הסיבוב הראשון בשלום היא חצי, אבל ההסתברות לעבור את השני בשלום היא כבר רבע (כי גם בראשון וגם בשני הוא צריך להצליח), בשלישי שמינית וכן הלאה וכן הלאה - מהר מאוד ההסתברות של מוכיח לשקר הופכת לאפסית, ולכן יש כאן גם נאותות.

כדי להוכיח פורמלית שזו הוכחת אפס ידע יש צורך בהדגמת סימולטור. במקרה שלנו זה "סימולטור עם נבוט" - הוא מזמין מוודא "אמיתי" להשתתף בסימולציה, ואז מנסה לרמות אותו באותה צורה שבה מוכיח רמאי היה פועל - מנחש מה תהיה השאלה של המוודא, ובוחר את המספר הראשון שישלח לו בהתאם לה. אם המוודא אכן בחר את השאלה שהמוכיח ניחש - מה טוב, מצלמים את התנהלות הסיבוב הזה (מוסיפים ל"תעתיק" של הפרוטוקול שהסימולטור יוצר) וכולם שמחים. אם לעומת זאת המוודא בחר את השאלה "הלא נכונה", הסימולטור מרביץ לו עם נבוט בראש (מאפס אותו כך שלא יזכור את הסיבוב הכושל הנוכחי), שורף את סרט הצילום (לא מוסיף את הסיבוב הכושל לפרוטוקול) ומתחיל סיבוב חדש. צריך להוכיח פורמלית שזה עובד - אבל זה עובד. בממוצע חצי מהסיבובים שהסימולטור מנסה לייצר ייכשלו, אבל זה לא כל כך הרבה, ולכן הסימולטור עדיין יעבוד בפרק זמן סביר, ויצליח לשכנע שהפרוטוקול שהוא ייצר "אותנטי" (ה"אותנטיות" נובעת מכך שהמוודא שהשתתף ביצירת הפרוטוקול היה אמיתי).

נשאר רק מה שהבטחתי קודם - השיפור של פייגה. כאמור, לסוגייה הטכנית אני לא הולך להיכנס אלא רק להפיכה שלו את הפרוטוקול למה שמכונה Proof of Knowledge. כפי שהוא כרגע, הפרוטוקול כן מעביר למוודא מידע כלשהו - הוא אומר לו של-{% equation %}y{% endequation %} יש שורש מודולו {% equation %}n{% endequation %} (דבר שאינו נכון בהכרח לכל המספרים מודולו {% equation %}n{% endequation %}). לכאורה זה לא בעייתי כי ממילא ההנחה המוקדמת של כל הפרוטוקול היא שקיים למספר הזה שורש (אחרת איך אפשר להוכיח שיודעים את השורש שלו?).

השיפור מחסל גם את הדבר הזה. עדיין יש מספר {% equation %}y{% endequation %}, אבל מה שהמוכיח מוכיח הוא ש<strong>אם</strong> קיים לו שורש, המוכיח יודע אותו; ואם לא קיים לו שורש, המוכיח יודע גם את העובדה הזו (שגם אותה קשה לבדוק), אבל הוא לא מגלה למוודא איזה משתי העובדות הללו נכונות. זוהי הצורה הקיצונית ביותר של הוכחות אפס-ידע; כאן אפילו לא ברור אם מה שהמוכיח מנסה להוכיח הוא נכון או לא, והדבר היחיד שידוע בסיום הפרוטוקול הוא שהמוכיח יודע.

וזוהי, לטעמי, אחת מהדוגמאות הנאות ביותר להוכחה לא קונסטרוקטיבית.
