---
title: "איך מחשבים דטרמיננטה?"
layout: post
categories:
  - אלגברה לינארית
tags:
  - דטרמיננטה
---

כאשר לומדים אלגברה לינארית, מושג <strong>הדטרמיננטה</strong> צץ בשלב זה או אחר. לפעמים מלמדים אותו מהר יחסית ולפעמים מחכים איתו עד שממש חייבים, כדי לא להפחיד אנשים תמימים, אבל הוא תמיד שם - וזה כי דטרמיננטות זה יופי של דבר כשמפסיקים לפחד מהן. <a href="https://gadial.net/2011/11/10/determinants/">יש לי כבר פוסט</a> שמסביר מהי דטרמיננטה, אבל דבר אחד אין שם: <strong>איך מחשבים אותה</strong>. בפוסט הזה אני רוצה להשלים את החור הזה ולתאר את הדרך הסטנדרטית, שהיא בסך הכל די פשוטה; המוטיבציה שלי מגיעה מכך שלא מזמן נזקקתי לדרך אחרת, שבמובנים מסוימים היא טובה יותר ובמובנים אחרים היא טובה פחות, אבל איתה אחכה לפוסט הבא.

ראשית, בואו ניזכר מה זו דטרמיננטה בעצם. ההיכרות הראשונה שלי עם הנושא הייתה בשיעור מחשבים אי שם בכיתה י' או משהו, שבו מסיבה לא ברורה המורה החליט בתור שאלת שיעורי בית לתת לנו לכתוב קוד שמחשב דטרמיננטות, ולכן בילה כמעט חמש דקות בלהכתיב את השאלה שרובה כללה הסבר של איך בכלל מוגדרת דטרמיננטה. לא רק שלא הבנתי כלום, גם נכנסתי להלם גדול וחרדה מפני הנושא הזה. למה שהמורה יתעלל בנו בצורה כזו? ובכן, כי הוא רצה להציג את המושג של <strong>רקורסיה</strong>, פונקציה שמחשבת משהו על קלט מסוים ידי קריאה לעצמה על קלטים קטנים יותר, וזו בהחלט <strong>אחת הדרכים</strong> שבהן ניתן לחשב דטרמיננטה. האם זו הדרך הנכונה להציג את הנושא? ובכן, לא וכן; לא, כי זה לא נותן לנו מבט בתמונה הגדולה - אבל בשביל זה יש את הפוסט שקישרתי אליו קודם - וכן, כי זה מכניס אותנו ישר למים של ההיבט החישובי.

דטרמיננטה מוגדרת על <strong>מטריצה ריבועית</strong>, כלומר על אוסף של מספרים שמסודר בטבלה עם אותו מספר שורות ועמודות. אם המספר הוא {% equation %}n{% endequation %}, אומרים שזו מטריצה מסדר {% equation %}n\times n{% endequation %}. בדרך כלל מסמנים את זה ב-

{% equation %}A=\left[\begin{array}{cccc} a_{11} & a_{12} & \cdots & a_{1n}\\ a_{21} & a_{22} &  & a_{2n}\\ \vdots &  & \ddots & \vdots\\ a_{n1} & a_{n2} & \cdots & a_{nn} \end{array}\right]{% endequation %}

הדטרמיננטה של {% equation %}A{% endequation %} מסומנת {% equation %}\left|A\right|{% endequation %} (אבל זה לא ערך מוחלט; זה סימן שנבחר בגלל דמיון שטחי כלשהו בין התכונות של הדטרמיננטה והתכונות של הערך המוחלט) או {% equation %}\text{det}A{% endequation %}. הנה דרך אחת לחשב את {% equation %}\left|A\right|{% endequation %}: אנחנו עוברים על כל האיברים בשורה העליונה של {% equation %}A{% endequation %}. ראשית אנחנו לוקחים את {% equation %}a_{11}{% endequation %} ואז אנחנו שומרים את {% equation %}A{% endequation %} בצד, לוקחים עותק שלה, <strong>מוחקים</strong> מהעותק את השורה והעמודה הראשונה, מחשבים את הדטרמיננטה של המטריצה הקטנה יותר הזו, כופלים את זה ב-{% equation %}a_{11}{% endequation %} ואת התוצאה שומרים בצד.

עכשיו עושים משהו דומה עם {% equation %}a_{12}{% endequation %}: מוחקים את השורה הראשונה והעמודה <strong>השניה</strong>, מקבלים מטריצה קטנה יותר, מחשבים את הדטרמיננטה שלה, כופלים ב-{% equation %}a_{12}{% endequation %} ואז <strong>מחסרים</strong> את התוצאה ממה שקיבלנו קודם. ואז לוקחים את {% equation %}a_{13}{% endequation %} ועושים את אותו הטריק איתו אבל <strong>מחברים</strong> - בקיצור, אנחנו רואים שזו מהומה, ושצריך להכניס קצת סימנים כדי לתאר את זה בצורה פשוטה.

הסימן הראשון שאנחנו רוצים הוא "המטריצה שמקבלים מ-{% equation %}A{% endequation %} כשמוחקים שורה ועמודה ספציפיות". למטריצה כזו קוראים <strong>מטריצת המינור</strong> של השורה והעמודה, ואם השורה היא {% equation %}i{% endequation %} והעמודה היא {% equation %}j{% endequation %} אני אסמן אותה ב-{% equation %}A^{ij}{% endequation %}. אצלנו תמיד מחקתי את השורה הראשונה, אבל זה היה רק לצורך הדוגמא - אפשר להראות שלא משנה איזו שורה אני בוחר, אני אקבל את אותו דבר. אז אני מקבל את הנוסחה הבאה:

{% equation %}\left|A\right|=\sum_{j=1}^{n}\left(-1\right)^{i+j}a_{ij}\left|A^{ij}\right|{% endequation %}

כאן {% equation %}\left|A^{ij}\right|{% endequation %} הוא הדטרמיננטה של מטריצת המינור, {% equation %}a_{ij}{% endequation %} האיבר שאת השורה והעמודה שלו מוחקים, ו-{% equation %}\left(-1\right)^{i+j}{% endequation %} זו הדרך להשיג את אפקט ה"לחבר ולחסר לסירוגין". הנוסחה הזו שלעיל מתאימה למה שנקרא "פיתוח הדטרמיננטה לפי השורה ה-{% equation %}i{% endequation %}". אפשר לעשות את זה גם לפי עמודות - לבחור עמודה {% equation %}j{% endequation %} ספציפית ולעבור על האיברים שלה אחד-אחד. זה מוביל לנוסחה

{% equation %}\left|A\right|=\sum_{i=1}^{n}\left(-1\right)^{i+j}a_{ij}\left|A^{ij}\right|{% endequation %}

זו נוסחה רקורסיבית, אז היא צריכה תנאי התחלה - מקרה בסיסי כל כך שבו לא צריך לחשב דטרמיננטה של משהו קטן יותר. די מתבקש להסתכל על המקרה של מטריצה בת איבר בודד ואז הדטרמיננטה שלה היא האיבר הבודד הזה. ומה קורה עם מטריצה מסדר {% equation %}2\times2{% endequation %}?

{% equation %}A=\left[\begin{array}{cc} a_{11} & a_{12}\\ a_{21} & a_{22} \end{array}\right]{% endequation %}

נפתח את הדטרמיננטה על פי השורה הראשונה: ראשית ניקח את {% equation %}a_{11}{% endequation %}, נמחק את השורה והעמודה הראשונות ונקבל את המטריצה {% equation %}\left[a_{22}\right]{% endequation %} שהדטרמיננטה שלה היא {% equation %}a_{22}{% endequation %}, אז האיבר הראשון בסכום הוא {% equation %}a_{11}a_{22}{% endequation %}. עכשיו נעבור אל {% equation %}a_{12}{% endequation %}, נמחק שורה ראשונה ועמודה שניה, נקבל דטרמיננטה {% equation %}a_{21}{% endequation %}, נכפיל ונשים סימן חיסור על הכל, ונקבל בסך הכל ש-{% equation %}\left|A\right|=a_{11}a_{22}-a_{12}a_{21}{% endequation %}. עכשיו תנסו לעשות את אותו הדבר עם פיתוח של שורה אחרת או עמודה אחרת (למשל, עמודה 2) ותראו איך יוצא אותו דבר (אם סימני הפלוס/מינוס לא מסתדרים תזכרו את הגורם {% equation %}\left(-1\right)^{i+j}{% endequation %}; לא <strong>תמיד</strong> כשמפתחים לפי שורה או עמודה כלשהי, האיבר הראשון שבו מטפלים יהיה עם סימן חיובי).

{% highlight python %}
def det(A):
    n = len(A)
    if n == 1:
        return A[0][0]
    result = 0
    for k in range(n):
        minor_matrix = [[A[i][j] for j in range(n) if j != k] for i in range(1, n)]
        result += (-1)**k * A[0][k] * det(minor_matrix)
    return result
{% endhighlight %}

האם זה עובד טוב? לא, זה עובד איום ונורא. זה ירוץ ויחזיר את התוצאה הנכונה, אבל <strong>באיזה מחיר</strong>? המחיר יהיה זמן ריצה גדול (וגם צריכת זכרון מיותרת, אבל בהיקף פחות משמעותי כאן). חשבו על זה כך: אם אני מפעיל את האלגוריתם על מטריצה מסדר {% equation %}n\times n{% endequation %}, אני צריך לחשב את הדטרמיננטה של {% equation %}n{% endequation %} מטריצות מסדר {% equation %}\left(n-1\right)\times\left(n-1\right){% endequation %}, וכל חישוב כזה דורש חישוב של {% equation %}n-1{% endequation %} דטרמיננטות של מטריצות מסדר {% equation %}\left(n-2\right)\times\left(n-2\right){% endequation %} וכן הלאה - יוצא שאני מחשב {% equation %}n\left(n-1\right)\left(n-2\right)\cdots1=n!{% endequation %} דטרמיננטות. קצב הגידול של {% equation %}n!{% endequation %} הוא אקספוננציאלי - תמיד חדשות רעות שמדובר על זמן חישוב. על מטריצת {% equation %}4\times4{% endequation %} האלגוריתם הזה יעבוד מעולה ויסתיים חיש קל. על מטריצה מסדר {% equation %}1000\times1000{% endequation %}? אני לא מעז להפעיל אותו.

האם ניתן לייעל את זה? למרבה השמחה כן, אפשר לייעל את החישוב בצורה קיצונית ממש, וכל זה בזכות תכונה קסומה אחת של הדטרמיננטה: היא <strong>כפלית</strong>. אם {% equation %}A,B{% endequation %} הן מטריצות ריבועיות, אז {% equation %}\left|AB\right|=\left|A\right|\cdot\left|B\right|{% endequation %}. ההוכחה היא אפילו לא כל כך מסובכת <a href="https://gadial.net/2011/11/21/matrix_revolutions/">ואני מציג אותה בפוסט שלי</a>, אבל היא דורשת את נקודת המבט התיאורטית יותר על דטרמיננטה שאני לא נכנס אליה כאן. גם לשאלה מה זה בדיוק כפל המטריצות {% equation %}AB{% endequation %} אני לא נכנס; זה לא כפל "איבר-איבר" אלא משהו מתוחכם יותר, אבל יש לי <a href="https://gadial.net/2011/10/06/matrix_product/">פוסט גם על זה</a> ומי שלא מכירים את המושג פשוט יוכלו לסמוך עלי בכמה טענות פשוטות שאני עוד מעט אטען.

לפני שנגיע לשימוש בכפליות של הדטרמיננטה, בואו נחשוב מתי ההגדרה הרקורסיבית כן שמישה בצורה נוחה. המקרה הקלאסי הוא זה: אם יש לי מטריצה שיש בה שורה שכל האיברים בה הם אפס חוץ אולי מאיבר אחד, <strong>מאוד</strong> כדאי לי לפתח את הדטרמיננטה על פי השורה הזו, כי בנוסחה {% equation %}\left|A\right|=\sum_{j=1}^{n}\left(-1\right)^{i+j}a_{ij}\left|A^{ij}\right|{% endequation %} כל האיברים {% equation %}a_{ij}{% endequation %} הולכים לצאת אפס חוץ אולי מאיבר אחד ספציפי, נניח {% equation %}a_{ik}{% endequation %}, ואז נקבל {% equation %}\left|A\right|=\left(-1\right)^{i+k}a_{ik}\left|A^{ik}\right|{% endequation %}. אני עדיין צריך לחשב רקורסיבית את הדטרמיננטה של {% equation %}A^{ik}{% endequation %}, אבל זו רק מטריצה אחת, בניגוד ל-{% equation %}n{% endequation %} מטריצות שהייתי צריך לחשב להן את הדטרמיננטה במקרה הכללי. יותר מזה - אנחנו רואים פה שאם יש במטריצה שורת אפסים, אז הדטרמיננטה שלה יוצאת אפס ואפשר לסיים את החישוב (ואותו דבר עבור טור של אפסים).

זה מאפשר לי לחשב ביעילות את הדטרמיננטה של מטריצות נחמדות, שבהן בכל שורה יש רק איבר אחד שונה מאפס. הדוגמא הקלאסית למטריצה כזו היא <strong>מטריצה אלכסונית</strong>, מטריצה שבה רק האיברים מהצורה {% equation %}a_{ii}{% endequation %} (שנקראים "אברי האלכסון הראשי") יכולים להיות שונים מאפס וכל היתר הם אפס. למשל

{% equation %}A=\left[\begin{array}{ccc} 13 & 0 & 0\\ 0 & -2 & 0\\ 0 & 0 & 8 \end{array}\right]{% endequation %}

אם נתחיל לפתח את הדטרמיננטה של {% equation %}A{% endequation %} על פי השורה הראשונה, נקבל

{% equation %}\left|A\right|=13\cdot\left|\begin{array}{cc} -2 & 0\\ 0 & 8 \end{array}\right|{% endequation %}

עכשיו את הדטרמיננטה של המטריצה החדשה אני יכול לחשב באותו אופן - פיתוח על פי השורה הראשונה, שהוא פשוט כפל במספר שכתוב בשורה הראשונה כפול הדטרמיננטה של מה שנשאר מהמטריצה כש"מגלחים" ממנה את השורה והעמודה הראשונה, וכן הלאה. אני אקבל {% equation %}\left|A\right|=13\cdot\left(-2\right)\cdot8{% endequation %}: הדטרמיננטה של מטריצה אלכסונית היא מכפלת האיברים על האלכסון.

אם זה ברור, בואו נשים לב שבעצם ראיתי כאן יותר מזה. כשאני מפתח את הדטרמיננטה על פי השורה הראשונה, האיבר היחיד שרלוונטי הוא ה-13 שבמקום הראשון. עבורו, אני "מגלח" גם את העמודה הראשונה מהמטריצה. זו הסיבה שאברי העמודה הזו לא משתתפים בהמשך החישוב - שהסירו אותם בצורה הזו. לא שהם אפסים. החישוב היה ממשיך באותו אופן בדיוק גם אם הם לא היו אפסים. כלומר, אם המטריצה הייתה

{% equation %}A=\left[\begin{array}{ccc} 13 & 0 & 0\\ 42 & -2 & 0\\ 555 & 0 & 8 \end{array}\right]{% endequation %}

הדטרמיננטה שלה בכלל לא הייתה משתנה - הפיתוח לפי השורה הראשונה היה מניב {% equation %}\left|A\right|=13\cdot\left|\begin{array}{cc} -2 & 0\\ 0 & 8 \end{array}\right|{% endequation %} באותה צורה כמו קודם. זה נכון שהפיתוח לפי <strong>העמודה</strong> הראשונה היה עכשיו מתנהל שונה לגמרי, אבל הוא היה מגיע לאותה תוצאה סופית (נסו!)

באופן דומה גם בעמודה השניה יכולים להופיע איברים שונים מאפס - אבל רק <strong>מתחת</strong> ל-{% equation %}-2{% endequation %} שבאמצע, כי איברים מעליו ישפיעו על שורות שמופיעות בחישוב של הדטרמיננטה לפני שהעמודה של {% equation %}-2{% endequation %} נמחקת. כלומר, גם הדטרמיננטה של המטריצה הזו היא מכפלת אברי האלכסון:

{% equation %}A=\left[\begin{array}{ccc} 13 & 0 & 0\\ 42 & -2 & 0\\ 555 & 9999 & 8 \end{array}\right]{% endequation %}

התוצאה הזו מראה שמטריצות שבהן "החצי העליון" של המטריצה, מעל האלכסון הראשי, הוא אפסים הן מטריצות מעניינות. למטריצות כאלו קוראים "מטריצה משולשית תחתונה" (תחתונה, כי האיזור שבו כן יכולים להיות דברים שונים מאפס הוא זה שמתחת לאלכסון הראשי). פורמלית, זו מטריצה שבה אם {% equation %}j>i{% endequation %} אז {% equation %}a_{ij}=0{% endequation %} (אם מספר העמודה גדול ממספר השורה, הכניסה היא אפס). מה שראינו עכשיו הוא שבמטריצות כאלו, הדטרמיננטה היא מכפלת אברי האלכסון הראשי. באופן דומה מגדירים גם "מטריצה משולשית עליונה" שבה אם {% equation %}i>j{% endequation %} אז {% equation %}a_{ij}=0{% endequation %} ופיתוח הדטרמיננטה לפי עמודות ולא לפי שורות מראה שגם במקרה הזה הדטרמיננטה של מטריצה כזו היא מכפלת אברי האלכסון הראשי. 

זה יפה מאוד, אבל איך זה עוזר לנו לחשב דטרמיננטה במקרה הכללי? כאן מגיע הפאנץ' הנחמד: יש כמה פעולות פשוטות שאפשר לבצע על מטריצה שהופכות אותה למטריצה משולשית, והשינויים שהפעולות הללו עושים לדטרמיננטה הם זניחים עד לא קיימים. זה מתקשר לנושא של <a href="https://gadial.net/2011/10/05/matrix_row_reducing/">דירוג מטריצות</a> אבל אני לא אצטרך לדבר על הנושא הזה בצורה הכללית שלו, אז נתמקד במה שעוזר לנו כאן.

בשביל חישוב דטרמיננטה, מספיקים לנו שתי פעולות שאפשר לבצע על מטריצה:

<ul> <li>להחליף שתי שורות במטריצה</li>


<li>לקחת שורה אחת, לכפול אותה במספר כלשהו, ולחבר לשורה אחרת</li>

</ul>

בואו נדגים את זה. הנה מטריצה:

{% equation %}A=\left[\begin{array}{ccc} 2 & 8 & 3\\ 4 & 9 & 1\\ 3 & 3 & 3 \end{array}\right]{% endequation %}

אם אני אחליף את השורה השניה והשלישית, אני אקבל

{% equation %}A=\left[\begin{array}{ccc} 2 & 8 & 3\\ 3 & 3 & 3\\ 4 & 9 & 1 \end{array}\right]{% endequation %}

האם הפעולה הזו תשנה את הדטרמיננטה של המטריצה? כן! אבל בצורה פשוטה: הדטרמיננטה תוכפל ב-{% equation %}-1{% endequation %}, וזה יקרה תמיד, לא משנה אילו שתי שורות נחליף. אולי יהיה יותר קל לראות את זה קורה אם נתחיל עם מטריצה אלכסונית פשוטה:

{% equation %}B=\left[\begin{array}{ccc} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 0 & 1 \end{array}\right]{% endequation %}

בבירור {% equation %}\left|B\right|=1{% endequation %} כי זו מכפלת אברי האלכסון. עכשיו, בואו נחליף את השורה השניה בשלישית ונקבל

{% equation %}B=\left[\begin{array}{ccc} 1 & 0 & 0\\ 0 & 0 & 1\\ 0 & 1 & 0 \end{array}\right]{% endequation %}

עכשיו זו כבר לא מטריצה משולשית אז מכפלת אברי האלכסון לא תיתן לנו את הדטרמיננטה, אבל עדיין אפשר לפתח אותה על פי הכללים הרגילים, שורה-שורה, ונקבל

{% equation %}\left|B\right|=1\cdot\left|\begin{array}{cc} 0 & 1\\ 1 & 0 \end{array}\right|=1\cdot\left(-1\right)=-1{% endequation %}

זה גם מה שיקרה במקרה הכללי אם ניקח מטריצה שכולה 1-ים על האלכסון הראשי ונחליף שתי שורות: אם נפתח את הדטרמיננטה וראשית כל נפתח אותה לפי השורות שלא השתנו, נקבל מכל שורה כזו 1, וכולם יוכפלו בסוף ב-{% equation %}\left|\begin{array}{cc} 0 & 1\\ 1 & 0 \end{array}\right|{% endequation %}, שזו הדטרמיננטה של מה שיישאר משתי השורות שכן הוחלפו, אחרי שכל יתר העמודות נקצצו מהמטריצה. כלומר (בנפנוף ידיים) לכל החלפת שורות, נקבל שהדטרמיננטה של המטריצה היא {% equation %}-1{% endequation %}.

עכשיו מגיע הקסם, ואיך שאני אוהב את הקסם הזה! אם ניקח את {% equation %}B{% endequation %} שלאחר ההחלפה ונכפול אותה ב-{% equation %}A{% endequation %} המקורית, נקבל:

{% equation %}\left[\begin{array}{ccc} 1 & 0 & 0\\ 0 & 0 & 1\\ 0 & 1 & 0 \end{array}\right]\left[\begin{array}{ccc} 2 & 8 & 3\\ 4 & 9 & 1\\ 3 & 3 & 3 \end{array}\right]=\left[\begin{array}{ccc} 2 & 8 & 3\\ 3 & 3 & 3\\ 4 & 9 & 1 \end{array}\right]{% endequation %}

מה קרה פה? הכפל במטריצה {% equation %}B{% endequation %} אחרי החלפת השורה היה בעל אפקט של ביצוע החלפת שורה על {% equation %}A{% endequation %}! כלומר, הצלחנו לתאר את הפעולה "החלפת שורה" בתור "כפל במטריצה כלשהי". עכשיו, בגלל שאני יודע ש-{% equation %}\left|BA\right|=\left|B\right|\left|A\right|{% endequation %} ובגלל ש-{% equation %}\left|B\right|=-1{% endequation %} כפי שזה עתה ראינו, אני מקבל שהדטרמיננטה של {% equation %}A{% endequation %} אחרי החלפת שורות - וזה יעבוד <strong>לכל</strong> פעולה בודדת של החלפת שורות - הוא כפל ב-{% equation %}-1{% endequation %}, כמו שהבטחתי.

האם אפשר לעשות את אותו תעלול גם עבור הפעולה המסובכת יותר, "לקחת שורה אחת, לכפול אותה במספר כלשהו, ולחבר לשורה אחרת"? ובכן, בואו ננסה דוגמא. נלך אל {% equation %}B{% endequation %} המקורית, נכפול את השורה הראשונה ב-{% equation %}-2{% endequation %} ונחבר אותה אל השורה השניה. שימו לב שאני <strong>לא</strong> משנה את השורה הראשונה; ההכפלה שלה במשהו היא רק לצורך חיבור עם השורה האחרת (יש גם פעולה של הכפלה של שורה, אבל אני לא צריך אותה פה; אותו הטריק עם {% equation %}B{% endequation %} יעבוד גם עבור הפעולה הזו ויראה שכפל שורה ב-{% equation %}\lambda{% endequation %} מכפיל את הדטרמיננטה ב-{% equation %}\lambda{% endequation %}). נקבל:

{% equation %}B=\left[\begin{array}{ccc} 1 & 0 & 0\\ -2 & 1 & 0\\ 0 & 0 & 1 \end{array}\right]{% endequation %}

מה הדטרמיננטה של {% equation %}B{% endequation %} החדשה? ובכן... אה... זה קצת מוזר. השינוי השפיע רק מתחת לאלכסון, לא מעליו, אז עדיין יש לי מטריצה משולשית, ולכן הדטרמיננטה היא עדיין רק מכפלת אברי האלכסון ולכן היא 1, כלומר היא... לא השתנתה בכלל? משהו פה לא מסתדר לי. אולי אם ניקח את השורה השניה ונוסיף אותה לשלישית? לא, גם אז זה יוצא מטריצה משולשית... ואם נוסיף את השלישית לשניה? אז מתקבלת מטריצה משולשית עליונה ולא תחתונה, אבל הדטרמיננטה היא עדיין 1... ובכן... ממש מוזר אבל נראה שלא משנה איך נבצע אותה, הפעולה "לקחת שורה אחת, לכפול אותה במספר כלשהו, ולחבר לשורה אחרת" פשוט <strong>לא משנה </strong>את הדטרמיננטה של {% equation %}B{% endequation %}.

בואו ניקח את {% equation %}B{% endequation %} שחישבתי קודם, זו שבה חיסרתי את פעמיים השורה הראשונה מהשניה, ונכפול אותה ב-{% equation %}A{% endequation %} המקורית. נקבל:

{% equation %}\left[\begin{array}{ccc} 1 & 0 & 0\\ -2 & 1 & 0\\ 0 & 0 & 1 \end{array}\right]\left[\begin{array}{ccc} 2 & 8 & 3\\ 4 & 9 & 1\\ 3 & 3 & 3 \end{array}\right]=\left[\begin{array}{ccc} 2 & 8 & 3\\ 0 & -7 & -5\\ 3 & 3 & 3 \end{array}\right]{% endequation %}

כלומר הטריק עבד שוב: ההכפלה ב-{% equation %}B{% endequation %} הייתה בדיוק בעלת האפקט של "קח את השורה הראשונה של {% equation %}A{% endequation %}, כפול במינוס 2, חבר לשורה השניה" ולכן הטריק של הדטרמיננטה של המכפלה מספר לנו שבמקרה הזה, גם הדטרמיננטה של {% equation %}A{% endequation %} לא תשתנה. זה נכון באופן כללי: הפעולה "קח שורה כלשהי, והוסף אותה כשהיא מוכפלת בסקלר לאחת השורות האחרות" <strong>לא משנה את הדטרמיננטה</strong>. אף פעם.

אבל עכשיו בואו ותראו מה קרה. מהמטריצה {% equation %}A{% endequation %} המסובכת קיבלתי גרסה חדשה של {% equation %}A{% endequation %}, עם אותה דטרמיננטה, אבל שנראית יותר פשוטה: יש בה 0 באחד המקומות. זה לא קרה בטעות: אני הסתכלתי על {% equation %}A{% endequation %}, ראיתי שבעמודה הראשונה, יש בשורה הראשונה 2 ובשורה השניה 4 ושאלתי את עצמי "במה אני צריך לכפול את 2 כדי שאחרי שאחבר אותו אל 4 אקבל 0?" וזה היה בדיוק {% equation %}-2{% endequation %} אז זה מה שעשיתי. עכשיו נעשה את זה במקרה המלוכלך יותר, של השורה השלישית: בשורה השניה יש 2, בשלישית יש {% equation %}3{% endequation %}, אז אני צריך לכפול ב-{% equation %}-\frac{3}{2}{% endequation %}. זה אולי יגרום לכל המספרים שמופיעים בשורה השלישית במטריצה להיות שברים מעיקים, אבל לא אכפת לי! אני אעשה את זה! הנה!

{% equation %}\left[\begin{array}{ccc} 2 & 8 & 3\\ 0 & -7 & -5\\ 0 & -9 & -\frac{3}{2} \end{array}\right]{% endequation %}

עכשיו אנחנו מאוד קרובים למטריצה משולשית - רק ה-{% equation %}-9{% endequation %} בשורה השלישית מפריע לנו. אני יכול להעלים אותו על ידי כפל השורה השניה ב-{% equation %}-\frac{9}{7}{% endequation %} וחיבור שלה לשלישית, ואני אקבל

{% equation %}\left[\begin{array}{ccc} 2 & 8 & 3\\ 0 & -7 & -5\\ 0 & 0 & \frac{69}{14} \end{array}\right]{% endequation %}

קיבלתי על האלכסון את המספר {% equation %}\frac{69}{14}{% endequation %}. זה לא נראה טוב. זה נראה כמו שבר משובר. זה בעצם העונש שלי על שתי פעולות של איפוס איברים שעשיתי "בכוח", על ידי זה שהיה לי {% equation %}a{% endequation %} בכניסה אחת ו-{% equation %}b{% endequation %} בכניסה אחרת וכפלתי ב-{% equation %}-\frac{b}{a}{% endequation %} וחיברתי, בלי שיהיה איזה צמצום נחמד שמערב את {% equation %}a,b{% endequation %}. זו גם בדיוק הנקודה שלי: לא צריך שדברים יסתדרו "יפה". אפשר פשוט לעשות את זה בכוח - או טוב יותר, לתת למחשב לעשות את זה. למחשב לא אכפת אם החישובים הם מכוערים, הוא פשוט יעשה את זה.

וכעת, כדי לקבל את הדטרמיננטה של המטריצה המקורית, כל מה שנשאר לעשות הוא לכפול את האיברים שעל האלכסון ולקבל ש...{% equation %}2\cdot\left(-7\right)\cdot\frac{69}{14}=-69{% endequation %}. הא. קיבלנו בסופו של דבר דטרמיננטה שהיא לא שבר אלא מספר שלם נחמד. זה לא באמת מפתיע, אם חושבים על זה - בהגדרה שנתתי לדטרמיננטה (וגם בהגדרות התיאורטיות יותר) לא מעורב חילוק - יש לנו סכומים של מכפלות של האיברים שבתוך המטריצה, כך שאם כולם היו מספרים שלמים, גם הדטרמיננטה תצא מספר שלם.

מכאן מגיעה בעצם המוטביציה העכשווית שלי לפוסט הזה ופוסט ההמשך; מבלי להיכנס לפרטים (שיגיעו בפוסט הבא), הגעתי לסיטואציה שבה אני באמת נזקק לחישוב דטרמיננטה של מטריצה; מטריצה {% equation %}6\times6{% endequation %} עם ערכים שהם מספרים שלמים, אבל גדולים למדי (נאמר, בני 15 ספרות). הדבר הראשון שעשיתי היה להשתמש בספריה של פייתון לחישובים מתמטיים שנקראת numpy והיא כשלה באופן מחפיר כי רמת הדיוק שלה הייתה מוגבלת והמספרים היו גדולים מדי עבורה; התוצאה שקיבלתי לא הייתה קירוב טוב של הדטרמיננטה שציפיתי לקבל אלא מספר לא קשור בעליל. מה שמייד אמרתי לעצמי הוא "אה-הא! הבעיה היא שהכנסתי שברים לתמונה! אני אחפש אלגוריתם שבמקרה של מטריצה עם איברים שלמים לא מתדרדר לסיטואציה שבה כתובים בה שברים" וחיפשתי ואפילו מצאתי אלגוריתם כזה שהוא די מרהיב לטעמי, ומימשתי אותו והכל עבד מצוין. רק מה? גם האלגוריתם הנאיבי שתיארתי בהתחלה עובד מצוין על אותה מטריצת {% equation %}6\times6{% endequation %} כי עבור מטריצות {% equation %}6\times6{% endequation %} זמן הריצה שלו הוא עדיין די סבבה. הלקח הוא תמיד לנסות קודם את הפתרון הנאיבי אלא אם רוצים להיתקל בנושאים מגניבים לפוסט (כמו כן גם גישת ה"לחלק" הייתה עובדת טוב אם הייתי משתמש בספריית פייתון שיודעת לייצר שברים ברמת דיוק אינסופית - ויש כזו ואני באמת משתמש בה מדי פעם).

בואו נחזור עכשיו לחישוב דטרמיננטה בשיטה שהצגתי. כל מה שראינו עד עכשיו היה דוגמא; בואו נבין מה עושים באופן כללי. אז נניח שיש לנו מטריצה כללית, היא נראית ככה:

{% equation %}A=\left[\begin{array}{cccc} a_{11} & a_{12} & \cdots & a_{1n}\\ a_{21} & a_{22} & \cdots & a_{2n}\\ \vdots & \vdots & \ddots & \vdots\\ a_{n1} & a_{n2} & \cdots & a_{nn} \end{array}\right]{% endequation %}

אותי מה שמעניין כאן הוא העמודה הראשונה. היעד שלי הוא ליצור מטריצה משולשית עליונה, אז בשביל זה אני רוצה לאפס את כל הכניסות בעמודה הראשונה. את זה אני אעשה בכוח, כפי שתיארתי כבר. כדי לאפס את {% equation %}a_{21}{% endequation %} אני מחבר לשורה השניה את הראשונה כשהיא מוכפלת ב-{% equation %}-\frac{a_{21}}{a_{11}}{% endequation %}, בשביל השלישית אני מכפיל ב-{% equation %}-\frac{a_{31}}{a_{11}}{% endequation %} וכן הלאה. אני אקבל:

{% equation %}A=\left[\begin{array}{cccc} a_{11} & a_{12} & \cdots & a_{1n}\\ 0 & \frac{a_{22}a_{11}-a_{21}a_{12}}{a_{11}} & \cdots & \frac{a_{2n}a_{11}-a_{21}a_{1n}}{a_{11}}\\ \vdots & \vdots & \ddots & \vdots\\ 0 & \frac{a_{n2}a_{11}-a_{n1}a_{12}}{a_{11}} & \cdots & \frac{a_{nn}a_{11}-a_{n1}a_{1n}}{a_{11}} \end{array}\right]{% endequation %}

החל מהנקודה הזו, העמודה והשורה הראשונות לא מעניינות אותי יותר. הרי אם אני אתחיל לפתח את הדטרמיננטה על פי העמודה הראשונה, אני אקבל שהיא שווה ל-{% equation %}a_{11}{% endequation %} כפול הדטרמיננטה של מה שמתקבל ממחיקת השורה והעמודה הראשונה. אז נמחק אותן ונטפל ביתר המטריצה על פי אותו עיקרון, עד שנסיים לטפל בכל העמודות. אם כן, האם סיימנו? לא, בגלל שהתעלמתי מבעיה אחת שיכולה לצוץ: מה אם {% equation %}a_{11}=0{% endequation %}?

במקרה הזה, יש שתי אפשרויות: או ש<strong>כל</strong> האיברים בעמודה הראשונה הם אפס, ובמקרה הזה הדטרמיננטה של המטריצה היא אפס; או שיש איבר כלשהו ששונה מאפס. במקרה השני, <strong>נחליף</strong> את השורה של האיבר הזה עם השורה הראשונה הנוכחית, ונזכור שזה "עלה לנו" בהכפלת הדטרמיננטה הכוללת ב-{% equation %}-1{% endequation %} (ואם נחליף עוד שורות בהמשך זה עשוי לבטל את זה).

האם האלגוריתם הזה יעיל? בהחלט. כדי לחשב דטרמיננטה של מטריצה מסדר {% equation %}n\times n{% endequation %} אנחנו צריכים לבצע בערך {% equation %}n^{2}{% endequation %} פעולות חשבוניות, ואחריהן לחשב דטרמיננטה של מטריצה <strong>אחת</strong> מסדר {% equation %}\left(n-1\right)\times\left(n-1\right){% endequation %}, כלומר אם אנחנו מחפשים הערכה גסה לזמן הריצה היא תהיה {% equation %}n^{2}+\left(n-1\right)^{2}+\ldots+1^{2}{% endequation %} וזה בערך מסדר גודל של {% equation %}n^{3}{% endequation %} - משמעותית יותר טוב מזמן ריצה אקספוננציאלי (אבל זה <strong>עדיין</strong> זמן ריצה בעייתי עבור מטריצות ענק, ולכן יש כאן פתח לעולם שלם של אופטימיזציות שאני לא אדבר עליו).

כשאני בא לממש את הדבר הזה בפועל, אני לא אטרח לממש רקורסיה כי זה סתם בזבזני (קריאה לפונקציה תמיד דורשת אקסטרה זמן ומשאבים), את כל השינויים אפשר לבצע כבר ברמת המטריצה המקורית. הנה קוד שעושה את העבודה:

{% highlight python %}
def det(A):
    result = 1
    n = len(A)
    # go over all columns k=0,1,...,n-1
    for k in range(n):
        if A[k][k] == 0:
            for i in range(k+1, n):
                if A[i][k] != 0:
                    A[k], A[i] = A[i], A[k]
                    result *= -1
                    break
            else:
                return 0
        # go over all rows i=k+1,k+2,...,n-1
        result *= A[k][k]
        for i in range(k+1, n):
            factor = A[i][k] / A[k][k]
            # go over all the nonzero elements in row i
            for j in range(k, n):
                A[i][j] -= factor * A[k][j]
    return result
{% endhighlight %}

אז זו הדרך הרגילה לחישוב דטרמיננטות; בפוסט הבא נראה משהו קצת שונה. 