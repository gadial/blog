---
title: "מספרי קטלן"
layout: post
categories:
  - קומבינטוריקה
tags:
  - מספרי קטלן
---


<h2>מבוא</h2>

אם אני אלך ברחוב ואשאל באקראי אנשים איזו סדרה מתמטית הם מכירים, אחרי שנקלף את שכבות האלו שיבהלו ויברחו או יתחכמו ויגידו ש-Numb3rs (אף אחד לא יגיד, העולם כבר שכח שהייתה סדרה כזו וגם לי לא יצא לראות אותה) כנראה אקבל שלל תשובות: "סדרת פיבונאצ'י", "סדרת פיבונאצ'י!", "פיבונאצ'י", "הטבעיים" (חכמולוג, לסנן) ו"פיבונאצ'י". ובכן, סדרת פיבונאצ'י כבודה במקומו מונח, יש עוד סדרות מעניינות בעולם ואני רוצה לדבר בפוסט הזה על אחת אהובה במיוחד - סדרת מספרי קטלן (Catalan, על שם המתמטיקאי הבלגי אז'ן שרל קטלן). זו הסדרה הבאה:

{% equation %}1,1,2,5,14,42,132,429,1430,4862,\ldots{% endequation %}

מה שמעניין בה הוא שהיא הפתרון של שלל בעיות קומבינטורית שונות ומשונות. המתמטיקאי ריצ'רד סטנלי (שכתב את הספר הפנטסטי Enumerative Combinatorics) התמחה בלאסוף בעיות שונות ומשונות שמספרי קטלן הם הפתרון שלהן, ובסופו של דבר פרסם ספר עם 214 בעיות כאלו. מן הסתם אני לא אכסה כמעט כלום מזה הפעם; אבל אני רוצה בפוסט הזה שנכיר את התכונות הבסיסיות של המספרים הללו (שאנחנו מבינים די טוב) ונראה שלל בעיות שונות ומשונות ולכאורה לא קשורות שהם פותרים.

היסטורית, האדם הראשון שיש לנו אינדיקציה שנתקל במספרי קטלן הוא המתמטיקאי המונגולי Minggatu, בספר על חישוב קירובים שכתב בסביבות 1730 שבו מספרי קטלן הופיעו בתוך חלק מהנוסחאות; זה פחות רלוונטי לנו כאן כי זה לא שימוש במספרי קטלן לפתרון בעיה קומבינטורית. מכאן אנחנו קופצים ל-1751, כשלאונרד אוילר (מהמתמטיקאים הפורים בהיסטוריה שנראה שהתעסק פשוט בכל דבר) תיאר אותם במכתב לשותפו המתמטי כריסטיאן גולדבך, בתור הפתרון של בעיה קומבינטורית ספציפית - אז בואו נתחיל מלדבר על הבעיה הזו למרות שהיא אולי לא הכי פשוטה מבין אלו שאפשר לפתוח בהן.

<h2>שילושים של מצולע</h2>

במקרה הזה תמונה אחת שווה אלף מילים, ואני מתנצל בפני מי שלא יכולים לראות אותה (ואת כל יתר האיורים שהפוסט הזה יהיה עמוס בהם):

<img src="{{site.baseurl}}{{site.post_images}}/2025/catalan_triangulations.svg" alt=""/>


מה רואים פה? אני מצייר משושה משוכלל (כלומר מצולע עם שש צלעות שאורכי כל הצלעות שלו שווים וכל הזוויות שלו שוות) ובתוך המשושה אני מותח קווים בין חלק מהקודקודים, בצורה כזו שאין שני קווים שחוצים אחד את השני, ואני מותח מספיק קווים כדי לחלק את המצולע למשולשים. דבר כזה נקרא "שילוש". בימינו אנו שילושים הם דבר מאוד מעניין, למשל בגרפיקה תלת ממדית, אבל כבר בימי אוילר זה היה מספיק מעניין כדי לנסות להבין איך נראים השילושים האפשריים השונים של מצולע - ובפרט, כמה כאלו יש. מה שאנחנו רואים בתמונה הוא את כל 14 השילושים האפשריים של משושה משוכלל. חלק מהשילושים נראים דומים אחד לשני - כאילו אפשר לסובב או לשקף אחד ולקבל את האחר. מה שמעניין אותנו כאן הוא לספור אותם בתור שילושים שונים - כלומר, אפשר לחשוב על זה כאילו מספרנו את הקודקודים של המצולע, ואנחנו מסתכלים על רשימה של שלשות שמציינות קודקודים. הנה דוגמא:

<img src="{{site.baseurl}}{{site.post_images}}/2025/catalan_triangulation_numbered.svg" alt=""/>

כאן מספרתי את הקודקודים מ-1 עד 6 בכיוון השעון החל מהקודקוד העליון השמאלי, והמשולשים שלי הם {% equation %}\left\{ 1,5,6\right\} ,\left\{ 1,2,5\right\} ,\left\{ 2,4,5\right\} ,\left\{ 2,3,4\right\} {% endequation %}.

האם יש דרך מסודרת "לייצר" שילושים? למרבה השמחה, כן - דרך <strong>רקורסיבית</strong>. כלומר, אם אנחנו כבר יודעים למצוא שילושים למצולעים פשוטים, אנחנו יכולים לנצל את זה כדי למצוא שילושים למצולעים מורכבים יותר. מה המצולעים הפשוטים ביותר? ובכן, כמובן שמשולש הוא די פשוט - אם יש לנו משולש, ה"שילוש" שלו זה בסך הכל הוא עצמו. שימו לב שזה לא צריך להיות משולש משוכלל ("משולש שווה צלעות") - זה נכון לכל משולש.

אבל חוץ ממשולש, תכף נראה שישתלם לנו לדבר על מצולע אפילו עוד יותר פשוט - מצולע בן <strong>שני קודקודים</strong>. מה זה הדבר הזה? זה בסך הכל קו ישר אחד; אפשר להתלונן ולומר שזה לא <strong>באמת</strong> מצולע, אבל זה לא משנה - כאמור, זה הולך להשתלם לנו לחשוב עליו כמצולע עוד מעט.

בואו ננסה למצוא שילוש למשושה המשוכלל. אני מתחיל עם השאלה - מה קורה עם הצלע 1-2? אני יודע שבסופו של דבר היא תהיה חלק ממשולש שכל הקודקודים שלו שייכים למצולע המקורי, כלומר משולש ששניים מהקודקודים שלו הם 1 ו-2 ואני חופשי לבחור את הקודקוד הנוסף - כל בחירה שונה תניב בסופו של דבר שילושים שונים. בואו נאמר שבחרתי את 5, אז אני מותח קווים אליו מ-1 ו-2, ומקבל:

<img src="{{site.baseurl}}{{site.post_images}}/2025/catalan_triangulation_initial.svg" alt=""/>

עכשיו מגיע הצעד הרקורסיבי: קונספטואלית, אפשר לחשוב על זה כאילו אני <strong>מוחק</strong> את הצלע 1-2 מהמשושה ומקבל:

<img src="{{site.baseurl}}{{site.post_images}}/2025/catalan_triangulation_erase.svg" alt=""/>

מה שקיבלתי פה הוא שפירקתי את המשושה המקורי לשני מצולעים שונים: המצולע 1-5-6 והמצולע 2-3-4-5. שני המצולעים חולקים קודקוד משותף אחד, את 5 - הקודקוד שבחרתי. בנוסף, יש להם פחות צלעות: לאחד יש 3 ולשני 4 (שימו לב שמספר הצלעות הכולל שלהם הוא כמספר הצלעות במצולע שהתחלנו ממנו, ועוד 1 - זה בגלל שמחקנו את 1-2 אבל הוספנו את 1-5 ואת 2-5). אם יש להם פחות צלעות, אני יכול רקורסיבית לשלש אותם... רגע, שניה, הרי 2-3-4-5 הוא אמנם מצולע, אבל הוא לא מצולע משוכלל, הוא נראה כמו מין טרפז שכזה. למה שאוכל לשלש אותו?

בואו נחשוב שניה - מה אנחנו צריכים כדי שנוכל לשלש צורה? ראינו שכל משולש הוא בר-שילוש, אבל מה קורה בצורה מורכבת יותר? במשושה שלנו הייתה לי הנחה סמויה - שאני באמת יכול להעביר קווים מ-1 ו-2 אל 5. לא הייתה לי בעיה לעשות את זה כי משושה משוכלל הוא צורה <strong>קמורה</strong> - כלומר, צורה שבה כל קו בין שתי נקודות ששייכות לצורה עובר כולו בתוך הצורה. זו ההנחה שאני זקוק לה - כלומר, מה שאני סופר הוא כמה שילושים יש למצולע קמור כלשהו, ויוצא שזה לא באמת תלוי בצורה של המצולע אלא רק במספר הקודקודים שלו.

בואו נכנס סימון לעניין: נסמן ב-{% equation %}T_{n}{% endequation %} את מספר השילושים של מצולע קמור עם {% equation %}n{% endequation %} קודקודים. הספירה שלנו מתחילה מ-2, ואז אמרנו שאני בוחר בצורה שנראית קצת שרירותית להגדיר {% equation %}T_{2}=1{% endequation %}. בנוסף {% equation %}T_{3}=1{% endequation %} כי למשולש יש שילוש יחיד. ומה קורה עבור {% equation %}n{% endequation %} גדולים יותר? אני אעשה את הטריק שכבר ראינו: אסתכל על הקודקודים 1,2 במצולע בן {% equation %}n{% endequation %} הצלעות שלי, ואשאל את עצמי מי הקודקוד הנוסף שמתחבר אליהם. נסמן את הקודקוד הזה ב-{% equation %}k{% endequation %} ({% equation %}3\le k\le n{% endequation %}). אחרי שנחבר את 1,2 אליו ונסיר את הקשת 1-2 נקבל שני מצולעים עם פחות צלעות. כמה צלעות? ובכן, בואו נסתכל על הדוגמא למעלה - שם בחרתי {% equation %}k=5{% endequation %}, מה שאמר שהמצולע הראשון שקיבלנו כלל את הקודקודים {% equation %}2,3,4,5{% endequation %} והמצולע השני את {% equation %}5,6,1{% endequation %}. זה מה שקורה באופן כללי - המצולעים שלנו יהיו בעלי קבוצות הקודקודים

{% equation %}\left\{ 2,3,\ldots,k\right\} ,\left\{ k,k+1,\ldots,n,1\right\} {% endequation %}

בקבוצה הראשונה יש {% equation %}k-1{% endequation %} קודקודים ובשתיהן יחד יש {% equation %}n+1{% endequation %} קודקודים (כי {% equation %}k{% endequation %} מופיע פעמיים) ולכן בקבוצה השניה יש {% equation %}\left(n+1\right)-\left(k-1\right){% endequation %} קודקודים. זה אומר שמספר השילושים האפשרי של המצולע הראשון הוא {% equation %}T_{k-1}{% endequation %} ושל השני הוא {% equation %}T_{\left(n+1\right)-\left(k-1\right)}{% endequation %}. עכשיו נשתמש <strong>בקומבינטוריקה</strong>: כל שילוש של המצולע המקורי שלנו מתקבל מבחירה של שילוש אחד של המצולע הראשון ושילוש אחד של המצולע השני, ושתי הבחירות הללו הן בלתי תלויות זו בזו (כלומר, <strong>לכל</strong> שילוש של המצולע הראשון אפשר לבחור <strong>כל</strong> שילוש של המצולע השני ונקבל שילוש שונה של המצולע המקורי) ולכן מספר האפשרויות הכולל הוא <strong>מכפלה</strong> של מספר האפשרויות הראשון ומספר האפשרויות השני - זה מה שנקרא בקומבינטוריקה <strong>עקרון הכפל</strong>. בסך הכל יש {% equation %}T_{k-1}\cdot T_{\left(n+1\right)-\left(k-1\right)}{% endequation %} אפשרויות.

עכשיו, זה היה מספר האפשרויות אם המשולש שאני בונה עם 1,2 כולל גם את {% equation %}k{% endequation %}. עבור בחירות שונות של {% equation %}k{% endequation %} אני אקבל שילושים שונים. האם אותו ניתוח יעבוד בכולן? נראה שכן, אבל כדי לוודא בואו נסתכל על המקרה הקיצוני - נאמר, כשבוחרים את הקודקוד {% equation %}k=6{% endequation %}:
<img src="{{site.baseurl}}{{site.post_images}}/2025/catalan_triangulation_trivial_case.svg" alt=""/>

למה זה המקרה הקיצוני? כי אם עכשיו אני מסיר את הצלע 1-2 אני מקבל "מצולע" בעל שני קודקודים, {% equation %}\left\{ 1,6\right\} {% endequation %}:

<img src="{{site.baseurl}}{{site.post_images}}/2025/catalan_triangulation_trivial_case_erase.svg" alt=""/>

אבל זו בדיוק הסיבה שבגללה אמרתי קודם שנוח לי לחשוב גם על המקרה הזה בתור מצולע, עם שילוש יחיד. למי שהגישה הזו מפריעה לו אפשר לנסח עוד דרכים לחשוב על זה - למשל, שאנחנו פשוט גוזרים את כל המשולש 1-2-6 מהמצולע ונשארנו רק עם מצולע יחיד להתמודד איתו. זה לא באמת משנה - השורה התחתונה היא שאני מקבל {% equation %}T_{k-1}\cdot T_{\left(n+1\right)-\left(k-1\right)}{% endequation %} אפשרויות תמיד, לכל {% equation %}k{% endequation %}, כולל מקרי הקיצון של {% equation %}k=3{% endequation %} ו-{% equation %}k=n{% endequation %}.

אם כך, אפשר לחשוב על בניית שילוש של מצולע בתור תהליך שבו אנחנו בוחרים {% equation %}k{% endequation %}, ועבור ה-{% equation %}k{% endequation %} שבחרנו יש לנו {% equation %}T_{k-1}\cdot T_{\left(n+1\right)-\left(k-1\right)}{% endequation %} אפשרויות לבנות שילוש. כאן זה לא תהליך דו-שלבי אלא סיטואציה של "או זה, או זה, או זה". במקרה הזה <strong>עקרון החיבור</strong> בקומבינטוריקה אומר שאנחנו צריכים לחבר את מספר האפשרויות בכל אחד מהמקרים. אצלנו {% equation %}3\le k\le n{% endequation %} ולכן בסך הכל קיבלנו את הנוסחה

{% equation %}T_{n}=\sum_{k=3}^{n}T_{k-1}T_{\left(n+1\right)-\left(k-1\right)}{% endequation %}

מה שאני אוהב בנוסחה הזו הוא שברור לנו איך היא התקבלה. הבעיה היא שהיא לא יפה במיוחד - יש קטסטרופה שלמה עם האינדקסים שם. אז המתמטיקאים אומרים - היי, בעצם, סדרת ה-{% equation %}T{% endequation %}-ים הזו "מבזבזת" את שני האינדקסים הראשונים של, {% equation %}T_{0},T_{1}{% endequation %} שבכלל לא מוגדרים. בואו נשנה סימון ונתחיל עם סדרה שכן מתחילה מאפס. נסמן ב-{% equation %}C{% endequation %} את האיברים שלה, כלומר {% equation %}C_{0}=T_{2}{% endequation %} ו-{% equation %}C_{1}=T_{3}{% endequation %} וכדומה - באופן כללי, {% equation %}C_{n}=T_{n+2}{% endequation %}. אז נוסחת הנסיגה תהפוך להיות:

{% equation %}C_{n}=T_{n+2}=\sum_{k=3}^{n+2}T_{k-1}T_{\left(n+3\right)-\left(k-1\right)}=\sum_{k=3}^{n+2}C_{k-3}C_{\left(n+1\right)-\left(k-1\right)}={% endequation %}

{% equation %}=\sum_{i=0}^{n-1}C_{i}C_{n+1-\left(i+2\right)}=\sum_{i=0}^{n-1}C_{i}C_{n-1-i}{% endequation %}

כאן השתמשתי בשינוי האינדקס {% equation %}i=k-3{% endequation %} כדי לפשט עוד יותר, ויש כאלו שכדאי שהנוסחה תהיה עוד יותר פשוטה מעדיפים להציג אותה ככה, עם {% equation %}C_{n+1}{% endequation %} במקום {% equation %}C_{n}{% endequation %}:

{% equation %}C_{n+1}=\sum_{i=0}^{n}C_{i}C_{n-i}{% endequation %}

זו נוסחת הנסיגה המהותית שמגדירה את מספרי קטלן, והיא מה שאוילר מצא (והסיק ממנה את מה שנקרא <strong>הפונקציה היוצרת</strong> של הסדרה ובשיטות מפוקפקות של חשבון דיפרנציאלי ואינטגרלי הסיק ממנה את הנוסחה הסגורה של הסדרה, שנראה בהמשך). כשהיא מוצגת כך, אפשר להבין למה מספרי קטלן הם כל כך בסיסיים - הנוסחה בעצם מתארת כל סיטואציה שבה כדי לבנות אובייקט מגודל {% equation %}n+1{% endequation %} אנחנו בונים זוג אובייקטים שהגודל שלהם מסתכם אל {% equation %}n{% endequation %}, וכל זוג כזה מייצר לנו באופן ייחודי אובייקט מגודל {% equation %}n+1{% endequation %}. זה טיפה טריקי (לפחות עבורי) לראות את זה ישירות עבור שילוש של מצולעים בגלל שמצולע מ"גודל" {% equation %}n+1{% endequation %} במקרה הזה הוא מצולע עם {% equation %}n+3{% endequation %} קודקודים ובהתאם, כשאנחנו מפרקים אותו לאובייקט מגודל {% equation %}i{% endequation %} ומגודל {% equation %}n-i{% endequation %} יש לנו מצולעים עם {% equation %}i+2{% endequation %} קודקודים ו-{% equation %}n-i+2{% endequation %} קודקודים ולכן בסך הכל {% equation %}n+4{% endequation %} קודקודים שאחד מהם (קודקוד {% equation %}i{% endequation %}) נספר פעמיים ולכן הם בדיוק {% equation %}n+3{% endequation %} הקודקודים של המצולע המקורי. הצלחתן לעקוב? יופי, כי אני לא. בכל פעם שבה אני מנסה לראות את זה ככה אני מסתבך בגלל כל עניין הפלוס 2 הזה; לכן הצגתי את זה קודם עם ה-{% equation %}T{% endequation %}-ים.

למרבה המזל יש בעיות קומבינטוריות שנותנות את {% equation %}C_{n}{% endequation %} בצורה ישירה יותר.

<h2>מסלולי שריג</h2>

גם כאן, תמונה אחת עוזרת מאוד להבין מה אני בכלל רוצה. ראשית, תמונה של כל ה-14 אובייקטים מגודל 4 שאני הולך לספור:
<img src="{{site.baseurl}}{{site.post_images}}/2025/grid_walks_4.svg" alt=""/>

אוקיי, אולי זה לא לגמרי ברור. בואו נראה עוד דוגמא קונקרטית:
<img src="{{site.baseurl}}{{site.post_images}}/2025/grid_walk_basic.svg" alt=""/>

יש לנו כאן לוח משבצות, אבל אני מתעניין פחות במשבצות הפעם ויותר בקודקודים שלהן ובקווים שמחברים אותן - לרשת כזו של קודקודים וקווים במרווחים שווים קוראים <strong>שריג</strong>. עכשיו, אני נותן קואורדינטות לכל נקודות השריג כך ש-{% equation %}\left(0,0\right){% endequation %} היא הנקודה השמאלית-תחתונה ו-{% equation %}\left(7,7\right){% endequation %} היא הקואורדינטה הימנית-עליונה, ואני מסתכל על <strong>מסלול</strong> שמתחיל מ-{% equation %}\left(0,0\right){% endequation %} ומסתיים ב-{% equation %}\left(7,7\right){% endequation %}. כל צעד במסלול עובר מקודקוד אחד לאחר על הקו שמחבר ביניהם, המסלול הספציפי שלי מתחיל בצעד ימינה, ואז למעלה, ימינה, למעלה... טוב, זה כאב ראש לתאר הכל במפורש, אבל אפשר לתאר בצורה קומפקטית בתור רצף של אותיות: R מסמן צעד ימינה ו-U מסמן צעד למעלה, ואז המסלול שמתואר באיור הוא

RURURRRUURUUUR

ספירה מהירה תראה שיש במסלול הזה 14 צעדים - בדיוק 7 צעדי R ו-7 צעדי U, מה שלא כל כך מפתיע כי כדי להגיע מלמטה למעלה צריך 7 צעדים, וכך גם כדי להגיע משמאל לימין. השאלה היא רק מה יהיה הסדר הפנימי בין הצעדים הללו. עכשיו, אפשר להוסיף גם צעדים שמאלה/למטה, אבל הם רק יובילו לכך שהמסלול יהיה ארוך יותר, ואנחנו מתעניינים בשאלה כמה מסלולים קצרים ביותר יש. באופן כללי, לכל {% equation %}n{% endequation %} טבעי, אנחנו שואלים את השאלה כמה מסלולי שריג יש מ-{% equation %}\left(0,0\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %} שאורכם בדיוק {% equation %}2n{% endequation %}.

מתברר שזו שאלה <strong>קלה</strong> שאנחנו לא צריכים את מספרי קטלן עבורה, אבל כן צריך להכיר קצת קומבינטוריקה בסיסית מהסוג שתיארתי <a href="https://gadial.net/2010/06/20/combinatorics_intro/">בפוסט הזה</a>: שם דיברתי על כך שמספר האפשרויות לבחור {% equation %}k{% endequation %} מתוך {% equation %}n{% endequation %} איברים, כשאין חשיבות לסדר שבו האיברים נבחרים ואי אפשר לבחור איבר פעמיים, הוא בדיוק מה שמסומן בתור {% equation %}{n \choose k}{% endequation %} (קרי: "{% equation %}n{% endequation %} בחר {% equation %}k{% endequation %}") ושווה ל-{% equation %}{n \choose k}=\frac{n!}{k!\left(n-k\right)!}{% endequation %}. אני אניח פה שהדבר הזה מוכר.

עכשיו, אפשר לחשוב על מסלול מאורך {% equation %}2n{% endequation %} שכולל בדיוק {% equation %}n{% endequation %} צעדי U ו-{% equation %}n{% endequation %} צעדי R בתור משהו שניתן להרכיב כך: ראשית, מבין {% equation %}2n{% endequation %} הצעדים במסלול (הצעד הראשון, השני, השלישי וכו') אנחנו בוחרים בדיוק {% equation %}n{% endequation %} ומציבים בהם U, ואז בכל השאר מציבים R. זו בחירה <strong>בלי</strong> חשיבות לסדר, כי זה לא משנה אם קודם החלטתי שבצעד 1 יהיה U ואז החלטתי שבצעד 5 יהיה גם U או אם החלטתי את זה קודם עבור צעד 5 ורק אז עבור צעד 1. זו גם בחירה שבה אי אפשר לבחור איבר פעמיים, כי אני לא יכול להחליט שאני רוצה לדחוף לצעד 5 "פעמיים U". לכן מספר מסלולי השריג מאורך {% equation %}2n{% endequation %} מ-{% equation %}\left(0,0\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %} הוא בדיוק {% equation %}{2n \choose n}{% endequation %}. זה היה קל.

אז בואו נסבך קצת את הבעיה. אני הולך למתוח <strong>אלכסון</strong> בלוח שלי, ולחפש רק את המסלולים <strong>שלא מגיעים מעל האלכסון</strong>, כלומר לא מבקרים באף משבצת מהצורה {% equation %}\left(a,b\right){% endequation %} כך ש-{% equation %}a<b{% endequation %}. המסלול שציירתי קודם <strong>כמעט</strong> מקיים את זה, אבל נכשל ברגע האחרון:

<img src="{{site.baseurl}}{{site.post_images}}/2025/grid_walk_wrong.svg" alt=""/>

כדי שיהיה קל להבין מה הולך פה, האיור שלי משתמש בויזואליזציה נחמדה שראיתי במקור בויקיפדיה האנגלית: צובעים את כל המשבצות <strong>מתחת</strong> למסלול בצבע כתום, והקריטריון לכך שהמסלול תקין הוא שהאלכסון (הקו המקווקו) לא עובר בתוך אף משבצת כתומה. כמה מסלולים כאלו יש? האינטואיציה הראשונית שלי היא שחצי ממספר המסלולים הכולל, כלומר {% equation %}\frac{1}{2}{2n \choose n}{% endequation %}, כי אנחנו לוקחים רק את המסלולים ש<strong>מתחת</strong> לאלכסון ולכל מסלול כזה יש מסלול סימטרי <strong>מעל</strong> האלכסון (כזה שבו כל צעד "למעלה" מוחלף בצעד "ימינה" וכל צעד "ימינה" מוחלף בצעד "למעלה"). רק שכמובן שזה לא עובד כי רוב המסלולים הם בכלל כאלו ש<strong>חוצים</strong> את האלכסון, לא שנשארים רק מעליו או מתחתיו. אז מה עושים?

אני אתחיל מלמצוא נוסחה רקורסיבית עבור מספר המסלולים, והפלא ופלא נקבל בדיוק את הנוסחה הרקורסיבית שכבר ראינו עבור {% equation %}C_{n}{% endequation %}. אחרי זה נראה להטוט שאני מאוד אוהב שיאפשר לנו לקבל עבור {% equation %}C_{n}{% endequation %} את הנוסחה המדויקת {% equation %}C_{n}=\frac{1}{n+1}{2n \choose n}{% endequation %}. אם היקום היה מושלם, אז הלהטוט היה פשוט לראות בעיה קומבינטורית שקל באופן ישיר לראות שיש לה {% equation %}\frac{1}{n+1}{2n \choose n}{% endequation %} פתרונות, אבל את זה אני לא יודע איך עושים אז אעשה משהו קצת יותר מתוסבך, אבל לא הרבה יותר.

אז איך נראה מסלול שריג "חוקי", כזה שבשום שלב לא עובר מעל האלכסון? דבר אחד שאנחנו יודעים בודאות הוא שהצעד הראשון חייב להיות R, אחרת המסלול יגיע מעל האלכסון כבר בצעד הראשון שלו. אז בואו נתחיל את זה:
<img src="{{site.baseurl}}{{site.post_images}}/2025/grid_walk_example_1.svg" alt=""/>

אחרי הצעד הזה, המסלול לא נוגע באלכסון - הוא מתחתיו. הדבר השני שאנחנו יודעים הוא ש<strong>מתישהו</strong> המסלול הולך לגעת באלכסון - לכל המאוחר הוא יגיע אליו ממש בסוף, כשיגיע אל {% equation %}\left(n,n\right){% endequation %}, אבל הוא בהחלט יכול להגיע לשם עוד קודם ולגעת בו כמה פעמים. מה שאני הולך להסתכל עליו הוא מה שקורה למסלול עד הפעם <strong>הראשונה</strong> שבה הוא מגיע אל האלכסון. מה שברור הוא שבצעד האחרון, שבו מגיעים אל האלכסון, המסלול הולך <strong>למעלה</strong> (כי אם הוא היה הולך ימינה ומגיע אל האלכסון, זה אומר שהוא נמצא מעליו, וזה לא חוקי). אז מה קורה למסלול <strong>בין</strong> ה-R ההתחלתי וה-U האחרון הזה? אפשר לצייר <strong>עוד</strong> אלכסון, מתחת לאלכסון המרכזי שלנו, לקרוא לו "האלכסון המשני" ולראות שהמסלול שלנו בין הצעד הראשון והאחרון נמצא כולו <strong>מתחת לאלכסון המשני</strong>. פשוט כי לעלות מעל האלכסון המשני אומר להגיע ולגעת באלכסון הראשי, וזה מה שאמרתי שקורה רק בסוף. במילים אחרות - בין הצעד הראשון והאחרון יש לנו <strong>עוד</strong> משהו שמתנהג בדיוק כמו מסלול שריג חוקי, פשוט על שריג קטן יותר. בדוגמא שלי צבעתי באדום את הצעדים שמתאימים למסלול הזה והאורך שלו הוא 6 (כלומר, 3 צעדי R ו-3 צעדי U).
<img src="{{site.baseurl}}{{site.post_images}}/2025/grid_walk_example_2.svg" alt=""/>

<strong>אחרי</strong> ההגעה לאלכסון הראשי, יש לנו עוד מסלול שמתנהג כמו מסלול שריג חוקי שלא עובר מעל האלכסון, פשוט על שריג קטן יותר - המשבצות שנותרו. אצלי צבעתי אותו בכחול והאורך שלו הוא גם כן 3:

<img src="{{site.baseurl}}{{site.post_images}}/2025/grid_walk_example_3.svg" alt=""/>

זו החוקיות הכללית: כל מסלול חוקי מאורך {% equation %}2n{% endequation %} מורכב מ-R בהתחלה (שמביא את המסלול אל {% equation %}\left(1,0\right){% endequation %}), ואז מסלול חוקי מאורך {% equation %}2k{% endequation %} כלשהו (שמביא את המסלול אל {% equation %}\left(k+1,k\right){% endequation %}), ואז U (שמביא את המסלול אל {% equation %}\left(k+1,k+1\right){% endequation %}) ואז עוד מסלול חוקי (שמגיע אל {% equation %}\left(n,n\right){% endequation %}). מכיוון שהאורך הכולל של המסלולים הוא {% equation %}2n{% endequation %} ו"בזבזנו" 2 צעדים על ה-R בהתחלה וה-U בהמשך ובזבזנו עוד {% equation %}2k{% endequation %} צעדים על המסלול החוקי הראשון, אז השני יהיה מאורך {% equation %}2n-2-2k=2\left(n-k-1\right){% endequation %}. כדי שהמספרים ייראו נחמד, בואו נדבר על מסלול מאורך {% equation %}2\left(n+1\right){% endequation %}, נמשיך לקרוא לאורך של המסלול הראשון {% equation %}2k{% endequation %} ואז האורך של השני יהיה {% equation %}2\left(n-k\right){% endequation %}.

קל לנחש את הצעד הבא: אני אסמן ב-{% equation %}C_{n}{% endequation %} את מספר המסלולים מאורך {% equation %}2n{% endequation %}, אז קיבלתי ש-

{% equation %}C_{n+1}=\sum_{k=0}^{n}C_{k}C_{n-k}{% endequation %}

מה שאנחנו רואים פה בפעולה הוא בדיוק את העיקרון של "שני אובייקטים בלתי תלויים שסכום הגדלים שלהם הוא {% equation %}n{% endequation %} מצטרפים ליצירת אובייקט חדש מגודל {% equation %}n+1{% endequation %}" (כאן ה"גודל" הוא, נאמר, מספר צעדי ה-R). עבורי, כשאני סתם רואה את הנוסחה של קטלן, השאלה שבאה מעצמה היא "למה בעצם איברים שסכום הגדלים שלהם הוא {% equation %}n{% endequation %} יוצרים משהו מגודל {% equation %}n+1{% endequation %}? מאיפה הפלוס אחד הזה בא?" וכאן אנחנו רואים דוגמא לדרך שבה הוא עשוי לבוא - אין לנו <strong>חופש בחירה</strong> מלא של איך לבנות את האובייקט החדש מתוך הקיימים; אנחנו <strong>חייבים</strong> לתת צעד ראשון R, מה ש"מבזבז" לנו צעד אחד.

אגב, מה מקרה הקיצון כאן? מה קורה בעצם כש-{% equation %}k=0{% endequation %}? במקרה הזה המסלול הראשון הוא "ריק" ולא כולל צעדים: המסלול הגדול פשוט עושה את ה-R בהתחלה ואז מייד את ה-U שמביא אותו אל האלכסון הראשי - וזה בסדר, אנחנו סופרים את המסלול הריק פעם אחת והנוסחה מסתדרת יפה ("מסלול ריק" זו לא איזו המצאה תלושה; זו בסך הכל סדרה ריקה, דהיינו פונקציה שהתחום שלה ריק, כלומר קבוצה ריקה - אפשר לפרמל את זה עד הסוף, אבל האם זה באמת עוזר לנו להבין את זה יותר טוב?)

טוב ויפה, אז שוכנענו שמספר מסלולי השריג שלא עולים מעל האלכסון הוא בדיוק מספר קטלן, אבל הבטחתי להראות דרך למצוא נוסחה סגורה עבורם בעזרת מסלולי שריג. בואו נראה את זה קורה. מה שאני הולך לעשות בפועל הוא לספור את המסלולים <strong>הלא חוקיים</strong>, אלו שכן חוצים את האלכסון. אני אוכיח שהמספר שלהם, עבור השריג מגודל {% equation %}n{% endequation %}, הוא {% equation %}{2n \choose n-1}{% endequation %}. עכשיו אפשר לעשות טיפה אלגברה:

{% equation %}{2n \choose n-1}=\frac{\left(2n\right)!}{\left(n-1\right)!\left(n+1\right)!}=\left(2n\right)!\cdot\frac{n}{n!}\cdot\frac{1}{n!\left(n+1\right)}=\frac{\left(2n\right)!}{n!n!}\cdot\frac{n}{n+1}={2n \choose n}\cdot\frac{n}{n+1}{% endequation %}

מכיוון שמספר המסלולים הכללי הוא {% equation %}{2n \choose n}{% endequation %}, אני אקבל שמספר המסלולים החוקיים הוא:

{% equation %}{2n \choose n}-{2n \choose n-1}={2n \choose n}-{2n \choose n}\cdot\frac{n}{n+1}{% endequation %}

{% equation %}={2n \choose n}\left(1-\frac{n}{n+1}\right)=\frac{1}{n+1}{2n \choose n}{% endequation %}

קיבלנו את הנוסחה הסגורה {% equation %}C_{n}=\frac{1}{n+1}{2n \choose n}{% endequation %}. יש כאמור עוד שלל דרכים להסיק אותה (ואוילר עשה את זה אלגברית, בעזרת הפונקציה היוצרת) אבל אני אוהב את הדרך הקומבינטורית שאראה עכשיו כי היא מאוד ציורית.

האתגר שלנו הוא לספור כמה מסלולים קיימים ש<strong>כן</strong> עולים מעל האלכסון. בדומה למה שעשיתי קודם, גם עכשיו הרעיון יהיה להסתכל על מסלול כללי כזה ולפרק אותו לחלק שלפני המעבר על החוק, והחלק שאחריו, ואז לעשות איזו מניפולציה. בואו נראה דוגמא:
<img src="{{site.baseurl}}{{site.post_images}}/2025/grid_walk_mirror_1.svg" alt=""/>

הפעם הראשונה שבה המסלול הזה מגיע אל מעל האלכסון המרכזי הוא בקואורדינטה {% equation %}\left(4,5\right){% endequation %}. מה שקורה אז הוא שהמסלול נוגע לראשונה באלכסון <strong>המשני</strong> שנמצא מעל האלכסון הראשי - כלומר האלכסון {% equation %}y=x+1{% endequation %}.

עכשיו מגיע הטריק: אני הולך <strong>לשקף</strong> את החלק של המסלול עד להגעה אל {% equation %}\left(4,5\right){% endequation %}, ולשקף אותו ביחס לאלכסון המשני הזה. זה הולך להיראות ככה:
<img src="{{site.baseurl}}{{site.post_images}}/2025/grid_walk_mirror_2.svg" alt=""/>

המסלול המשוקף עושה בדיוק ההפך ממה שהמסלול הרגיל עושה - בכל פעם שהרגיל עושה U המשוקף עושה R, ולהפך. הבדל נוסף הוא בנקודת ההתחלה: המסלול הרגיל מתחיל בנקודה {% equation %}\left(0,0\right){% endequation %}, שהיא צעד R אחד מהנקודה {% equation %}\left(-1,0\right){% endequation %} שדרכה עובר האלכסון המשני; המסלול המשוקף מתחיל בנקודה שהיא צעד U אחד מאותה נקודה, כלומר הוא מתחיל מ-{% equation %}\left(-1,1\right){% endequation %}.

עכשיו, אם ניקח את המסלול המשוקף עד שהוא מגיע לנקודה {% equation %}\left(4,5\right){% endequation %} ואז נמשיך ללכת במסלול <strong>הרגיל</strong>, מה שקיבלנו הוא מסלול מ-{% equation %}\left(-1,1\right){% endequation %} אל {% equation %}\left(10,10\right){% endequation %}, והיופי הוא כמובן שזה עובד באופן כללי. כלומר, הטכניקה הזו של "לקחת מסלול שעובר מעל האלכסון הראשי, להעביר אלכסון משני מהנקודה הראשונה שבה זה קורה, לשקף ולחבר עם המשך המסלול" - זו טכניקה שבהינתן מסלול שעובר מעל האלכסון הראשי נותנת לנו מסלול מ-{% equation %}\left(-1,1\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %}. לא קשה להוכיח את זה פורמלית: הרי מסלול הוא בסך הכל סדרה של U ו-R, ומה שעושה פעולת השיקוף היא כאמור להפוך כל R אל U וכל U אל R. אם אנחנו עושים את זה עבור מסלול כללי עד הנקודה שבה המסלול הגיע לנקודה מהצורה {% equation %}\left(a,a+1\right){% endequation %}, זה אומר שהמסלול כלל {% equation %}a{% endequation %} צעדי R ו-{% equation %}a+1{% endequation %} צעדי U ולכן המסלול המשוקף כולל {% equation %}a{% endequation %} צעדי U ו-{% equation %}a+1{% endequation %} צעדי R - ולכן אם הוא מתחיל מ-{% equation %}\left(-1,1\right){% endequation %} הוא יגיע אל {% equation %}\left(-1+\left(a+1\right),1+a\right)=\left(a,a+1\right){% endequation %} ומשם אפשר יהיה להמשיך אותו כרגיל.

העניין הוא שאפשר לעשות גם <strong>את ההפך</strong>: לקחת מסלול <strong>כלשהו</strong> מ-{% equation %}\left(-1,1\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %} ולקבל ממנו מסלול מ-{% equation %}\left(0,0\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %} שעובר מעל האלכסון. הרעיון פשוט: ברגע שהמסלול שלנו נוגע באלכסון המשני {% equation %}y=x+1{% endequation %}, לבצע עליו את אותה פעולת שיקוף בדיוק. והנה הפאנץ': <strong>כל</strong> מסלול מ-{% equation %}\left(-1,1\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %} חייב מתישהו להגיע אל האלכסון המשני, כי הוא מתחיל את המסלול <strong>מעליו</strong> אבל מסיים את המסלול <strong>מתחתיו</strong>. מכאן שבאמת אפשר להפוך ככה כל מסלול מ-{% equation %}\left(-1,1\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %}, ובמילים אחרות - ההתאמה בין מסלולים מ-מ-{% equation %}\left(-1,1\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %} ומסלולים לא חוקיים מ-{% equation %}\left(0,0\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %} היא התאמה חח"ׂע ועל - גודל שתי הקבוצות הללו זהה. אבל מסלולים <strong>כלשהם</strong> מ-{% equation %}\left(-1,1\right){% endequation %} אל {% equation %}\left(n,n\right){% endequation %} שכוללים רק צעדי U ו-R - את זה קל לספור. מסלול כזה חייב להכיל {% equation %}n+1{% endequation %} צעדי R ו-{% equation %}n-1{% endequation %} צעדי U, ולכן מספר הצעדים הכולל שלו הוא {% equation %}\left(n-1\right)+\left(n+1\right)=2n{% endequation %} ומתוכם צריך לבחור {% equation %}n-1{% endequation %} כדי להציב בהם את ה-U - וזה בדיוק {% equation %}{2n \choose n-1}{% endequation %}. קיבלנו את התוצאה שחיפשנו.

למסלולי שריג יש שם: <strong>מסלולי דיק</strong> (Dyck), והם קשורים בצורה ישירה לסדרות של תווים שנקראות <strong>מילות דיק</strong>. הרעיון במילת דיק, בהקשר הזה, הוא שזו מילה מאורך {% equation %}2n{% endequation %} שמורכבת משני תווים שכל אחד מופיע {% equation %}n{% endequation %} פעמים - אלו בדיוק ה-U,R אצלנו. הדרישה הנוספת, שתואמת את הדרישה שהמסלול לא יעבור מעל האלכסון, היא שבאף <strong>רישא</strong> של המילה לא יהיו יותר U מאשר R-ים (רישא היא תת-מילה שמקבלים מכך שמתחילים מהאות הראשונה במילה, מתקדמים הלאה ועוצרים מתישהו). דרך אחרת לתאר מסלולי דיק היא אם מפרשים את U בתור "למטה וימינה" ואת R בתור "למעלה וימינה" ואז מקבלים מסלול מ-{% equation %}\left(0,0\right){% endequation %} אל {% equation %}\left(n,0\right){% endequation %} שלא יורד מתחת לציר {% equation %}x{% endequation %} בשום שלב. הנה ציור סכמטי של איך 14 המסלולים מאורך 4 נראים:
<img src="{{site.baseurl}}{{site.post_images}}/2025/dyck_paths_4.svg" alt=""/>

דרך נחמדה אחת לחשוב על מילות דיק היא אם מפרשים את R בתור סוגריים שמאליים, כלומר הסימן ")", ואת U בתור סוגריים ימניים, כלומר "(". כשכותבים סוגריים, מקובל לפעמים לשים סוגריים בתוך סוגריים (אמנם, לא תמיד אבל זה די נפוץ (למשל פראצ'ט מאוד אהב התחכמויות כאלו (האמת שאני לא בטוח אם פראצ'ט השתמש בסוגריים בתוך סוגריים או בהערות שוליים בתוך הערות שוליים) והוא לא היחיד מסוגו) ולכן כשאני משתמש בזה כאן זה לא כזה חריג). כשכותבים משמאל לימין, כמו למשל במתמטיקה, הכלל הוא שסוגריים שמאליים פותחים קונטקסט חדש וסוגריים ימניים סוגרים את הקונטקסט הפתוח הנוכחי. אם ברישא כלשהי יהיו יותר סוגריים ימניים משמאליים, זה אומר שייסגרו יותר קונטקסטים מאשר נפתחו עד כה, וזה לא הגיוני - ולכן זה "אסור". ובאמת, כשמנסים לנתח ביטוי שכולל סוגריים הרבה פעמים עושים בדיוק את הפירוק שראינו כאן - הולכים עד הפעם הראשונה שבה מספר הסוגריים הימניים משתווה לשמאליים, ומפרקים ל"מה שבין הסוגר הימני שבהתחלה והסוגר השמאלי שעכשיו, וכל מה שבא אחר כך".

<h2>עצים</h2>

נראה לי שכבר הבנו את הרעיון - אני מציג משהו חדש שמתאים למספרי קטלן, קודם כל אני מראה תמונה של 14 האובייקטים שמתאימים לגודל 4, כלומר למקרה {% equation %}C_{4}=14{% endequation %}:
<img src="{{site.baseurl}}{{site.post_images}}/2025/binary_trees_4.svg" alt=""/>

מה שאנחנו רואים פה הוא <strong>עצים בינאריים</strong> עם 4 צמתים. עצים בינאריים כאלו הם מקרה פרטי של <strong>גרף</strong> - הרעיון בגרף הוא שיש לנו אוסף של נקודות שנקראות "צמתים" וקווים שמחברים אותם, שנקראים "קשתות". הרעיון הכללי ב"עץ" הוא שזה גרף שבו יש צומת מיוחד - "השורש" - שאפשר להגיע ממנו לכל הצמתים האחרים בגרף. אנחנו אוהבים לצייר עצים כך שהשורש הוא הצומת העליון ביותר וה"כיוון" של העץ הוא כלפי מטה (אבל אם רוצים אפשר גם להגדיר שמותר לעלות למעלה בחזרה, מה שאומר שכל צומת הוא בעצם שורש, וזו לא בעיה). אם אנחנו משתמשים בקונבנציה הזו של "מלמעלה למטה" אז בסיטואציה שבה יש קשת מצומת א' לצומת ב' הנמוך יותר, אומרים שא' הוא <strong>אבא</strong> של ב' ושב' הוא <strong>ילד</strong> של א'. הרעיון בעץ <strong>בינארי</strong> הוא שלכל צומת יש לכל היותר שני בנים - ויותר מכך, יש ביניהם <strong>סדר</strong>. יש בן ימני ובן שמאלי, וזה נשאר כך גם אם אחד מהבנים חסר. כלומר, לכל צומת יש ארבע אפשרויות: או שיש לו שני בנים, או שאין לו בנים, או שיש לו בן ימני או שיש לו בן שמאלי.

עצים בינאריים הם מושג חשוב ומועיל במדעי המחשב - למשל, נוח לאחסן בהם נתונים בצורה שהופכת חיפושים ליעילים. אבל כאן אנחנו מתעניינים <strong>במספר</strong> שלהם, וכצפוי התוצאה היא שמספר העצים הבינאריים עם {% equation %}n{% endequation %} צמתים הוא {% equation %}C_{n}{% endequation %}. גם פה קל לראות את זה בעזרת בניה רקורסיבית, ועצים הם אולי המקרה הטבעי ביותר שבו בניה כזו צצה; זה ממש נעוץ בהגדרה. אני מגדיר <strong>עץ בינארי</strong> באופן הבא: עץ ריק (עם 0 צמתים) הוא עץ בינארי, ובהינתן שני עצים בינאריים {% equation %}T_{1},T_{2}{% endequation %} ניתן לבנות מהם עץ בינארי חדש על ידי הוספת צומת שורש חדש כך שאם יש ל-{% equation %}T_{1}{% endequation %} שורש, הוא הבן הימני של השורש החדש, ואם יש ל-{% equation %}T_{2}{% endequation %} שורש הוא הבן השמאלי של השורש החדש.

עם ההגדרה הזו, מה קיבלנו? שמשני עצים אנחנו מקבלים עץ חדש <strong>על ידי הוספת צומת</strong>. כלומר, אם קודם סכום הצמתים ב-{% equation %}T_{1},T_{2}{% endequation %} היה {% equation %}n{% endequation %}, בעץ החדש יש {% equation %}n+1{% endequation %} צמתים. מכאן הנוסחה הרקורסיבית מגיעה מייד - והפעם הבניה הייתה סימטרית, להבדיל ממה שקרה עבור שילושים או מסלולי שריג.

יופי, זה היה פשוט! בואו נעבור למשהו קצת יותר מוזר:
<img src="{{site.baseurl}}{{site.post_images}}/2025/plane_trees_4.svg" alt=""/>

מה אנחנו רואים כאן? גם זה נראה כמו עצים, אבל לא בינאריים - יש צמתים עם יותר משני בנים. אלו גם לא עצים עם 4 צמתים אלא דווקא עם 5 צמתים, אז מה הקטע? עצים כאלו נקראים "עצים סדורים" (או plane trees ועוד כל מני שמות) וההסבר הכי פשוט מה הם הוא פשוט ההגדרה: עץ סדור הוא גרף שכולל צומת מיוחד שנקרא <strong>השורש</strong> של העץ, ובנוסף יש רשימה {% equation %}P_{1},\ldots,P_{n}{% endequation %} (אולי ריקה) של עצים סדורים כך שלכל {% equation %}i{% endequation %} יש קשת מהשורש של העץ אל השורש של {% equation %}P_{i}{% endequation %}, והסדר בין הבנים של צומת הוא חשוב (כלומר, הרשימות {% equation %}P_{1},P_{2}{% endequation %} ו-{% equation %}P_{2},P_{1}{% endequation %} ייתנו עצים שונים אם {% equation %}P_{1}\ne P_{2}{% endequation %}).

עבור עצים סדורים מתקיים שמספר העצים הסדורים עם {% equation %}n+1{% endequation %} צמתים הוא {% equation %}C_{n}{% endequation %}, וזה מה שמודגם באיור. במבט ראשון זה קצת מפתיע - עץ סדור זו הגדרה יותר "חופשית" מעצים בינאריים, אז איך ייתכן שיש <strong>יותר</strong> עצים בינארים מעצים סדורים? הרי בהינתן {% equation %}n{% endequation %} יש {% equation %}C_{n}{% endequation %} עצים בינאריים אבל רק {% equation %}C_{n-1}{% endequation %} עצים סדורים עם {% equation %}n{% endequation %} צמתים. העניין הוא שבעץ בינארי מקרים של בנים חסרים <strong>עדיין נספרים</strong>. כמו שאמרתי קודם, אנחנו מבדילים בין המקרה שבו יש לצומת רק בן ימני והמקרה שיש לו רק בן שמאלי - ואת זה אין בעצים סדורים. אם יש רק בן יחיד לצומת, אז זה מקרה אחד שלא הולך להיספר פעמיים.

טוב ויפה, אז איך מראים שעצים סדורים מקיימים את הנוסחה הרקורסיבית? ובכן... אה... אני לא יודע. עבורי זה מקרה מעניין בדיוק בגלל שעצים סדורים <strong>לא</strong> נראים ממבט ראשון כמו משהו שקל להתאים לבניה רקורסיבית של שני חלקים. אני מניח שאם מתאמצים קצת אפשר למצוא דרך לקבל את הנוסחה הרקורסיבית גם כאן, אבל אני לא רוצה לעשות את זה כי יש התאמה חד-חד-ערכית ועל יפהפיה בין עצים בינאריים ועצים סדורים. בואו נראה דוגמא לאיך זה עובד, באדיבות הספר של Stanely:
<img src="{{site.baseurl}}{{site.post_images}}/2025/trees_bijaction_diragram.svg" alt=""/>

בצד שמאל יש לנו עץ סדור ובצד ימין יש לנו את העץ הבינארי שמתאים לו, כשבמרכז יש לנו איזה שהוא "ייצוג ביניים" שמסביר איך מקבלים אחד מהשני. איך זה עובד? נתחיל מהעץ הסדור בצד השמאל ונבצע עליו את הפעולות הבאות:

<ol> <li>לכל צומת, נחבר כל בן של הצומת לבן הבא בתור של הצומת בקו מקוווקו.</li>


<li>לכל צומת, נמחק את כל הקשתות ממנו לבנים שלו חוץ מאשר לבן השמאלי ביותר.</li>


<li>נמחק את צומת השורש מהגרף.</li>


<li>נהפוך את הקווים המקווקווים לקווים רגילים.</li>

</ol>

במילים אחרות, כל צומת "איבד" את כל הבנים שלו חוץ מאחד, אבל "הרוויח" את אחד האחים שלו (אם יש כזה). הבנים של הצומת שנותקו לא הלכו לאיבוד כי כולם עדיין מחוברים אל הבן שלא נותק, והעץ בינארי כי עכשיו לכל צומת יש לכל היותר שני בנים: הבן השמאלי המקורי שלו (אם היו לו בנים) והאח שמימין לו (אם היה לו כזה).

למה זו התאמה חח"ע ועל? כי אפשר <strong>להפוך</strong> אותה, כלומר מכל עץ בינארי לקבל עץ סדור, ובצורה כזו שאם נתחיל מעץ סדור, נהפוך אותו לבינארי ואז חזרה לעץ סדור, אכן נחזור לעץ שהתחלנו ממנו. הנה השיטה:

<ol> <li>נוסיף לגרף צומת חדש שיהיה מחובר לבן שמאלי יחיד - השורש של הגרף המקורי.</li>


<li>לכל צומת, אם יש לו בן ימני נהפוך את הקו שמחבר אותם למקווקו.</li>


<li>לכל צומת {% equation %}a{% endequation %}, אם יש לו בן שמאלי {% equation %}b{% endequation %}, נלך ימינה על גבי הקווים המקווקווים החל מ-{% equation %}b{% endequation %} ונהפוך כל צומת שנפגוש בדרך לבן של הצומת {% equation %}a{% endequation %}, כשהסדר שלהם הוא כמו הסדר שבו פוגשים אותם על המסלול ({% equation %}b{% endequation %} נותר הבן הכי שמאלי).</li>


<li>נמחק את הקווים המקווקווים מהגרף.</li>

</ol>

קל לראות שזה באמת עובד - ובחיי שזו התאמה מרהיבה.

<h2>דברים שלא נחתכים</h2>

בואו נראה עוד תמונה של 14 דברים!
<img src="{{site.baseurl}}{{site.post_images}}/2025/nonintersecting_chords_4.svg" alt=""/>

מה שיש לנו כאן הוא קבוצות של 8 נקודות <strong>על מעגל</strong>. אני לא מצייר את המעגל כי הוא רק מקשה להבין מה קורה פה, אבל מכאן הנקודות מגיעות. חלק מהנקודות מחוברות בקווים שעוברים בתוך המעגל - <strong>מיתרים</strong>. הפואנטה פה היא שאנחנו מחלקים את הנקודות לזוגות, ובין כל זוג מעבירים מיתר, כך שהמיתרים <strong>לא נחתכים</strong>. עבור {% equation %}n{% endequation %} מיתרים שאנחנו מעבירים דרך {% equation %}2n{% endequation %} נקודות נקבל {% equation %}C_{n}{% endequation %} אפשרויות שונות לעשות את זה.

אם מנסים לפרמל את זה די מהר רואים דרך פשוטה לתאר סיטואציה של "היחתכות" בלי גאומטריה: אם אני אמספר את הנקודות על ידי {% equation %}1,2,\ldots,2n{% endequation %}, אז המיתר {% equation %}\left(a,b\right){% endequation %} חותך את המיתר {% equation %}\left(c,d\right){% endequation %}, כאשר אני מניח בלי הגבלת הכלליות ש-{% equation %}a<c{% endequation %}, רק אם {% equation %}c<b{% endequation %} וגם {% equation %}d>b{% endequation %}. בניסוח שונה, אם אני אתאר את נקודות ההתחלה והסיום של אחד המיתרים עם סוגריים עגולים ושל מיתר אחר עם סוגריים מרובעים, אז הסיטואציה הבאה מובילה לחיתוך: {% equation %})[(]{% endequation %}, וזאת להבדיל מ-{% equation %}\left(\right)\left[\right]{% endequation %} שהיא בסדר (זה {% equation %}c>b{% endequation %}) או {% equation %}\left(\left[\right]\right){% endequation %} שהיא גם בסדר (זה {% equation %}d<b{% endequation %}).

כדי להוכיח שזה שקול למשהו שאנחנו כבר מכירים, בואו נעבור לייצוג ביניים שהוא בעיה מעניינת בפני עצמה:
<img src="{{site.baseurl}}{{site.post_images}}/2025/nonintersecting_arcs_4.svg" alt=""/>

כאן אנחנו מציירים {% equation %}2n{% endequation %} נקודות <strong>בשורה</strong> ומחברים אותן בקשתות שלא נחתכות. זה באופן מובהק אותו הדבר בדיוק כמו הנקודות על המעגל, אבל הציור שונה (ולשם שינוי קשה לי לסדר אותו בשתי שורות של שבע פריטים כל אחת, כי כל שורת נקודות כזו היא די ארוכה).

הרעיון הוא להתאים לכל סידור כזה מילת דיק, שאציג בתור סדרת סוגריים מאוזנת - כלומר, סדרה של אותו מספר של ")"{} ו-"(" כך שבכל רישא אין יותר "(" מאשר ")". הנה איך זה עובד:
<img src="{{site.baseurl}}{{site.post_images}}/2025/nonintersecting_arcs_example.svg" alt=""/>

הרעיון פשוט: לכל נקודה, אם היא <strong>הראשונה</strong> בזוג שלה, שמים ")"{} ואם היא <strong>השניה</strong> שמים "(", כשהולכים משמאל לימין. מכיוון שיש לנו חלוקה של {% equation %}2n{% endequation %} הנקודות ל-{% equation %}n{% endequation %} זוגות יהיו לנו בסך הכל {% equation %}n{% endequation %} מופעים של כל סוג סוגריים, אבל למה התנאי על הרישא מתקיים? זה די פשוט: בכל פעם שמופיע "(" זה בגלל שהנקודה שמעליו <strong>היא השניה בזוג</strong>, כלומר בשלב מוקדם יותר פגשנו את הנקודה הראשונה שהתאימה לה ואז כתבנו ")". לכן ההתאמה עובדת - אנחנו תמיד מקבלים מילת דיק חוקית.

כדי להשלים את ההתאמה צריך להסביר את הכיוון השני - איך בונים ממילת דיק התאמה כזו של נקודות לזוגות? גם זה קל: מעל כל אות במילת הדיק מציירים נקודה, ואז עוברים עליהן משמאל לימין. בכל פעם שבה נתקלים ב-"(", מתחילים ללכת שמאלה שוב עד שמגיעים אל הנקודה הראשונה שטרם חוברה למישהו. היא בודאות תהיה מסומנת ב-")"{} כי כאמור, בכל פעם שבה אנחנו נתקלים ב-"(" אנחנו מייד מחברים את הנקודה שלו למישהו. התנאי על הרישות של מילות דיק מבטיח שתמיד נמצא <strong>מישהו</strong> להתחבר אליו, ומכיוון שאנחנו תמיד מתחברים לנקודה הפנויה הראשונה שאנחנו מגיעים אליה לא יכולים להיווצר חיתוכים.

כדי לראות את זה, בואו נחשוב שאני הנקודה {% equation %}b{% endequation %} ואני מתחיל ללכת שמאלה כדי לחפש מישהו להתחבר אליו עד שאני מוצא {% equation %}a{% endequation %} פנוי. עכשיו, האם ייתכן שיש נקודות {% equation %}c,d{% endequation %} כך ש-{% equation %}a<c<b<d{% endequation %}? לא! כי אם {% equation %}c{% endequation %} מחוברת ל-{% equation %}d{% endequation %} זה אומר שבזמן ש-{% equation %}d{% endequation %} חיפש אל מי להתחבר, {% equation %}c{% endequation %} הייתה <strong>פנויה</strong>, אבל אם זה היה המצב - למה {% equation %}b{% endequation %} לא התחברה אליה אלא המשיכה עד {% equation %}a{% endequation %}? אוקיי, אז {% equation %}a<c<b<d{% endequation %} הוא בלתי אפשרי. מה בדבר {% equation %}c<a<d<b{% endequation %}? במקרה הזה, מאותו שיקול, {% equation %}d{% endequation %} לא הייתה יכולה להיות מחוברת אל {% equation %}c{% endequation %} כי היא הייתה מתחברת אל {% equation %}a{% endequation %} לפני כן. זה מסיים את ההוכחה.

<h2>מגדלי קפלר</h2>

שמרתי לסוף את הדבר הכי חדש והכי מוזר: מגדלי קפלר.
<img src="{{site.baseurl}}{{site.post_images}}/2025/kepler_towers_4.svg" alt=""/>

מה הולך כאן? כרגע זה בעיקר מזכיר לי את הסמל של ערוץ 1 העתיק, אבל חלק מהעניין הוא שבמקרה הזה, המגדלים מגודל 4 הם קטנים מדי מכדי שאפשר יהיה להסביר בצורה טובה את ההגדרה הכללית, אז אלך על דוגמא מורכבת יותר. המגדלים הוצגו במאמר Three Catalan Bijections של דונלד קנות' שמספר שהם הומצאו בפברואר 2005 (חדשים!) על ידי Xavier Viennot שנתן להם את שמם. למה "קפלר"? קנות' מסביר שזה בגלל שהדיאגרמה של מגדל קפלר (כמו אלו שרואים למעלה) מזכירה את מודל מערכת השמש של קפלר.
<img src="{{site.baseurl}}{{site.post_images}}/2025/kepler_tower_example.svg" alt=""/>

כדי לעזור להבין את הדוגמא הזו אני כבר אספר שאפשר לתאר מגדל קפלר בצורה פשוטה גם בתור רשימה של רשימות של רשימות של מספרים - פשוט! במקרה שלנו, המגדל הוא {% equation %}T=\left(W_{1},W_{2},W_{3}\right){% endequation %} כאשר {% equation %}W_{1}=\left[\left(1\right),\left(2\right),\left(3\right)\right]{% endequation %} ו-{% equation %}W_{2}=\left[\left(1,3\right),\left(4\right),\left(1,3\right)\right]{% endequation %} ו-{% equation %}W_{3}=\left[\left(1,3,5,7\right),\left(1,4,7\right),\left(3,8\right),\left(2,4,7\right),\left(1,7\right)\right]{% endequation %}.

עכשיו, כפי שאפשר לראות מהתמונה, מגדל קפלר מורכב מאוסף של מעגלים. כל מעגל כזה מכונה <strong>טבעת</strong> (Ring) ואפשר לראות שיש בכל טבעת קשתות שחורות בולטות. הקשתות הללו מכונות <strong>לבנים</strong> (Bricks) והן מה שאנחנו סופרים: יש בדיוק {% equation %}C_{n}{% endequation %} מגדלי קפלר עם {% equation %}n{% endequation %} לבנים.

עכשיו, אפשר גם לראות שהטבעות מאוגדות בקבוצות, עם רווחים גדולים שמסמנים מתי קבוצה אחת נגמרת והבאה בתור מתחילה. כל קבוצה כזו מכונה <strong>חומה</strong> (Wall). האינטואיציה הציורית שלנו יכולה להיות זו: חומה היא הדבר הרגיל שאנחנו חושבים עליו - אוסף של לבנים שמונחות בשכבות אחת מעל השניה. במקרה הזה השכבות הן מעגליות, וכל שכבה מכונה "טבעת" ומכילה כמה "לבנים". קנות' מציע לנו לחשוב על הלבנים כאילו הן עשויות מלגו, כך שאפשר "להדביק" לבנים זו לזו, כך שכדי שלבנה לא תיפול מספיק שתהיה מתחתיה לבנה במקום כלשהו, אפילו אם מרכז המסה שלה בולט החוצה.

בואו נעבור לדבר על זה קצת יותר פורמלי. בצורת הרישום {% equation %}T=\left(W_{1},W_{2},\ldots,W_{m}\right){% endequation %} כל {% equation %}W_{k}{% endequation %} כזה הוא חומה, וכל חומה היא מהצורה {% equation %}W_{k}=\left(R_{1}^{k},R_{2}^{k},\ldots,R_{t_{k}}^{k}\right){% endequation %}, כלומר כל חומה היא רשימה של טבעות, ובחומות שונות יכולים להיות מספרים שונים של טבעות. המוסכמה היא שאנחנו מתחילים מהמרכז ומתקדמים החוצה - כלומר, החומה הראשונה היא זו שהכי פנימית, והטבעת הראשונה בכל חומה היא זו שהכי פנימית וכן הלאה.

עכשיו, מה יש בכל טבעת? כאן העניינים מתחילים להסתבך. קונספטואלית, אנחנו מחלקים את המעגל לחלקים, וכל טבעת מכילה לבנים שהן חלק מהחלקים הללו. השאלה <strong>לכמה</strong> חלקים מחלקים את המעגל תלויה במספר החומה הנוכחי. בחומה הראשונה, כל המעגלים מחולקים ל-2 חלקים. בחומה השניה הם מחולקים ל-4 חלקים; בשלישית ל-8 וכן הלאה עם חזקות של 2. בניסוח פורמלי, {% equation %}R_{i}^{k}\subseteq\left[2^{k}\right]{% endequation %}, כאשר הסימון {% equation %}\left[n\right]{% endequation %} הוא סימון סטנדרטי ל-{% equation %}\left\{ 1,2,3,\ldots,n\right\} {% endequation %}.

עכשיו, החוק שמגדיר את מגדלי קפלר קובע שבכל חומה, הטבעת הראשונה תמיד מכילה בדיוק את כל הלבנים האי-זוגיות, כלומר {% equation %}R_{1}^{k}=\left\{ 1,3,5,\ldots,2^{k}-1\right\} {% endequation %}. כל טבעת אחרת יכולה להכיל איזה מספרים שרוצים, אבל יש <strong>שתי מגבלות</strong>. כדי להבין איך הן נראות באופן ציורי, תעיפו לרגע מבט בציור - אפשר לראות שאני מצייר לבנים לא בתור בדיוק חצי עיגול, רבע עיגול וכו' אלא <strong>קצת יותר מזה</strong>, כאילו הוספתי צ'ופצ'יקים בקצוות. זה אומר שאם היו לי שתי לבנים סמוכות באותה טבעת הן היו עולות אחת על השניה <strong>וזה אסור</strong>. זה גם אומר שאם יש לי בטבעת אחת לבנה במקום {% equation %}x{% endequation %} ובטבעת שלפניה לבנה במקום {% equation %}x+1{% endequation %} או {% equation %}x-1{% endequation %}, זה נראה שהן עולות אחת על השניה. אז הנה החוקים:

<ul> <li>אסור שבאותה טבעת יהיו שתי לבנים שעולות זו על זו. כלומר, אם {% equation %}x\in R_{i}^{k}{% endequation %} אז {% equation %}x-1,x+1\notin R_{i}^{k}{% endequation %}, כאשר פעולות החשבון הן מודולו {% equation %}2^{k}{% endequation %}.</li>


<li>אם בטבעת שאיננה הראשונה בחומה יש לבנה כלשהי, היא חייבת להישען על לבנה בטבעת שלפניה. כלומר, אם {% equation %}x\in R_{i+1}^{k}{% endequation %} {% equation %}x\in R_{i}^{k}{% endequation %} או {% equation %}x-1\in R_{i}^{k}{% endequation %} או {% equation %}x+1\in R_{i}^{k}{% endequation %} כששוב, החשבון הוא מודולו {% equation %}2^{k}{% endequation %}.</li>

</ul>

זהו, זו כל ההגדרה! טיפה מסובך, אבל אין קושי עקרוני לכתוב קוד שבודק אם רשימה של רשימות של רשימות של מספרים הוא מגדל קפלר חוקי, או קוד שיודע לייצר את כל המגדלים עם {% equation %}n{% endequation %} לבנים (בצורה לא יעילה) וכדומה.

מה שקנות' עושה במאמר שלו הוא להראות התאמה חח"ע ועל מפורשת בין מגדלי קפלר עם {% equation %}n{% endequation %} לבנים ומסלולי דיק מאורך {% equation %}2n{% endequation %}, ואני רוצה להציג את זה כאן, אם כי בצורה טיפה שונה ממה שקנות' עושה. פישוט אחד שהוא לא קריטי אבל בהחלט יעזור לקוד שאני אציג להיות קצת פחות מסורבל הוא לשנות את איך שממספרים לבנים: במקום שהלבנים בקיר ה-{% equation %}k{% endequation %} יהיו {% equation %}\left\{ 1,2,3,\ldots,2^{k}\right\} {% endequation %} אני אסמן אותן ב-{% equation %}\left\{ 0,1,2,3,\ldots,2^{k}-1\right\} {% endequation %}. זה נוח, כי כשלוקחים דברים מודולו {% equation %}2^{k}{% endequation %} מקבלים מספרים בקבוצה הזו; אם היינו מסתכלים על הקבוצה מ-{% equation %}1{% endequation %} עד {% equation %}2^{k}{% endequation %} היינו צריכים טיפה לשנות את איך שעושים מודולו, וזה סתם מסרבל.

הרעיון המבריק של קנות' הולך ככה: אנחנו מסתכלים על מסלול דיק מאורך {% equation %}2n{% endequation %}. אפשר לחשוב על מסלול כזה בתור סדרה של U ו-D כך ש-U הוא צעד למעלה-ימינה ו-D הוא צעד למטה-ימינה, והמסלול מתחיל בגובה 0, מסיים בגובה 0 ולא יורד מתחת לגובה 0 בשום שלב. הרעיון של קנות' הוא עכשיו לשים "גבולות" - בגובה 1, בגובה 3, בגובה 7 וכן הלאה - בגובה {% equation %}2^{k}-1{% endequation %} לכל {% equation %}k\ge0{% endequation %}. כעת, חומה מספר {% equation %}k{% endequation %} תיבנה על פי בסיס החלק של המסלול שמתחיל עם ההגעה הראשונה לגבול {% equation %}2^{k}-1{% endequation %} ומסתיים עם ההגעה הראשונה לגבול {% equation %}2^{k+1}-1{% endequation %}, או מסתיים בסוף המסלול אם לא מגיעים לגובה הזה.

בואו נראה דוגמא:
<img src="{{site.baseurl}}{{site.post_images}}/2025/dyck_split.svg" alt=""/>

מה שיש כאן הוא המסלול שמתאים למחרוזת הבאה:

UUDUDUDDUUUDUDDUUDDDUDUDUUUUUDUUUDDDUDDDUUDUUDDDDD

 צבעתי את המסלול בשלושה צבעים - החלק הראשון בכחול, השני בירוק והשלישי באדום. הרעיון הוא שנשתמש בכל המסלול כדי לבנות מגדל קפלר: החומה הראשונה תיבנה על בסיס החלק הכחול, החומה השניה על בסיס החלק הירוק והשלישית על בסיס החלק האדום. מתי חלק מתחיל? החל מהפעם הראשונה שבה המסלול מגיע לקו הגבול שלו, ומרגע זה והלאה המסלול הקודם נזנח לאנחות. אפשר לראות שבאיור, הצעד הראשון צבוע בשחור - זה בגלל שעדיין לא הגענו אפילו לקו הגבול הראשון ולכן עוד לא התחלנו לבנות את החומות (אבל הצעד הראשון הוא תמיד למעלה ולכן תמיד נתחיל לבנות את החומה הראשונה מייד אחריו).

הרעיון עכשיו הוא זה: בחומה מס' {% equation %}k{% endequation %} יכולות להופיע לבנים שממוספרות ב-{% equation %}0,1,\ldots,2^{k}-1{% endequation %}, כלומר, מספרים שהם החל מ-0 וכלה בגובה של הגבול שהגעה אליו התחילה את המסלול שלנו. כפי שרואים טוב עם המסלול הירוק, המסלול יכול להיות <strong>מעל</strong> הגבול, וגם <strong>מתחת</strong> לגבול. בשני המקרים הללו העקרון הוא - אם המסלול ביצע צעד <strong>לכיוון הגבול</strong>, אז הצעד הזה יתורגם להוספת לבנה לחומה; אחרת הוא לא ישפיע על המגדל שאותו בונים. כך למשל במסלול הירוק, הצעד הראשון הוא <strong>למטה</strong> והוא מתרחק מהגבול, ולכן הצעד הזה <strong>לא</strong> יוסיף לבנה למגדל; אבל הצד השני הוא <strong>למעלה</strong> ומתקרב אל הגבול (ואפילו מגיע אליו) ולכן הוא כן יוסיף לבנה למגדל.

איזו לבנה הולכים להוסיף? זה תלוי <strong>בגובה</strong> של המקום שהגענו אליו אחרי הצעד. אם היינו <strong>מתחת</strong> לגבול וביצענו צעד למעלה, אז נוסיף את הלבנה שהמספר שלה הוא כמו הגובה של המסלול. אם היינו <strong>מעל</strong> הגבול וביצענו צעד אחד למטה, אז נוסיף את הלבנה שהמספר שלה הוא כמו הגובה של המסלול <strong>מעל הגבול</strong>, כלומר אם הגבול הוא 3 ואנחנו בגובה 5, אז נוסיף את לבנה 2. ככה זה נראה בדוגמא שלנו:
<img src="{{site.baseurl}}{{site.post_images}}/2025/dyck_split_with_nums.svg" alt=""/>

למשל, ה-0-ים בהתחלה מגיעים מכך שהקו הכחול שוב ושוב <strong>יורד</strong> אל הגבול. אחר כך הוא חוצה אותו כלפי מטה ואז <strong>עולה</strong> שוב - ולכן הפעם זה נספר בתור הגעה לגובה 1. או למשל, בחלק של הירוק שבו הוא מתחיל לעלות ולעלות הוא בהתחלה מוסיף את הלבנים 1,2,3 ואז פתאום מפסיק למרות שהעלייה נמשכת - למה? כי הוא חצה את קו הגבול 3, ומרגע שהוא חוצה אותו, לבנים חדשות מתווספות כשהוא <strong>יורד</strong>, לא כשהוא עולה.

מה בעצם הרעיון כאן? תסתכלו על המסלול הכחול: אסור לו לרדת מתחת ל-0 (כי כל מסלול דיק מקיים את זה) ו"אסור" לו להגיע אל 3 (כי בפעם הראשונה שבה הוא יגיע אל 3 הוא יהפוך להיות מסלול שונה, המסלול הירוק), כך שכל "מרחב התמרון" שלו הוא פס צר סביב קו הגבול 1: הוא יכול להיות ב-0,1,2 ולכן הלבנים שהוא יכול להוסיף <strong>מתחת</strong> לגבול הן 0 ו-1 (הגבהים האפשריים שלו מתחת לגבול, עד שמגיעים אליו) והלבנים שהוא יכול להוסיף <strong>מעל</strong> לגבול הן גם כן 0,1 (הגבהים שלו מעל הגבול הזה). כלומר, "מרחב התמרון" של המסלול הכחול מאפשר לו רק להוסיף לבנים עם המספר 0,1 ואלו <strong>בדיוק</strong> הלבנים שיכולות להופיע בחומה הראשונה במגדל.

המסלול השני, הירוק, מקבל מרחב תמרון רחב יותר ויכול להוסיף את הלבנים {% equation %}0,1,2,3{% endequation %} שהן בדיוק מה שיכול להופיע בחומה השניה במגדל, וכן הלאה.

עכשיו, אפשר לשאול - בשביל מה זה טוב, שיש גם חלק <strong>מעל</strong> וגם חלק <strong>מתחת</strong> לקו הגבול, אם הם מייצרים את אותן לבנים בדיוק? ובכן, זה כל היופי פה: זה מאפשר למסלול ליצור לבנים <strong>כשהוא רוצה</strong>. תראו למשל את הסיום של המסלול האדום - הוא <strong>חייב</strong> לסיים בכך שהוא יורד עד 0, אבל מרגע שהוא מתחת לקו הגבול, עוד ירידה לא תוסיף לבנים - אז הצורך לרדת עד הסוף לא מכריח את המסלול להוסיף לבנים למגדל שהוא בונה. זה נותן לנו בדיוק את הגמישות שאנחנו צריכים כאן.

אם כן, טוב ויפה, אבל מה זה בעצם אומר, "להוסיף לבנה"? איך בוחרים לאיזו טבעת להוסיף אותה? ובכן, זה קל: פשוט זורקים אותה ורואים מה קורה.

בואו ניזכר איך חומה בנויה. ברגע שמתחילים חומה חדשה, כי המסלול הגיע לגובה מתאים חדש ושינה צבע, אוטומטית יוצרים חומה חדשה עם טבעת ראשונה שכוללת את כל המספרים שהטבעת הראשונה חייבת לכלול. כלומר, כשמגיעים לראשונה לגובה {% equation %}2^{k}-1{% endequation %} יוצרים חומה חדשה עם הטבעת {% equation %}\left\{ 0,2,4,\ldots,2^{k}-2\right\} {% endequation %}. זה עדיין לא החלק של "להוסיף לבנים למגדל", זה פשוט יוצר לנו את החומה הבסיסית שהמסלול יבנה מעליה.

עכשיו, אם המסלול רוצה להוסיף את הלבנה {% equation %}s{% endequation %} למגדל, אנחנו עוברים על הטבעות במגדל מהעליונה ביותר אל התחתונה. לכל טבעת כזו, אם {% equation %}s{% endequation %} או {% equation %}s+1{% endequation %} או {% equation %}s-1{% endequation %} (מודולו {% equation %}2^{k}{% endequation %}) נמצאות בה - "נתקענו" - אי אפשר להכניס את הלבנה לטבעת הזו (היא תתנגש באחת מהלבנים הללו) וגם אי אפשר לדחוף אותה דרכן אל טבעת נמוכה יותר כי הן חוסמות את הדרך (זו הצורה שבה כדאי לחשוב על זה כי זה נותן אינטואיציה למה הוספת לבנה מתנהגת כפי שהיא מתנהגת; הסיבה <strong>האמיתית</strong> להתנהגות הזו היא כי ככה הבניה עובדת). אם אף אחת מהלבנים הללו לא נמצאת בטבעת, אפשר לעבור לטבעת הבאה בתור, הנמוכה יותר, ולראות אם גם שם אפשר להתקדם או שנתקעים. בסופו של דבר מוסיף את הלבנה החדשה לטבעת הנמוכה ביותר שמצאנו שאפשר להוסיף את {% equation %}s{% endequation %} אליה - או, אם לא הייתה כזו, פותחים טבעת חדשה שכוללת רק את {% equation %}s{% endequation %}.

זהו, זו כל הבניה! הנה קוד פייתון שעושה את הכל ואני מקווה שברור וחף מבאגים:

{% highlight python %}
def add_brick(wall, s, n):
    m = len(wall) - 1
    while not (s in wall[m] or (s+1) % n in wall[m] or (s-1) % n in wall[m]):
        m -= 1
    if m == len(wall) - 1: # new ring
        wall.append([])
    wall[m+1].append(s)
     
def generate_kepler_tower_from_dyck(word):
    tower = []
    height = 0
    for ch in word:
        k = len(tower)
        current_border = 2**k-1
        next_border = 2**(k+1)-1
        height += 1 if ch == 'U' else -1
        if height >= current_border and ch == 'D':
            add_brick(tower[-1], height - current_border, 2**k)
        if height <= current_border and ch == 'U':
            add_brick(tower[-1], height, 2**k)
        if height == next_border:
            new_wall = [[2*i for i in range(2**k)]]
            tower.append(new_wall)
    return tower
{% endhighlight %}

השאלה הראשונה שאנחנו צריכים לשאול את עצמנו היא אם הבניה הזו באמת נותנת מגדל קפלר, אבל ברור שהיא עושה את זה כי כללי הוספת הלבנים שלנו מבטיחים שתמיד יהיה לנו מגדל חוקי - אנחנו מוסיף במפורש את הטבעת הראשונה בכל חומה, וכשאנחנו מוסיפים לבנה אנחנו מקפידים שהיא תיכנס למקום שבו מותר לה להיות, ובטבעת שמתחתיה היא כבר לא יכולה להיכנס כי יש שם לבנה <strong>שעליה היא יכולה להישען</strong>.

שאלה קצת יותר טריקית היא למה מסלול מאורך {% equation %}2n{% endequation %} נותן מגדל קפלר עם בדיוק {% equation %}n{% endequation %} לבנים. בדוגמא שראינו למעלה, המסלול שלי היה מאורך 50, כלומר {% equation %}n=25{% endequation %}. אם סופרים את הלבנים שהמסלולים מוסיפים (המספרים שמתחת למסלולים, באיור השני) מגיעים ל-18. איפה הלבנים החסרות? ובכן, בטבעת הראשונה בכל חומה. יש לנו שלוש חומות. בחומה הראשונה הטבעת הראשונה היא {% equation %}\left\{ 0\right\} {% endequation %}, בשניה היא {% equation %}\left\{ 0,2\right\} {% endequation %} ובשלישית היא {% equation %}\left\{ 0,2,4,6\right\} {% endequation %}. בסך הכל קיבלנו את שבע הלבנים החסרות - אבל איך בדיוק אנחנו יודעים שזה לא הסתדר בפוקס?

בואו נדמיין לרגע שהמסלול שלנו כולו מאותו צבע. במסלול הזה, בכל פעם שאנחנו מבצעים צעד "למעלה", יהיה אי שם בהמשך צעד "למטה" שיקזז אותו, כי בסוף אנחנו חוזרים אל 0. אני אחדד: אם היה לנו צעד "למעלה" שהעלה אותנו מגובה {% equation %}h{% endequation %} אל גובה {% equation %}h+1{% endequation %}, יהיה צעד "למטה" שיוריד אותנו מגובה {% equation %}h+1{% endequation %} אל גובה {% equation %}h{% endequation %}. עכשיו, אם הצעדים הללו התבצעו <strong>מתחת לגבול</strong> אז צעד ה"למעלה" הוסיף לבנה וצעד ה"למטה" לא הוסיף; ואם הם התבצעו <strong>מעל לגבול</strong> אז צעד ה"למטה" הוסיף וצעד ה"למעלה" לא הוסיף. בשני המקרים בדיוק חצי מהצעדים שלנו הוסיפו לבנה.

אם נסתכל על האיור שבדוגמא, קל להיזכר שיש חריג - הצעד הראשון, שהוא צעד "למעלה" אל הגבול אבל הוא לא מוסיף לבנה, כי בשלב הזה המסלול הכחול עוד לא קיים. זה מתקזז עם העובדה שכשהגענו לגבול, יצרנו חומה חדשה עם טבעת ראשונה {% equation %}\left\{ 0\right\} {% endequation %}. זה גם מה שהולך לקרות <strong>באופן כללי</strong> כשיש לנו מסלול שמשנה צבע: כשהמסלול הירוק הגיע לגובה 7 ושינה את הצבע שלו, מה שקרה הוא שנוצרו אצלו צעדים שקודם <strong>לא הוסיפו</strong> לבנים אבל עכשיו יתקזזו עם עוד צעדים ש<strong>לא יוסיפו</strong> לבנים: הצעדים החל מהגבול ומעלה, כלומר {% equation %}3\to4\to5\to6\to7{% endequation %}. ארבעה צעדים שעכשיו כשיתבצעו בכיוון ההפוך גם כן לא יוסיפו לבנים - אבל עכשיו מתקזזים עם העובדה שהמסלול האדום נפתח עם הוספת הטבעת {% equation %}\left\{ 0,2,4,6\right\} {% endequation %}.

זה קורה גם באופן כללי: אם היה לנו מסלול סביב קו הגבול {% equation %}2^{k}-1{% endequation %} והוא הגיע אל {% equation %}2^{k+1}-1{% endequation %} אז "איבדנו" את כל הצעדים {% equation %}2^{k}-1\to2^{k}\to\ldots\to2^{k+1}-1{% endequation %}, כלומר {% equation %}2^{k}{% endequation %} צעדים; אבל אז אנחנו יוצרים קיר חדש שבטבעת הראשונה שלו יש את {% equation %}\left\{ 0,2,\ldots,2^{k+1}-2\right\} {% endequation %}, כלומר בדיוק {% equation %}2^{k}{% endequation %} הלבנים שהיו חסרות לנו.

זה מוכיח שקיבלנו פונקציה ממסלולי דיק מאורך {% equation %}2n{% endequation %} אל מגדלי קפלר מגודל {% equation %}n{% endequation %}. כדי להראות שהיא חח"ע ועל, צריך להסביר איך להפוך אותה.

הרעיון הוא די פשוט: בהינתן מגדל קפלר, נבנה את המסלול שיוצר אותו "מהסוף להתחלה", על ידי כך שנפרק לאט ובזהירות את החומות של המגדל. אם נעקוב אחרי הגובה הנוכחי של המסלול, נוכל לראות שבהינתן הגובה הזה והמצב הנוכחי של המגדל, יש בדיוק אפשרות אחת למצב של המגדל והגובה של המסלול בצעד הקודם שהביאו אותנו לכאן.

בואו נחזור למסלול שראינו קודם. כשמייצרים ממנו מגדל קפלר, מקבלים את זה:
<img src="{{site.baseurl}}{{site.post_images}}/2025/kepler_tower_from_dyck.svg" alt=""/>

אנחנו רוצים להבין איך אפשר לקבל ממנו בחזרה את המסלול הזה:
<img src="{{site.baseurl}}{{site.post_images}}/2025/dyck_split.svg" alt=""/>

כאמור - אני ארכיב את המסלול מהסוף להתחלה. בשביל זה צריך לדעת בכל רגע נתון מה קו הגבול הנוכחי, שקובע איזו לבנה מוסיפים למגדל. עבור המסלול האדום קו הגבול הזה הוא ב-7. איך אפשר לדעת את זה רק מהסתכלות על מגדל הקפלר שלנו? אנחנו סופרים כמה <strong>חומות</strong> יש בו - כאן יש שלוש, מה שאומר שהחומה החיצונית ביותר, זו שאנחנו מתחילים מלפרק אותה, זו שתיתן את המסלול האדום - מורכבת מהלבנים {% equation %}\left\{ 0,1,2,\ldots,2^{3}-1\right\} {% endequation %}.

עכשיו, אנחנו זוכרים בכל רגע נתון מה הגובה הנוכחי של המסלול שאנחנו משחזרים מהסוף להתחלה, ומה המצב הנוכחי של המגדל (שאמור להיות תואם את המצב של המגדל כשהוא נבנה על ידי המסלול המקורי עד שהוא מגיע בדיוק אל הנקודה בשחזור שבה אנחנו נמצאים). אנחנו מתחילים מגובה 0. אם אני בגובה 0, מה היה הצעד הקודם? זה היה <strong>חייב</strong> להיות צעד D כי אם זה היה צעד U, והצעד הזה הביא אותי לגובה 0, זה אומר שקודם הייתי בגובה {% equation %}-1{% endequation %} וזה בלתי אפשרי. באופן דומה, אם במהלך הבניה של המסלול האדום הייתי איכשהו מטפס עד לגובה 14, הייתי יודע שהצעד הקודם היה חייב להיות U, כי צעד D היה אומר שקודם הייתי בגובה 15 <strong>וזה היה יוצר מסלול חדש</strong>, עם חומה חדשה - יותר חומות מאשר יש במגדל. אז אלו שני מקרי הקיצון שבהם אנחנו יודעים בדיוק מה חייב לקרות אפילו בלי לבדוק מה הולך עם הלבנים שבתוך המגדל שלנו - ובשני המקרים הללו, הצעדים שעושים הם <strong>לכיוון</strong> קו הגבול שבאמצע ולכן לא מוסיפים לבנים, ולכן אין לי מה <strong>להסיר</strong> לבנים מהמגדל שאני מפרק.

יש עוד אפשרויות. אם אני בגובה {% equation %}s{% endequation %} שהוא 1 לפחות אבל עדיין מתחת לקו האמצע, יכלתי להגיע לגובה הזו או בפעולת D שלא הייתה מוסיפה לבנה למגדל, או בפעולת U שכן הייתה מוסיפה - והיא הייתה מוסיפה בדיוק את הלבנה {% equation %}s{% endequation %}, כי זה מה שקורה כשאנחנו מתחת לקו האמצע, אנחנו מוסיפים לבנה ששווה לגובה שהגענו אליו <strong>אחרי</strong> ביצוע הצעד. אז אנחנו מנסים להסיר מהמגדל שלנו את הלבנה {% equation %}s{% endequation %}, כלומר בודקים אם היא נמצאת בחומה הנוכחית, במיקום שבו אין לבנים אחרות שיושבות עליה, באחת מהטבעות <strong>מעל</strong> הטבעת הראשונה (הטבעת הראשונה כזכור נבנית בצורה שונה). אם היא שם, אנחנו מסירים אותה ומסמנים שבוצע צעד U, ואחרת פשוט מסמנים שבוצע צעד D, ומעדכנים את הגובה שלנו בהתאם (אם בוצע צעד U אנחנו <strong>מקטינים</strong> את הגובה, כי הרי אנחנו רוצים לדעת באיזה גובה היינו <strong>קודם</strong>). באופן דומה מטפלים גם במקרה שבו אנחנו מעל קו האמצע.

המקרה הכי בעייתי הוא זה שהוא אנחנו נמצאים <strong>בדיוק</strong> על קו האמצע. במקרה הזה יש שתי אפשרויות שונות להגעה לשם, ששתיהן מוסיפות לבנה למגדל - או עלייה למעלה שמוסיפה את הלבנה {% equation %}2^{k}-1{% endequation %}, או ירידה למטה שמוסיפה את הלבנה 0. אז מנסים לחלץ מהמגדל את שתי הלבנים הללו ורואים איזו מהן הצליחה. ברור ש<strong>רק אחת</strong> היא אפשרית, כי שתי הלבנים הללו הן שכנות ולכן מתנגשות אחת עם השניה ולא יכולות להיות באותה טבעת, ולכן אם הן נמצאות במגדל, אחת נמצאת גבוה יותר והיא זו שתקבע לנו איזה מהלך אנחנו משחזרים. אבל למה בעצם שאחת משתיהן תהיה במגדל? אי אפשר להנדס מגדלים שבהם זה לא קורה? זה הטיעון הכי עדין כאן: אפשר להראות שאלא אם החומה התרוקנה למעט הטבעת הראשונה, זה לא יכול לקרות כי <strong>בדרך</strong> אל קו האמצע הזה היינו מרוקנים מהחומה כל לבנה שלא תקועה - חוץ מאשר הלבנים {% equation %}0,2^{k-1}{% endequation %} שאפשר להוציא רק כשמגיעים לאמצע, וכל לבנה אחרת שאי אפשר להוציא כי אחת משתי הלבנים הללו חוסמת אותה. זה טיעון קצת מעצבן להוכחה פורמלית אבל הוא עובד; כל מה שנשאר לעשות הוא לדבר על מה שקורה כשמגיעים לאמצע כשהחומה ריקה חוץ מהטבעת הראשונה, וברור מה עושים בשלב הזה - מעיפים את החומה ומתחילים לשחזר את המסלול מהצבע הבא (כלומר, הקודם).

הנה קוד (חף מבאגים, אני מקווה - היו בו כל כך הרבה בהתחלה!) שעושה את זה:

{% highlight python %}
def remove_brick(wall, s, n):
    # we are trying to understand if it's possible that s was the latest brick added to the tower
    # for this, it's not enough that it's IN the tower, the way for it must be clear, meaning no s+1 and no s-1 in the way
    # print(f"Trying to remove brick {s} from wall {wall}, num_segments={num_segments}")
    for ring in reversed(wall[1:]): # skip the first ring, it's not touched by add_brick()
        if s in ring:
            ring.remove(s)
            if len(ring) == 0: # if the ring is empty, remove it
                wall.remove(ring)
            return True
        else:
            if (s+1) % n in ring or (s-1) % n in ring:
                return False
    return False

def generate_dyck_from_kepler(tower):
    tower = copy.deepcopy(tower) # we're going to remove bricks
    word = []
    height = 0
    for k in range(len(tower)-1, -1, -1): # go over the walls from last to first
        wall = tower[k]
        current_border = 2**(k+1)-1
        while len(wall) > 1 or height != current_border: # continue until wall is empty except the first ring
            if height == 2*current_border:
                # we're near the next border. we can't reach it, otherwise the tower would have had more walls
                word.append('U')
                height -= 1
            elif height == 0:
                # we're at the bottom, we can't go down anymore
                word.append('D')
                height += 1
            elif height > current_border: # if s_down is in the tower, we made a "down" move, else nothing
                if remove_brick(wall, height - current_border, 2**(k+1)):
                    word.append('D')
                    height += 1
                else:
                    word.append('U')
                    height -= 1
            elif height < current_border: # if s_up is in the tower, we made an "up" move, else nothing
                if remove_brick(wall, height, 2**(k+1)):
                    word.append('U')
                    height -= 1
                else:
                    word.append('D')
                    height += 1
            elif height == current_border:
                # we reached the border either by "down" from above, and then s_down is in the tower, or by "up" from below, and then s_up is in the tower
                # they can't both be in the tower since in this case, s_down = 1 and s_up = current_border + 1, which are adjacent (modulo current_border + 1)
                # print("height == current_border, so we are at the border, trying to remove bricks", s_down, s_up)
                if remove_brick(wall, height - current_border, 2**(k+1)):
                    word.append('D')
                    height += 1
                elif remove_brick(wall, height, 2**(k+1)):
                    word.append('U')
                    height -= 1
                else:
                    raise ValueError("This should not happen")
    word.append('U') # first step is always U
    return ''.join(reversed(word))
{% endhighlight %}

זה מסיים את הסיפור מבחינתי, אבל מספרי קטלן לא נגמרים שם - הספר של Stanely עמוס בשלל דוגמאות אחרות (אם כי חייבים להודות שרובן הן פשוט וריאציות עם כל מני מגבלות ופרמטרים על אותה בעיה), אבל שולי הפוסט הזה כבר צרים מלהכילן. 