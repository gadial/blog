---
id: 3036
title: "פותרים את SAT - אלגוריתם CDCL"
date: 2014-02-03 17:20:48
layout: post
categories: 
  - לוגיקה
  - מבני נתונים ואלגוריתמים
tags: 
  - DPLL
  - אלגוריתם CDCL
  - בעיית SAT
---
<a href="http://www.gadial.net/2013/12/11/dpll_algorithm/">בפוסט הקודם</a> על פתרונות לבעיית SAT ראינו את אלגוריתם DPLL - זה היה פחות או יותר האלגוריתם הבסיסי שרוב פותרי ה-SAT המדוייקים (להבדיל מהסתברותיים) מבוססים עליו, אבל מן הסתם פותרים מודרניים הולכים רחוק יותר ממנו, ובפוסט הזה אני רוצה להציג אלגוריתם קצת יותר מודרני שמתבסס על DPLL אבל עושה עוד דברים מתוחכמים - אלגוריתם CDCL, קיצור של Conflict-Driven Clause Learning. כמובן, כמו DPLL גם זה לא "אלגוריתם" במלוא מובן המילה אלא בעיקר "מסגרת" שלתוכה אפשר לצקת שלל שיפורים ושפצורים, אבל הרעיונות הכלליים שלו עדיין מעניינים.

בואו ניזכר מה DPLL עושה, ברמה הבסיסית: הוא מבצע לסירוגין שתי פעולות שונות - הראשונה היא בחינה של הפסוק שיש לו כרגע וזיהוי השמות למשתנים ספציפיים ש<strong>חייבות</strong> להתרחש, ופישוט של הפסוק לאחר ביצוע ההשמות הללו; והשניה היא בחירה של משתנה כלשהו וערך להציב בו. אם כן, יש לנו שני סוגים של השמות למשתנים: אלו שבהן <strong>בחרנו</strong> לתת למשתנה ערך מסויים - במקרה הזה, המשתנה ייקרא "משתנה בחירה" (Decision Variable), ואלו שבהן "לא הייתה לנו ברירה" והערך ששמנו במשתנה נבע מהבחירות שעשינו. כאשר האלגוריתם מזהה שהוא "נתקע" - כלומר, הוא מגלה שיש פסוקית שכבר אין לו סיכוי לספק - הוא פשוט חוזר אחורה אל משתנה הבחירה האחרון שטרם ניסינו בו את האפשרות השניה, ומנסה אותה.

המבנה של CDCL דומה אבל קצת יותר חכם. בראש ובראשונה, כאשר מתגלה ש"נתקענו" - מה שנקרא בטרמינולוגיה של האלגוריתם הזה Conflict, האלגוריתם לא סתם מתייאש ואומר "בואו נחזור אחורה" - הוא מנסה <strong>ללמוד</strong> מזה מידע כלשהו על מה שגרם לקונפליקט. את המידע שהוא לומד הוא ממדל בצורת <strong>אילוץ חדש</strong> שמוסיפים לפסוק ה-CNF שמנסים לפתור. אחר כך האלגוריתם חוזר אחורה ומבטל חלק ממשתני הבחירה האחרונים (לאו דווקא רק אחד אחורה). אספקט נחמד של האלגוריתם הוא שאין צורך לבצע "ניהול חשבונות" כדי לזכור עבור משתנה בחירה אם כבר ניסינו בו את האפשרות השניה - האילוצים שאנחנו לומדים כבר יבטיחו שלא ננסה לתת למשתנה בחירה כלשהו את אותה האפשרות פעמיים.

כל זה מאוד אבסטרקטי ולכן בואו נראה דוגמה קונקרטית, שאני גונב מה-Handbook of Satisfiability (יש דבר כזה!). פסוק {% equation %}\varphi=C_{1}\wedge C_{2}\wedge C_{3}\wedge C_{4}\wedge C_{5}\wedge C_{6}{% endequation %} שמורכב מהפסוקיות הבאות:

{% equation %}C_{1}=\left(x_{1}\vee x_{31}\vee\neg x_{2}\right){% endequation %}

{% equation %}C_{2}=\left(x_{1}\vee\neg x_{3}\right){% endequation %}

{% equation %}C_{3}=\left(x_{2}\vee x_{3}\vee x_{4}\right){% endequation %}

{% equation %}C_{4}=\left(\neg x_{4}\vee\neg x_{5}\right){% endequation %}

{% equation %}C_{5}=\left(x_{21}\vee\neg x_{4}\vee\neg x_{6}\right){% endequation %}

{% equation %}C_{6}=\left(x_{5}\vee x_{6}\right){% endequation %}

בואו נניח שבמהלך הריצה האלגוריתם שלנו הציב -{% equation %}x_{1}{% endequation %} את הערך 0, ואחר כך ב-{% equation %}x_{31}{% endequation %} הציב את הערך 0, ולבסוף הציב ב-{% equation %}x_{21}{% endequation %} את הערך 0. מה קורה?

ובכן, ההצבה ב-{% equation %}x_{1}{% endequation %} תגרום ל-{% equation %}C_{2}{% endequation %} להפוך לפסוק {% equation %}\left(\neg x_{3}\right){% endequation %} כך ש-{% equation %}x_{3}{% endequation %} חייב להיות 0. בדומה, {% equation %}C_{1}{% endequation %} יאבד גם את {% equation %}x_{1}{% endequation %} וגם את {% equation %}x_{31}{% endequation %} ולכן גם {% equation %}x_{2}{% endequation %} חייב להיות 0. עכשיו משני אלו נקבל ב-{% equation %}C_{3}{% endequation %} ש-{% equation %}x_{4}{% endequation %} חייב להיות 1, וזה יגרור ש-{% equation %}x_{5}{% endequation %} הוא 0 בגלל {% equation %}C_{4}{% endequation %}, וש-{% equation %}x_{6}{% endequation %} חייב להיות 0 על פי {% equation %}C_{5}{% endequation %}. אבל עכשיו "הפסדנו" את {% equation %}C_{6}{% endequation %} כי שני הליטרלים שלו (החיובי והשלילי) קיבלו 0. השאלה היא מה אפשר ללמוד מזה.

ובכן, כל המלל שלעיל הוא קצת מסורבל. קל יותר להבין מה הלך כאן אם מציירים את זה בתור גרף:

<strong><a href="{{site.baseurl}}{{site.post_images}}/2014/02/sat_implication_grap.png"><img class="alignnone size-full wp-image-3037" alt="sat_implication_grap" src="{{site.baseurl}}{{site.post_images}}/2014/02/sat_implication_grap.png" width="976" height="293" /></a></strong>

מה שיש לנו כאן מכונה Implication graph - "גרף הגרירות". הצמתים שלו הן כל ההשמות למשתנים - הן משתני הבחירה והן המשתנים הנגררים. יש קשת מהשמה אחת להשמה אחרת אם ההשמה האחת הייתה מעורבת בגרירה של האחרת - והכיתוב של הקשת הוא הפסוקית שבה התבצעה הגרירה הזו. {% equation %}X{% endequation %} מייצג את ההרס והחורבן של הסתירה שהגענו אליה - אם תרצו, אפשר לחשוב עליו כאילו הוא נגרר מפסוקית ש"התרוקנה", או ממשתנה אחד שהושמו בו שני ערכים שונים (זו בעצם אינדיקציה לכך שיש שתי פסוקיות שמתרוקנות - אחת כשמציבים במשתנה הזה 0 והשניה שמתרוקנת כשמציבים בו 1).

פורמלית, אם {% equation %}x{% endequation %} הוא משתנה אז כדי שהצומת {% equation %}x=1{% endequation %} יופיע בגרף צריכה להיות ב-{% equation %}\varphi{% endequation %} פסוקית מהצורה {% equation %}\left(l_{1}\vee\dots\vee l_{k}\vee x\right){% endequation %} כך ש-{% equation %}l_{1},\dots,l_{k}{% endequation %} קיבלו כולם את הערך 0 בהשמה למשתנים שלהם, ואז מהצמתים של ההשמות הללו תהיה קשת אל הצומת {% equation %}x=1{% endequation %}. הסיפור עבור {% equation %}x=0{% endequation %} דומה רק שהפסוקית צריכה להיות מהצורה {% equation %}\left(l_{1}\vee\dots\vee l_{k}\vee\neg x\right){% endequation %}.

הצמתים היחידים בגרף שאין להם אב הם הצמתים שמייצגים השמות למשתני החלטה (כי ההשמות הללו לא נגררו משום דבר). כמובן, בפסוק ענקי עשוי להיות גרף גרירות ענקי, ורובו לאו דווקא יהיה רלוונטי בכלל לקונפליקט שאליו הגענו בסוף. לכן נהוג להצטמצם לתת-גרף ("גרף הקונפליקט") שבו "מגלחים" את החלק המיותר - אם ל-{% equation %}X{% endequation %} יש יותר ממשתנה אחד שגורר אותו (יש קונפליקט בכמה משתנים) מתמקדים רק בצמתים של משתנה אחד, והולכים ממנו אחורה תוך שלוקחים רק את מה שחייבים: לכל צומת בוחרים פסוקית אחת ולוקחים את כל הצמתים שנכנסים אליו והקשתות שלהם מסומנות בפסוקית הזו, עד שמגיעים בכל מקום לצמתים של השמות למשתני בחירה.

כמובן, האופן שבו בוחרים איך בדיוק לצמצם גרף גרירה כללי לתת-גרף הקונפליקט הזה הוא עניין לאינסוף היוריסטיקות שיכולות להשפיע באופן דרסטי על איכות הפותר. אבל אני לא מבין בזה יותר מדי ולא אכנס לזה עכשיו.

נניח שיש לנו גרף קונפליקט ואנחנו רוצים ללמוד ממנו משהו. מה נעשה עכשיו? אם נחשוב על זה לרגע, ברור שכל קשת בגרף הזו קריטית - אם נעיף אחת מהקשתות, הגרירות של הגרף כבר לא יתקיימו והקונפליקט לא יתרחש. איך מעיפים קשת? "לומדים" פסוקית חדשה שמחסלת את ההשמה שהקשת יצאה ממנה. למשל, נניח שאנחנו רוצים לחסל את הקשת שיוצאת מ-{% equation %}x_{5}=0{% endequation %}. אנחנו יכולים להוסיף לפסוק שלנו את הפסוקית {% equation %}\left(x_{5}\right){% endequation %} שמכריחה את {% equation %}x_{5}{% endequation %} להיות 1, ובכך נמנע את הקונפליקט. הבעיה היא שזו גישה חזקה <strong>מדי</strong> - אנחנו נסגרים על הערך שניתן ל-{% equation %}x_{5}{% endequation %} מכאן ואילך, ולא חושבים שאולי פספסנו אפשרויות שבהן {% equation %}x_{5}{% endequation %} עדיין יקבל 0 והפסוק יסתפק (וזה בעייתי מאוד כי באופן כללי ייתכן שיש השמה כזו, אבל אין השמה שבה {% equation %}x_{5}{% endequation %} מקבל 1 והפסוק מסתפק).

אז אפשר ללכת לקיצוניות השניה: אפשר לומר שצריך להיפטר מקשת <strong>כלשהי</strong> בגרף, ולהוסיף פסוקית שאומרת שלפחות אחת מההשמות שמופיעות בגרף, חוץ מ-{% equation %}x_{6}=1{% endequation %}, היא פסולה: {% equation %}\left(x_{31}\vee x_{1}\vee x_{2}\vee x_{3}\vee\neg x_{4}\vee x_{21}\vee x_{5}\vee x_{6}\right){% endequation %}. למה חוץ מ-{% equation %}x_{6}=1{% endequation %}? כי כבר אמרנו ש-{% equation %}x_{6}=0{% endequation %} פסול, ואם נאמר שגם {% equation %}x_{6}=1{% endequation %} פסול נכסה בכך את כל האפשרויות מבלי לומר משהו מעניין חדש, כי כל השמה פוסלת את {% equation %}x_{6}=0{% endequation %} או את {% equation %}x_{6}=1{% endequation %}.

הבעיה היא שהפסוקית הזו בבירור גדולה מדי - אנחנו יכולים להיות יותר ממוקדים מזה. אז מה הסוד? לוקחים חתך בגרף.

אינטואיטיבית, חתך הוא קטיעה של קשתות בגרף כך שהגרף יתפרק לשני חלקים. פורמלית, חתך הוא פשוט חלוקה של צמתי הגרף לשתי קבוצות, ונהוג לדבר על הקשתות שחוצות את החתך - כל הקשתות שקצה אחד שלהן הוא בקבוצה אחת של החתך והקצה השני בקבוצה השניה. הנה דוגמה לחתך בגרף שלנו:

<strong><a href="{{site.baseurl}}{{site.post_images}}/2014/02/sat_implication_graph_cut_1.png"><img class="alignnone size-full wp-image-3038" alt="sat_implication_graph_cut_1" src="{{site.baseurl}}{{site.post_images}}/2014/02/sat_implication_graph_cut_1.png" width="2105" height="790" /></a></strong>

אז אנחנו לוקחים חתך שמקיים את התכונה הבאה: בקבוצה האחת שלו יש את כל משתני ההחלטה, ובקבוצה השניה יש לפחות אחד מהמשתנים שגרם לקונפליקט, ואת הצומת {% equation %}X{% endequation %}. נסתכל על הקשתות שחוצות את החתך, ובאופן יותר ספציפי - בצמתים שמהם הקשתות יצאו. לא קשה במיוחד להשתכנע שאם יש לנו השמה <strong>כלשהי</strong> שמתאימה להשמות שכתובות בצמתים הללו, אז בהכרח נגיע לקונפליקט (בלי קשר לשאלה מה ההשמה עושה לשאר הצמתים). אז בכל השמה שמספקת את הפסוק, לפחות אחת מההשמות הללו חייבת להשתנות. המשמעות של זה עבור החתך הספציפי שבחרנו הוא הוספת הפסוקית הבאה לפסוק:

{% equation %}\left(\neg x_{4}\vee x_{21}\right){% endequation %}

זה כמובן הרבה יותר פשוט (ומצמצם יותר את מרחב החיפוש של אלגוריתם ה-CDCL) מאשר הפסוקית המפלצתית שתיארתי קודם. אבל זו לא האפשרות היחידה, כמובן; הנה חתך שנותן לנו את הפסוקית {% equation %}\left(x_{21}\vee x_{2}\vee x_{3}\right){% endequation %}:

<strong><a href="{{site.baseurl}}{{site.post_images}}/2014/02/sat_implication_graph_cut_2.png"><img class="alignnone size-full wp-image-3039" alt="sat_implication_graph_cut_2" src="{{site.baseurl}}{{site.post_images}}/2014/02/sat_implication_graph_cut_2.png" width="2105" height="953" /></a></strong>

ושוב, איך מחליטים איזה חתך לקחת? אין לי תשובה נחמדה - היוריסטיקות, היוריסטיקות, היוריסטיקות. ודברים קצת יותר חכמים שאני לא הולך להיכנס אליהם עכשיו.

חזרה לאלגוריתם ה-CDCL שלנו. אחרי שהאלגוריתם נתקל בקונפליקט, הוא מביט בגרף קונפליקט עבורו, בוחר חתך, מוסיף פסוקית לפסוק שלו, ואז קופץ חזרה אחורה - כלומר, מבטל חלק ממשתני הבחירה (לא מחליף את ערכם; פשוט שוכח שאי פעם הושם בהם ערך).

לצורך כך, גרף הגרירות צריך להכיל עוד פריט מידע שלא כתבתי בו כי זה כבר היה מסרבל: לכל השמה צריך להוסיף את <strong>דרגת ההחלטה</strong> שלה. דרגת החלטה של צומת החלטה היא קלה: היא שווה לדרגת ההחלטה של צומת ההחלטה הקודם, ועוד 1. עבור צמתים אחרים, דרגת ההחלטה שלהם היא המקסימלית מבין דרגות ההחלטה של הצמתים שנכנסים אליהם (מכיוון שרק אחרי שכל ההשמות הללו בוצעו ערכו של הצומת נקבע). כעת, אחרי שהחלטנו איזו פסוקית להוסיף, אנחנו מסתכלים על דרגות ההחלטה של הליטרלים שבפסוקיות - אם נלך אחורה ונבטל את כל ההחלטות עד וכולל דרגת ההחלטה הגבוהה ביותר של ליטרל בפסוקית, הפסוקית "תיכנס לפעולה".

בואו נסתכל על הדוגמה שלנו לשם כך. אצלנו דרגת ההחלטה של {% equation %}x_{1}{% endequation %} היא 0, של {% equation %}x_{31}{% endequation %} היא 1 ושל {% equation %}x_{21}{% endequation %} היא 2. מה זה אומר על ההשמות הנגזרות? {% equation %}x_{3}=0{% endequation %} היא מדרגה 0 (נובעת רק מ-{% equation %}x_{1}=0{% endequation %}) ו-{% equation %}x_{2}=0{% endequation %} היא מדרגה 1, ולכן {% equation %}x_{4}=1{% endequation %} היא מדרגה 1, ולכן {% equation %}x_{5}=0{% endequation %} היא מדרגה 1 וכך גם {% equation %}x_{6}=1{% endequation %}, ואילו {% equation %}x_{6}=0{% endequation %} היא מדרגה 2. נניח עכשיו שאנחנו לוקחים חתך שיוסיף לנו את הפסוקית {% equation %}\left(x_{2}\vee x_{3}\right){% endequation %}. אם עכשיו נחזור רק צעד אחד אחורה בזמן ונבטל את ההשמה של דרגה 2, כלומר את {% equation %}x_{21}=0{% endequation %}, זה לא יבטל את ההצבה של 0 ב-{% equation %}x_{2},x_{3}{% endequation %} ונישאר תקועים עם פסוקית שלא הסתפקה. אז יש לנו שתי אפשרויות: או לבטל גם את ההשמה בדרגה 1, כלומר את {% equation %}x_{31}=0{% endequation %}, מה שיבטל את ההשמה {% equation %}x_{2}=0{% endequation %}; או לבטל אפילו את ההשמה בדרגה 0.

במקרה הראשון, נקבל ש-{% equation %}x_{3}=0{% endequation %} עדיין מתקיים, ולכן הפסוקית {% equation %}\left(x_{2}\vee x_{3}\right){% endequation %} תהפוך ל-{% equation %}x_{2}{% endequation %}; במילים אחרות, ההצבה של דרגה 0, זו של {% equation %}x_{1}=0{% endequation %}, תגרור ש-{% equation %}x_{2}=1{% endequation %}. ואז יקרה משהו מעניין - אם תסתכלו על הפסוקית {% equation %}C_{1}{% endequation %}, תראו שאחרי ההשמה הזו, נהיה חייבים להציב {% equation %}x_{31}=1{% endequation %}. במילים אחרות, הוספת הפסוקית {% equation %}\left(x_{2}\vee x_{3}\right){% endequation %} וחזרה אחורה עד לביטול לדרגה 1 גרמה לכך ש-{% equation %}x_{31}{% endequation %} כבר לא יהיה משתנה בחירה אלא משתנה נגזר, והערך שאנחנו מציבים בו יהיה הפוך מהערך שהצבנו בו כשהוא היה משתנה בחירה והגענו לסתירה. בקיצור, זה עובד!

במקרה השני, יש לנו משחק חדש - הפסוקית {% equation %}\left(x_{2}\vee x_{3}\right){% endequation %} לא תגרום לשום דבר להתרחש מייד. אבל היא תהיה חלק מהפסוק שלנו, ופעפועים עתידיים הולכים להתחשב בה.

אם כן, זהו הרעיון הכללי שמאחורי "למידת פסוקיות". לי הרעיון הזה נשמע פשוט יחסית, וזה מאוד מפתיע ששיטות כאלו הן כל כך יעילות (יחסית). אבל בזכות היעילות הגבוהה שלהן, פותרי SAT הם שימושיים מאוד בפתרון בעיות אמיתיות; בפוסט הבא אתחיל להציג דוגמה לתחום שכזה.
