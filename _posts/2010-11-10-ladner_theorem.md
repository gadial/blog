---
id: 842
title: "משפט לדנר, או - מפרקים לגורמים את NP"
date: 2010-11-10 23:33:16
layout: post
categories: 
  - תורת הסיבוכיות
tags: 
  - הוכחות יפות
  - טכני
  - משפט לדנר
  - סיבוכיות
---
סדרת הפוסטים האחרונה בבלוג עוררה תגובות נזעמות על כך שהכל קל וטריוויאלי מדי. כדי לנקום במי שטוענים כך, אציג היום פוסט שילכלך את הידיים עד למאוד בפרטים טכניים, אך יציג תוצאה בתורת הסיבוכיות שלטעמי היא יפה מאוד - משפט לדנר (יש יותר ממשפט מפורסם אחד של לדנר, אבל תכף יתברר על מה בדיוק מדובר). גם מי שנרתעים מפרטים טכניים מוזמנים להישאר לפחות לתחילת הפוסט, שבו אסביר מי נגד מי כאן.

ובכן, לא אחזור על כל תורת הסיבוכיות מההתחלה - אניח שהקוראים מכירים את המושגים P ו-NP, ואפילו את המושג הקשה יותר של NP-שלמות. <a href="http://www.gadial.net/2010/08/15/p_vs_np_overview/">כתבתי</a> לא מזמן על המחלקות הללו כך שלא אעשה זאת שוב. השאלה שבה אעסוק הפעם היא זו:

אנחנו מכירים בעיות רבות ששייכות ל-P, כלומר בעיות ששיכות ל-NP והן "הכי קלות" שם. על קצה המזלג: חישוב אריתמטי, חיפוש ברשימה, מיון, חיפוש בגרף, מציאת עץ פורש של גרף, התמרת פורייה בדידה, מציאת קמור של קבוצת נקודות, פתרון בעיית תכנון לינארי, ועוד ועוד ועוד ועוד - וגולת הכותרת של תחילת העשור: בדיקת ראשוניות. לא כל אלו הן בעיות כן/לא אבל העיקרון ברור). בדומה, אנחנו מכירים בעיות רבות שהן NP-שלמות - כלומר, בעיות ב-NP שהן "הכי קשות". ושוב, רשימת המכולת כוללת את SAT, את 3-צביעה של גרפים, מציאת מעגל המילטוני, פתרון בעיית תכנון לינארי בשלמים, ועוד ועוד ועוד. אבל מה אנחנו לא מכירים כרגע בכלל? בעיות ב-NP שהן לא ב-P וגם אינן NP-שלמות.

צריך להבהיר כאן משהו: אין לנו כרגע מושג האם P שונה מ-NP. אם שתי המחלקות הללו שוות, אז <strong>כל</strong> בעיה ב-NP היא גם NP-שלמה, וגם ב-P (למעשה, שתי השפות ה"טריוויאליות" - שפת כל המילים והשפה הריקה - אינן NP-שלמות בגלל בעיה טכנית לא חשובה, אבל נעזוב את זה). אם כן, לשאלה האם יש שפה שאינה ב-P וגם אינה NP-שלמה. כלומר, האם העולם שלנו כולל רק בעיות "הכי קלות" ובעיות "הכי קשות", או שיש גם בעיות "הכי בינוניות"?

יש לנו כרגע מועמדת טבעית לתפקיד בעיה שכזו - בעיית הפירוק לגורמים. לא ידוע אלגוריתם פולינומי לבעיה זו, ובניגוד לבדיקת ראשוניות - גם לא ממש מצפים שאלגוריתם כזה יימצא. עם זאת, ולמרות שזו תהיה סנסציה של ממש, אני לא חושב שהאפשרות לכך שזה יקרה נפסלת על הסף (למעשה, <strong>קיים</strong> אלגוריתם פולינומי לפירוק לגורמים, אבל למחשבים קוונטיים). מפתיע עוד יותר יהיה לגלות שפירוק לגורמים היא בעיה NP-שלמה. אבל כאמור, <strong>להוכיח</strong> שפירוק לגורמים זו בעיית ביניים שכזו בפרט יפתור לנו אחת ולתמיד את סוגיית {% equation %}\mbox{P=NP}{% endequation %}, ולא ממש סביר שכך זה יקרה...

אז מה כן אפשר לעשות? הוכחה שמתבססת על ההנחה ש-{% equation %}\mbox{P}\ne\mbox{NP}{% endequation %}, כמובן, וזה מה שאציג כעת. לרוע המזל, ההוכחה אינה פשוטה; למרבה המזל, היא גם לא כל כך קשה כמו הוכחה אחרת שקראתי בשעתו. ההוכחה הזו קלה מספיק כדי שאציג אותה בבלוג, ולו כדי לנקום במי שרוצים דברים קשים יותר.

כעת אני עובר למוד "מתמטי". אתם מוזמנים להפסיק כאן - מי שימשיך, שלא יתלונן - הזהרתי אתכם. מכאן ואילך אני מניח ידע כלשהו בסיבוכיות.

שפת הביניים שנבנה תתבסס על {% equation %}\mbox{SAT}{% endequation %}; כזכור (מי שלא זוכר, אולי עדיף שלא ימשיך...), SAT היא פשוט אוסף של פסוקי {% equation %}\mbox{CNF}{% endequation %} ספיקים, והיא האמא של השפות ה-NP-שלמות, ולכן בוחרים אותה, אבל אפשר היה לקחת כל שפה NP-שלמה אחרת במקומה. הרעיון הוא לקחת מילים ב-SAT ו"לנפח" את האורך שלהן על ידי הוספת ג'יבריש לא מזיק - נניח, תווי {% equation %}x{% endequation %}, שמן הסתם לא מהווים חלק מקידוד של פסוק חוקי. בשביל מה זה טוב? כי אם נוסיף המון תווי {% equation %}x{% endequation %} לפסוק, זה "ישפר"את זמן הריצה של אלגוריתמים עליו; זמן הריצה נמדד ביחס לאורך המילה כולה, כולל הדולרים, אבל זמן הריצה של האלגוריתם ינבע רק מאורך הפסוק עצמו, כי מהדולרים הוא מתעלם... זה נראה כמו רמאות מוחלטת וכמו משהו מטופש מאין כמותו, אני יודע; זו אחת הסיבות שבגללן ההוכחה הזו כה מגניבה.

פורמלית, נניח ש-{% equation %}H\left(n\right){% endequation %} היא פונקציה מהטבעיים לטבעיים, אז נסמן {% equation %}\mbox{SAT}_{H}\triangleq\left\{ \varphi \$^{n^{H\left(n\right)}}|\varphi\in\mbox{SAT},\left|\varphi\right|=n\right\} {% endequation %}. כלומר, אנחנו "מרפדים" כל {% equation %}\varphi\in\mbox{SAT}{% endequation %} על ידי הוספת {% equation %}n^{H\left(n\right)}{% endequation %} תווי זבל, כאשר {% equation %}n{% endequation %} הוא האורך של {% equation %}\varphi{% endequation %}. ה-{% equation %}H\left(n\right){% endequation %} שבה נשתמש, שאגדיר אותה בהמשך, תקיים את התכונות הבאות: ראשית, אפשר יהיה לחשב אותה בזמן "סביר". שנית, היא תהיה מונוטונית עולה; ושלישית, והכי חשוב, היא תהיה חסומה אם ורק אם {% equation %}\mbox{SAT}_{H}\in\mbox{P}{% endequation %}.

כאן נמצא לב ההוכחה. אם {% equation %}H{% endequation %} הייתה גדלה <strong>מהר</strong>, אז היא הייתה גורמת לניפוח אדיר של מילים מ-{% equation %}\mbox{SAT}{% endequation %} ואז לא היה שום דבר מפתיע בכך ש-{% equation %}\mbox{SAT}_{H}\in\mbox{P}{% endequation %}. כי, למשל, אם אני מקבל קלט {% equation %}\varphi \$^{2^{n}}{% endequation %}, אז גם אם אבדוק את כל ההשמות האפשריות ל-{% equation %}\varphi{% endequation %} זה ייקח לי זמן של {% equation %}O\left(2^{n}\right){% endequation %} בלבד, וזהו האורך של המילה {% equation %}\varphi \$^{2^{n}}{% endequation %} - כלומר, יש לי אלגוריתם "לינארי" שפותר את {% equation %}\mbox{SAT}_{H}{% endequation %}, אבל כמובן שלא עשיתי פה שום דבר חכם. אם כן, העובדה שדווקא כאשר {% equation %}H{% endequation %} חסומה, ולכן הניפוח שלנו את {% equation %}\mbox{SAT}{% endequation %} הוא לא יותר מפולינומי בגודלו, דווקא אז {% equation %}\mbox{SAT}_{H}\in\mbox{P}{% endequation %} - זו עובדה משונה מאוד שלא כל כך מפתיע שגוררת את התוצאה שאנו מחפשים.

בואו נראה למה.

ראשית, אם {% equation %}\mbox{SAT}_{H}\in\mbox{P}{% endequation %} אז כאמור {% equation %}H{% endequation %} חסומה, כלומר {% equation %}H\left(n\right)&lt;c{% endequation %} עבור קבוע {% equation %}c{% endequation %} כלשהו ולכן {% equation %}\mbox{SAT}_{H}{% endequation %} כוללת פסוקים שהניפוח שלהם הוא בסך הכל פולינומי. זה מאפשר לנו לבצע רדוקציה פשוטה של {% equation %}\mbox{SAT}{% endequation %} אל {% equation %}\mbox{SAT}_{H}{% endequation %}: בהינתן {% equation %}\varphi{% endequation %}, צריך לייצר ממנו את {% equation %}\varphi\$^{n^{H\left(n\right)}}{% endequation %} אבל את זה קל לעשות - אמרתי שקל לחשב את {% equation %}H\left(n\right){% endequation %}, ומכיוון שצריך לכתוב רק מספר פולינומי של תווים אחרי {% equation %}\varphi{% endequation %}, הרדוקציה תהיה פולינומית (אם למשל היה צריך לכתוב {% equation %}2^{n}{% endequation %} תווים, הרדוקציה לא הייתה פולינומית והכל היה קורס). אם כן, מאחר והנחנו ש-{% equation %}\mbox{SAT}_{H}\in\mbox{P}{% endequation %} והראינו רדוקציה פולינומית של {% equation %}\mbox{SAT}{% endequation %} אל {% equation %}\mbox{SAT}_{H}{% endequation %}, אז גם {% equation %}\mbox{SAT}\in\mbox{P}{% endequation %} מה שגורר {% equation %}\mbox{P=NP}{% endequation %}, בסתירה להנחה שלנו ש-{% equation %}\mbox{P}\ne\mbox{NP}{% endequation %}.

מצד שני, אם {% equation %}\mbox{SAT}_{H}{% endequation %} היא {% equation %}\mbox{NP}{% endequation %}-שלמה, זה אומר (מהגדרת המושג של {% equation %}\mbox{NP}{% endequation %}-שלמות) שיש רדוקציה פולינומית מ-{% equation %}\mbox{SAT}{% endequation %} אליה. טוב, הפעם זה לא מוביל מייד לסתירה כי הרי לא ניתן להסיק מכך ש-{% equation %}\mbox{SAT}\in\mbox{P}{% endequation %}, אז מה כן? ובכן, הרדוקציה היא פולינומית? נניח שיש לה חסם זמן ריצה של {% equation %}c\cdot n^{d}{% endequation %}.

עכשיו נעשה תעלול חביב ביותר - <strong>רדוקציה עצמית</strong> של {% equation %}\mbox{SAT}{% endequation %}. נראה אלגוריתם שבהינתן פסוק {% equation %}\varphi{% endequation %} שאנו רוצים לבדוק את שייכותו ל-{% equation %}\mbox{SAT}{% endequation %}, מצליח לחלץ ממנו פסוק {% equation %}\psi{% endequation %} ששייך ל-{% equation %}\mbox{SAT}{% endequation %} אם ורק אם {% equation %}\varphi{% endequation %} שייך ל-{% equation %}\mbox{SAT}{% endequation %}, וכמו כן {% equation %}\left|\psi\right|&lt;\left|\varphi\right|{% endequation %}. ההקטנה הזו היא קריטית - זה אומר שנוכל לחזור על התהליך שוב ושוב ובכל סיבוב להקטין בביט אחד את מה שיש לבדוק, ועל כן תוך מספר לינארי של סיבובים הפסוק שאנו בודקים יהיה קטן מספיק כדי שניתן יהיה לבדוק אותו באופן ישיר בלי לחשוש מהשלכות קטסטרופליות על זמן הריצה. הרעיון של רדוקציות עצמיות מקצרות אורך שכאלו הוא רעיון יפה וחשוב בפני עצמו ואני שמח שהוא צץ כך באמצע ההוכחה הזו.

טוב, אז איפה היינו? אה, כן, {% equation %}\mbox{SAT}_{H}\notin\mbox{P}{% endequation %} (כי היא {% equation %}\mbox{NP}{% endequation %}-שלמה והנחנו ש-{% equation %}\mbox{P}\ne\mbox{NP}{% endequation %}). ולכן מהתכונה החשובה של {% equation %}H\left(n\right){% endequation %} שדיברתי עליה עולה ש-{% equation %}H\left(n\right){% endequation %} לא חסומה. מכיוון שהיא גם מונוטונית עולה, נקבל שקיים {% equation %}n_{0}{% endequation %} כך שלכל {% equation %}n&gt;n_{0}{% endequation %} מתקיים {% equation %}n^{H\left(n\right)}&gt;c\cdot n^{2d}{% endequation %}. במילים אחרות - הניפוח הוא יחסית גדול.

אלא מה? הרדוקציה של {% equation %}\mbox{SAT}{% endequation %} ל-{% equation %}\mbox{SAT}_{H}{% endequation %} לוקחת פסוק {% equation %}\varphi{% endequation %} כך ש-{% equation %}\left|\varphi\right|=n>n_{0}{% endequation %} ומייצרת אחד משני דברים: או משהו שנראה כמו {% equation %}\psi \$^{\left|\psi\right|^{H\left(\left|\psi\right|\right)}}{% endequation %}, כאשר {% equation %}\psi{% endequation %} הוא פסוק חוקי (כי כך נראית מילה ב-{% equation %}\mbox{SAT}_{H}{% endequation %}), או משהו שבכלל לא מהצורה הזו (אין בו את הכמות הנכונה של דולרים, או שהוא בכלל נראה שונה לגמרי). במקרה שהמשהו לא מהצורה הנכונה, ברור לנו שהוא לא שייך ל-{% equation %}\mbox{SAT}_{H}{% endequation %} ולכן {% equation %}\varphi{% endequation %} לא שייך ל-{% equation %}\mbox{SAT}{% endequation %} וסיימנו. אז נניח מעתה ואילך שהרדוקציה תמיד מייצרת משהו מהצורה הנכונה. השאלה שלנו היא - כמה גדול {% equation %}\psi{% endequation %} יכול להיות? התשובה היא שלא ממש גדול, בגלל שלא היה לרדוקציה הרבה זמן כדי לכתוב את {% equation %}\psi\$^{\left|\psi\right|^{H\left(\left|\psi\right|\right)}}{% endequation %}, והיו לה המון דולרים לכתוב...

פורמלית, בואו נסמן {% equation %}\left|\psi\right|=k{% endequation %}. הרדוקציה פעלה על {% equation %}\varphi{% endequation %} בזמן {% equation %}c\cdot n^{d}{% endequation %} לכל היותר, ולכן זה המספר המקסימלי של תווים שהיא יכלה לכתוב - כלומר, {% equation %}\left|\psi \$^{k^{H\left(k\right)}}\right|\le c\cdot n^{d}{% endequation %}. מצד שני, {% equation %}\left|\psi \$^{k^{H\left(k\right)}}\right|=k+k^{H\left(k\right)}>c\cdot k^{2d}{% endequation %}. כלומר, קיבלנו {% equation %}c\cdot k^{2d}&lt;c\cdot n^{d}{% endequation %}. מכאן חיש קל עולה ש-{% equation %}k=\sqrt{n}{% endequation %}. כלומר, קיצרנו <strong>מאוד</strong> את {% equation %}\varphi{% endequation %}, ולכן ניתן להשתמש בתעלול הרדוקציה העצמית.

הפסקה. מישהו עדיין עוקב? כי עכשיו הגענו לחלק המסובך בהוכחה - הבניה של {% equation %}H{% endequation %}. למי שבאמת שרד עד לכאן - קחו נשימה עמוקה. ועכשיו בואו ונתחיל.

ראשית, נמספר את כל מכונות הטיורינג: {% equation %}M_{k}{% endequation %} תהיה המכונה ה-{% equation %}k{% endequation %}-ית בסדר הלקסיקוגרפי על כל קידודי המכונות. כעת נגדיר את {% equation %}H\left(n\right)=k{% endequation %} להיות ה-{% equation %}k{% endequation %} הקטן ביותר שמקיים {% equation %}k&lt;\log\log n{% endequation %} וגם ש-{% equation %}M_{k}{% endequation %} מכריעה את {% equation %}\mbox{SAT}_{H}{% endequation %} עבור {% equation %}x{% endequation %}-ים המקיימים {% equation %}\left|x\right|\le\log n{% endequation %}, בזמן ריצה {% equation %}k\left|x\right|^{k}{% endequation %} לכל היותר. אם אין מכונה כזו, אז {% equation %}k=\log\log n{% endequation %}.

ההגדרה נראית מעגלית, אך מכיוון שכדי להגדיר את {% equation %}H\left(n\right){% endequation %} עלינו להכיר רק ערכים של {% equation %}H{% endequation %} הקטנים או שווים ל-{% equation %}\log n{% endequation %} אין כאן מעגליות (זוהי הגדרה <strong>רקורסיבית</strong>, לא מעגלית).

אם אתם תוהים כרגע מה לעזאזל - כן, גם אני הרגשתי ככה בהתחלה. אבל ההגדרה לא באמת כזו נוראית, וכל הלוגים המפחידים קיימים שם מסיבה טובה - אנחנו רוצים שאפשר יהיה לחשב את {% equation %}H\left(n\right){% endequation %} ביעילות. החישוב הזה הוא עניין ישיר למדי - פשוט עוברים בהרצה מבוקרת על כל המכונות {% equation %}M_{1},\dots,M_{\log\log n}{% endequation %} ולכל מכונה, מריצים אותה על כל הקלטים {% equation %}x{% endequation %} המקיימים {% equation %}\left|x\right|\le\log n{% endequation %}. בנוסף צריך לבדוק באופן ישיר האם {% equation %}x\in\mbox{SAT}_{h}{% endequation %} - זאת עושים באמצעות פתרון בכוח גס של {% equation %}\mbox{SAT}{% endequation %} וחישוב רקורסיבי של {% equation %}H\left(n\right){% endequation %} לגדלים קטנים יותר. זו פשוט הפעלת כוח גס באופן הברוטלי ביותר האפשרי, וזה יוצא יעיל בזכות הלוגים.

עכשיו, אם {% equation %}H{% endequation %} אינה מונוטונית עולה אז יש {% equation %}n{% endequation %} כך ש-{% equation %}H\left(n\right)=k{% endequation %} אבל {% equation %}H\left(n+1\right)&lt;k{% endequation %}. מכאן בפרט ש-{% equation %}H\left(n+1\right)\ne\log\log\left(n+1\right){% endequation %} (כי {% equation %}k\le\log\log n{% endequation %}), כלומר {% equation %}H\left(n+1\right){% endequation %} הוא מספרה של מכונה שעונה "כמו שצריך" על כל הקלטים עד גודל {% equation %}\log\left(n+1\right){% endequation %}. אבל מכונה כזו עונה נכון על כל הקלטים עד גודל {% equation %}\log n{% endequation %} ולכן {% equation %}H\left(n\right){% endequation %} היה צריך להיות קטן או שווה למספרה הסידורי - סתירה.

הראנו כי {% equation %}H\left(n\right){% endequation %} ניתנת לחישוב יעיל ושהיא מונוטונית עולה. נותר להבין מדוע {% equation %}H\left(n\right){% endequation %} אכן מקיימת את תכונת החסימות. ראשית נניח כי {% equation %}\mbox{SAT}_{H}\in\mbox{P}{% endequation %} ונוכיח כי {% equation %}H{% endequation %} חסומה. אם {% equation %}\mbox{SAT}_{H}\in\mbox{P}{% endequation %} אז יש אינסוף מכונות פולינומיות המכריעות את {% equation %}\mbox{SAT}_{H}{% endequation %} בזמן {% equation %}cn^{c}{% endequation %} עבור {% equation %}c&gt;0{% endequation %} קבוע גדול דיו; תהא {% equation %}M_{k}{% endequation %} מכונה שכזו כך ש-{% equation %}k&gt;c{% endequation %}. אז בפרט {% equation %}M_{k}{% endequation %} מכריעה את {% equation %}\mbox{SAT}_{H}{% endequation %} עבור קלטים המקיימים {% equation %}\left|x\right|\le\log n{% endequation %} בזמן ריצה {% equation %}k\left|x\right|^{k}{% endequation %} <strong>לכל</strong> {% equation %}n{% endequation %}; מכאן ש-{% equation %}H\left(n\right)\le k{% endequation %} לכל {% equation %}n{% endequation %} שעבורו {% equation %}k\le\log\log n{% endequation %}, כלומר לכל {% equation %}n&gt;2^{2^{k}}{% endequation %}, כלומר {% equation %}H{% endequation %} חסומה.

בכיוון השני, אם {% equation %}H{% endequation %} חסומה נוכיח ש-{% equation %}\mbox{SAT}_{H}\in\mbox{P}{% endequation %} באופן הבא: מכיוון ש-{% equation %}H\left(n\right){% endequation %} חסומה, מעקרון שובך היונים יש ערך {% equation %}k{% endequation %} שאותו היא מקבלת אינסוף פעמים, והדבר גורר ש-{% equation %}M_{k}{% endequation %} מכריעה את {% equation %}\mbox{SAT}_{H}{% endequation %} בזמן {% equation %}k\cdot n^{k}{% endequation %}. כדי לראות זאת, נניח שעל קלט {% equation %}x{% endequation %} כלשהו, {% equation %}M_{k}{% endequation %} לא עוצרת עם התשובה הנכונה בזמן {% equation %}k\cdot\left|x\right|^{k}{% endequation %}, אז על פי הגדרת {% equation %}H{% endequation %} בהכרח {% equation %}H\left(n\right)\ne k{% endequation %} לכל {% equation %}n&gt;2^{\left|x\right|}{% endequation %} - סתירה.

זו סוף ההוכחה.

בקריאה מחודשת, ההוכחה הזו היא למעשה <strong>פשוטה</strong> למדי. אין בה יותר מדי פרטים, ההגדרה היא יחסית ישירה, ואין צורך בטיעונים מחוכמים כל כך בשביל להתקדם. הוכחות כאלו הן נפוצות למדי בתורת הסיבוכיות, ואחרי שמתרגלים אליהן, הן באמת לא נוראיות כל כך. כך זה באופן כללי במתמטיקה - הוכחות שלצופה מבחוץ נראות מזוויעות לחלוטין, נראות פשוטות למדי למישהו "מבפנים". עבורי, ככותב בלוג מתמטי, הוכחות כאלו מהוות בעיה מהותית. מצד אחד לטעמי הן יפהפיות וקלות להבנה ומן הראוי שאציג אותן לכל דורש; מצד שני, ברור לי לחלוטין שרובם המוחץ של הקוראים לא ישרדו יותר מכמה שורות של ההוכחה - ולמה שישרדו? הרי הם לא קוראים ספר לימוד בסיבוכיות וקשה להם להתעמק בפרטים, שאותם אני כנראה לא מציג באופן טוב כפי שספר לימוד מסוגל. אני לא מסוגל לפשט מהותית את ההוכחה או לתת הרבה הסברים אינטואיטיביים לה - כאן ההבנה מגיעה משליטה בטכניקה עצמה.

אז טוב שלפעמים מפצירים בי לכתוב משהו מתקדם ונותנים לי תירוץ לכתוב פוסט כזה כעונש. כמובן, אנסה גם לכתוב פוסטים יותר "סקירתיים"ופחות טכניים על נושאים מתקדמים, אבל יותר קל להבטיח מלקיים; בפרט, בהתחשב בכך שהידע המתמטי שלי הוא לא רחב עד כדי כך (גם אם הבלוג אולי נותן אשלייה שגויה שאין זה כך).
