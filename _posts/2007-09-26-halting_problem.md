---
id: 64
title: "בעיית העצירה"
date: 2007-09-26 17:15:26
layout: post
categories: 
  - חישוביות
  - תכנות
social_media_share: true
---
<a href="http://www.gadial.net/2007/09/23/turing_machine/">בפוסטים</a> <a href="http://www.gadial.net/2007/09/24/turing_machine_extensions/">האחרונים</a> דיברנו על <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%9B%D7%95%D7%A0%D7%AA_%D7%98%D7%99%D7%95%D7%A8%D7%99%D7%A0%D7%92">מכונת טיורינג</a>. מכונת טיורינג היא מעין מחשב זעיר, שמקבל כקלט סדרה של אפסים ואחדים, "רץ" עליהם (מבצע כל מני פעולות חישוב), ובסופו של דבר עוצר ואומר "כן" או "לא". אחלה.

אלא שבשום מקום לא נדרש שהמכונה אכן תעצור. קל מאוד לכתוב מכונה שאינה עוצרת. הנה: מכונה בעלת מצב אחד, {% equation %}q_0{% endequation %}, ובעלת פונקצית המעברים הבאה: {% equation %}\delta(q_0,0)=\delta(q_0,1)=\delta(q_0,\flat)=(q_0,0,R){% endequation %} (ה-{% equation %}\flat{% endequation %} מסמל כאן "תא ריק" בסרט).

מה שהמכונה עושה הוא להתחיל לרוץ, להתעלם לחלוטין ממה שיש על הסרט (כלומר: לנהוג באותו אופן עבור כל קלט), ופשוט למלא את הסרט (האינסופי) באפסים, תוך שהראש נע בלי הרף ימינה. בפרט, המכונה מעולם לא מגיעה למצב סופי (המצב המקבל או המצב הדוחה) ולכן לעולם אינה עוצרת. בעסה.

הבעיה הזו אינה מוגבלת למכונות טיורינג, כמובן; גם <a href="http://he.wikipedia.org/wiki/%D7%AA%D7%95%D7%9B%D7%A0%D7%99%D7%AA_%D7%9E%D7%97%D7%A9%D7%91">תוכניות מחשב</a> "אמיתיות" יכולות לרוץ לנצח. בחלקן זה בדיוק הרעיון - <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A2%D7%A8%D7%9B%D7%AA_%D7%94%D7%A4%D7%A2%D7%9C%D7%94">מערכת הפעלה</a>, למשל, אמורה (בתיאוריה) לרוץ ללא הפסקה וללא צורך באיתחולים, ובד בבד עם מערכת ההפעלה ישנן תוכנות נוספות שאמורות לרוץ כל הזמן (<a href="http://he.wikipedia.org/wiki/%D7%90%D7%A0%D7%98%D7%99_%D7%95%D7%99%D7%A8%D7%95%D7%A1">אנטי וירוס</a>, למשל). אלא שהתוכנות הללו הן אינטראקטיביות במהותן; הן לא עוסקות כל הזמן בחישובים, אלא מגיבות לקלטים שהן מקבלות מהסביבה. אפשר לחשוב עליהן כעל אוסף של המון "מכונות טיורינג" קטנות, שכל אחת מהן מבצעת משימה מוגדרת היטב, <strong>מסיימת</strong> אותה, מוציאה את הפלט ואז מחכה להפעלה הבאה שלה (למשל, כשאנו מריצים קובץ, מערכת ההפעלה מכניסה לפעולה תוכנה קטנה שמטרתה להעלות את התוכנה שבקובץ, להקצות לה משאבים ולהתחיל את פעולתה). לכן, גם בהקשר של תוכנות שאמורות לרוץ לנצח, אנחנו נתקלים בתת תוכנות בעלות תפקיד שאמור לדרוש זמן סופי (תוכנות "נצחיות" שכאלו הן לרוב מבוססות אירועים - ממתינות שיקרה משהו ואז מכניסות לפעולה את תת התוכנית המתאימה).

כאשר עוסקים בחישובים, העסק טיפה יותר מחוכם. נכון, היינו רוצים בדרך כלל שתוכנית שאמורה לבצע משימה חישובית כלשהי תסיים את פעולתה, אבל זה כלל לא הכרחי: נניח, תוכנית שמדפיסה את כל ספרות <a href="http://he.wikipedia.org/wiki/%D7%A4%D7%90%D7%99">פאי</a> לא אמורה להפסיק לרוץ לעולם, אלא רק להדפיס עוד ועוד ועוד ספרות, פשוט כי יש אינסוף ספרות. אלא שגם כאן, אפשר לחשוב על התוכנית כאילו היא מבצעת אינסוף פעולות חישוב <strong>סופיות</strong>, שכל אחת מעניינת אותנו בפני עצמה: חישוב הספרה הראשונה, חישוב הספרה השנייה, וכן הלאה. בקונטקסט של שאלות "כן/לא", חישוב פאי מתואר כמכונה שמקבלת כקלט מספר טבעי של "מקום בפיתוח העשרוני של פאי" וספרה כלשהי, ועונה "כן" אם זו הספרה שנמצאת במקום הזה, ו"לא" אם לא. אנו כמובן מצפים שהמכונה תסיים את ריצתה מתישהו, אחרת היא חסרת ערך. לכן אפילו מטלה אינסופית כמו חישוב פאי ניתנת לדיון בהקשר של מכונות שאמורות לעצור (כמובן שאפשר לומר שזה אידיוטי לחשב את פאי ספרה ספרה באופן הזה, וזו תהיה טענה מדוייקת - זה הרבה פחות יעיל - אבל לא ביעילות אנו דנים כאן, אלא במה שבכלל אפשר לחשב).

לרוע המזל, טעויות תכנות עלולות לגרום בקלות לבנייה של תוכנות שלא עוצרות לעולם למרות שציפינו שהן יעצרו. הנה דוגמה נפוצה, משפת האימים <a href="http://he.wikipedia.org/wiki/%2B%2BC">++C</a>. נניח שאנחנו רוצים לכתוב לולאה שתרוץ שוב ושוב כל עוד משתנה כלשהו, notFinished שמו, שווה ל-1. נשמע הגיוני, לא? הנה הלולאה:
<p dir="ltr">while (notNinished=1){</p>
<p dir="ltr">... (doing stuff)</p>
<p dir="ltr">}</p>
<p dir="rtl">מה הבעיה כאן? שהתחביר של ++C לא משתמש בסימן "=" לצורך השוואה, אלא ב-"==". כלומר, מה שאני בודק אינו האם notFinished שווה ל-1. מה שקורה בפועל הוא שבכל איטרציה, המספר 1 מושם <strong>בתוך</strong> המשתנה notFinished, ומה שה-while בודק הוא את תוצאת ההשמה הזו - 1, שנחשב ל-"true" לוגי. כלומר, הלולאה תמשיך לרוץ לנצח, לא משנה איזה ערך יקבל notFinished בפנים.</p>
<p dir="rtl">זו שגיאה נפוצה מאוד, שנגרמת בגלל חוסר תשומת לב רגעי של המתכנת. <a href="http://he.wikipedia.org/wiki/%D7%A7%D7%95%D7%9E%D7%A4%D7%99%D7%99%D7%9C%D7%A8">קומפיילר</a> סביר יכלול אזהרה נגד שימוש ב-"=" בתוך משפט תנאי (אך ב-++C הדבר מקובל לפעמים בכוונה). בשפות כמו <a href="http://he.wikipedia.org/wiki/Java">ג'אווה</a> מחסלים את הבעיה לחלוטין על ידי כך שאוסרים על מספר לתפקד כערך לוגי (ולכן ה"תנאי" שבתוך הלולאה אינו תנאי), ואילו מתכנתי ++C מנוסים כנראה יימנעו מהבעיה על ידי כך שייכתבו קודם את ה-1:</p>
<p dir="ltr">while (1=notFinished)</p>
<p dir="rtl">ויקבלו אזהרה בזמן הקומפילצייה שהם מנסים להכניס ערך לתוך הקבוע 1, אבל, לרוע המזל לא כל המתכנתים מנוסים, ולולאות אינסופיות מתרחשות גם מסיבות מתוחכמות בהרבה. לפעמים זה לא תלוי בנו אלא במשתמש: ייתכן שמשתמש יכניס סדרה מופרעת לגמרי של קלטים, שיגרמו לתוכנה שלנו לבצע דברים שלא חשבנו עליהם בכלל - ובסופו של דבר, גם להיכנס ללולאה אינסופית. זה קורה. מי ששיחק בקווסטים ישנים של <a href="http://he.wikipedia.org/wiki/Sierra">סיירה</a> אולי נתקל לפעמים בהודעת שגיאה מסוג "אופס! עשית דבר שלא חשבנו עליו!" שמייד אחריה ריצת המשחק הסתיימה. הדרך להתגברות על הבעיה הזו היא מה שנקרא <a href="http://he.wikipedia.org/wiki/%D7%91%D7%93%D7%99%D7%A7%D7%95%D7%AA_%D7%AA%D7%95%D7%9B%D7%A0%D7%94">בדיקות תוכנה</a> - הרצה של התוכנית או חלקים ממנה הרבה פעמים, כשעושים הרבה דברים שונים, כולל כאלו שנראים מופרכים לחלוטין. אני מניח שגם בעולם האמיתי זה מה שקורה - לפני שמוציאים מוצר לשוק, בוחנים אותו גם בתנאים קיצוניים שלא אמורים להתקיים בפועל (ובפרט, כשמוציאים צעצוע, בודקים את כל הדרכים השונות לגרום לעצמך נזק באמצעותו - לפחות כך אני מקווה).</p>
<p dir="rtl">בדיקת תוכנה היא תהליך ארוך ומייגע, ולא קיים שום "מתכון בישול" טוב באמת לבדיקת תוכנה - מה שחשוב הוא הנסיון של הבודק (למרות שכלים מועילים ומתודולוגיות קיימות תמיד עוזרים). אין פלא שתחום <a href="http://he.wikipedia.org/wiki/%D7%90%D7%99%D7%9E%D7%95%D7%AA_%D7%AA%D7%95%D7%9B%D7%A0%D7%94">אימות התוכנה</a> האוטומטי נחשב לתחום חשוב ומעניין בזכות עצמו. כדאי להבהיר כבר עכשיו שזה תחום חי, פעיל, מתפתח ומועיל. למה אני מבהיר את זה? כי אני מייד אנפץ את מה שנראה על פניו כאחד מהגביעים הקדושים של התחום.</p>
<p dir="rtl">הגביע הקדוש הזה - <a href="http://he.wikipedia.org/wiki/%D7%91%D7%A2%D7%99%D7%99%D7%AA_%D7%94%D7%A2%D7%A6%D7%99%D7%A8%D7%94">בעיית העצירה</a> - הוא תוכנה שתהיה מסוגלת לקבל כקלט כל תוכנה אחרת (נסמן אותה בתור M), וקלט של המשתמש עבור אותה התוכנה (נסמן אותו בתור x), ולהגיד האם M מסיימת בשלב כלשהו לרוץ על x, או שהיא רצה לנצח. כמובן, זה לא אומר שהתוכנית חסינת לולאות אינסופיות - אולי עבור x אחר תהיה בעיה - כך שהשאלה פחות כללית מהשאלה "האם אפשר להכניס את M איכשהו ללולאה אינסופית?". אלא שהשאפתנות הפחותה לא משפרת לנו את החיים - גם בניסוחה הצנוע, בעיית העצירה היא בלתי כריעה. אין תוכנה שפותרת אותה.</p>
<p dir="rtl">כמובן, כשאנו אומרים "תוכנה" הכוונה היא למכונת טיורינג - אך זה לא משנה כלום. נניח שהיינו יודעים לפתור את בעיית העצירה עבור תוכנות, הרי שמכאן היה נובע שאנו יודעים לפתור אותה גם עבור מכונות טיורינג: בהינתן מכונת טיורינג שהיינו רוצים לבדוק אם היא עוצרת, היינו מתרגמים באופן אוטומטי את מכונת הטיורינג הזו לתוכנית מחשב (אפשר לעשות זאת, זה לא קשה במיוחד), מעבירים את התוכנית הזו, יחד עם הקלט, לתוכנה הפלאית שפותרת את בעיית העצירה עבור תוכנות, ומקבלים תשובה נכונה שתקפה גם עבור מכונת הטיורינג - והנה, באופן פלאי, פתרנו את בעיית העצירה גם עבור מכונות טיורינג.</p>
<p dir="rtl">לתעלול הזה - להשתמש בפתרון עבור בעיה אחת כדי לפתור בעיה אחרת - קוראים <strong>רדוקציה</strong>, והוא כנראה המושג החשוב ביותר בתורת החישוביות. אחזור אליו בפירוט רב יותר בהמשך, אחרי שאגמור את העיסוק בבעיית העצירה, אבל לפני שאפרד ממנו לגמרי אדגים באמצעותו עד כמה בעיית העצירה חזקה, בעצם.</p>
<p dir="rtl">בואו נניח שיש לנו דרך לפתור את בעיית העצירה, ונראה אילו בעיות מתמטיות זה מאפשר לנו לפתור.</p>

<ul>
	<li><a href="http://he.wikipedia.org/wiki/%D7%94%D7%A9%D7%A2%D7%A8%D7%AA_%D7%92%D7%95%D7%9C%D7%93%D7%91%D7%9A">השערת גולדבך</a>: נבנה מכונה שעוברת על כל המספרים הזוגיים הגדולים מ-4. עבור כל מספר כזה נעבור על כל הפירוקים האפשריים שלו לסכום שני מספרים גדולים מ-2 ונבדוק לכל אחד משני המספרים בפירוק אם הם <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A1%D7%A4%D7%A8_%D7%A8%D7%90%D7%A9%D7%95%D7%A0%D7%99">ראשוניים</a>. אם כן, ממשיכים למספר הבא. אם לא, וגמרנו לעבור על כל הפירוקים, עוצרים ומוציאים פלט "השערת גולדבך שגויה". כעת, בודקים האם המכונה שבנינו עוצרת אי פעם או לא. אם היא עוצרת - השערת גולדבך שגויה. אם אינה עוצרת, השערת גולדבך נכונה.</li>
	<li><a href="http://he.wikipedia.org/wiki/%D7%94%D7%9E%D7%A9%D7%A4%D7%98_%D7%94%D7%90%D7%97%D7%A8%D7%95%D7%9F_%D7%A9%D7%9C_%D7%A4%D7%A8%D7%9E%D7%94">המשפט האחרון של פרמה</a> (שאמנם, הוכח בינתיים בשיטה קונבנציונלית, ועדיין): בונים מכונה שעוברת בשיטתיות על כל הרביעיות {% equation %}(x,y,z,n){% endequation %} של מספרים טבעיים עם {% equation %}n&gt;2{% endequation %} (איך עושים זאת? אתגר לקוראים) ועבור כל רביעייה בודקים האם מתקיים {% equation %}x^n+y^n=z^n{% endequation %}. אם כן, עוצרים ומוציאים פלט "המשפט האחרון של פרמה לא נכון". בודקים האם המכונה עוצרת או לא. אם היא עוצרת, המשפט האחרון של פרמה לא נכון. אם היא לא עוצרת, הוא נכון.</li>
	<li><a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A9%D7%95%D7%95%D7%90%D7%94_%D7%93%D7%99%D7%95%D7%A4%D7%A0%D7%98%D7%99%D7%AA">משוואות דיופנטיות</a>: בדומה למשפט האחרון של פרמה, אבל כאן עוברים בשיטתיות על כל ההצבות האפשריות של מספרים שלמים למשתנים של המשוואה.</li>
	<li>האם קיים <a href="http://he.wikipedia.org/wiki/%D7%9E%D7%A1%D7%A4%D7%A8_%D7%A4%D7%A8%D7%9E%D7%94">מספר פרמה</a> ראשוני פרט לחמשת הראשונים: נבנה מכונה שלכל מספר פרמה {% equation %}F_n{% endequation %} עבור {% equation %}n&gt;4{% endequation %}, בודקת האם הוא ראשוני: אם הוא ראשוני, היא עוצרת ומדפיסה "כן". בודקים האם המכונה עוצרת או לא: אם כן, יש עוד ראשוני פרמה; אם לא, אין.</li>
</ul>
נראה לי שהרעיון הבסיסי ברור. כל הדוגמאות הללו הן פשוט המחשה למשהו כללי יותר: אם בעיית העצירה הייתה כריעה, היה מתקיים <a href="http://www.gadial.net/2007/09/18/r_and_re/">R=RE</a>, שכן <strong>כל</strong> בעיה ב-RE ניתנת לרדוקציה לבעיית העצירה. הבה ונראה זאת:

נזכור ש-RE היא אוסף הקבוצות של טבעיים שקיימת מכונת טיורינג שעוצרת ומחזירה "כן" על מספרים ששייכים לקבוצה, אבל על מספרים שלא שייכים לקבוצה היא לא מחוייבת לעצור (אם כבר היא עוצרת, היא צריכה לעצור ולהחזיר "לא"). מכאן שאם בעיית העצירה פתירה, אלגוריתם להכרעת קבוצה ב-RE הוא טריוויאלי: לוקחים את מכונת ה-RE של הקבוצה, "משפצרים" אותה כך שהיא לא תעצור בכלל על קלטים שלא שייכים לקבוצה (למשל, על ידי החלפת כל מעבר למצב הדוחה במעבר למצב שבו המכונה נמצאת בלולאה אינסופית) ומעבירים אותה למכונה שפותרת את בעיית העצירה. המכונה הפותרת תענה "כן" אם המכונה המשופצרת שלנו עוצרת על הקלט (כלומר, הקלט שייך בהכרח לקבוצה) ותענה "לא" אם המכונה המשופצרת שלנו לא עוצרת על הקלט (כלומר, הקלט בהכרח אינו שייך לשפה), וזהו. נסו להבהיר לעצמכם מדוע כל הדוגמאות לעיל הן פשוט מקרים פרטיים של זה (שימו לב כי רק במקרה השלישי יש בכלל קלט למכונה). מכאן שבעיית העצירה היא לא "סתם" בעיה שאני שלף מאי שם - היא בעיה חשובה ומרכזית, שהעיסוק בה צץ באופן טבעי כאשר עוסקים בחישוביות.
בעיית העצירה עצמה שייכת ל-RE: הרי בהינתן מכונה M וקלט x, הדבר הפשוט ביותר שאפשר לעשות הוא לסמלץ את ריצת M על x ולראות אם M עוצרת. אם היא עוצרת, נהדר: נחזיר פלט "כן". אם היא אינה עוצרת, גם הסימולציה שלנו תימשך לנצח ולכן גם המכונה המסמלצת לא תעצור לעולם - ולכן זוהי מכונת RE קלאסית. אם כן, בכך שמראים שבעיית העצירה אינה כריעה - כלומר, אינה ב-R - מראים גם כי RE שונה ממש מ-R (ומכילה אותה).

דבר אחרון לפני שנעבור להוכחה שבעיית העצירה אינה כריעה: ייתכן שחוסר הסימטריה בהגדרת RE מפריע לכם. אם התשובה היא "כן" המכונה חייבת לעצור, ואם התשובה היא "לא" היא לא חייבת - ומה עם המקרה ההפוך? מה עם בעיות שאם התשובה להן שלילית, אפשר לעצור ולהגיד "לא", אבל אם התשובה חיובית ייתכן שנרוץ לנצח? בעיות שכאלו שייכות למחלקה המכונה co-RE. כאן co הוא מלשון "המחלקה המשלימה" - אבל שימו לב, זו אינה השלמה במובן של תורת הקבוצות, שכן RE ו-co-RE אינן זרות; החיתוך שלהן הוא בדיוק R. תרגיל לא מסובך במיוחד שעוזר לוודא שההגדרות מובנות הוא להוכיח זאת.

בפעם הבאה - ההוכחה עצמה.
<p dir="rtl">&nbsp;</p>
<p dir="rtl">&nbsp;</p>
